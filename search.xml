<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>好用的node包汇总</title>
    <url>/2023/08/01/%E5%A5%BD%E7%94%A8%E7%9A%84node%E5%8C%85%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下面是一个<a href="https://github.com/huaize2020/awesome-nodejs" rel="external nofollow noopener noreferrer" target="_blank">开源项目</a>收集整理的一些很有用、很酷的 Node.js 包。强烈推荐给大家。喜欢的话，别忘了去 <a href="https://github.com/huaize2020/awesome-nodejs" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 上 star 哦。<a id="more"></a></p>
<h2 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h2><ul>
<li><a href="https://github.com/expressjs/express" rel="external nofollow noopener noreferrer" target="_blank">Express</a> - Web应用程序框架，为构建单页和多页以及混合Web应用程序提供了一组强大的功能。</li>
<li><a href="https://github.com/zeit/next.js" rel="external nofollow noopener noreferrer" target="_blank">Next.js</a> - React服务端渲染框架。</li>
<li><a href="https://github.com/blitz-js/blitz" rel="external nofollow noopener noreferrer" target="_blank">blitz</a> - 全栈 React 框架——建立在 Next.js 之上。</li>
<li><a href="https://github.com/meteor/meteor" rel="external nofollow noopener noreferrer" target="_blank">Meteor</a> - 超简单，无处不在的数据库，在线数据，纯Javascript Web框架。 <em>（你也许会喜欢 <a href="https://github.com/Urigo/awesome-meteor" rel="external nofollow noopener noreferrer" target="_blank">awesome-meteor</a>)</em></li>
<li><a href="https://github.com/nuxt/nuxt.js" rel="external nofollow noopener noreferrer" target="_blank">Nuxt.js</a> - Vue服务端渲染框架。</li>
<li><a href="https://github.com/nestjs/nest" rel="external nofollow noopener noreferrer" target="_blank">Nest</a> -受Angular启发的框架，用于构建高效且可扩展的服务器端应用程序。<em>(你也许会喜欢 <a href="https://github.com/juliandavidmr/awesome-nestjs" rel="external nofollow noopener noreferrer" target="_blank">awesome-nestjs</a>)</em></li>
<li><a href="https://github.com/cellbang/malagu" rel="external nofollow noopener noreferrer" target="_blank">Malagu</a> - Malagu 是基于 TypeScript 的 Serverless First、可扩展和组件化的应用框架。</li>
<li><a href="https://github.com/koajs/koa" rel="external nofollow noopener noreferrer" target="_blank">Koa</a> - 由Express背后的团队设计的框架，旨在为Web应用程序和API提供更小，更富表现力和更强大的基础。</li>
<li><a href="https://github.com/balderdashy/sails" rel="external nofollow noopener noreferrer" target="_blank">sails</a> - Node.js实时MVC框架。</li>
<li><a href="https://github.com/fastify/fastify" rel="external nofollow noopener noreferrer" target="_blank">Fastify</a> - 快速和低开销的Web框架。</li>
<li><a href="https://github.com/hapijs/hapi" rel="external nofollow noopener noreferrer" target="_blank">Hapi</a> - 用于创建应用和服务的框架。</li>
<li><a href="https://github.com/eggjs/egg" rel="external nofollow noopener noreferrer" target="_blank">Egg</a> - 为企业级框架和应用而生。</li>
<li><a href="https://github.com/feathersjs/feathers" rel="external nofollow noopener noreferrer" target="_blank">Feathers</a> - 基于Express精神构建的微服务框架。</li>
<li><a href="https://github.com/strongloop/loopback" rel="external nofollow noopener noreferrer" target="_blank">LoopBack</a> - 用于创建REST API并轻松连接到后端数据源的强大框架。</li>
<li><a href="https://github.com/restify/node-restify" rel="external nofollow noopener noreferrer" target="_blank">Restify</a> - 使你能够构建正确的REST Web服务。</li>
<li><a href="https://github.com/thinkjs/thinkjs" rel="external nofollow noopener noreferrer" target="_blank">ThinkJS</a> - 支持ES2015 +的框架，WebSockets，REST API。</li>
<li><a href="https://github.com/midwayjs/midway" rel="external nofollow noopener noreferrer" target="_blank">Midway</a> - 一个面向未来的云端一体 Node.js 框架。</li>
<li><a href="https://github.com/totaljs/framework" rel="external nofollow noopener noreferrer" target="_blank">total.js</a> - 使用纯JavaScript编写的Node.js框架，类似PHP’s Laravel或Python’s Django或ASP.NET MVC</li>
<li><a href="http://adonisjs.com/" rel="external nofollow noopener noreferrer" target="_blank">AdonisJs</a> - 基于依赖注入和IoC容器的坚实基础构建的Node.js的真正MVC框架。</li>
<li><a href="https://github.com/zeit/micro" rel="external nofollow noopener noreferrer" target="_blank">Micro</a> - 具有异步方法的简约微服务框架。</li>
<li><a href="https://moleculer.services/" rel="external nofollow noopener noreferrer" target="_blank">Moleculer</a> - 快速而强大的微服务框架。</li>
<li><a href="https://github.com/19majkel94/type-graphql" rel="external nofollow noopener noreferrer" target="_blank">TypeGraphQL</a> - 使用类和装饰器使用TypeScript创建GraphQL API的现代框架。</li>
<li><a href="https://github.com/senecajs/seneca" rel="external nofollow noopener noreferrer" target="_blank">seneca</a> - 编写微服务的工具包。</li>
<li><a href="https://github.com/alibaba/beidou" rel="external nofollow noopener noreferrer" target="_blank">beidou</a> - NodeJS &amp; React 同构框架，基于Egg.js开发。</li>
<li><a href="https://github.com/marblejs/marble" rel="external nofollow noopener noreferrer" target="_blank">Marble.js</a> - 基于TypeScript和RxJS，用于构建服务端应用的函数响应式框架。</li>
<li><a href="https://github.com/actionhero/actionhero" rel="external nofollow noopener noreferrer" target="_blank">ActionHero</a> - 用于为TCP套接字，WebSocket和HTTP客户端制作可重用和可扩展的API的框架。</li>
<li><a href="https://github.com/ladjs/lad" rel="external nofollow noopener noreferrer" target="_blank">lad</a> - 最好的Node.js框架，由前Express和Koa团队成员创建。</li>
<li><a href="https://github.com/talentlessguy/tinyhttp" rel="external nofollow noopener noreferrer" target="_blank">Tinyhttp</a> - 类Express更现代更快的Web框架。</li>
<li><a href="https://github.com/darukjs/daruk" rel="external nofollow noopener noreferrer" target="_blank">daruk</a> - 基于 typescript 的 Node.js web 框架。</li>
<li><a href="https://github.com/hemerajs/hemera" rel="external nofollow noopener noreferrer" target="_blank">Hemera</a> - 使用以下工具编写可靠且容错的微服务 <a href="https://nats.io/" rel="external nofollow noopener noreferrer" target="_blank">NATS</a>。</li>
<li><a href="https://github.com/BackendStack21/restana" rel="external nofollow noopener noreferrer" target="_blank">restana</a> - 用于构建REST微服务的超快速和简约的框架。</li>
<li><a href="https://github.com/sfast/zeronode" rel="external nofollow noopener noreferrer" target="_blank">Zeronode</a> - 最小的构建块，可实现可靠且容错的微服务。</li>
</ul>
<h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><ul>
<li><a href="https://github.com/serverless/serverless" rel="external nofollow noopener noreferrer" target="_blank">serverless</a> - 无服务器框架 – 使用 AWS Lambda、Azure Functions、Google CloudFunctions 等无服务器架构构建 Web、移动和 IoT 应用程序。</li>
<li><a href="https://github.com/cellbang/malagu" rel="external nofollow noopener noreferrer" target="_blank">Malagu</a> - Malagu 是基于 TypeScript 的 Serverless First、可扩展和组件化的应用框架。云厂商不锁定，目前支持 阿里云函数计算、腾讯云云函数、AWS Lambda、Verce 等等。</li>
<li><a href="https://github.com/midwayjs/midway" rel="external nofollow noopener noreferrer" target="_blank">Midway</a> - 一个面向未来的云端一体 Node.js 框架。</li>
</ul>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ul>
<li><p><strong>通用</strong></p>
</li>
<li><p><a href="https://github.com/dmnd/dedent" rel="external nofollow noopener noreferrer" target="_blank">dedent</a> - ES6模板字符串函数，用于去除多行字符串的缩进。</p>
</li>
<li><a href="https://github.com/sindresorhus/camelcase" rel="external nofollow noopener noreferrer" target="_blank">camelcase</a> - 将破折号/点号/下划线/空格分隔的字符串转换为驼峰式, 案例：foo-bar→fooBar。</li>
<li><a href="https://github.com/sindresorhus/string-width" rel="external nofollow noopener noreferrer" target="_blank">string-width</a> - 获取字符串的可视宽度-显示字符串所需的列数。</li>
<li><a href="https://github.com/sindresorhus/decamelize" rel="external nofollow noopener noreferrer" target="_blank">decamelize</a> - 将驼峰式字符串转化成小写带分隔符带字符串, 案例：unicornRainbow → unicorn_rainbow</li>
<li><a href="https://github.com/sindresorhus/detect-indent" rel="external nofollow noopener noreferrer" target="_blank">detect-indent</a> - 检查代码缩进。</li>
<li><a href="https://github.com/sindresorhus/string-length" rel="external nofollow noopener noreferrer" target="_blank">string-length</a> - 获取字符串的真实长度 - 通过正确计算星号并忽略ansi转义码。</li>
<li><a href="https://github.com/sindresorhus/strip-indent" rel="external nofollow noopener noreferrer" target="_blank">strip-indent</a> - 将字符串每一行中前置的空格删除。</li>
<li><a href="https://github.com/sindresorhus/strip-bom" rel="external nofollow noopener noreferrer" target="_blank">strip-bom</a> - 从字符串中删除UTF-8字节顺序标记（BOM）。</li>
<li><a href="https://github.com/sindresorhus/indent-string" rel="external nofollow noopener noreferrer" target="_blank">indent-string</a> - 将字符串每一行缩进。</li>
<li><a href="https://github.com/sindresorhus/redent" rel="external nofollow noopener noreferrer" target="_blank">redent</a> - 去除多余的缩进并缩进字符串。</li>
<li><a href="https://github.com/sindresorhus/normalize-newline" rel="external nofollow noopener noreferrer" target="_blank">normalize-newline</a> - Normalize the newline characters in a string to <code>\n</code>.</li>
<li><a href="https://github.com/jamiebuilds/min-indent" rel="external nofollow noopener noreferrer" target="_blank">min-indent</a> - 取每一行最少前置空格数。</li>
<li><a href="https://github.com/sindresorhus/trim-right" rel="external nofollow noopener noreferrer" target="_blank">trim-right</a> - 与 String#trim() 类似，但仅删除右侧的空格。</li>
<li><a href="https://github.com/sindresorhus/splice-string" rel="external nofollow noopener noreferrer" target="_blank">splice-string</a> - 移除或替换字符串的一部分。类似<code>Array#splice</code>.</li>
</ul>
<ul>
<li><strong>国际化</strong></li>
</ul>
<ul>
<li><a href="https://github.com/i18next/i18next" rel="external nofollow noopener noreferrer" target="_blank">i18next</a> - 国际化框架。</li>
<li><a href="https://github.com/mashpie/i18n-node" rel="external nofollow noopener noreferrer" target="_blank">i18n-node</a> - 具有动态JSON存储的简单翻译模块。</li>
<li><a href="https://github.com/nodeca/babelfish" rel="external nofollow noopener noreferrer" target="_blank">babelfish</a> - 适用于JavaScript的人性化i18n（node.js +浏览器）。</li>
</ul>
<ul>
<li><strong>唯一ID</strong></li>
</ul>
<ul>
<li><a href="https://github.com/ai/nanoid" rel="external nofollow noopener noreferrer" target="_blank">nanoid</a> - 小巧、安全、URL友好、唯一的字符串ID生成器。</li>
<li><a href="https://github.com/uuidjs/uuid" rel="external nofollow noopener noreferrer" target="_blank">uuid</a> - 在JavaScript中生成符合RFC规范的UUID。</li>
<li><a href="https://github.com/dylang/shortid" rel="external nofollow noopener noreferrer" target="_blank">shortid</a> - 短ID生成器。 网址友好。 不可预测的。 集群兼容。</li>
<li><a href="https://github.com/ulid/javascript" rel="external nofollow noopener noreferrer" target="_blank">ulid</a> - 通用唯一词典分类排序标识符。</li>
<li><a href="https://github.com/pnegri/uuid-js" rel="external nofollow noopener noreferrer" target="_blank">uuid-js</a> - 用于生成和解析 UUID、TimeUUID 并根据日期生成 TimeUUID 以供范围选择。</li>
<li><a href="https://github.com/rse/pure-uuid" rel="external nofollow noopener noreferrer" target="_blank">pure-uuid</a> - 基于纯JavaScript全局唯一ID(UUID)。</li>
</ul>
<ul>
<li><strong>编码/解码</strong></li>
</ul>
<ul>
<li><a href="https://github.com/mathiasbynens/he" rel="external nofollow noopener noreferrer" target="_blank">he</a> - HTML实体编码器/解码器。</li>
<li><a href="https://github.com/ashtuchkin/iconv-lite" rel="external nofollow noopener noreferrer" target="_blank">iconv-lite</a> - 转换字符编码。</li>
<li><a href="https://github.com/aadsm/jschardet" rel="external nofollow noopener noreferrer" target="_blank">jschardet</a> - JavaScript编码自动识别 (Python版chardet的实现)。</li>
</ul>
<ul>
<li><strong>差异对比</strong></li>
</ul>
<ul>
<li><a href="https://github.com/kpdecker/jsdiff" rel="external nofollow noopener noreferrer" target="_blank">jsdiff</a> - 一种JavaScript文本差异实现。</li>
<li><a href="https://github.com/cosmicanant/recursive-diff" rel="external nofollow noopener noreferrer" target="_blank">recursive-diff</a> - 查找两个JavaScript对象的差异，支持数组、数字、日期和其他原始数据类型。</li>
</ul>
<ul>
<li><strong>其他</strong></li>
</ul>
<ul>
<li><a href="https://github.com/kurolabs/stegcloak" rel="external nofollow noopener noreferrer" target="_blank">StegCloak</a> - 基于纯JavaScript开发的隐写功能模块，StegCloak可以对文本中的机密信息进行压缩和加密，然后再使用特殊的Unicode不可见字符来隐藏它。</li>
<li><a href="https://github.com/nodeca/unhomoglyph" rel="external nofollow noopener noreferrer" target="_blank">unhomoglyph</a> - 规范视觉上相似的unicode字符。</li>
</ul>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul>
<li><a href="https://github.com/adamwdraper/Numeral-js" rel="external nofollow noopener noreferrer" target="_blank">Numeral.js</a> - 格式化和操作数字。</li>
<li><a href="https://github.com/MikeMcl/bignumber.js" rel="external nofollow noopener noreferrer" target="_blank">bignumber.js</a> - 用于任意精度十进制和非十进制算术的 JavaScript 库。</li>
<li><a href="https://github.com/MikeMcl/decimal.js" rel="external nofollow noopener noreferrer" target="_blank">decimal.js</a> - JavaScript的任意精度的十进制类型。</li>
<li><a href="https://github.com/MikeMcl/big.js" rel="external nofollow noopener noreferrer" target="_blank">big.js</a> - 一个小型，快速的JavaScript库，用于任意精度的十进制算术运算。</li>
<li><a href="https://github.com/sindresorhus/round-to" rel="external nofollow noopener noreferrer" target="_blank">round-to</a> - 将数字四舍五入到指定的小数位数：<code>1.234</code>→1.2`。</li>
<li><a href="https://github.com/sindresorhus/unique-random" rel="external nofollow noopener noreferrer" target="_blank">unique-random</a> - 生成连续唯一的随机数。</li>
<li><a href="https://github.com/sindresorhus/random-int" rel="external nofollow noopener noreferrer" target="_blank">random-int</a> - 生成随机整数。</li>
<li><a href="https://github.com/sindresorhus/random-float" rel="external nofollow noopener noreferrer" target="_blank">random-float</a> - 生成随机浮点数。</li>
</ul>
<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><ul>
<li><a href="https://github.com/josdejong/mathjs" rel="external nofollow noopener noreferrer" target="_blank">mathjs</a> - 广泛的数学运算库。</li>
<li><a href="https://github.com/scijs/ndarray" rel="external nofollow noopener noreferrer" target="_blank">ndarray</a> - 多维数组。</li>
<li><a href="https://github.com/fibo/algebra" rel="external nofollow noopener noreferrer" target="_blank">algebra</a> - 代数结构。</li>
<li><a href="https://github.com/nodeca/multimath" rel="external nofollow noopener noreferrer" target="_blank">multimath</a> - 在WebAssembly和JS中进行快速图像数学运算。</li>
</ul>
<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><ul>
<li><a href="https://github.com/moment/moment" rel="external nofollow noopener noreferrer" target="_blank">moment</a> - 解析、校验、操作和显示日期。</li>
<li><a href="https://github.com/iamkun/dayjs" rel="external nofollow noopener noreferrer" target="_blank">dayjs</a> - 仅2KB，不可变的日期时间库。使用与Moment.js同样的API，Moment.js的替代库。</li>
<li><a href="https://github.com/date-fns/date-fns" rel="external nofollow noopener noreferrer" target="_blank">date-fns</a> - 现代JavaScript日期工具库。</li>
<li><a href="https://github.com/moment/luxon" rel="external nofollow noopener noreferrer" target="_blank">luxon</a> - 用于处理日期和时间的库。</li>
<li><a href="https://github.com/hustcc/timeago.js" rel="external nofollow noopener noreferrer" target="_blank">timeago.js</a> - timeago.js是一个很小的（2.0 kb）库，用于使用 *** time ago 语句格式化日期。</li>
<li><a href="https://github.com/vercel/ms" rel="external nofollow noopener noreferrer" target="_blank">ms</a> - 毫秒转换工具。</li>
<li><a href="https://github.com/felixge/node-dateformat" rel="external nofollow noopener noreferrer" target="_blank">dateformat</a> - 日期格式化。</li>
<li><a href="https://github.com/sindresorhus/pretty-ms" rel="external nofollow noopener noreferrer" target="_blank">pretty-ms</a> - 将毫秒转换为人类可读的字符串，如: <code>1337000000</code> → <code>15d 11h 23m 20s</code>。</li>
<li><a href="https://github.com/samsonjs/strftime" rel="external nofollow noopener noreferrer" target="_blank">strftime</a> - JavaScript版时间格式化Strftime。</li>
<li><a href="https://github.com/wadey/node-microtime" rel="external nofollow noopener noreferrer" target="_blank">node-microtime</a> - 以微秒为单位获取当前时间。</li>
<li><a href="https://github.com/JerrySievert/date-utils" rel="external nofollow noopener noreferrer" target="_blank">date-utils</a> - 用于Node.js和浏览器的日期垫片（Polyfills）。</li>
<li><a href="https://github.com/robrich/pretty-hrtime" rel="external nofollow noopener noreferrer" target="_blank">pretty-hrtime</a> - 将process.hrtime()的结果转换为人可读性的字符串。</li>
<li><a href="https://github.com/node-modules/humanize-ms" rel="external nofollow noopener noreferrer" target="_blank">humanize-ms</a> - 将人类可读的时间转换为毫秒。</li>
</ul>
<h2 id="正则-通配符匹配"><a href="#正则-通配符匹配" class="headerlink" title="正则/通配符匹配"></a>正则/通配符匹配</h2><ul>
<li><a href="https://github.com/pillarjs/path-to-regexp" rel="external nofollow noopener noreferrer" target="_blank">path-to-regexp</a> - 将路径字符串（如<code>/user/:name</code>）转化为正则。</li>
<li><a href="https://github.com/isaacs/minimatch" rel="external nofollow noopener noreferrer" target="_blank">minimatch</a> - 最小匹配工具。</li>
<li><a href="https://github.com/micromatch/micromatch" rel="external nofollow noopener noreferrer" target="_blank">micromatch</a> - 高度优化的通配符和全局匹配库。更快，直接替换到 minimatch 和 multimatch。由webpack、babel core、yarn、jest、browser-sync、documentation.js、stylelint、nyc、ava以及许多其他资源使用！</li>
<li><a href="https://github.com/fent/randexp.js" rel="external nofollow noopener noreferrer" target="_blank">randexp.js</a> - 根据给定的正则表达式，生成随机字符串。</li>
<li><a href="https://github.com/substack/safe-regex" rel="external nofollow noopener noreferrer" target="_blank">safe-regex</a> - 检测可能是灾难性的、指数时间的正则表达式。</li>
<li><a href="https://github.com/sindresorhus/matcher" rel="external nofollow noopener noreferrer" target="_blank">matcher</a> - 简单通配符匹配。</li>
<li><a href="https://github.com/sindresorhus/escape-string-regexp" rel="external nofollow noopener noreferrer" target="_blank">escape-string-regexp</a> - 转义特殊正则字符。</li>
<li><a href="https://github.com/sindresorhus/multimatch" rel="external nofollow noopener noreferrer" target="_blank">multimatch</a> - 扩展 minimatch.match() 以支持多种模式。</li>
<li><a href="https://github.com/sindresorhus/execall" rel="external nofollow noopener noreferrer" target="_blank">execall</a> - 在字符串中查找多个RegExp匹配项。</li>
</ul>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul>
<li><a href="https://github.com/medialize/URI.js" rel="external nofollow noopener noreferrer" target="_blank">URI.js</a> - URL转换库。</li>
<li><a href="https://github.com/ljharb/qs" rel="external nofollow noopener noreferrer" target="_blank">qs</a> - 请求字符串解析器。</li>
<li><a href="https://github.com/sindresorhus/query-string" rel="external nofollow noopener noreferrer" target="_blank">query-string</a> - 解析和字符串化URL查询字符串。</li>
<li><a href="https://github.com/unshiftio/url-parse" rel="external nofollow noopener noreferrer" target="_blank">url-parse</a> - 轻量URL解析器，可跨Node.js和浏览器环境无缝运行。</li>
<li><a href="https://github.com/sindresorhus/normalize-url" rel="external nofollow noopener noreferrer" target="_blank">normalize-url</a> - 规范化URL.</li>
<li><a href="https://github.com/snd/url-pattern" rel="external nofollow noopener noreferrer" target="_blank">url-pattern</a> - 比正则表达式更易匹配URL和其他字符串，将字符串转化成数据 或 将数据转换成字符串。</li>
<li><a href="https://github.com/GoogleChromeLabs/native-url" rel="external nofollow noopener noreferrer" target="_blank">native-url</a> - 使用内建URL API实现的NodeJS URL模块。</li>
<li><a href="https://github.com/jfromaniello/url-join" rel="external nofollow noopener noreferrer" target="_blank">url-join</a> - 将所有参数连接在一起，并将结果url规范化。</li>
<li><a href="https://github.com/sindresorhus/humanize-url" rel="external nofollow noopener noreferrer" target="_blank">humanize-url</a> - 使URL更可读: <a href="http://sindresorhus.com" rel="external nofollow noopener noreferrer" target="_blank">http://sindresorhus.com</a> → sindresorhus.com。</li>
<li><a href="https://github.com/pillarjs/parseurl" rel="external nofollow noopener noreferrer" target="_blank">parseurl</a> - 使用记忆化方式解析URL.</li>
<li><a href="https://github.com/sindresorhus/file-url" rel="external nofollow noopener noreferrer" target="_blank">file-url</a> - 将文件路径转化为文件URL: <code>unicorn.jpg</code> → <code>file:///Users/sindresorhus/unicorn.jpg</code></li>
<li><a href="https://github.com/pillarjs/encodeurl" rel="external nofollow noopener noreferrer" target="_blank">encodeurl</a> - 将URL编码为”百分比”形式，不编码已编码部分。</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li><a href="https://github.com/json5/json5" rel="external nofollow noopener noreferrer" target="_blank">json5</a> - JSON5是对JSON的扩展，其目的是能够更加容易的阅读和编写。</li>
<li><a href="https://github.com/benjamine/jsondiffpatch" rel="external nofollow noopener noreferrer" target="_blank">jsondiffpatch</a> - 对比JSON对象，并生成差异和Patch信息。</li>
<li><a href="https://github.com/json-schema-faker/json-schema-faker" rel="external nofollow noopener noreferrer" target="_blank">json-schema-faker</a> - JSON-Schema + 假数据生成器。</li>
<li><a href="https://github.com/fastify/fast-json-stringify" rel="external nofollow noopener noreferrer" target="_blank">fast-json-stringify</a> - 比JSON.stringify()快2倍。</li>
<li><a href="https://github.com/jprichardson/node-jsonfile" rel="external nofollow noopener noreferrer" target="_blank">jsonfile</a> - 轻松读写JSON文件。</li>
<li><a href="https://github.com/jsonata-js/jsonata" rel="external nofollow noopener noreferrer" target="_blank">jsonata</a> - JSONata 查询和转换语言 - <a href="http://jsonata.org" rel="external nofollow noopener noreferrer" target="_blank">http://jsonata.org</a></li>
<li><a href="https://github.com/substack/json-stable-stringify" rel="external nofollow noopener noreferrer" target="_blank">json-stable-stringify</a> - 具有自定义排序功能的确定性JSON.stringify(), 可以从字符串化结果中获取确定性哈希值。</li>
<li><a href="https://github.com/sindresorhus/strip-json-comments" rel="external nofollow noopener noreferrer" target="_blank">strip-json-comments</a> - 去除JSON文件中的注释。让你可以在JSON中使用注释。</li>
<li><a href="https://github.com/moll/json-stringify-safe" rel="external nofollow noopener noreferrer" target="_blank">json-stringify-safe</a> - 类似于JSON.stringify，但不会引发循环引用。</li>
<li><a href="https://github.com/sindresorhus/load-json-file" rel="external nofollow noopener noreferrer" target="_blank">load-json-file</a> - 读取并解析JSON文件。</li>
<li><a href="https://github.com/sindresorhus/write-json-file" rel="external nofollow noopener noreferrer" target="_blank">write-json-file</a> - 序列化并写入JSON文件。</li>
<li><a href="https://github.com/epoberezkin/fast-json-stable-stringify" rel="external nofollow noopener noreferrer" target="_blank">fast-json-stable-stringify</a> - 确定性JSON.stringify() - 比 @substack 的 json-stable-stringify 更快的版本，不带jsonify。</li>
<li><a href="https://github.com/aligay/jsonuri" rel="external nofollow noopener noreferrer" target="_blank">jsonuri</a> - 使用”URI样式“的方法来操作数据。</li>
</ul>
<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><ul>
<li><a href="https://github.com/lovell/sharp" rel="external nofollow noopener noreferrer" target="_blank">sharp</a> - 调整JPEG，PNG，WebP和TIFF格式图像大小的最快模块。</li>
<li><a href="https://github.com/oliver-moran/jimp" rel="external nofollow noopener noreferrer" target="_blank">jimp</a> - 纯JavaScript中的图像处理。</li>
<li><a href="https://github.com/aheckmann/gm" rel="external nofollow noopener noreferrer" target="_blank">gm</a> - GraphicsMagick 和 ImageMagick 封装。</li>
<li><a href="https://github.com/soldair/node-qrcode" rel="external nofollow noopener noreferrer" target="_blank">qrcode</a> - 二维码和条形码生成器。</li>
<li><a href="https://github.com/mapbox/pixelmatch" rel="external nofollow noopener noreferrer" target="_blank">pixelmatch</a> - 最小、最简单、最快的 JavaScript 像素级图像比较库。</li>
<li><a href="https://github.com/rsmbl/Resemble.js" rel="external nofollow noopener noreferrer" target="_blank">Resemble.js</a> - 图像分析和比较。</li>
<li><a href="https://github.com/nodeca/pica" rel="external nofollow noopener noreferrer" target="_blank">pica</a> - 使用纯JS中的高质量和快速调整大小（lanczos3）。 当不允许像素化时替代canvas drawImage()。</li>
<li><a href="https://github.com/cozmo/jsQR" rel="external nofollow noopener noreferrer" target="_blank">jsQR</a> - 一个纯javascript的二维码读取库。 该库接收原始图像，并将定位、提取和解析其中发现的任何二维码。</li>
<li><a href="https://github.com/EyalAr/lwip" rel="external nofollow noopener noreferrer" target="_blank">lwip</a> - 不需要ImageMagick的轻量级图像处理器.</li>
<li><a href="https://github.com/nodeca/probe-image-size" rel="external nofollow noopener noreferrer" target="_blank">probe-image-size</a> - 无需完全下载即可获取大多数图像格式的大小.</li>
<li><a href="https://github.com/deanm/omggif" rel="external nofollow noopener noreferrer" target="_blank">omggif</a> - GIF 89a编码解码器。</li>
<li><a href="https://github.com/jpeg-js/jpeg-js" rel="external nofollow noopener noreferrer" target="_blank">jpeg-js</a> - 使用纯JavaScript的JPEG编码和解码器。</li>
<li><a href="https://github.com/lukeapage/pngjs" rel="external nofollow noopener noreferrer" target="_blank">pngjs</a> - 简单的PNG编码解码器。</li>
<li><a href="https://github.com/scijs/get-pixels" rel="external nofollow noopener noreferrer" target="_blank">get-pixels</a> - 将图像读入ndarray。</li>
<li><a href="https://github.com/sindresorhus/image-type" rel="external nofollow noopener noreferrer" target="_blank">image-type</a> - 检测Buffer / Uint8Array的图像类型.</li>
<li><a href="https://github.com/nowelium/node-bitmap" rel="external nofollow noopener noreferrer" target="_blank">node-bitmap</a> - 纯JavaScript Bitmap库。</li>
</ul>
<h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><ul>
<li><a href="https://github.com/fluent-ffmpeg/node-fluent-ffmpeg" rel="external nofollow noopener noreferrer" target="_blank">fluent-ffmpeg</a> - FFMPEG的流畅API (<a href="http://www.ffmpeg.org" rel="external nofollow noopener noreferrer" target="_blank">http://www.ffmpeg.org</a>)</li>
<li><a href="https://github.com/tnfe/FFCreator" rel="external nofollow noopener noreferrer" target="_blank">FFCreator</a> - 一个基于node.js的高速短视频加工库。</li>
<li><a href="https://github.com/damianociarla/node-ffmpeg" rel="external nofollow noopener noreferrer" target="_blank">node-ffmpeg</a> - Nodejs版Ffmpeg模块。</li>
</ul>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li><a href="https://github.com/aui/font-spider" rel="external nofollow noopener noreferrer" target="_blank">font-spider</a> - 字蛛是一个智能 WebFont 压缩工具，它能自动分析出页面使用的 WebFont 并进行按需压缩。</li>
</ul>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul>
<li><a href="https://github.com/gka/chroma.js" rel="external nofollow noopener noreferrer" target="_blank">chroma</a> - JavaScript库，用于各种颜色处理。</li>
<li><a href="https://github.com/davidmerfield/randomColor" rel="external nofollow noopener noreferrer" target="_blank">randomColor</a> - 一个小型脚本，用于优雅的生成颜色。</li>
<li><a href="https://github.com/briangonzalez/rgbaster.js" rel="external nofollow noopener noreferrer" target="_blank">rgbaster</a> - 一个简单的库，用于从图像中提取主色。</li>
<li><a href="https://github.com/bgrins/TinyColor" rel="external nofollow noopener noreferrer" target="_blank">TinyColor</a> - 快速、小型的颜色操作和转换库。</li>
<li><a href="https://github.com/One-com/one-color" rel="external nofollow noopener noreferrer" target="_blank">onecolor</a> - 面向对象的JavaScript颜色解析器/计算工具包，支持RGB，HSV，HSL，CMYK和alpha通道。 颜色空间之间的转换是隐式进行的，并且所有方法都返回新对象，而不是对现有实例进行突变。 可在浏览器和Node.js中使用。</li>
</ul>
<h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><ul>
<li><a href="https://github.com/brix/crypto-js" rel="external nofollow noopener noreferrer" target="_blank">crypto-js</a> - JavaScript加密标准库。</li>
<li><a href="https://github.com/kelektiv/node.bcrypt.js" rel="external nofollow noopener noreferrer" target="_blank">bcrypt</a> - Node.js版Bcrypt。</li>
<li><a href="https://github.com/travist/jsencrypt" rel="external nofollow noopener noreferrer" target="_blank">jsencrypt</a> - 用于执行OpenSSL RSA加密、解密和密钥生成的Javascript库。</li>
<li><a href="https://github.com/dcodeIO/bcrypt.js" rel="external nofollow noopener noreferrer" target="_blank">bcrypt.js</a> - 经过优化bcrypt库，使用纯JavaScript且零依赖。</li>
<li><a href="https://github.com/kjur/jsrsasign" rel="external nofollow noopener noreferrer" target="_blank">jsrsasign</a> - “jsrsasign”（RSA Sign JavaScript库）是一个开源的免费加密库，支持纯JavaScript中的RSA/RSAPSS/ECDSA/DSA签名/验证、ASN.1、PKCS#1/5/8私钥/公钥、X.509证书、CRL、OCSP、CMS SignedData、TimeStamp、CAdES JSON Web签名/令牌。</li>
<li><a href="https://github.com/rzcoder/node-rsa" rel="external nofollow noopener noreferrer" target="_blank">node-rsa</a> - Node.js RSA库。</li>
<li><a href="https://github.com/ricmoo/aes-js" rel="external nofollow noopener noreferrer" target="_blank">aes-js</a> - AES的纯JavaScript实现。</li>
<li><a href="https://github.com/pvorb/node-md5" rel="external nofollow noopener noreferrer" target="_blank">node-md5</a> - 一个JavaScript函数，用于使用MD5对消息进行哈希处理。</li>
<li><a href="https://github.com/sindresorhus/crypto-hash" rel="external nofollow noopener noreferrer" target="_blank">crypto-hash</a> - 微型哈希模块，在Node.js和浏览器中使用原生crypto API。</li>
<li><a href="https://github.com/indutny/hash.js" rel="external nofollow noopener noreferrer" target="_blank">hash.js</a> - 使用纯JavaScript的哈希实现。</li>
<li><a href="https://github.com/JuneAndGreen/sm-crypto" rel="external nofollow noopener noreferrer" target="_blank">sm-crypto</a> - sm2, sm3, sm4的JavaScript实现。</li>
<li><a href="https://github.com/crypto-browserify/sha.js" rel="external nofollow noopener noreferrer" target="_blank">sha.js</a> - 使用纯JavaScript中的流式SHA哈希。</li>
<li><a href="https://github.com/MauriceButler/cryptr" rel="external nofollow noopener noreferrer" target="_blank">cryptr</a> - 非常基础的加密和解密Node.js模块。</li>
<li><a href="https://github.com/crypto-browserify/pbkdf2" rel="external nofollow noopener noreferrer" target="_blank">pbkdf2</a> - 在Node中具有任何受支持的哈希算法PBKDF2。</li>
<li><a href="https://github.com/joyent/node-bcrypt-pbkdf" rel="external nofollow noopener noreferrer" target="_blank">bcrypt-pbkdf</a> - POpenBSD <code>bcrypt_pbkdf</code> Javascript实现。</li>
</ul>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul>
<li><a href="https://github.com/dominictarr/event-stream" rel="external nofollow noopener noreferrer" target="_blank">event-stream</a> - EventStream就像函数式编程遇到IO。</li>
<li><a href="https://github.com/rvagg/through2" rel="external nofollow noopener noreferrer" target="_blank">through2</a> - 基于Node stream2 的封装进行转换以避免显式的子类化噪声。</li>
<li><a href="https://github.com/dominictarr/JSONStream" rel="external nofollow noopener noreferrer" target="_blank">JSONStream</a> - 流JSON.parse和stringify。</li>
<li><a href="https://github.com/maxogden/mississippi" rel="external nofollow noopener noreferrer" target="_blank">mississippi</a> - 有用的流实用程序模块的集合，用于更好编写的使用流的代码。</li>
<li><a href="https://github.com/nodejs/readable-stream" rel="external nofollow noopener noreferrer" target="_blank">readable-stream</a> - 可读流。</li>
<li><a href="https://github.com/mafintosh/pump" rel="external nofollow noopener noreferrer" target="_blank">pump</a> - 将流连接在一起，如果其中一个关闭，则关闭所有流。</li>
<li><a href="https://github.com/maxogden/concat-stream" rel="external nofollow noopener noreferrer" target="_blank">concat-stream</a> - 可写流，它将字符串或数据连接起来并执行回调。</li>
<li><a href="https://github.com/uhop/stream-json" rel="external nofollow noopener noreferrer" target="_blank">stream-json</a> - stream-json是用于创建自定义标准兼容JSON处理器的nod​​e.js流组件的集合，该组件所需的内存占用最少。它可以解析远远超出可用内存的JSON文件。甚至单个原始数据项（键，字符串和数字）也可以分段流式传输。还包括流式SAX启发式的基于事件的API。</li>
<li><a href="https://github.com/dominictarr/split" rel="external nofollow noopener noreferrer" target="_blank">split</a> - 分解流并重新组装它，以便每一行都是一块。匹配器可以是字符串，也可以是正则表达式。</li>
<li><a href="https://github.com/mafintosh/tar-stream" rel="external nofollow noopener noreferrer" target="_blank">tar-stream</a> - tar-stream是一个流式tar解析器和生成器。</li>
<li><a href="https://github.com/jahewson/node-byline" rel="external nofollow noopener noreferrer" target="_blank">node-byline</a> - 逐行流阅读器。</li>
<li><a href="https://github.com/maxogden/ndjson" rel="external nofollow noopener noreferrer" target="_blank">ndjson</a> - 流逐行分隔的json解析器 + 序列化器。</li>
<li><a href="https://github.com/substack/oppressor" rel="external nofollow noopener noreferrer" target="_blank">oppressor</a> - 流HTTP压缩响应协商程序。</li>
<li><a href="https://github.com/feross/multistream" rel="external nofollow noopener noreferrer" target="_blank">multistream</a> - 一种流，一个接一个地发出多个其他流（streams2）。</li>
<li><a href="https://github.com/sindresorhus/get-stream" rel="external nofollow noopener noreferrer" target="_blank">get-stream</a> - 以字符串，缓冲区或数组的形式获取流。</li>
<li><a href="https://github.com/samcday/node-stream-buffer" rel="external nofollow noopener noreferrer" target="_blank">node-stream-buffer</a> - 使用缓存的可读和可写流。</li>
<li><a href="https://github.com/mcollina/split2" rel="external nofollow noopener noreferrer" target="_blank">split2</a> - 拆分stream3样式。</li>
<li><a href="https://github.com/npm/fstream" rel="external nofollow noopener noreferrer" target="_blank">fstream</a> - 高级的Node.js文件操作流。</li>
<li><a href="https://github.com/mafintosh/pumpify" rel="external nofollow noopener noreferrer" target="_blank">pumpify</a> - 使用泵和全双工，将一系列流合并为单个双工流。</li>
<li><a href="https://github.com/freeall/progress-stream" rel="external nofollow noopener noreferrer" target="_blank">progress-stream</a> - 读取流的进度。</li>
<li><a href="https://github.com/grncdr/merge-stream" rel="external nofollow noopener noreferrer" target="_blank">merge-stream</a> - 将多个流合并为一个交错流。</li>
<li><a href="https://github.com/mafintosh/duplexify" rel="external nofollow noopener noreferrer" target="_blank">duplexify</a> - 将可写和可读流转换为具有异步初始化和stream1/streams2输入支持的stream2双工流。</li>
<li><a href="https://github.com/sindresorhus/into-stream" rel="external nofollow noopener noreferrer" target="_blank">into-stream</a> - 将缓存/字符串/数组/对象转换为流。</li>
<li><a href="https://github.com/teambition/merge2" rel="external nofollow noopener noreferrer" target="_blank">merge2</a> - 按顺序或并行的方式将多个流合并为一个流。</li>
<li><a href="https://github.com/mafintosh/end-of-stream" rel="external nofollow noopener noreferrer" target="_blank">end-of-stream</a> - 当可读/可写/双工流已完成或失败时，调用回调。</li>
<li><a href="https://github.com/bendrucker/stream-to-promise" rel="external nofollow noopener noreferrer" target="_blank">stream-to-promise</a> - 将流（可读或可写流）转换为Promise。</li>
<li><a href="https://github.com/gagle/node-streamifier" rel="external nofollow noopener noreferrer" target="_blank">node-streamifier</a> - 将 Buffer/String 转换为可读流。</li>
<li><a href="https://github.com/dominictarr/stream-spec" rel="external nofollow noopener noreferrer" target="_blank">stream-spec</a> - Stream的可执行规范（让测试流变得更容易）。</li>
<li><a href="https://github.com/hughsk/from2" rel="external nofollow noopener noreferrer" target="_blank">from2</a> - ReadableStream的便捷封装，其灵感来自through2。</li>
<li><a href="https://github.com/dominictarr/map-stream" rel="external nofollow noopener noreferrer" target="_blank">dmap-stream</a> - 基于Event-stream事件流重构。</li>
<li><a href="https://github.com/substack/emit-stream" rel="external nofollow noopener noreferrer" target="_blank">emit-stream</a> - 将event-emiiters转换为流 和 将流转换为event-emiiters。</li>
<li><a href="https://github.com/dominictarr/stream-combiner" rel="external nofollow noopener noreferrer" target="_blank">stream-combiner</a> - 将管道变成单个流。合并返回的流，写入第一个流并从最后一个流读取的流。</li>
<li><a href="https://github.com/raynos/duplexer" rel="external nofollow noopener noreferrer" target="_blank">duplexer</a> - 创建一个双工流。</li>
<li><a href="https://github.com/spion/promise-streams" rel="external nofollow noopener noreferrer" target="_blank">promise-streams</a> - Node.js流的集合，可以很好地与Promises (through, map, reduce等）一起使用。</li>
<li><a href="https://github.com/maxogden/binary-split" rel="external nofollow noopener noreferrer" target="_blank">binary-split</a> - 快速的换行符（或任何分隔符）分隔符流。</li>
<li><a href="https://github.com/substack/stream-combiner2" rel="external nofollow noopener noreferrer" target="_blank">stream-combiner2</a> - stream3的stream-combiner。</li>
<li><a href="https://github.com/almost/through2-concurrent" rel="external nofollow noopener noreferrer" target="_blank">through2-concurrent</a> - 简单的Node.JS流（streams2）转换，可并行执行转换功能（可设置的最大并发数）。</li>
<li><a href="https://github.com/mcollina/cloneable-readable" rel="external nofollow noopener noreferrer" target="_blank">cloneable-readable</a> - 安全地克隆可读流。</li>
<li><a href="https://github.com/stream-utils/destroy" rel="external nofollow noopener noreferrer" target="_blank">destroy</a> - 如果可能，销毁流。</li>
<li><a href="https://github.com/mafintosh/peek-stream" rel="external nofollow noopener noreferrer" target="_blank">peek-stream</a> - 转换流，可让您在决定如何解析前先窥视第一行。</li>
<li><a href="https://github.com/substack/resumer" rel="external nofollow noopener noreferrer" target="_blank">resumer</a> - 通过流开始暂停，并在下一个tick恢复。</li>
<li><a href="https://github.com/mafintosh/stream-each" rel="external nofollow noopener noreferrer" target="_blank">stream-each</a> - 迭代流中的所有数据。</li>
<li><a href="https://github.com/mafintosh/flush-write-stream" rel="external nofollow noopener noreferrer" target="_blank">flush-write-stream</a> - 一种写入流构造函数，支持流完成之前调用的flush函数。</li>
<li><a href="https://github.com/mafintosh/multi-write-stream" rel="external nofollow noopener noreferrer" target="_blank">multi-write-stream</a> - 创建一个可写流，其可写入多个其他可写流。</li>
<li><a href="https://github.com/sindresorhus/first-chunk-stream" rel="external nofollow noopener noreferrer" target="_blank">first-chunk-stream</a> - 缓冲并转换流的前n个字节。</li>
<li><a href="https://github.com/mafintosh/multi-read-stream" rel="external nofollow noopener noreferrer" target="_blank">multi-read-stream</a> - 可读流，它同时从多个可读流中读取。</li>
<li><a href="https://github.com/parshap/node-stream-reduce" rel="external nofollow noopener noreferrer" target="_blank">node-stream-reduce</a> - 将流数据减少为单个值。</li>
<li><a href="https://github.com/mafintosh/stream-shift" rel="external nofollow noopener noreferrer" target="_blank">stream-shift</a> - 返回流可读队列中的下一个缓冲区/对象。</li>
<li><a href="https://github.com/floatdrop/stream-assert" rel="external nofollow noopener noreferrer" target="_blank">stream-assert</a> - 流的断言库。</li>
<li><a href="https://github.com/schnittstabil/stream-from-promise" rel="external nofollow noopener noreferrer" target="_blank">stream-from-promise</a> - 根据Promise创建流。</li>
<li><a href="https://github.com/lewisdiamond/stromjs" rel="external nofollow noopener noreferrer" target="_blank">stromjs</a> - 无依赖的流实用程序。流的Lodash。</li>
<li><a href="https://github.com/suarasaur/exec-stream" rel="external nofollow noopener noreferrer" target="_blank">exec-stream</a> - 将流传入到子进程。</li>
<li><a href="https://github.com/kikobeats/stream-callback" rel="external nofollow noopener noreferrer" target="_blank">stream-callback</a> – 将流转换为一个回调函数。</li>
</ul>
<h2 id="检测-判断"><a href="#检测-判断" class="headerlink" title="检测/判断"></a>检测/判断</h2><ul>
<li><a href="https://github.com/arasatasaygin/is.js" rel="external nofollow noopener noreferrer" target="_blank">is.js</a> - 微型检查库。</li>
<li><a href="https://github.com/then/is-promise" rel="external nofollow noopener noreferrer" target="_blank">is-promise</a> - 测试对象是否看起来像一个 Promises-a+ promise。</li>
<li><a href="https://github.com/watson/is-ci" rel="external nofollow noopener noreferrer" target="_blank">is-ci</a> - 判断当前环境是否为CI服务器。</li>
<li><a href="https://github.com/enricomarino/is" rel="external nofollow noopener noreferrer" target="_blank">is</a> - JavaScript类型测试库。</li>
<li><a href="https://github.com/node-modules/is-type-of" rel="external nofollow noopener noreferrer" target="_blank">is-type-of</a> - Node.js完整类型判断。</li>
<li><a href="https://github.com/sindresorhus/is-stream" rel="external nofollow noopener noreferrer" target="_blank">is-stream</a> - 判断对象是否为流对象。</li>
<li><a href="https://github.com/wayfind/is-utf8" rel="external nofollow noopener noreferrer" target="_blank">is-utf8</a> - 判断Buffer对象是否UTF8编码。</li>
<li><a href="https://github.com/isaacs/core-util-is" rel="external nofollow noopener noreferrer" target="_blank">core-util-is</a> - Node.js核心工具 util.is* 函数。</li>
<li><a href="https://github.com/sindresorhus/is-ip" rel="external nofollow noopener noreferrer" target="_blank">is-ip</a> - 检查字符串是否为IP地址。</li>
<li><a href="https://github.com/rvagg/isstream" rel="external nofollow noopener noreferrer" target="_blank">isstream</a> - 判断对象是否为流对象。</li>
<li><a href="https://github.com/miguelmota/is-class" rel="external nofollow noopener noreferrer" target="_blank">is-class</a> - 判断函数是否为 ES6类(class) 类型。</li>
<li><a href="https://github.com/isaacs/isexe" rel="external nofollow noopener noreferrer" target="_blank">isexe</a> - 检查文件是否可执行文件。</li>
<li><a href="https://github.com/juliangruber/is-type" rel="external nofollow noopener noreferrer" target="_blank">is-type</a> - Node.js核心类型判断。</li>
<li><a href="https://github.com/imanhodjaev/is-md5" rel="external nofollow noopener noreferrer" target="_blank">is-md5</a> - JavaScript实用程序，用于检查字符串是否为md5加密。</li>
<li><a href="https://github.com/inspect-js/is-core-module" rel="external nofollow noopener noreferrer" target="_blank">is-core-module</a> - 判断一个说明符 是否为 Node.js 核心模块。</li>
</ul>
<h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><ul>
<li><a href="https://github.com/validatorjs/validator.js" rel="external nofollow noopener noreferrer" target="_blank">validator.js</a> - 字符串校验库。</li>
<li><a href="https://github.com/hapijs/joi" rel="external nofollow noopener noreferrer" target="_blank">joi</a> - 基于JavaScript对象的对象模式描述语言和验证器。</li>
<li><a href="https://github.com/yiminghe/async-validator" rel="external nofollow noopener noreferrer" target="_blank">async-validator</a> - 异步校验。</li>
<li><a href="https://github.com/typestack/class-validator" rel="external nofollow noopener noreferrer" target="_blank">class-validator</a> - 基于装饰器属性校验的类校验器。</li>
<li><a href="https://github.com/epoberezkin/ajv" rel="external nofollow noopener noreferrer" target="_blank">ajv</a> - 最快的JSON Schema验证器。支持JSON Schema draft-04/06/07/2019-09/2020-12 and JSON类型定义(RFC8927)。</li>
<li><a href="https://github.com/ianstormtaylor/superstruct" rel="external nofollow noopener noreferrer" target="_blank">Superstruct</a> - 用简单和可组合的方式在JavaScript和TypeScript中校验数据。</li>
<li><a href="https://github.com/imbrn/v8n" rel="external nofollow noopener noreferrer" target="_blank">v8n</a> - 流畅的JavaScript校验库。</li>
<li><a href="https://github.com/oussamahamdaoui/forgJs" rel="external nofollow noopener noreferrer" target="_blank">forgJs</a> - 轻量的JavaScript对象校验器。</li>
<li><a href="https://github.com/tdegrunt/jsonschema" rel="external nofollow noopener noreferrer" target="_blank">jsonschema</a> - JSON Schema校验器.</li>
<li><a href="https://github.com/mikeerickson/validatorjs" rel="external nofollow noopener noreferrer" target="_blank">validatorjs</a> - 受Laravel的校验器启发，在浏览器和Node.JS上的数据校验库。</li>
<li><a href="https://github.com/mafintosh/is-my-json-valid" rel="external nofollow noopener noreferrer" target="_blank">is-my-json-valid</a> - 极快的JSON Schema校验工具。</li>
<li><a href="https://github.com/nettofarah/property-validator" rel="external nofollow noopener noreferrer" target="_blank">property-validator</a> - 用于JavaScript、Node和Express的易用的属性校验工具。</li>
<li><a href="https://github.com/Atinux/schema-inspector" rel="external nofollow noopener noreferrer" target="_blank">schema-inspector</a> - 用于净化和验证JS对象的强大工具。</li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul>
<li><a href="https://github.com/lodash/lodash" rel="external nofollow noopener noreferrer" target="_blank">lodash</a> - 可提供一致性、自定义、性能和其他功能的实用程序库，比Underscore.js更好更快。</li>
<li><a href="https://github.com/facebook/immutable-js" rel="external nofollow noopener noreferrer" target="_blank">immutable</a> - 不可变的数据集合。</li>
<li><a href="https://github.com/reactivex/rxjs" rel="external nofollow noopener noreferrer" target="_blank">RxJS</a> - 用于转换、组合和查询各种数据的函数式响应式库。</li>
<li><a href="https://github.com/ramda/ramda" rel="external nofollow noopener noreferrer" target="_blank">Ramda</a> - 实用程序库着重于通过自动计算和相反的参数顺序实现的灵活功能组合，避免数据变化。</li>
<li><a href="https://github.com/immerjs/immer" rel="external nofollow noopener noreferrer" target="_blank">immer</a> - 函数式响应式编程。</li>
<li><a href="https://github.com/baconjs/bacon.js" rel="external nofollow noopener noreferrer" target="_blank">Bacon.js</a> - 函数式响应式编程。</li>
<li><a href="https://github.com/dtao/lazy.js" rel="external nofollow noopener noreferrer" target="_blank">Lazy.js</a> - 类似于lodash/underline的工具库，但具有惰性计算，在许多情况下可以转换为卓越的性能.</li>
<li><a href="https://github.com/origamitower/folktale" rel="external nofollow noopener noreferrer" target="_blank">Folktale</a> - 一套用于JavaScript中的通用函数编程的库，它允许您编写优雅的、模块化的应用程序，并且bug更少及更强的重用性。</li>
<li><a href="https://github.com/kefirjs/kefir" rel="external nofollow noopener noreferrer" target="_blank">Kefir.js</a> - 响应式库，专注于高性能和低内存使用。</li>
<li><a href="https://github.com/mout/mout" rel="external nofollow noopener noreferrer" target="_blank">Mout</a> - 该库与其他现有解决方案之间最大的区别是，您可以选择只加载需要的模块/函数，而不需要额外开销。.</li>
</ul>
<h2 id="控制反转-依赖注入"><a href="#控制反转-依赖注入" class="headerlink" title="控制反转/依赖注入"></a>控制反转/依赖注入</h2><ul>
<li><a href="https://github.com/inversify/InversifyJS" rel="external nofollow noopener noreferrer" target="_blank">InversifyJS</a> - 功能强大且轻便的控制反转容器。</li>
<li><a href="https://github.com/mgechev/injection-js" rel="external nofollow noopener noreferrer" target="_blank">injection-js</a> - 5.1K中的JavaScript和TypeScript的依赖注入库。它提取自Angular的ReflectiveInjector，这意味着它设计合理，功能完整、快速、可靠且经过良好测试。</li>
<li><a href="https://github.com/zhang740/power-di" rel="external nofollow noopener noreferrer" target="_blank">power-di</a> - 轻量的依赖注入库。</li>
</ul>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><ul>
<li><a href="https://github.com/shelljs/shelljs" rel="external nofollow noopener noreferrer" target="_blank">shelljs</a> - 跨平台Unix shell命令。</li>
<li><a href="https://github.com/sindresorhus/execa" rel="external nofollow noopener noreferrer" target="_blank">execa</a> - 跨平台实现子进程执行 <code>child_process.{execFile,exec}</code>。</li>
<li><a href="https://github.com/coreybutler/node-windows" rel="external nofollow noopener noreferrer" target="_blank">node-windows</a> - Node.js上支持的Windows脚本。如(daemons, eventlog, UAC等)。</li>
<li><a href="https://github.com/shelljs/shx" rel="external nofollow noopener noreferrer" target="_blank">shx</a> - Node的可移植Shell命令。</li>
<li><a href="https://github.com/sindresorhus/clipboardy" rel="external nofollow noopener noreferrer" target="_blank">clipboardy</a> - 跨平台的复制/粘贴。</li>
<li><a href="https://github.com/IndigoUnited/node-cross-spawn" rel="external nofollow noopener noreferrer" target="_blank">cross-spawn</a> - 跨平台实现 <code>child_process.spawn()</code>。</li>
<li><a href="https://github.com/darkguy2008/parallelshell" rel="external nofollow noopener noreferrer" target="_blank">parallelshell</a> - 并行运行多个 shell 命令。</li>
<li><a href="https://github.com/sindresorhus/clipboard-cli" rel="external nofollow noopener noreferrer" target="_blank">clipboard-cli</a> - 跨平台的复制/粘贴。</li>
<li><a href="https://github.com/ehmicky/gulp-execa" rel="external nofollow noopener noreferrer" target="_blank">gulp-execa</a> - 在Gulp中跨平台命令执行。</li>
<li><a href="https://github.com/node-modules/runscript" rel="external nofollow noopener noreferrer" target="_blank">runscript</a> - 更容易的运行脚本命令。</li>
<li><a href="https://github.com/zentrick/cross-spawn-promise" rel="external nofollow noopener noreferrer" target="_blank">cross-spawn-promise</a> - Promise化的cross-spawn。</li>
<li><a href="https://github.com/tiaanduplessis/shell-exec" rel="external nofollow noopener noreferrer" target="_blank">shell-exec</a> - 通过系统Shell执行命令。</li>
</ul>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li><a href="https://github.com/motdotla/dotenv" rel="external nofollow noopener noreferrer" target="_blank">dotenv</a> - 从 .env文件 加载用于nodejs项目的环境变量。</li>
<li><a href="https://github.com/kentcdodds/cross-env" rel="external nofollow noopener noreferrer" target="_blank">cross-env</a> - 跨平台设置环境变量。</li>
<li><a href="https://github.com/tabrindle/envinfo" rel="external nofollow noopener noreferrer" target="_blank">envinfo</a> - 生成关于您的开发环境的报告，用于调试和问题报告。</li>
<li><a href="https://github.com/npm/node-which" rel="external nofollow noopener noreferrer" target="_blank">which</a> - 跨平台实现的Unix <code>which</code>.</li>
<li><a href="https://github.com/sindresorhus/user-home" rel="external nofollow noopener noreferrer" target="_blank">user-home</a> - 跨平台获取用户home目录路径。</li>
<li><a href="https://github.com/sindresorhus/username" rel="external nofollow noopener noreferrer" target="_blank">username</a> - 获取当前用户名。</li>
<li><a href="https://github.com/npm/osenv" rel="external nofollow noopener noreferrer" target="_blank">osenv</a> - 跨平台环境变量。</li>
<li><a href="https://github.com/sindresorhus/is-elevated" rel="external nofollow noopener noreferrer" target="_blank">is-elevated</a> - 检查进程是否以提升的权限运行。</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><a href="https://github.com/jonathanong/ee-first" rel="external nofollow noopener noreferrer" target="_blank">ee-first</a> - 获取一组EventEmitter和Event对中的第一个事件，然后对其进行清理。</li>
</ul>
<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><ul>
<li><p><strong>框架/解决方案</strong></p>
</li>
<li><p><a href="https://github.com/tj/commander.js" rel="external nofollow noopener noreferrer" target="_blank">Commander.js</a> - Node.JS命令行界面完整解决方案。</p>
</li>
<li><a href="https://github.com/yargs/yargs" rel="external nofollow noopener noreferrer" target="_blank">yargs</a> - 通用可交互命令行工具集合。</li>
<li><a href="https://github.com/oclif/oclif" rel="external nofollow noopener noreferrer" target="_blank">oclif</a> - 基于Heroku开源Node.js CLI框架。</li>
<li><a href="https://github.com/sindresorhus/meow" rel="external nofollow noopener noreferrer" target="_blank">meow</a> - CLI应用助手。</li>
<li><a href="https://github.com/cacjs/cac" rel="external nofollow noopener noreferrer" target="_blank">cac</a> - 用于构建命令行应用的强大框架。</li>
<li><a href="https://github.com/drew-y/cliffy" rel="external nofollow noopener noreferrer" target="_blank">Cliffy</a> - 可交互命令行框架。</li>
<li><a href="https://github.com/node-modules/common-bin" rel="external nofollow noopener noreferrer" target="_blank">common-bin</a> - 基于yargs的命令行工具抽象，提供更方便的使用，支持async/generator。</li>
</ul>
<ul>
<li><p><strong>命令行参数解析</strong></p>
</li>
<li><p><a href="https://github.com/substack/minimist" rel="external nofollow noopener noreferrer" target="_blank">minimist</a> - 命令行参数解析引擎。</p>
</li>
<li><a href="https://github.com/vercel/arg" rel="external nofollow noopener noreferrer" target="_blank">arg</a> - 简单的参数解析。</li>
<li><a href="https://github.com/npm/nopt" rel="external nofollow noopener noreferrer" target="_blank">nopt</a> - Node/npm参数解析。</li>
<li><a href="https://github.com/nodeca/argparse" rel="external nofollow noopener noreferrer" target="_blank">argparse</a> - Node.js CLI参数解析。</li>
<li><a href="https://github.com/yargs/yargs-parser" rel="external nofollow noopener noreferrer" target="_blank">yargs-parser</a> - yargs在使用，优雅参数解析库.</li>
</ul>
<ul>
<li><p><strong>Prompt提示</strong></p>
</li>
<li><p><a href="https://github.com/SBoudrias/Inquirer.js" rel="external nofollow noopener noreferrer" target="_blank">Inquirer.js</a> - 通用可交互命令行工具集合。</p>
</li>
<li><a href="https://github.com/terkelg/prompts" rel="external nofollow noopener noreferrer" target="_blank">prompts</a> - 轻量、美观、用户友好的交互式命令行提示。</li>
<li><a href="https://github.com/enquirer/enquirer" rel="external nofollow noopener noreferrer" target="_blank">Enquirer</a> - 用户友好、直观且易于创建的时尚CLI提示。</li>
<li><a href="https://github.com/moxystudio/node-promptly" rel="external nofollow noopener noreferrer" target="_blank">node-promptly</a> - 简单命令行提示实用程序。</li>
</ul>
<ul>
<li><p><strong>进度条</strong></p>
</li>
<li><p><a href="https://github.com/visionmedia/node-progress" rel="external nofollow noopener noreferrer" target="_blank">progress</a> - Node.js的灵活ascii进度条。</p>
</li>
<li><a href="https://github.com/bvaughn/progress-estimator" rel="external nofollow noopener noreferrer" target="_blank">progress-estimator</a> - 打印进度条并估计完成Promise所需的时间。</li>
<li><a href="https://github.com/AndiDittrich/Node.CLI-Progress" rel="external nofollow noopener noreferrer" target="_blank">cli-progress</a> - 在命令行/终端应用中轻松的使用进度条。</li>
</ul>
<ul>
<li><p><strong>样式</strong></p>
</li>
<li><p><a href="https://github.com/chalk/chalk" rel="external nofollow noopener noreferrer" target="_blank">chalk</a> - 命令行字符串样式美化工具。</p>
</li>
<li><a href="https://github.com/sindresorhus/ora" rel="external nofollow noopener noreferrer" target="_blank">ora</a> - 优雅的命令行loading效果。</li>
<li><a href="https://github.com/Marak/colors.js" rel="external nofollow noopener noreferrer" target="_blank">colors.js</a> - 获取Node.js控制台的颜色。</li>
<li><a href="https://github.com/SamVerschueren/listr" rel="external nofollow noopener noreferrer" target="_blank">listr</a> - 命令行任务列表。</li>
<li><a href="https://github.com/patorjk/figlet.js" rel="external nofollow noopener noreferrer" target="_blank">figlet.js</a> - 用 JavaScript 编写的 FIG，旨在完全实现 FIGfont 规范。</li>
<li><a href="https://github.com/lukeed/kleur" rel="external nofollow noopener noreferrer" target="_blank">kleur</a> - 最快的Node.js库，使用ANSI颜色格式化命令行文本。</li>
<li><a href="https://github.com/jorgebucaran/colorette" rel="external nofollow noopener noreferrer" target="_blank">colorette</a> - 在终端中轻松设置文本的颜色和样式。</li>
<li><a href="https://github.com/gtanner/qrcode-terminal" rel="external nofollow noopener noreferrer" target="_blank">qrcode-terminal</a> - 命令行中显示二维码。</li>
<li><a href="https://github.com/sindresorhus/boxen" rel="external nofollow noopener noreferrer" target="_blank">boxen</a> - 控制台中创建盒子。</li>
<li><a href="https://github.com/sindresorhus/terminal-image" rel="external nofollow noopener noreferrer" target="_blank">terminal-image</a> - 在终端中展示图片。</li>
<li><a href="https://github.com/sindresorhus/log-symbols" rel="external nofollow noopener noreferrer" target="_blank">log-symbols</a> - 为不同日志级别添加色彩图标。</li>
<li><a href="https://github.com/bokub/gradient-string" rel="external nofollow noopener noreferrer" target="_blank">gradient-string</a> - 终端输出中漂亮的颜色渐变。</li>
<li><a href="https://github.com/sindresorhus/figures" rel="external nofollow noopener noreferrer" target="_blank">figures</a> - Windows兜底的Unicode符号。</li>
<li><a href="https://github.com/sindresorhus/terminal-link" rel="external nofollow noopener noreferrer" target="_blank">terminal-link</a> - 在终端中创建可点击的链接。</li>
<li><a href="https://github.com/standard/snazzy" rel="external nofollow noopener noreferrer" target="_blank">snazzy</a> - 将 JavaScript 标准样式格式化为时尚（即时髦）输出。</li>
<li><a href="https://github.com/timoxley/columnify" rel="external nofollow noopener noreferrer" target="_blank">columnify</a> - 创建适合控制台输出的基于文本的列。 支持单元格。</li>
<li><a href="https://github.com/cli-table/cli-table3" rel="external nofollow noopener noreferrer" target="_blank">cli-table3</a> - 命令行的漂亮unicode表。</li>
<li><a href="https://github.com/eldargab/easy-table" rel="external nofollow noopener noreferrer" target="_blank">easy-table</a> - 漂亮的文本表格。</li>
<li><a href="https://github.com/notatestuser/treeify" rel="external nofollow noopener noreferrer" target="_blank">treeify</a> - 将javascript对象漂亮地打印为树。</li>
<li><a href="https://github.com/marvinhagemeister/kolorist" rel="external nofollow noopener noreferrer" target="_blank">kolorist</a> - 使用输入和输出色彩化的小工具。</li>
<li><a href="https://github.com/aantthony/console-png" rel="external nofollow noopener noreferrer" target="_blank">console-png</a> - 在命令行输出中打印PNG图片。</li>
</ul>
<ul>
<li><p><strong>编辑器</strong></p>
</li>
<li><p><a href="https://github.com/slap-editor/slap" rel="external nofollow noopener noreferrer" target="_blank">slap</a> - 基于命令行终端的类Sublime文本编辑器。</p>
</li>
</ul>
<ul>
<li><p><strong>其他</strong></p>
</li>
<li><p><a href="https://github.com/commitizen/cz-cli" rel="external nofollow noopener noreferrer" target="_blank">commitizen</a> - Commitizen命令行实用程序。</p>
</li>
<li><a href="https://github.com/yeoman/update-notifier" rel="external nofollow noopener noreferrer" target="_blank">update-notifier</a> - 为你的CLI应用提供的更新提示。</li>
<li><a href="https://github.com/lukeed/console-clear" rel="external nofollow noopener noreferrer" target="_blank">console-clear</a> - 跨平台清空控制台。</li>
</ul>
<h2 id="Node-js管理工具"><a href="#Node-js管理工具" class="headerlink" title="Node.js管理工具"></a>Node.js管理工具</h2><ul>
<li><a href="https://github.com/nvm-sh/nvm" rel="external nofollow noopener noreferrer" target="_blank">nvm</a> - Node.js版本管理工具。</li>
<li><a href="https://github.com/coreybutler/nvm-windows" rel="external nofollow noopener noreferrer" target="_blank">nvm for Windows</a> - Node.js版本管理工具Windows版。</li>
<li><a href="https://github.com/tj/n" rel="external nofollow noopener noreferrer" target="_blank">n</a> - Node.js版本管理工具。</li>
<li><a href="https://github.com/Schniz/fnm" rel="external nofollow noopener noreferrer" target="_blank">fnm</a> - 快速、轻量的Node.js版本管理工具，由Rust构建。</li>
<li><a href="https://github.com/isaacs/nave" rel="external nofollow noopener noreferrer" target="_blank">nave</a> - Node.js虚拟环境。</li>
<li><a href="https://github.com/nodenv/nodenv" rel="external nofollow noopener noreferrer" target="_blank">nodenv</a> - 版本管理工具（类似Ruby的 rbenv ），它支持自动切换。</li>
<li><a href="https://github.com/ekalinin/nodeenv" rel="external nofollow noopener noreferrer" target="_blank">nodeenv</a> - 与Python的 virtualenv 兼容的Node.js虚拟环境。</li>
</ul>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><ul>
<li><p><strong>NPM管理工具</strong></p>
</li>
<li><p><a href="https://github.com/pnpm/pnpm" rel="external nofollow noopener noreferrer" target="_blank">pnpm</a> - 快速、节省磁盘空间高效的包管理器。</p>
</li>
<li><a href="https://github.com/npm/cli" rel="external nofollow noopener noreferrer" target="_blank">npm</a> - JavaScript包管理工具。</li>
<li><a href="https://github.com/yarnpkg/berry" rel="external nofollow noopener noreferrer" target="_blank">yarn</a> - 现代包管理工具，拆分成多个不同的包。</li>
<li><a href="https://github.com/Pana/nrm" rel="external nofollow noopener noreferrer" target="_blank">nrm</a> - 快速切换npm注册服务商，如npm、cnpm、nj、taobao。</li>
<li><a href="https://github.com/cnpm/cnpm" rel="external nofollow noopener noreferrer" target="_blank">cnpm</a> - NPM中国区镜像客户端。</li>
</ul>
<ul>
<li><p><strong>package.json</strong></p>
</li>
<li><p><a href="https://github.com/sindresorhus/read-pkg-up" rel="external nofollow noopener noreferrer" target="_blank">read-pkg-up</a> - 读取最近的package.json文件。</p>
</li>
<li><a href="https://github.com/indexzero/node-pkginfo" rel="external nofollow noopener noreferrer" target="_blank">node-pkginfo</a> - 从package.json读取属性的简单方法。</li>
<li><a href="https://github.com/sindresorhus/pkg-dir" rel="external nofollow noopener noreferrer" target="_blank">pkg-dir</a> - 查找npm包的根目录。</li>
<li><a href="https://github.com/sindresorhus/read-pkg" rel="external nofollow noopener noreferrer" target="_blank">read-pkg</a> - 读取package.json文件。</li>
<li><a href="https://github.com/sindresorhus/write-pkg" rel="external nofollow noopener noreferrer" target="_blank">write-pkg</a> - 写入package.json文件。</li>
<li><a href="https://github.com/npm/read-package-json-fast" rel="external nofollow noopener noreferrer" target="_blank">read-package-json-fast</a> - 类似 read-package-json, 但更快。</li>
</ul>
<ul>
<li><p><strong>语义化版本</strong></p>
</li>
<li><p><a href="https://github.com/npm/node-semver" rel="external nofollow noopener noreferrer" target="_blank">semver</a> - NPM使用的JavaScript语义化版本号解析器。</p>
</li>
<li><a href="https://github.com/omichelsen/compare-versions" rel="external nofollow noopener noreferrer" target="_blank">compare-versions</a> - 比较semver版本字符串，找出哪个更大，哪个相等，哪个更小。</li>
</ul>
<ul>
<li><p><strong>工具</strong></p>
</li>
<li><p><a href="https://github.com/raineorshine/npm-check-updates" rel="external nofollow noopener noreferrer" target="_blank">npm-check-updates</a> - 查找当前package.json依赖允许的更新的版本。</p>
</li>
<li><a href="https://github.com/kimmobrunfeldt/concurrently" rel="external nofollow noopener noreferrer" target="_blank">concurrently</a> - 并行执行命令，类似 <code>npm run watch-js &amp; npm run watch-less</code>但更优。</li>
<li><a href="https://github.com/mysticatea/npm-run-all" rel="external nofollow noopener noreferrer" target="_blank">npm-run-all</a> - 命令行工具，同时运行多个npm脚本（并行或串行）。</li>
<li><a href="https://github.com/depcheck/depcheck" rel="external nofollow noopener noreferrer" target="_blank">depcheck</a> - 检查你的NPM模块未使用的依赖。</li>
<li><a href="https://github.com/cnpm/npminstall" rel="external nofollow noopener noreferrer" target="_blank">npminstall</a> - 使 <code>npm install</code> 更快更容易。</li>
<li><a href="https://github.com/npm/validate-npm-package-name" rel="external nofollow noopener noreferrer" target="_blank">validate-npm-package-name</a> - 校验给定的字符串 是否为 可接受的 npm 包名称。</li>
<li><a href="https://github.com/sindresorhus/npm-home" rel="external nofollow noopener noreferrer" target="_blank">npm-home</a> - 打开npm包页面。</li>
<li><a href="https://github.com/sindresorhus/npm-name" rel="external nofollow noopener noreferrer" target="_blank">npm-name</a> - 在npm上检查软件包名称的可用性。</li>
<li><a href="https://github.com/npm/pacote" rel="external nofollow noopener noreferrer" target="_blank">pacote</a> - 从npm注册商下载tar压缩文件，并获取包的资源信息。</li>
<li><a href="https://github.com/npm/npm-package-arg" rel="external nofollow noopener noreferrer" target="_blank">npm-package-arg</a> - 根据包名解析信息。</li>
<li><a href="https://github.com/npm/npm-registry-fetch" rel="external nofollow noopener noreferrer" target="_blank">npm-registry-fetch</a> - 类型fetch()函数，但用于npm仓库。</li>
<li><a href="https://github.com/node-modules/npm-updater" rel="external nofollow noopener noreferrer" target="_blank">npm-updater</a> - 检查npm包的更新。</li>
</ul>
<h2 id="Monorepo"><a href="#Monorepo" class="headerlink" title="Monorepo"></a>Monorepo</h2><p><em>(你也许喜欢 <a href="https://github.com/korfuri/awesome-monorepo" rel="external nofollow noopener noreferrer" target="_blank">awesome-monorepo</a>)</em></p>
<ul>
<li><a href="https://github.com/lerna/lerna" rel="external nofollow noopener noreferrer" target="_blank">lerna</a> - 用于管理具有多个包的JavaScript项目的工具。</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ul>
<li><p><strong>通用</strong></p>
</li>
<li><p><a href="https://github.com/jprichardson/node-fs-extra" rel="external nofollow noopener noreferrer" target="_blank">fs-extra</a> - 为 <code>fs</code> 模块提供额外方法。</p>
</li>
<li><a href="https://github.com/isaacs/node-graceful-fs" rel="external nofollow noopener noreferrer" target="_blank">graceful-fs</a> - graceful-fs可以替代fs模块，并做了各种改进。</li>
<li><a href="https://github.com/avoidwork/filesize.js" rel="external nofollow noopener noreferrer" target="_blank">filesize.js</a> - 生成人类可读的文件大小字符串。</li>
<li><a href="https://github.com/streamich/memfs" rel="external nofollow noopener noreferrer" target="_blank">memfs</a> - Node.js API内存文件系统。</li>
<li><a href="https://github.com/szwacz/fs-jetpack" rel="external nofollow noopener noreferrer" target="_blank">fs-jetpack</a> - 完全重新设计的文件系统API，方便日常使用。</li>
<li><a href="https://github.com/sindresorhus/make-dir" rel="external nofollow noopener noreferrer" target="_blank">make-dir</a> - 递归创建文件夹，类似 <code>mkdir -p</code>。</li>
<li><a href="https://github.com/sindresorhus/find-up" rel="external nofollow noopener noreferrer" target="_blank">find-up</a> - 通过上级父目录查找文件或目录。</li>
<li><a href="https://github.com/sindresorhus/filenamify" rel="external nofollow noopener noreferrer" target="_blank">filenamify</a> - 将字符串转换为有效的文件名。</li>
<li><a href="https://github.com/calvinmetcalf/copyfiles" rel="external nofollow noopener noreferrer" target="_blank">copyfiles</a> - 在命令行中复制文件。</li>
<li><a href="https://github.com/nspragg/filehound" rel="external nofollow noopener noreferrer" target="_blank">filehound</a> - 灵活流畅的文件系统搜索接口。</li>
<li><a href="https://github.com/sindresorhus/move-file" rel="external nofollow noopener noreferrer" target="_blank">move-file</a> - 移动文件，甚至可以跨设备工作。</li>
<li><a href="https://github.com/IndigoUnited/node-proper-lockfile" rel="external nofollow noopener noreferrer" target="_blank">proper-lockfile</a> - 进程间和机器间文件锁实用工具。</li>
<li><a href="https://github.com/bevry/istextorbinary" rel="external nofollow noopener noreferrer" target="_blank">istextorbinary</a> - 检查文件是文本文件还是二进制文件。</li>
<li><a href="https://github.com/isaacs/node-mkdirp" rel="external nofollow noopener noreferrer" target="_blank">mkdirp</a> - 递归创建文件夹，类似 <code>mkdir -p</code>。</li>
<li><a href="https://github.com/gliviu/dir-compare" rel="external nofollow noopener noreferrer" target="_blank">dir-compare</a> - Node JS文件夹对比。</li>
<li><a href="https://github.com/marc136/node-folder-hash" rel="external nofollow noopener noreferrer" target="_blank">folder-hash</a> - 为 文件夹或文件 上创建哈希检验码。</li>
<li><a href="https://github.com/kevva/lnfs" rel="external nofollow noopener noreferrer" target="_blank">lnfs</a> - 强制创建符号链接。类似<code>ln -fs</code>.</li>
</ul>
<ul>
<li><p><strong>复制</strong></p>
</li>
<li><p><a href="https://github.com/AvianFlu/ncp" rel="external nofollow noopener noreferrer" target="_blank">ncp</a> - 使用Node.js进行异步递归文件复制。</p>
</li>
<li><a href="https://github.com/sindresorhus/cpy" rel="external nofollow noopener noreferrer" target="_blank">cpy</a> - 文件拷贝。</li>
</ul>
<ul>
<li><p><strong>删除</strong></p>
</li>
<li><p><a href="https://github.com/isaacs/rimraf" rel="external nofollow noopener noreferrer" target="_blank">rimraf</a> - 递归删除文件，类似 <code>rm -rf</code>。</p>
</li>
<li><a href="https://github.com/sindresorhus/del" rel="external nofollow noopener noreferrer" target="_blank">del</a> - 删除文件/文件夹。</li>
</ul>
<ul>
<li><p><strong>临时</strong></p>
</li>
<li><p><a href="https://github.com/bruce/node-temp" rel="external nofollow noopener noreferrer" target="_blank">temp</a> - Node.js临时文件、文件夹、流。</p>
</li>
<li><a href="https://github.com/sindresorhus/tempy" rel="external nofollow noopener noreferrer" target="_blank">tempy</a> - 获取随机的临时文件或目录路径。</li>
<li><a href="https://github.com/sindresorhus/temp-dir" rel="external nofollow noopener noreferrer" target="_blank">temp-dir</a> - 获取系统临时文件夹的真实路径。</li>
</ul>
<ul>
<li><p><strong>监控</strong></p>
</li>
<li><p><a href="https://github.com/paulmillr/chokidar" rel="external nofollow noopener noreferrer" target="_blank">chokidar</a> - 最小且高效的跨平台Watch库。</p>
</li>
<li><a href="https://github.com/webpack/watchpack" rel="external nofollow noopener noreferrer" target="_blank">watchpack</a> - Watch文件和文件夹。</li>
</ul>
<ul>
<li><p><strong>遍历查找</strong></p>
</li>
<li><p><a href="https://github.com/isaacs/node-glob" rel="external nofollow noopener noreferrer" target="_blank">glob</a> - Node.js版glob功能。</p>
</li>
<li><a href="https://github.com/sindresorhus/globby" rel="external nofollow noopener noreferrer" target="_blank">globby</a> - 基于fast-glob，但添加了很多有用的特性。</li>
<li><a href="https://github.com/mrmlnc/fast-glob" rel="external nofollow noopener noreferrer" target="_blank">fast-glob</a> - 非常快速且高效的Node.js glob库。</li>
<li><a href="https://github.com/AndyOGo/node-sync-glob" rel="external nofollow noopener noreferrer" target="_blank">node-sync-glob</a> - 通过glob模式在本地同步文件和文件夹，包括watch选项。</li>
</ul>
<h2 id="解析工具"><a href="#解析工具" class="headerlink" title="解析工具"></a>解析工具</h2><ul>
<li><p><strong>Markdown</strong></p>
</li>
<li><p><a href="https://github.com/markedjs/marked" rel="external nofollow noopener noreferrer" target="_blank">marked</a> - Markdown解析器和编译器，专为提高速度而设计。</p>
</li>
<li><a href="https://github.com/wooorm/remark" rel="external nofollow noopener noreferrer" target="_blank">remark</a> - Markdown处理工具。</li>
<li><a href="https://github.com/markdown-it/markdown-it" rel="external nofollow noopener noreferrer" target="_blank">markdown-it</a> - 支持100%通用Markdown标签解析的扩展&amp;语法插件。</li>
<li><a href="https://www.npmjs.com/package/turndown" rel="external nofollow noopener noreferrer" target="_blank">turndown</a> - 用 JavaScript 编写的 HTML 到 Markdown 转换器。</li>
</ul>
<ul>
<li><strong>CSV</strong></li>
</ul>
<ul>
<li><a href="https://github.com/mholt/PapaParse" rel="external nofollow noopener noreferrer" target="_blank">PapaParse</a> - 快速而强大的 CSV（分隔文本）解析器，可以优雅地处理大文件和格式错误的输入。</li>
<li><a href="https://github.com/adaltas/node-csv" rel="external nofollow noopener noreferrer" target="_blank">node-csv</a> - 具有简单api的全功能CSV解析器，并针对大型数据集进行了测试。</li>
<li><a href="https://github.com/mafintosh/csv-parser" rel="external nofollow noopener noreferrer" target="_blank">csv-parser</a> - 旨在比其他任何人都快的流式CSV解析器。</li>
<li><a href="https://github.com/sindresorhus/neat-csv" rel="external nofollow noopener noreferrer" target="_blank">neat-csv</a> - 快速的CSV解析器。</li>
</ul>
<ul>
<li><strong>YAML</strong></li>
</ul>
<ul>
<li><a href="https://github.com/nodeca/js-yaml" rel="external nofollow noopener noreferrer" target="_blank">js-yaml</a> - 快速的YAML解析器。</li>
<li><a href="https://github.com/eemeli/yaml" rel="external nofollow noopener noreferrer" target="_blank">yaml</a> - YAML 的 JavaScript 解析器和字符串化。</li>
</ul>
<ul>
<li><strong>XML</strong></li>
</ul>
<ul>
<li><a href="https://github.com/Leonidas-from-XIV/node-xml2js" rel="external nofollow noopener noreferrer" target="_blank">xml2js</a> - 将XML转换为JavaScript对象的转换器。</li>
<li><a href="https://github.com/NaturalIntelligence/fast-xml-parser" rel="external nofollow noopener noreferrer" target="_blank">fast-xml-parser</a> - 验证&amp;解析 XML。</li>
<li><a href="https://github.com/oozcitak/xmlbuilder-js" rel="external nofollow noopener noreferrer" target="_blank">xmlbuilder</a> - XML构建器。</li>
<li><a href="https://github.com/michaelkourlas/node-js2xmlparser" rel="external nofollow noopener noreferrer" target="_blank">js2xmlparser</a> - 用于将 JavaScript 对象解析为 XML 的流行 Node.js 模块。</li>
</ul>
<ul>
<li><strong>HTML</strong></li>
</ul>
<ul>
<li><a href="https://github.com/fb55/htmlparser2" rel="external nofollow noopener noreferrer" target="_blank">htmlparser2</a> - 宽容的 HTML 和 XML 解析器。</li>
<li><a href="https://github.com/andrejewski/himalaya" rel="external nofollow noopener noreferrer" target="_blank">himalaya</a> - 将HTML转化为JSON的解析器。</li>
</ul>
<ul>
<li><strong>CSS</strong></li>
</ul>
<ul>
<li><a href="https://github.com/postcss/postcss" rel="external nofollow noopener noreferrer" target="_blank">PostCSS</a> - CSS解析工具。</li>
<li><a href="https://github.com/less/less.js" rel="external nofollow noopener noreferrer" target="_blank">less</a> - Less动态样式表语言。</li>
</ul>
<ul>
<li><strong>SQL</strong></li>
</ul>
<ul>
<li><a href="https://github.com/oguimbal/pgsql-ast-parser" rel="external nofollow noopener noreferrer" target="_blank">pgsql-ast-parser</a> - 简单的Postgres SQL解析器。</li>
<li><a href="https://github.com/DTStack/dt-sql-parser" rel="external nofollow noopener noreferrer" target="_blank">dt-sql-parser</a> - 大数据的SQL解析器，用antlr4构建。</li>
</ul>
<ul>
<li><strong>Plist</strong></li>
</ul>
<ul>
<li><a href="https://github.com/joeferner/node-bplist-parser" rel="external nofollow noopener noreferrer" target="_blank">node-bplist-parser</a> - 二进制plist文件解析。</li>
</ul>
<ul>
<li><strong>ini</strong></li>
</ul>
<ul>
<li><a href="https://github.com/npm/ini" rel="external nofollow noopener noreferrer" target="_blank">ini</a> - ini文件解析和序列化。</li>
</ul>
<ul>
<li><strong>其他</strong></li>
</ul>
<ul>
<li><a href="https://github.com/mozilla/readability" rel="external nofollow noopener noreferrer" target="_blank">readability</a> - 可读内容提取库，用于Firefox Reader View的独立提取版本。</li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a href="https://github.com/typicode/husky" rel="external nofollow noopener noreferrer" target="_blank">husky</a> - 现代化的本地Git钩子使操作更加轻松！</li>
<li><a href="https://github.com/nodegit/nodegit" rel="external nofollow noopener noreferrer" target="_blank">nodegit</a> - <a href="https://libgit2.org/" rel="external nofollow noopener noreferrer" target="_blank">libgit2</a> 的 Node.js 绑定版本。</li>
<li><a href="https://github.com/steveukx/git-js" rel="external nofollow noopener noreferrer" target="_blank">simple-git</a> - 一个轻量级的接口，用于在任何 node.js 应用程序中运行 git 命令。</li>
<li><a href="https://github.com/nicoespeon/gitgraph.js/tree/master/packages/gitgraph-node" rel="external nofollow noopener noreferrer" target="_blank">gitgraph-node</a> - 在 Terminal 绘制 git 流程图（支持浏览器、React）。</li>
<li><a href="https://github.com/observing/pre-commit" rel="external nofollow noopener noreferrer" target="_blank">pre-commit</a> - 自动在您的git储存库中安装git pre-commit脚本，该脚本在pre-commit上运行您的<code>npm test</code>。</li>
<li><a href="https://github.com/yyx990803/yorkie" rel="external nofollow noopener noreferrer" target="_blank">yorkie</a> - husky的Fork，让 Git 钩子变得简单(在 vue3 中使用)</li>
<li><a href="https://github.com/IonicaBizau/git-url-parse" rel="external nofollow noopener noreferrer" target="_blank">git-url-parse</a> - 高级别git解析。</li>
<li><a href="https://github.com/piuccio/git-promise" rel="external nofollow noopener noreferrer" target="_blank">git-promise</a> - 简单的封装，可运行任何git命令，并使用promise处理其输出。</li>
<li><a href="https://github.com/lukeed/gittar" rel="external nofollow noopener noreferrer" target="_blank">gittar</a> - 下载/提取git仓库 (GitHub, GitLab, BitBucket)，跨平台和优先离线。</li>
<li><a href="https://github.com/jonschlinkert/parse-git-config" rel="external nofollow noopener noreferrer" target="_blank">parse-git-config</a> - 将 <code>.git/config</code> 解析为 JavaScript 对象。 同步或异步。</li>
<li><a href="https://github.com/sindresorhus/remote-git-tags" rel="external nofollow noopener noreferrer" target="_blank">remote-git-tags</a> - 从远程仓库中获取标签。</li>
<li><a href="https://github.com/repo-utils/giturl" rel="external nofollow noopener noreferrer" target="_blank">giturl</a> - 将Git链接转化成Web链接。</li>
<li><a href="https://gitlab.com/flippidippi/download-git-repo" rel="external nofollow noopener noreferrer" target="_blank">download-git-repo</a> - 下载和提取Git仓库 (支持GitHub, GitLab, Bitbucket)。</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul>
<li><a href="https://github.com/winstonjs/winston" rel="external nofollow noopener noreferrer" target="_blank">winston</a> - 多传输异步日志记录库。</li>
<li><a href="https://github.com/pinojs/pino" rel="external nofollow noopener noreferrer" target="_blank">pino</a> - 受Bunyan启发的超快日志记录库。</li>
<li><a href="https://github.com/klauscfhq/signale" rel="external nofollow noopener noreferrer" target="_blank">signale</a> - 高度可配置的日志工具。</li>
<li><a href="https://github.com/trentm/node-bunyan" rel="external nofollow noopener noreferrer" target="_blank">bunyan</a> - 一个用于 Node.js 服务的简单快速的 JSON 日志模块。</li>
<li><a href="https://github.com/log4js-node/log4js-node" rel="external nofollow noopener noreferrer" target="_blank">log4js-node</a> - 不同于Java log4j的日志记录库。</li>
<li><a href="https://github.com/nuxt/consola" rel="external nofollow noopener noreferrer" target="_blank">consola</a> - 优雅的Node.js和浏览器日志记录库。</li>
<li><a href="https://github.com/guigrpa/storyboard" rel="external nofollow noopener noreferrer" target="_blank">storyboard</a> - 一个Chrome浏览器插件，用于查看日志。</li>
<li><a href="https://github.com/cabinjs/cabin" rel="external nofollow noopener noreferrer" target="_blank">cabin</a> - 提供日志服务和NPM包。</li>
<li><a href="https://github.com/gulpjs/fancy-log" rel="external nofollow noopener noreferrer" target="_blank">fancy-log</a> - 带上时间前缀的日志记录库。</li>
<li><a href="https://github.com/balderdashy/captains-log" rel="external nofollow noopener noreferrer" target="_blank">captains-log</a> - 通过简单的配置就可以使用的轻量日志记录库。</li>
</ul>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul>
<li><a href="https://github.com/Unitech/pm2" rel="external nofollow noopener noreferrer" target="_blank">PM2</a> - 高级进程管理工具。</li>
<li><a href="https://github.com/remy/nodemon" rel="external nofollow noopener noreferrer" target="_blank">nodemon</a> - 监视应用程序中的更改并自动重新启动服务器。</li>
<li><a href="https://github.com/foreversd/forever" rel="external nofollow noopener noreferrer" target="_blank">forever</a> - 简单的CLI工具，用于确认提供的代码持续运行。</li>
<li><a href="https://github.com/petruisfan/node-supervisor" rel="external nofollow noopener noreferrer" target="_blank">supervisor</a> - 当脚本崩溃时重新启动脚本，或者当`*.js’文件更改时重新启动脚本。</li>
<li><a href="https://github.com/coreybutler/node-windows" rel="external nofollow noopener noreferrer" target="_blank">node-windows</a> - 将脚本作为本机Windows服务运行，并登录到事件查看器。</li>
<li><a href="https://github.com/coreybutler/node-mac" rel="external nofollow noopener noreferrer" target="_blank">node-mac</a> - 将脚本作为本机Mac守护进程运行，并登录到控制台应用程序。</li>
<li><a href="https://github.com/coreybutler/node-linux" rel="external nofollow noopener noreferrer" target="_blank">node-linux</a> - 将脚本作为本机系统服务运行，并登录到syslog。</li>
<li><a href="https://github.com/branneman/current-processes" rel="external nofollow noopener noreferrer" target="_blank">current-processes</a> - 可获取当前正在运行的进程快照（操作系统无关）。</li>
</ul>
<h2 id="代码校验-和-格式化工具"><a href="#代码校验-和-格式化工具" class="headerlink" title="代码校验 和 格式化工具"></a>代码校验 和 格式化工具</h2><ul>
<li><a href="https://github.com/prettier/prettier" rel="external nofollow noopener noreferrer" target="_blank">prettier</a> - ❤”有主见”的多语言代码格式化程序。</li>
<li><a href="https://github.com/standard/standard" rel="external nofollow noopener noreferrer" target="_blank">standard</a> - JavaScript 代码规范，自带 linter &amp; 代码自动修正。</li>
<li><a href="https://github.com/eslint/eslint" rel="external nofollow noopener noreferrer" target="_blank">eslint</a> - 插件化并且可配置的 JavaScript 语法规则和代码风格的检查工具。</li>
<li><a href="https://github.com/stylelint/stylelint" rel="external nofollow noopener noreferrer" target="_blank">stylelint</a> - 功能强大现代风格检查工具，帮助你避免错误和强制约定样式风格。</li>
<li><a href="https://github.com/okonet/lint-staged" rel="external nofollow noopener noreferrer" target="_blank">lint-staged</a> - 在Git暂存文件上运行风格检查工具。</li>
<li><a href="https://github.com/conventional-changelog/commitlint" rel="external nofollow noopener noreferrer" target="_blank">commitlint</a> - Git提交信息风格检查工具。</li>
<li><a href="https://github.com/beautify-web/js-beautify" rel="external nofollow noopener noreferrer" target="_blank">js-beautify</a> - Javascript美化工具。</li>
<li><a href="https://github.com/xojs/xo" rel="external nofollow noopener noreferrer" target="_blank">xo</a> - 带出色默认配置的JavaScript/TypeScript代码校验 (基于ESLint封装)</li>
<li><a href="https://github.com/DavidAnson/markdownlint" rel="external nofollow noopener noreferrer" target="_blank">markdownlint</a> - Markdown/CommonMark风格检查工具。</li>
<li><a href="https://github.com/textlint/textlint" rel="external nofollow noopener noreferrer" target="_blank">textlint</a> - Text 和 Markdown 校验和格式化。</li>
<li><a href="https://github.com/azz/pretty-quick" rel="external nofollow noopener noreferrer" target="_blank">pretty-quick</a> - 快速美化。</li>
</ul>
<h2 id="配置工具"><a href="#配置工具" class="headerlink" title="配置工具"></a>配置工具</h2><ul>
<li><a href="https://github.com/lorenwest/node-config" rel="external nofollow noopener noreferrer" target="_blank">node-config</a> - Node.js 应用程序配置。</li>
<li><a href="https://github.com/indexzero/nconf" rel="external nofollow noopener noreferrer" target="_blank">nconf</a> - 可通过文件、环境变量、命令行参数和对象 合并的分层 Node.js 配置。</li>
<li><a href="https://github.com/mozilla/node-convict/tree/master/packages/convict" rel="external nofollow noopener noreferrer" target="_blank">convict</a> - Convict 扩展了配置 node.js 应用程序的标准模式，提供了更健壮且易于访问。</li>
<li><a href="https://github.com/dominictarr/rc" rel="external nofollow noopener noreferrer" target="_blank">rc</a> - 懒人的配置加载器。</li>
</ul>
<h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><ul>
<li><a href="https://github.com/webpack/webpack" rel="external nofollow noopener noreferrer" target="_blank">webpack</a> - 打包浏览器的模块和资产。</li>
<li><a href="https://github.com/parcel-bundler/parcel" rel="external nofollow noopener noreferrer" target="_blank">parcel</a> - 快速，零配置的Web应用构建工具。</li>
<li><a href="https://github.com/gulpjs/gulp" rel="external nofollow noopener noreferrer" target="_blank">gulp</a> - 流式快速构建系统，支持代码而不是配置。</li>
<li><a href="https://github.com/evanw/esbuild" rel="external nofollow noopener noreferrer" target="_blank">esbuild</a> - 极快的JavaScript打包压缩工具。</li>
<li><a href="https://github.com/rollup/rollup" rel="external nofollow noopener noreferrer" target="_blank">rollup</a> - 新一代的 ES2015 打包构建工具。</li>
<li><a href="https://github.com/zeit/pkg" rel="external nofollow noopener noreferrer" target="_blank">pkg</a> - 将Node.js项目打包成可执行文件。</li>
<li><a href="https://github.com/gruntjs/grunt" rel="external nofollow noopener noreferrer" target="_blank">Grunt</a> - JavaScript任务执行器。</li>
<li><a href="https://github.com/brunch/brunch" rel="external nofollow noopener noreferrer" target="_blank">Brunch</a> - 前端web应用程序构建工具，具有简单的声明性配置、快速的增量编译和自定的工作流。</li>
<li><a href="https://github.com/fuse-box/fuse-box" rel="external nofollow noopener noreferrer" target="_blank">FuseBox</a> - 快速构建系统，结合了webpack，JSPM和SystemJS的强大功能，并具有一流的TypeScript支持。</li>
<li><a href="https://github.com/broccolijs/broccoli" rel="external nofollow noopener noreferrer" target="_blank">Broccoli</a> - 快速、可靠的资产管道，支持固定时间重建和紧凑的构建定义。</li>
</ul>
<h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a><strong>ESM</strong></h2><ul>
<li><a href="https://github.com/vitejs/vite" rel="external nofollow noopener noreferrer" target="_blank">Vite</a> - 新一代前端构建工具。</li>
<li><a href="https://github.com/snowpackjs/snowpack" rel="external nofollow noopener noreferrer" target="_blank">snowpack</a> - 由ESM支持的前端构建工具。 即时，轻量级，无捆绑开发。</li>
</ul>
<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><ul>
<li><a href="https://github.com/pugjs/pug" rel="external nofollow noopener noreferrer" target="_blank">Pug</a> - 受Haml启发的高性能模板引擎。</li>
<li><a href="https://github.com/wycats/handlebars.js" rel="external nofollow noopener noreferrer" target="_blank">handlebars.js</a> - Mustache 模板的超集，添加了强大的功能，如helper和更高级的block。</li>
<li><a href="https://github.com/janl/mustache.js" rel="external nofollow noopener noreferrer" target="_blank">mustache.js</a> - 轻量的JavaScript模板引擎。</li>
<li><a href="https://github.com/marko-js/marko" rel="external nofollow noopener noreferrer" target="_blank">marko</a> - 基于HTML的模板引擎，编译成CommonJS模块，支持流、异步渲染和自定义标签。</li>
<li><a href="https://github.com/aui/art-template" rel="external nofollow noopener noreferrer" target="_blank">art-template</a> - 高性能JavaScript模板引擎。</li>
<li><a href="https://github.com/mozilla/nunjucks" rel="external nofollow noopener noreferrer" target="_blank">nunjucks</a> - 具有继承，异步控制等功能的模板引擎（受Jinja2启发）。</li>
<li><a href="https://github.com/mde/ejs" rel="external nofollow noopener noreferrer" target="_blank">EJS</a> - 超级简单的模板语言。</li>
<li><a href="https://github.com/twitter/hogan.js" rel="external nofollow noopener noreferrer" target="_blank">hogan.js</a> -  样式的模板语言。</li>
<li><a href="https://github.com/olado/doT" rel="external nofollow noopener noreferrer" target="_blank">doT</a> - 最快简洁的JavaScript模板引擎。</li>
<li><a href="https://github.com/linkedin/dustjs" rel="external nofollow noopener noreferrer" target="_blank">dustjs</a> - 用于浏览器和服务器的异步Javascript模板。</li>
<li><a href="https://github.com/BorisMoore/jsrender" rel="external nofollow noopener noreferrer" target="_blank">jsrender</a> - 轻巧，功能强大且高度可扩展的模板引擎。</li>
<li><a href="https://github.com/twigjs/twig.js" rel="external nofollow noopener noreferrer" target="_blank">Twig.js</a> - Twig模板语言的JavaScript实现。</li>
<li><a href="https://github.com/pillarjs/hbs" rel="external nofollow noopener noreferrer" target="_blank">hbs</a> - Handlebars的Express版本封装。</li>
<li><a href="https://github.com/PaulGuo/Juicer" rel="external nofollow noopener noreferrer" target="_blank">Juicer</a> - 轻量级JavaScript模板引擎。</li>
<li><a href="https://github.com/twigkit/tempo" rel="external nofollow noopener noreferrer" target="_blank">tempo</a> - Tempo是一个简单，直观的JavaScript渲染引擎，使您能够以纯HTML格式制作数据模板。</li>
<li><a href="https://github.com/xtemplate/xtemplate" rel="external nofollow noopener noreferrer" target="_blank">xtemplate</a> - 用于浏览器和Node.js上的高速，可扩展模板引擎库。支持异步控制，继承，包含，逻辑表达式，自定义函数等。</li>
</ul>
<h2 id="内容管理系统-CMS"><a href="#内容管理系统-CMS" class="headerlink" title="内容管理系统 (CMS)"></a>内容管理系统 (CMS)</h2><ul>
<li><a href="https://github.com/TryGhost/Ghost" rel="external nofollow noopener noreferrer" target="_blank">Ghost</a> - 用于专业发布的无头 Node.js CMS。</li>
<li><a href="https://github.com/strapi/strapi" rel="external nofollow noopener noreferrer" target="_blank">Strapi</a> - 用于构建强大 API 的内容管理框架 (headless-CMS)。</li>
<li><a href="https://github.com/keystonejs/keystone" rel="external nofollow noopener noreferrer" target="_blank">KeystoneJS</a> - 基于 Express 和 MongoDB 的 CMS 和 Web应用程序平台。</li>
<li><a href="https://github.com/SoftwareBrothers/admin-bro" rel="external nofollow noopener noreferrer" target="_blank">AdminBro</a> - 为您的所有模型自动生成带有 增删查改(CRUD) 的管理面板。</li>
<li><a href="https://github.com/apostrophecms/apostrophe" rel="external nofollow noopener noreferrer" target="_blank">ApostropheCMS</a> - 基于 Express 和 MongoDB，拥有直观的内容编辑和管理的内容管理系统。</li>
<li><a href="https://github.com/tipeio/tipe" rel="external nofollow noopener noreferrer" target="_blank">Tipe</a> - 面向开发人员的下一代 API优先 CMS。使用离线原型和内置编辑器从 GraphQL Schema 中 生成 API优先 的 CMS。</li>
<li><a href="https://github.com/fiction-com/factor" rel="external nofollow noopener noreferrer" target="_blank">Factor</a> - Vue.js 仪表板框架 和 无头CMS。</li>
</ul>
<h2 id="静态网站生成-amp-博客"><a href="#静态网站生成-amp-博客" class="headerlink" title="静态网站生成 &amp; 博客"></a>静态网站生成 &amp; 博客</h2><ul>
<li><a href="https://github.com/gatsbyjs/gatsby" rel="external nofollow noopener noreferrer" target="_blank">gatsby</a> - 使用React构建快速、现代的应用程序和网站。</li>
<li><a href="https://github.com/hexojs/hexo" rel="external nofollow noopener noreferrer" target="_blank">hexo</a> - 使用Node.js的快速，简单，强大的博客框架。</li>
<li><a href="https://github.com/vuejs/vuepress" rel="external nofollow noopener noreferrer" target="_blank">vuepress</a> - 极简的Vue静态网站生成工具。</li>
<li><a href="https://github.com/netlify/netlify-cms" rel="external nofollow noopener noreferrer" target="_blank">netlify-cms</a> - 基于Git的静态网站生成工具。</li>
<li><a href="https://github.com/react-static/react-static" rel="external nofollow noopener noreferrer" target="_blank">react-static</a> - 渐进式的React静态网站生成工具。</li>
<li><a href="https://github.com/gridsome/gridsome" rel="external nofollow noopener noreferrer" target="_blank">gridsome</a> - Vue.js静态网站生成工具。</li>
<li><a href="https://github.com/vuejs/vitepress" rel="external nofollow noopener noreferrer" target="_blank">vitepress</a> - Vite &amp; Vue.js静态网站生成工具。</li>
<li><a href="https://github.com/scullyio/scully" rel="external nofollow noopener noreferrer" target="_blank">scully</a> - Angular 应用程序的静态站点生成器。</li>
</ul>
<h2 id="文档生成"><a href="#文档生成" class="headerlink" title="文档生成"></a>文档生成</h2><ul>
<li><a href="https://github.com/facebook/docusaurus" rel="external nofollow noopener noreferrer" target="_blank">Docusaurus</a> - 使用React和Markdown并具有翻译和版本控制功能的文档站点生成器。</li>
<li><a href="https://github.com/docsifyjs/docsify" rel="external nofollow noopener noreferrer" target="_blank">docsify</a> - API文档生成器。</li>
<li><a href="https://github.com/jsdoc3/jsdoc" rel="external nofollow noopener noreferrer" target="_blank">JSDoc</a> - API文档生成器，类似于JavaDoc或PHPDoc。</li>
<li><a href="https://github.com/documentationjs/documentation" rel="external nofollow noopener noreferrer" target="_blank">documentation.js</a> - API文档生成器，支持ES2015+和流程注释。</li>
<li><a href="https://github.com/jashkenas/docco" rel="external nofollow noopener noreferrer" target="_blank">Docco</a> - 文档生成器，该生成器生成一个HTML文档，该文档显示与代码混合的注释。</li>
<li><a href="https://github.com/egoist/docute" rel="external nofollow noopener noreferrer" target="_blank">docute</a> - 毫不费力的文档，做就对了。</li>
<li><a href="https://github.com/esdoc/esdoc" rel="external nofollow noopener noreferrer" target="_blank">ESDoc</a> - 针对ES2015的文档生成器，附加测试代码并衡量文档覆盖范围。</li>
</ul>
<h2 id="桌面应用程序"><a href="#桌面应用程序" class="headerlink" title="桌面应用程序"></a>桌面应用程序</h2><ul>
<li><a href="https://github.com/atom/electron" rel="external nofollow noopener noreferrer" target="_blank">Electron</a> - 使用Web技术构建跨平台的桌面应用程序。 <em>(你也许喜欢 <a href="https://github.com/sindresorhus/awesome-electron" rel="external nofollow noopener noreferrer" target="_blank">awesome-electron</a>)</em></li>
<li><a href="https://github.com/nwjs/nw.js" rel="external nofollow noopener noreferrer" target="_blank">nw.js</a> - 使用 Web 技术编写应用程序的新方法，并直接从 DOM/WebWorker 调用所有 Node.js 模块。</li>
</ul>
<h2 id="实时通信"><a href="#实时通信" class="headerlink" title="实时通信"></a>实时通信</h2><ul>
<li><a href="https://github.com/socketio/socket.io" rel="external nofollow noopener noreferrer" target="_blank">Socket.io</a> - 实现基于事件的实时双向通信。</li>
<li><a href="https://github.com/websockets/ws" rel="external nofollow noopener noreferrer" target="_blank">ws</a> - 简单易用，速度极快，经过全面测试的WebSocket客户端和服务器Node.js通信库。</li>
<li><a href="https://github.com/uWebSockets/uWebSockets" rel="external nofollow noopener noreferrer" target="_blank">µWebSockets</a> - 高度可扩展的WebSocket服务器和客户端库。</li>
<li><a href="https://github.com/mqttjs/MQTT.js" rel="external nofollow noopener noreferrer" target="_blank">MQTT.js</a> - MQTT客户端-基于Pub-sub的消息协议，用于TCP / IP。</li>
<li><a href="https://github.com/SocketCluster/socketcluster" rel="external nofollow noopener noreferrer" target="_blank">SocketCluster</a> - 可扩展的HTTP + WebSocket引擎，可以在多个CPU内核上运行。</li>
<li><a href="https://github.com/faye/faye" rel="external nofollow noopener noreferrer" target="_blank">Faye</a> - 基于Bayeux协议的实时客户端-服务器消息总线。</li>
<li><a href="https://github.com/primus/primus" rel="external nofollow noopener noreferrer" target="_blank">Primus</a> - 实时框架的抽象层，以防止模块锁定。</li>
<li><a href="https://github.com/socketio/engine.io" rel="external nofollow noopener noreferrer" target="_blank">engine.io</a> - 基于传输的跨浏览器/跨设备双向通信层的实现Socket.IO。</li>
<li><a href="https://github.com/sockjs/sockjs-node" rel="external nofollow noopener noreferrer" target="_blank">SockJS-node</a> - WebSocket Node.js服务端实现。</li>
<li><a href="https://github.com/mcollina/aedes" rel="external nofollow noopener noreferrer" target="_blank">Aedes</a> - 可以在任何流服务器上运行的准系统MQTT服务器。</li>
<li><a href="https://github.com/elpheria/rpc-websockets" rel="external nofollow noopener noreferrer" target="_blank">rpc-websockets</a> - 通过WebSocket实现JSON-RPC 2.0。</li>
<li><a href="https://github.com/deepstreamIO/deepstream.io-client-js" rel="external nofollow noopener noreferrer" target="_blank">deepstream.io</a> - 可扩展的实时通信微服务框架。</li>
<li><a href="https://github.com/heineiuo/isomorphic-ws" rel="external nofollow noopener noreferrer" target="_blank">isomorphic-ws</a> - WebSocket 的同构实现。</li>
<li><a href="https://github.com/kalm/kalm.js" rel="external nofollow noopener noreferrer" target="_blank">Kalm</a> - 低级套接字路由器和中间件框架。</li>
</ul>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><ul>
<li><a href="https://github.com/OptimalBits/bull" rel="external nofollow noopener noreferrer" target="_blank">bull</a> - 持久作业和消息队列。</li>
<li><a href="https://github.com/squaremo/amqp.node" rel="external nofollow noopener noreferrer" target="_blank">amqp</a>- AMQP 0-9-1 rabbit消息队列连接库。</li>
<li><a href="https://github.com/SOHU-Co/kafka-node" rel="external nofollow noopener noreferrer" target="_blank">kafka-node</a>- Apache Kafka 0.8 kafka客户端。</li>
<li><a href="https://github.com/bee-queue/bee-queue" rel="external nofollow noopener noreferrer" target="_blank">bee-queue</a> - 高性能的 基于Redis的任务队列。</li>
<li><a href="https://github.com/bee-queue/arena" rel="external nofollow noopener noreferrer" target="_blank">arena</a> - bee-queue的交互式UI仪表盘。</li>
<li><a href="https://github.com/tulios/kafkajs" rel="external nofollow noopener noreferrer" target="_blank">kafkajs</a> - A modern Apache Kafka client for node.js.</li>
<li><a href="https://github.com/smrchy/rsmq" rel="external nofollow noopener noreferrer" target="_blank">rsmq</a> - 基于Redis的消息队列.</li>
<li><a href="https://github.com/bbc/sqs-consumer" rel="external nofollow noopener noreferrer" target="_blank">sqs-consumer</a> - 在没有样板文件的情况下构建基于Amazon简单队列服务（SQS）的应用程序.</li>
<li><a href="https://github.com/taskrabbit/node-resque" rel="external nofollow noopener noreferrer" target="_blank">node-resque</a> - Redis支持的作业队列.</li>
<li><a href="https://github.com/diamondio/better-queue" rel="external nofollow noopener noreferrer" target="_blank">better-queue</a> - 当你无法使用Redis时，简单高效的作业队列.</li>
<li><a href="https://github.com/weyoss/redis-smq" rel="external nofollow noopener noreferrer" target="_blank">RedisSMQ</a> - 具有实时监控功能的简单高性能Redis消息队列.</li>
<li><a href="https://github.com/nodeca/idoit" rel="external nofollow noopener noreferrer" target="_blank">idoit</a> - 具有高级作业控制的Redis支持的作业队列引擎.</li>
</ul>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><ul>
<li><a href="https://github.com/node-schedule/node-schedule" rel="external nofollow noopener noreferrer" target="_blank">node-schedule</a> - 类Cron和不类似Cron的Node.js定时任务。</li>
<li><a href="https://github.com/agenda/agenda" rel="external nofollow noopener noreferrer" target="_blank">agenda</a> - Node.js轻量级定时任务。</li>
<li><a href="https://github.com/kelektiv/node-cron" rel="external nofollow noopener noreferrer" target="_blank">node-cron</a> - 允许执行定时任务的工具。</li>
<li><a href="https://github.com/harrisiirak/cron-parser" rel="external nofollow noopener noreferrer" target="_blank">cron-parser</a> - 用于解析crontab指令的Node.js库。</li>
</ul>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul>
<li><a href="https://github.com/node-inspector/node-inspector" rel="external nofollow noopener noreferrer" target="_blank">node-inspector</a> - 基于Blink开发者工具的调试器。</li>
<li><a href="https://github.com/GoogleChromeLabs/ndb" rel="external nofollow noopener noreferrer" target="_blank">ndb</a> - Chrome DevTools调试体验改进工具。</li>
<li><a href="https://github.com/visionmedia/debug" rel="external nofollow noopener noreferrer" target="_blank">debug</a> - 轻量调试工具。</li>
<li><a href="https://github.com/s-a/iron-node" rel="external nofollow noopener noreferrer" target="_blank">ironNode</a> - 支持ES2015的Node.js开箱即用的调试器。</li>
<li><a href="https://github.com/mafintosh/why-is-node-running" rel="external nofollow noopener noreferrer" target="_blank">why-is-node-running</a> - 当Node因不明原因继续运行时，使用的分析工具。</li>
<li><a href="https://github.com/nodejs/llnode" rel="external nofollow noopener noreferrer" target="_blank">llnode</a> - 事后分析工具，使您可以检查对象并从崩溃的Node.js进程中获取信息。</li>
<li><a href="https://github.com/valyouw/njstrace" rel="external nofollow noopener noreferrer" target="_blank">njsTrace</a> - 检测和跟踪您的代码，查看所有函数调用、参数、返回值以及在每个函数中花费的时间。</li>
<li><a href="https://github.com/alidavut/locus" rel="external nofollow noopener noreferrer" target="_blank">locus</a> - Locus 是一个调试模块，它允许您通过 REPL 在运行时执行命令。</li>
<li><a href="https://github.com/watson/stackman" rel="external nofollow noopener noreferrer" target="_blank">stackman</a> - 使用代码摘录和其他优点增强错误堆栈跟踪。</li>
<li><a href="https://github.com/june07/nim" rel="external nofollow noopener noreferrer" target="_blank">NiM</a> - 管理DevTools调试工具流。</li>
<li><a href="https://github.com/automation-stack/ctrace" rel="external nofollow noopener noreferrer" target="_blank">ctrace</a> - 将系统调用信息和信号，以更良好的格式显示和扩展。</li>
<li><a href="https://github.com/joyent/node-vstream" rel="external nofollow noopener noreferrer" target="_blank">vstream</a> - 检测流。</li>
</ul>
<h2 id="剖析-分析"><a href="#剖析-分析" class="headerlink" title="剖析/分析"></a>剖析/分析</h2><ul>
<li><a href="https://github.com/clinicjs/node-clinic" rel="external nofollow noopener noreferrer" target="_blank">Clinic.js</a> - Clinic.js诊断Node.js性能问题。</li>
<li><a href="https://github.com/davidmarkclements/0x" rel="external nofollow noopener noreferrer" target="_blank">0x</a> - 火焰图分析。</li>
<li><a href="https://github.com/bnoordhuis/node-heapdump" rel="external nofollow noopener noreferrer" target="_blank">node-heapdump</a> - 存储V8内存堆使用情况，以供以后诊断。</li>
<li><a href="https://github.com/andywer/leakage" rel="external nofollow noopener noreferrer" target="_blank">leakage</a> - 内存写入泄漏测试。</li>
<li><a href="https://github.com/node-inspector/v8-profiler" rel="external nofollow noopener noreferrer" target="_blank">v8-profiler</a> - V8性能探测器。</li>
<li><a href="https://github.com/marcominetti/node-memwatch" rel="external nofollow noopener noreferrer" target="_blank">node-memwatch</a> - 一个 NodeJS 库，用于监视您的内存使用情况，并发现和隔离泄漏。</li>
<li><a href="https://github.com/hyj1991/v8-analytics" rel="external nofollow noopener noreferrer" target="_blank">v8-analytics</a> - V8引擎CPU 和 堆内存分析。</li>
<li><a href="https://github.com/sfninja/thetool" rel="external nofollow noopener noreferrer" target="_blank">thetool</a> - 以Chrome DevTools友好格式为您的应用捕获不同的CPU，内存和其他配置文件。</li>
<li><a href="https://github.com/thlorenz/flamegraph" rel="external nofollow noopener noreferrer" target="_blank">flamegraph</a> - 在Node.js或浏览器中生成火焰图。</li>
<li><a href="https://github.com/hyj1991/v8-profiler-next" rel="external nofollow noopener noreferrer" target="_blank">v8-profiler-next</a> - V8性能探测器。</li>
<li><a href="https://github.com/nswbmw/cpu-memory-monitor" rel="external nofollow noopener noreferrer" target="_blank">cpu-memory-monitor</a> - CPU 和内存监视器，自动转储。</li>
</ul>
<h2 id="应用性能监控-APM"><a href="#应用性能监控-APM" class="headerlink" title="应用性能监控 (APM)"></a>应用性能监控 (APM)</h2><ul>
<li><p><strong>解决方案</strong></p>
</li>
<li><p><a href="https://github.com/hyj1991/easy-monitor" rel="external nofollow noopener noreferrer" target="_blank">easy-monitor</a> - 企业级 Node.js 应用性能监控和在线故障定位解决方案。</p>
</li>
<li><a href="https://github.com/a597873885/webfunny_monitor" rel="external nofollow noopener noreferrer" target="_blank">webfunny_monitor</a> - Webfunny是一款轻量级的前端监控系统，也是一款前端性能监控系统，无埋点监控前端日志，实时分析前端健康状态。</li>
</ul>
<ul>
<li><strong>中间件</strong></li>
</ul>
<ul>
<li><a href="https://github.com/slanatech/swagger-stats" rel="external nofollow noopener noreferrer" target="_blank">swagger-stats</a> - 跟踪 API 调用并监控 API 性能、运行状况和使用指标。</li>
</ul>
<ul>
<li><strong>代理</strong></li>
</ul>
<ul>
<li><a href="https://github.com/siimon/prom-client" rel="external nofollow noopener noreferrer" target="_blank">prom-client</a> - Prometheus代理。</li>
<li><a href="https://github.com/elastic/apm-agent-nodejs" rel="external nofollow noopener noreferrer" target="_blank">apm-agent-nodejs</a> - Elastic APM Node.js代理。</li>
<li><a href="https://github.com/apache/skywalking-nodejs" rel="external nofollow noopener noreferrer" target="_blank">skywalking-nodejs</a> - Apache SkyWalking Node.js代理</li>
</ul>
<h2 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h2><ul>
<li><a href="https://github.com/NodeBB/NodeBB" rel="external nofollow noopener noreferrer" target="_blank">NodeBB</a> - 基于Node.js的现代Web论坛。</li>
<li><a href="https://github.com/cnodejs/nodeclub/" rel="external nofollow noopener noreferrer" target="_blank">nodeclub</a> - Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li><p><strong>驱动</strong></p>
</li>
<li><p><a href="https://github.com/mysqljs/mysql" rel="external nofollow noopener noreferrer" target="_blank">MySQL</a> - MySQL 客户端。</p>
</li>
<li><a href="https://github.com/brianc/node-postgres" rel="external nofollow noopener noreferrer" target="_blank">PostgreSQL</a> - PostgreSQL客户端。</li>
<li><a href="https://github.com/mongodb/node-mongodb-native" rel="external nofollow noopener noreferrer" target="_blank">MongoDB</a> - 官方MongoDB驱动。</li>
<li><a href="https://github.com/luin/ioredis" rel="external nofollow noopener noreferrer" target="_blank">ioredis</a> - Redis客户端。</li>
<li><a href="https://github.com/Level/levelup" rel="external nofollow noopener noreferrer" target="_blank">LevelUP</a> - LevelDB客户端。</li>
<li><a href="https://github.com/apache/couchdb-nano" rel="external nofollow noopener noreferrer" target="_blank">couchdb-nano</a> - 官方CouchDB客户端。</li>
<li><a href="https://github.com/couchbase/couchnode" rel="external nofollow noopener noreferrer" target="_blank">Couchbase</a> - Couchbase客户端（官方）。</li>
<li><a href="https://github.com/aerospike/aerospike-client-nodejs" rel="external nofollow noopener noreferrer" target="_blank">Aerospike</a> - Aerospike客户端。</li>
</ul>
<ul>
<li><strong>ODM / ORM</strong></li>
</ul>
<ul>
<li><a href="https://github.com/sequelize/sequelize" rel="external nofollow noopener noreferrer" target="_blank">Sequelize</a> - 多方ORM。 支持PostgreSQL，SQLite，MySQL。</li>
<li><a href="https://github.com/typeorm/typeorm" rel="external nofollow noopener noreferrer" target="_blank">TypeORM</a> - PostgreSQL，MariaDB，MySQL，SQLite等的ORM。</li>
<li><a href="https://github.com/Automattic/mongoose" rel="external nofollow noopener noreferrer" target="_blank">Mongoose</a> - 优雅的MongoDB对象建模。</li>
<li><a href="https://github.com/typegoose/typegoose" rel="external nofollow noopener noreferrer" target="_blank">typegoose</a> - Typegoose - 使用 TypeScript 类定义 Mongoose 模型。</li>
<li><a href="https://github.com/prisma/prisma" rel="external nofollow noopener noreferrer" target="_blank">Prisma</a> - 支持PostgreSQL, MySQL &amp; SQLite，自动生成、类型安全的query builder。</li>
<li><a href="https://github.com/bookshelf/bookshelf" rel="external nofollow noopener noreferrer" target="_blank">Bookshelf</a> - Backbone.js风格的PostgreSQL，MySQL和SQLite3的ORM。</li>
<li><a href="https://github.com/Vincit/objection.js" rel="external nofollow noopener noreferrer" target="_blank">Objection.js</a> - 基于SQL查询生成器Knex的轻量级ORM。</li>
<li><a href="https://github.com/balderdashy/waterline" rel="external nofollow noopener noreferrer" target="_blank">Waterline</a> - 与数据存储区无关的工具，可大大简化与一个或多个数据库的交互。</li>
<li><a href="https://github.com/robconery/massive-js" rel="external nofollow noopener noreferrer" target="_blank">Massive</a> - PostgreSQL数据访问工具。</li>
<li><a href="https://github.com/vitaly-t/pg-promise" rel="external nofollow noopener noreferrer" target="_blank">pg-promise</a> - 用于使用Promise的本机SQL的PostgreSQL框架。</li>
<li><a href="https://github.com/mikro-orm/mikro-orm" rel="external nofollow noopener noreferrer" target="_blank">MikroORM</a> - 基于数据映射器，工作单元和身份映射模式的TypeScript ORM。 支持MongoDB，PostgreSQL，MySQL和SQLite。</li>
<li><a href="https://github.com/gajus/slonik" rel="external nofollow noopener noreferrer" target="_blank">slonik</a> - 具有严格类型，详细日志记录和断言的PostgreSQL客户端。</li>
<li><a href="https://github.com/PhilWaldmann/openrecord" rel="external nofollow noopener noreferrer" target="_blank">OpenRecord</a> - PostgreSQL，MySQL，SQLite3和RESTful数据存储的ORM。 类似于ActiveRecord</li>
<li>Query builder</li>
<li><a href="https://github.com/tgriesser/knex" rel="external nofollow noopener noreferrer" target="_blank">Knex</a> - PostgreSQL，MySQL和SQLite3的查询构建器，旨在灵活，可移植且易于使用。</li>
</ul>
<ul>
<li><strong>SQL</strong></li>
</ul>
<ul>
<li><a href="https://github.com/mysqljs/sqlstring" rel="external nofollow noopener noreferrer" target="_blank">sqlstring</a> - 简单 SQL 转义和格式，用于MySQL。</li>
</ul>
<ul>
<li><strong>其他</strong></li>
</ul>
<ul>
<li><a href="https://github.com/typicode/lowdb" rel="external nofollow noopener noreferrer" target="_blank">Lowdb</a> - 用于小型项目的微型本地 JSON 数据库（支持 Node、Electron 和浏览器）。</li>
<li><a href="https://github.com/louischatriot/nedb" rel="external nofollow noopener noreferrer" target="_blank">NeDB</a> - 用于 Node.js、nw.js、Electron和浏览器的嵌入式持久数据库或内存数据库。</li>
<li><a href="https://github.com/lukechilds/keyv" rel="external nofollow noopener noreferrer" target="_blank">Keyv</a> - 支持多个后端的简单键值(KV)存储。</li>
<li><a href="https://github.com/oguimbal/pg-mem" rel="external nofollow noopener noreferrer" target="_blank">pg-mem</a> - 内存 PostgreSQL 实例。</li>
<li><a href="https://github.com/pkosiec/mongo-seeding" rel="external nofollow noopener noreferrer" target="_blank">Mongo Seeding</a> - 使用 JavaScript 和 JSON 文件填充 MongoDB 数据库。</li>
<li><a href="https://github.com/ForbesLindesay/atdatabases" rel="external nofollow noopener noreferrer" target="_blank">@databases</a> - 使用普通 SQL 查询 PostgreSQL、MySQL 和 SQLite3，而不会导致 SQL注入 的风险。</li>
<li><a href="https://github.com/tommybananas/finale" rel="external nofollow noopener noreferrer" target="_blank">Finale</a> - 基于 Sequelize 模型生成 RESTful接口。</li>
<li><a href="https://github.com/mlaanderson/database-js" rel="external nofollow noopener noreferrer" target="_blank">database-js</a> - 类似 JDBC连接 的多个数据库连接封装。</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li><a href="https://github.com/isaacs/node-lru-cache" rel="external nofollow noopener noreferrer" target="_blank">lru-cache</a> - 最近最少使用的缓存（LRU）实现。</li>
<li><a href="https://github.com/node-cache/node-cache" rel="external nofollow noopener noreferrer" target="_blank">node-cache</a> - Node.js内存缓存模块。</li>
<li><a href="https://github.com/3rd-Eden/memcached" rel="external nofollow noopener noreferrer" target="_blank">memcached</a> - 功能齐全的Memcached Node.js客户端库。 考虑到扩展性，因此它将支持Memcached群集和一致的哈希。</li>
<li><a href="https://github.com/BryanDonovan/node-cache-manager" rel="external nofollow noopener noreferrer" target="_blank">node-cache-manager</a> - Node.js Cache模块。</li>
<li><a href="https://github.com/dominictarr/hashlru" rel="external nofollow noopener noreferrer" target="_blank">hashlru</a> - 更轻量更快的LRU算法。</li>
<li><a href="https://github.com/royriojas/flat-cache" rel="external nofollow noopener noreferrer" target="_blank">flat-cache</a> - 一个傻瓜般简单的键/值存储使用文件来持久化数据。</li>
<li><a href="https://github.com/node-modules/ylru" rel="external nofollow noopener noreferrer" target="_blank">ylru</a> - 基于hashlru添加过期时间，允许空值。</li>
</ul>
<h2 id="自动化-amp-机器人流程自动化-RPA"><a href="#自动化-amp-机器人流程自动化-RPA" class="headerlink" title="自动化 &amp; 机器人流程自动化 - RPA"></a><strong>自动化 &amp; 机器人流程自动化 - RPA</strong></h2><ul>
<li><a href="https://github.com/puppeteer/puppeteer" rel="external nofollow noopener noreferrer" target="_blank">puppeteer</a> - 无头Chrome Node.js API。</li>
<li><a href="https://github.com/microsoft/playwright" rel="external nofollow noopener noreferrer" target="_blank">playwright</a> - 使用单一API自动操作Chromium, Firefox and WebKi。</li>
<li><a href="https://github.com/ariya/phantomjs" rel="external nofollow noopener noreferrer" target="_blank">phantomjs</a> - 脚本化无头浏览器。</li>
<li><a href="https://github.com/appium/appium" rel="external nofollow noopener noreferrer" target="_blank">appium</a> - iOS, Android, and Windows Apps自动化。</li>
<li><a href="https://github.com/octalmage/robotjs" rel="external nofollow noopener noreferrer" target="_blank">robotjs</a> - Node.js桌面自动化。</li>
<li><a href="https://github.com/nut-tree/nut.js" rel="external nofollow noopener noreferrer" target="_blank">nut.js</a> - 使用Node.js进行原生 UI 测试/控制</li>
</ul>
<h2 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h2><ul>
<li><p><strong>断言库</strong></p>
</li>
<li><p><a href="https://github.com/chaijs/chai" rel="external nofollow noopener noreferrer" target="_blank">chai</a> - 基于行为驱动开发(BDD)和测试驱动开发(TDD)理念的Node.js和浏览器断言库，可与任何 JavaScript 测试框架集成。</p>
</li>
<li><a href="https://github.com/power-assert-js/power-assert" rel="external nofollow noopener noreferrer" target="_blank">power-assert</a> - 使用标准assert接口提供的描述型断言消息。</li>
<li><a href="https://github.com/Automattic/expect.js" rel="external nofollow noopener noreferrer" target="_blank">expect.js</a> - 适用于Node.JS和浏览器的简约BDD风格的断言库。</li>
<li><a href="https://github.com/shouldjs/should.js" rel="external nofollow noopener noreferrer" target="_blank">should.js</a> - Node.JS的行为驱动开发(BDD)风格断言库。</li>
<li><a href="https://github.com/tj/better-assert" rel="external nofollow noopener noreferrer" target="_blank">better-assert</a> - C语言风格的Node.js断言，将表达式字符串报告为错误消息。</li>
<li><a href="https://github.com/jshttp/http-assert" rel="external nofollow noopener noreferrer" target="_blank">http-assert</a> - 带状态码的断言。</li>
</ul>
<ul>
<li><strong>假数据生成</strong></li>
</ul>
<ul>
<li><a href="https://github.com/marak/Faker.js/" rel="external nofollow noopener noreferrer" target="_blank">faker.js</a> - 在Node.js和浏览器中生成大量逼真的假数据。</li>
<li><a href="https://github.com/boo1ean/casual" rel="external nofollow noopener noreferrer" target="_blank">casual</a> - JavaScript假数据生成。</li>
<li><a href="https://github.com/captainsafia/fony" rel="external nofollow noopener noreferrer" target="_blank">fony</a> - 一个简单的命令行工具，从字符串模板中生成假数据。</li>
</ul>
<ul>
<li><strong>Mock</strong></li>
</ul>
<ul>
<li><a href="https://github.com/nuysoft/Mock" rel="external nofollow noopener noreferrer" target="_blank">Mock.js</a> - 浏览器和 Node 均可用，支持自定义 schema 和 随机数据。</li>
<li><a href="https://github.com/pgte/nock" rel="external nofollow noopener noreferrer" target="_blank">Nock</a> - HTTP mock和期望。</li>
<li><a href="https://github.com/sinonjs/sinon" rel="external nofollow noopener noreferrer" target="_blank">Sinon.JS</a> - 通过间谍函数(spies), 目标函数替换（stubs）和mocks功能提供的Mock库。</li>
<li><a href="https://github.com/easy-mock/easy-mock" rel="external nofollow noopener noreferrer" target="_blank">easy-mock</a> - 可视化，并且能快速生成模拟数据的持久化服务。</li>
<li><a href="https://github.com/node-modules/mm" rel="external nofollow noopener noreferrer" target="_blank">mm</a> - 简单但灵活的 mock(或者叫stub) 包, mock伴侣。</li>
<li><a href="https://github.com/sinedied/smoke" rel="external nofollow noopener noreferrer" target="_blank">smoke</a> - 具有记录功能的，简单但功能强大的基于文件的Mock服务器。</li>
</ul>
<ul>
<li><strong>端到端的测试(E2E) / 自动化UI</strong></li>
</ul>
<ul>
<li><a href="https://github.com/nightwatchjs/nightwatch" rel="external nofollow noopener noreferrer" target="_blank">nightwatch</a> - 用 Node.js 编写，并使用 Webdriver API 的端到端测试框架。</li>
<li><a href="https://github.com/codeceptjs/CodeceptJS" rel="external nofollow noopener noreferrer" target="_blank">CodeceptJS</a> - Node.js端到端测试框架。</li>
</ul>
<ul>
<li><strong>测试框架</strong></li>
</ul>
<ul>
<li><a href="https://github.com/facebook/jest" rel="external nofollow noopener noreferrer" target="_blank">jest</a> - 愉悦的JavaScript测试。</li>
<li><a href="https://github.com/mochajs/mocha" rel="external nofollow noopener noreferrer" target="_blank">mocha</a> - 简单、灵活、有趣的功能丰富的Node.js和浏览器测试框架。</li>
<li><a href="https://github.com/avajs/ava" rel="external nofollow noopener noreferrer" target="_blank">ava</a> - 面向未来的测试运行程序。</li>
<li><a href="https://github.com/jasmine/jasmine" rel="external nofollow noopener noreferrer" target="_blank">jasmine</a> - 简单的Node.js和浏览器测试框架。</li>
<li><a href="https://github.com/visionmedia/supertest" rel="external nofollow noopener noreferrer" target="_blank">supertest</a> - 使用流畅的API，基于Super-agent库测试Node.js HTTP服务器。</li>
<li><a href="https://github.com/tapjs/node-tap" rel="external nofollow noopener noreferrer" target="_blank">node-tap</a> - 用于Node.js测试任何协议的工具。</li>
</ul>
<ul>
<li><strong>覆盖率</strong></li>
</ul>
<ul>
<li><a href="https://github.com/istanbuljs/nyc" rel="external nofollow noopener noreferrer" target="_blank">nyc</a> - Istanbul的命令行工具。</li>
<li><a href="https://github.com/nickmerwin/node-coveralls" rel="external nofollow noopener noreferrer" target="_blank">node-coveralls</a> - 借助持续集成服务(Travis CI 或 Jenkins) 向用户报告自动测试的测试覆盖率；为README添加一个很酷的覆盖率按钮。</li>
<li><a href="https://github.com/codecov/codecov-node" rel="external nofollow noopener noreferrer" target="_blank">codecov</a> - NodeJS中代码覆盖率报告上载器。</li>
</ul>
<ul>
<li><strong>基准测试</strong></li>
</ul>
<ul>
<li><a href="https://github.com/bestiejs/benchmark.js" rel="external nofollow noopener noreferrer" target="_blank">Benchmark.js</a> - 基准测试库，支持高分辨率计时器并返回具有统计意义的结果。</li>
<li><a href="https://github.com/logicalparadox/matcha" rel="external nofollow noopener noreferrer" target="_blank">matcha</a> - 基准测试的简化方法。</li>
<li><a href="https://github.com/caderek/benny" rel="external nofollow noopener noreferrer" target="_blank">benny</a> - 一个非常简单的 JS/TS 库基准测试框架。</li>
<li><a href="https://github.com/sidorares/node-wrk" rel="external nofollow noopener noreferrer" target="_blank">node-wrk</a> - Wrk负载测试工具Node.js版封装。</li>
</ul>
<ul>
<li><strong>解决方案</strong></li>
</ul>
<ul>
<li><a href="https://github.com/alibaba/macaca" rel="external nofollow noopener noreferrer" target="_blank">macaca</a> - 多端自动化解决方案。</li>
</ul>
<h2 id="办公软件"><a href="#办公软件" class="headerlink" title="办公软件"></a>办公软件</h2><ul>
<li><p><strong>Excel</strong></p>
</li>
<li><p><a href="https://github.com/SheetJS/sheetjs" rel="external nofollow noopener noreferrer" target="_blank">sheetjs</a> - 电子表格数据工具箱。</p>
</li>
<li><a href="https://github.com/exceljs/exceljs" rel="external nofollow noopener noreferrer" target="_blank">exceljs</a> - Excel工作表管理工具。</li>
<li><a href="https://github.com/dtjohnson/xlsx-populate" rel="external nofollow noopener noreferrer" target="_blank">xlsx-populate</a> - Excel XLSX生成和解析工具，可运行在Node和浏览器。</li>
</ul>
<ul>
<li><strong>Word</strong></li>
</ul>
<ul>
<li><a href="https://github.com/Ziv-Barber/officegen" rel="external nofollow noopener noreferrer" target="_blank">officegen</a> - 使用Javascript，生成可打开Word（docx）、PowerPoint（pptx）和Excel（xlsx）的XML文件（需Microsoft Office 2007及更高版本），输出是一个stream。</li>
<li><a href="https://github.com/mwilliamson/mammoth.js" rel="external nofollow noopener noreferrer" target="_blank">Mammoth</a> - 将Word文档(.docx文件)转化为HTML。</li>
<li><a href="https://github.com/dolanmiu/docx" rel="external nofollow noopener noreferrer" target="_blank">docx</a> - 通过良好定义的API,在NodeJS和浏览器中，使用JS/TS轻松的生成docx文件。</li>
</ul>
<ul>
<li><strong>PDF</strong></li>
</ul>
<ul>
<li><a href="https://github.com/MrRio/jsPDF" rel="external nofollow noopener noreferrer" target="_blank">jsPDF</a> - 使用JavaScript生成PDF文件的库。</li>
<li><a href="https://github.com/foliojs/pdfkit" rel="external nofollow noopener noreferrer" target="_blank">PDFKit</a> - 在Node.js和浏览器中生成PDF的库。</li>
<li><a href="https://github.com/danburzo/percollate" rel="external nofollow noopener noreferrer" target="_blank">percollate</a> - 一个命令行工具，可将网页转换为漂亮的，可读的PDF，EPUB或HTML文档。</li>
<li><a href="https://github.com/Hopding/pdf-lib" rel="external nofollow noopener noreferrer" target="_blank">pdf-lib</a> - 在任意JavaScript环境中创建和修改PDF文档。</li>
<li><a href="https://github.com/modesty/pdf2json" rel="external nofollow noopener noreferrer" target="_blank">pdf2json</a> - PDF文件解析器，它将PDF二进制文件转换为基于文本的JSON。</li>
</ul>
<ul>
<li><strong>PPT</strong></li>
</ul>
<ul>
<li><a href="https://github.com/ksky521/nodeppt" rel="external nofollow noopener noreferrer" target="_blank">nodeppt</a> - Web端展示端PPT工具。</li>
</ul>
<h2 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h2><ul>
<li><a href="https://github.com/sebhildebrandt/systeminformation" rel="external nofollow noopener noreferrer" target="_blank">systeminformation</a> - 获取硬件和软件系统信息。</li>
<li><a href="https://github.com/sindresorhus/is-wsl" rel="external nofollow noopener noreferrer" target="_blank">is-wsl</a> - 判断当前是否是否为WSL (适用于Linux的Windows子系统)。</li>
<li><a href="https://github.com/sindresorhus/os-name" rel="external nofollow noopener noreferrer" target="_blank">os-name</a> - 获取当前操作系统的名字。</li>
<li><a href="https://github.com/retrohacker/getos" rel="external nofollow noopener noreferrer" target="_blank">getos</a> - 获取当前操作系统名称，包括Linux的发行版名称。</li>
<li><a href="https://github.com/jonschlinkert/is-windows" rel="external nofollow noopener noreferrer" target="_blank">is-windows</a> - 判断当前系统是否为Windows。</li>
</ul>
<h2 id="文件压缩解压"><a href="#文件压缩解压" class="headerlink" title="文件压缩解压"></a>文件压缩解压</h2><ul>
<li><a href="https://github.com/Stuk/jszip" rel="external nofollow noopener noreferrer" target="_blank">jszip</a> - 使用JavaScript创建、读取、编辑.zip文件。</li>
<li><a href="https://github.com/cthackers/adm-zip" rel="external nofollow noopener noreferrer" target="_blank">adm-zip</a> - 使用JavaScript创建、读取、编辑.zip文件。</li>
<li><a href="https://github.com/npm/node-tar" rel="external nofollow noopener noreferrer" target="_blank">node-tar</a> - 快速且功能齐全的Tar。</li>
<li><a href="https://github.com/thejoshwolfe/yauzl" rel="external nofollow noopener noreferrer" target="_blank">yauzl</a> - Node.js unzip解压库。</li>
<li><a href="https://github.com/mafintosh/tar-fs" rel="external nofollow noopener noreferrer" target="_blank">tar-fs</a> - tar-fs允许您将目录打包到tar格式压缩包中，并将tar格式压缩包提取到目录中。</li>
<li><a href="https://github.com/node-modules/compressing" rel="external nofollow noopener noreferrer" target="_blank">compressing</a> - 压缩和解压缩你所需的一切。</li>
<li><a href="https://github.com/thejoshwolfe/yazl" rel="external nofollow noopener noreferrer" target="_blank">yazl</a> - Node.js zip压缩库。</li>
<li><a href="https://github.com/fritx/win-7zip" rel="external nofollow noopener noreferrer" target="_blank">7zip</a> - Windows包压缩/解压 - 7zip。</li>
</ul>
<h2 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h2><ul>
<li><a href="https://github.com/mishoo/UglifyJS" rel="external nofollow noopener noreferrer" target="_blank">UglifyJS</a> - JavaScript压缩工具。</li>
<li><a href="https://github.com/imagemin/imagemin" rel="external nofollow noopener noreferrer" target="_blank">imagemin</a> - Image压缩工具。</li>
<li><a href="https://github.com/babel/minify" rel="external nofollow noopener noreferrer" target="_blank">babel-minify</a> - 基于Babel工具链的 ES6+ 压缩库。</li>
<li><a href="https://github.com/cssnano/cssnano" rel="external nofollow noopener noreferrer" target="_blank">cssnano</a> - 建立在PostCSS生态系统之上模块化的压缩工具。</li>
<li><a href="https://github.com/jakubpawlowicz/clean-css" rel="external nofollow noopener noreferrer" target="_blank">clean-css</a> - CSS压缩工具。</li>
<li><a href="https://github.com/Swaagie/minimize" rel="external nofollow noopener noreferrer" target="_blank">minimize</a> - HTML压缩工具。</li>
<li><a href="https://github.com/sindresorhus/strip-css-comments" rel="external nofollow noopener noreferrer" target="_blank">strip-css-comments</a> - CSS注释剔除工具。</li>
</ul>
<h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><ul>
<li><a href="https://github.com/nylas/nylas-mail" rel="external nofollow noopener noreferrer" target="_blank">Nylas Mail</a> - 构建在现代Web技术的高扩展性邮件客户端程序。</li>
<li><a href="https://github.com/nodemailer/nodemailer" rel="external nofollow noopener noreferrer" target="_blank">Nodemailer</a> - 使用Node.js轻松发送电子邮件。</li>
<li><a href="https://github.com/forwardemail/email-templates" rel="external nofollow noopener noreferrer" target="_blank">Email Templates</a> - 创建、预览和发送自定义电子邮件模板。</li>
<li><a href="https://github.com/eleith/emailjs" rel="external nofollow noopener noreferrer" target="_blank">emailjs</a> - 向任何SMTP服务器发送带有附件的文本/HTML电子邮件。</li>
<li><a href="https://github.com/mjmlio/mjml" rel="external nofollow noopener noreferrer" target="_blank">mjml</a> - 旨在减少创建响应电子邮件的痛苦的标记语言。</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li><p><strong>IP</strong></p>
</li>
<li><p><a href="https://github.com/indutny/node-ip" rel="external nofollow noopener noreferrer" target="_blank">node-ip</a> - NodeJS IP地址工具。</p>
</li>
<li><a href="https://github.com/sindresorhus/public-ip" rel="external nofollow noopener noreferrer" target="_blank">public-ip</a> - 非常快的获取你的公网IP地址。</li>
<li><a href="https://github.com/pbojinov/request-ip" rel="external nofollow noopener noreferrer" target="_blank">request-ip</a> - 在服务器中获取请求的IP地址。</li>
<li><a href="https://github.com/whitequark/ipaddr.js" rel="external nofollow noopener noreferrer" target="_blank">ipaddr.js</a> - JavaScript 中的 IP 地址操作库。</li>
<li><a href="https://github.com/sindresorhus/internal-ip" rel="external nofollow noopener noreferrer" target="_blank">internal-ip</a> - 获取您的内网IP地址。</li>
<li><a href="https://github.com/sindresorhus/ipify" rel="external nofollow noopener noreferrer" target="_blank">ipify</a> - 获取你的公网IP地址。</li>
<li><a href="https://github.com/node-modules/address" rel="external nofollow noopener noreferrer" target="_blank">address</a> - 获取当前机器IP地址和MAC地址。</li>
</ul>
<ul>
<li><strong>端口</strong></li>
</ul>
<ul>
<li><a href="https://github.com/http-party/node-portfinder" rel="external nofollow noopener noreferrer" target="_blank">node-portfinder</a> - 在当前机器上查找开放端口 或 域套接字的简单工具。</li>
<li><a href="https://github.com/sindresorhus/get-port" rel="external nofollow noopener noreferrer" target="_blank">get-port</a> - 获取一个可用的端口。</li>
<li><a href="https://github.com/node-modules/detect-port" rel="external nofollow noopener noreferrer" target="_blank">detect-port</a> - 端口探测的Node.JS实现。</li>
</ul>
<ul>
<li><strong>隧道代理</strong></li>
</ul>
<ul>
<li><a href="https://github.com/koichik/node-tunnel" rel="external nofollow noopener noreferrer" target="_blank">node-tunnel</a> - 用于隧道代理的 HTTP/HTTPS代理。</li>
<li><a href="https://github.com/request/tunnel-agent" rel="external nofollow noopener noreferrer" target="_blank">tunnel-agent</a> - HTTP 隧道代理。以前是 mikeal/request 的一部分，现在是一个独立的模块。</li>
</ul>
<ul>
<li><strong>其他</strong></li>
</ul>
<ul>
<li><a href="https://github.com/roccomuso/netcat" rel="external nofollow noopener noreferrer" target="_blank">netcat</a> - 纯JS中的Netcat端口。</li>
<li><a href="https://github.com/bevry/getmac" rel="external nofollow noopener noreferrer" target="_blank">getmac</a> - 获取电脑的MAC地址。</li>
<li><a href="https://github.com/infusion/node-dhcp" rel="external nofollow noopener noreferrer" target="_blank">DHCP</a> - DHCP客户端和服务器。</li>
<li><a href="https://github.com/silverwind/default-gateway" rel="external nofollow noopener noreferrer" target="_blank">default-gateway</a> - 获取默认网络网关(跨平台)。</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li><p><strong>请求库</strong></p>
</li>
<li><p><a href="https://github.com/mzabriskie/axios" rel="external nofollow noopener noreferrer" target="_blank">axios</a> - 基于Promise 的HTTP客户端（也可以在浏览器中工作）。</p>
</li>
<li><a href="https://github.com/request/request" rel="external nofollow noopener noreferrer" target="_blank">request</a> - 简单的 HTTP 请求客户端。</li>
<li><a href="https://github.com/visionmedia/superagent" rel="external nofollow noopener noreferrer" target="_blank">superagent</a> - HTTP请求库。</li>
<li><a href="https://github.com/sindresorhus/got" rel="external nofollow noopener noreferrer" target="_blank">got</a> - 更好的基于内建“http”模块接口实现。</li>
<li><a href="https://github.com/bitinn/node-fetch" rel="external nofollow noopener noreferrer" target="_blank">node-fetch</a> - Node.js的 <code>window.fetch</code> 实现。</li>
<li><a href="https://github.com/tomas/needle" rel="external nofollow noopener noreferrer" target="_blank">needle</a> - 灵活，基于流的HTTP Node.js客户端请求库。支持proxy，iconv，cookie，deflate和multipart。</li>
<li><a href="https://github.com/node-modules/urllib" rel="external nofollow noopener noreferrer" target="_blank">urllib</a> - 在复杂世界中请求HTTP/HTTPS的URL。</li>
<li><a href="https://github.com/ethanent/phin" rel="external nofollow noopener noreferrer" target="_blank">phin</a> - Node HTTP client.</li>
<li><a href="https://github.com/khaosdoctor/gotql" rel="external nofollow noopener noreferrer" target="_blank">gotql</a> - 基于<a href="https://github.com/sindresorhus/got" rel="external nofollow noopener noreferrer" target="_blank">got</a>构建的GraphQL请求库。</li>
<li><a href="https://github.com/hapijs/wreck" rel="external nofollow noopener noreferrer" target="_blank">wreck</a> - HTTP 客户端工具。</li>
<li><a href="https://github.com/lukechilds/cacheable-request" rel="external nofollow noopener noreferrer" target="_blank">cacheable-request</a> - 使用符合RFC的缓存封装的本机HTTP请求库。</li>
<li><a href="https://github.com/sindresorhus/gh-got" rel="external nofollow noopener noreferrer" target="_blank">gh-got</a> - 基于”got”封装，与GitHub API更方便的交互。</li>
<li><a href="https://github.com/bbc/flashheart" rel="external nofollow noopener noreferrer" target="_blank">flashheart</a> - REST 客户端。</li>
</ul>
<ul>
<li><strong>服务端库</strong></li>
</ul>
<ul>
<li><a href="https://github.com/http-party/http-server" rel="external nofollow noopener noreferrer" target="_blank">http-server</a> - 零配置的命令行Http服务端。</li>
<li><a href="https://github.com/JacksonTian/anywhere" rel="external nofollow noopener noreferrer" target="_blank">anywhere</a> - 随启随用的静态文件服务器。</li>
<li><a href="https://github.com/micromata/http-fake-backend" rel="external nofollow noopener noreferrer" target="_blank">http-fake-backend</a> - 通过可配置的路由，提供JSON文件或JavaScript对象来构建伪造的后端。</li>
<li><a href="https://github.com/typicode/json-server" rel="external nofollow noopener noreferrer" target="_blank">json-server</a> - 在不到30秒的时间内获得具有零编码的完整伪造的REST API。</li>
</ul>
<ul>
<li><strong>代理</strong></li>
</ul>
<ul>
<li><a href="https://github.com/nodejitsu/node-http-proxy" rel="external nofollow noopener noreferrer" target="_blank">http-proxy</a> - HTTP代理。</li>
<li><a href="https://github.com/TooTallNate/node-https-proxy-agent" rel="external nofollow noopener noreferrer" target="_blank">https-proxy-agent</a> - HTTP(S) 代理 <code>http.Agent</code>实现。</li>
<li><a href="https://github.com/gajus/global-agent" rel="external nofollow noopener noreferrer" target="_blank">global-agent</a> - 可以使用环境变量配置的全局 HTTP/HTTPS 代理。</li>
<li><a href="https://github.com/fastify/fast-proxy" rel="external nofollow noopener noreferrer" target="_blank">fast-proxy</a> - Node.js框架，使您可以将http请求转发到另一个HTTP服务器。 支持的协议：HTTP，HTTPS，HTTP2。</li>
<li><a href="https://github.com/argo/argo" rel="external nofollow noopener noreferrer" target="_blank">argo</a> - 一个可扩展的异步 HTTP 反向代理和源服务器。</li>
</ul>
<ul>
<li><strong>中间件</strong></li>
</ul>
<ul>
<li><a href="https://github.com/chimurai/http-proxy-middleware" rel="external nofollow noopener noreferrer" target="_blank">http-proxy-middleware</a> - ⚡用于connect，express和browser-sync的单线Node.js Http代理中间件。</li>
</ul>
<ul>
<li><strong>下载</strong></li>
</ul>
<ul>
<li><a href="https://github.com/kevva/download" rel="external nofollow noopener noreferrer" target="_blank">download</a> - 轻松下载和提取文件。</li>
<li><a href="https://github.com/maxogden/nugget" rel="external nofollow noopener noreferrer" target="_blank">nugget</a> - 使用Node.js编写的极简主义wget clone。 HTTP GET文件并将其下载到当前目录。</li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h2><ul>
<li><a href="https://github.com/jaredhanson/passport" rel="external nofollow noopener noreferrer" target="_blank">Passport</a> - 简单的身份验证。</li>
<li><a href="https://github.com/simov/grant" rel="external nofollow noopener noreferrer" target="_blank">Grant</a> - 适用于Express，Koa，Hapi，Fastify，AWS Lambda，Azure，Google Cloud，Vercel等的OAuth程序。</li>
<li><a href="https://github.com/ianstormtaylor/permit" rel="external nofollow noopener noreferrer" target="_blank">permit</a> - 用于构建Node.js API的非标准认证库。</li>
</ul>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><ul>
<li><a href="https://github.com/stalniy/casl" rel="external nofollow noopener noreferrer" target="_blank">CASL</a> - 同构授权用于可视化界面和API。</li>
<li><a href="https://github.com/casbin/node-casbin" rel="external nofollow noopener noreferrer" target="_blank">node-casbin</a> - 支持访问控制模型（如ACL，RBAC和ABAC）的授权库。</li>
<li><a href="https://github.com/jshttp/basic-auth" rel="external nofollow noopener noreferrer" target="_blank">basic-auth</a> - 通用基础身份验证授权头字段解析器。</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul>
<li><a href="https://github.com/alexguan/node-zookeeper-client" rel="external nofollow noopener noreferrer" target="_blank">node-zookeeper-client</a> - 纯JavaScript ZooKeeper客户端。</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ul>
<li><a href="https://github.com/protobufjs/protobuf.js" rel="external nofollow noopener noreferrer" target="_blank">protobuf</a> - Protocol Buffers实现。</li>
<li><a href="https://github.com/node-modules/hessian.js" rel="external nofollow noopener noreferrer" target="_blank">hessian.js</a> - JavaScript hessian 二进制web服务协议实现，支持与 java 通信。</li>
<li><a href="https://github.com/kesla/node-snappy" rel="external nofollow noopener noreferrer" target="_blank">snappy</a> - Google 的 Snappy 压缩库的原生绑定（Native bindings）。</li>
<li><a href="https://github.com/compactr/compactr.js" rel="external nofollow noopener noreferrer" target="_blank">compactr</a> - Compactr协议的实现。</li>
</ul>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ul>
<li><a href="https://github.com/grpc/grpc-node/tree/master/packages/grpc-js" rel="external nofollow noopener noreferrer" target="_blank">grpc-js</a> - 纯JavaScript gRPC客户端。</li>
<li><a href="https://github.com/tedeh/jayson" rel="external nofollow noopener noreferrer" target="_blank">jayson</a> - Jayson是用于Node.js的简单但功能强大的JSON-RPC 2.0 / 1.0客户端和服务器。</li>
<li><a href="https://github.com/sofastack/sofa-rpc-node" rel="external nofollow noopener noreferrer" target="_blank">sofa-rpc-node</a> - SOFARPC Node是高性能、高可扩展性、产品级Node.js RPC框架。</li>
</ul>
<h2 id="服务端DOM"><a href="#服务端DOM" class="headerlink" title="服务端DOM"></a>服务端DOM</h2><ul>
<li><a href="https://github.com/cheeriojs/cheerio" rel="external nofollow noopener noreferrer" target="_blank">cheerio</a> - 运行在服务器端，快速、灵活和精益的jQuery核心功能实现。</li>
<li><a href="https://github.com/jsdom/jsdom" rel="external nofollow noopener noreferrer" target="_blank">jsdom</a> - Node.js版Web标准实现。</li>
<li><a href="https://github.com/fgnass/domino" rel="external nofollow noopener noreferrer" target="_blank">domino</a> - 基于 Mozilla的dom.js的服务器端DOM实现。</li>
</ul>
<h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><ul>
<li><a href="https://github.com/bda-research/node-crawler" rel="external nofollow noopener noreferrer" target="_blank">node-crawler</a> - NodeJS Web爬虫 + 服务端jQuery。</li>
<li><a href="https://github.com/lapwinglabs/x-ray" rel="external nofollow noopener noreferrer" target="_blank">x-ray</a> - 具有分页的Web抓取爬虫。</li>
<li><a href="https://github.com/yujiosaka/headless-chrome-crawler" rel="external nofollow noopener noreferrer" target="_blank">headless-chrome-crawler</a> - 使用Chrome无头浏览器的分布式爬虫。</li>
<li><a href="https://github.com/rchipka/node-osmosis" rel="external nofollow noopener noreferrer" target="_blank">node-osmosis</a> - Node.js的HTML / XML解析器和Web抓取工具。</li>
<li><a href="https://github.com/IonicaBizau/scrape-it" rel="external nofollow noopener noreferrer" target="_blank">scrape-it</a> - 适用于人类的Node.js抓取工具。</li>
<li><a href="https://github.com/ruipgil/scraperjs" rel="external nofollow noopener noreferrer" target="_blank">scraperjs</a> - 完整而多功能的Web抓取器。</li>
<li><a href="https://github.com/cgiffard/node-simplecrawler" rel="external nofollow noopener noreferrer" target="_blank">simplecrawler</a> - 事件驱动的Web爬虫。</li>
<li><a href="https://github.com/martinsbalodis/web-scraper-chrome-extension" rel="external nofollow noopener noreferrer" target="_blank">web-scraper-chrome-extension</a> -实现为Chrome插件的Web数据抽取工具。</li>
<li><a href="https://github.com/zhuyingda/webster" rel="external nofollow noopener noreferrer" target="_blank">webster</a> - 一个可靠的Web爬虫框架，可以在网页中抓取Ajax和js呈现的内容。</li>
<li><a href="https://github.com/brendonboshell/supercrawler" rel="external nofollow noopener noreferrer" target="_blank">supercrawler</a> - 定义自定义处理程序以解析内容。 遵守robots.txt，速率限制和并发限制。</li>
<li><a href="https://github.com/n0tan3rd/squidwarc" rel="external nofollow noopener noreferrer" target="_blank">Squidwarc</a> - 高保真度，用户可编写脚本的归档爬虫程序，使用带头或不带头的Chrome或Chromium。</li>
<li><a href="https://github.com/antivanov/js-crawler" rel="external nofollow noopener noreferrer" target="_blank">js-crawler</a> - 适用于Node.JS的Web爬虫，同时支持HTTP和HTTPS。</li>
</ul>
<h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><ul>
<li><p><strong>解析器</strong></p>
</li>
<li><p><a href="https://github.com/babel/babel/tree/master/packages/babel-parser" rel="external nofollow noopener noreferrer" target="_blank">babel-parser</a> - JavaScript解析器。</p>
</li>
<li><a href="https://github.com/antlr/antlr4" rel="external nofollow noopener noreferrer" target="_blank">antlr</a> - ANTLR (ANother Tool for Language Recognition)是一个用于阅读、处理、执行和翻译结构化文本或二进制文件的强大的解析生成器。</li>
<li><a href="https://github.com/acornjs/acorn/tree/master/acorn" rel="external nofollow noopener noreferrer" target="_blank">acorn</a> - 小巧、快速的JavaScript解析器。</li>
<li><a href="https://github.com/jquery/esprima" rel="external nofollow noopener noreferrer" target="_blank">esprima</a> - 高性能、符合ECMASCRIPT标准的解析器。</li>
<li><a href="https://github.com/benjamn/recast" rel="external nofollow noopener noreferrer" target="_blank">recast</a> - JavaScript语法树转换器，非破坏性漂亮print和自动source map生成器。</li>
<li><a href="https://github.com/kach/nearley" rel="external nofollow noopener noreferrer" target="_blank">nearley</a> - JavaScript的简单、快速、功能强大的解析工具集。</li>
<li><a href="https://github.com/eslint/espree" rel="external nofollow noopener noreferrer" target="_blank">espree</a> - 与Esprima兼容的JavaScript解析器。</li>
<li><a href="https://github.com/csstree/csstree" rel="external nofollow noopener noreferrer" target="_blank">csstree</a> - 基于W3C标准和浏览器标准实现，包含快速详细的解析器、遍历器、生成器、词法解析的CSS工具集。</li>
<li><a href="https://github.com/guybedford/es-module-lexer" rel="external nofollow noopener noreferrer" target="_blank">es-module-lexer</a> - 低开销的词法分析器，专门用于ES模块快速分析解析。</li>
</ul>
<ul>
<li><strong>遍历</strong></li>
</ul>
<ul>
<li><a href="https://github.com/acornjs/acorn/tree/master/acorn-walk" rel="external nofollow noopener noreferrer" target="_blank">acorn-walker</a> - 小巧、快速的JavaScript解析器。</li>
<li><a href="https://github.com/estools/estraverse" rel="external nofollow noopener noreferrer" target="_blank">estraverse</a> - ECMAScript JS AST遍历功能。</li>
</ul>
<ul>
<li><strong>代码生成</strong></li>
</ul>
<ul>
<li><a href="https://github.com/estools/escodegen" rel="external nofollow noopener noreferrer" target="_blank">escodegen</a> - ECMAScript代码生成。</li>
<li><a href="https://github.com/davidbonnet/astring" rel="external nofollow noopener noreferrer" target="_blank">astring</a> - 小巧快速的JavaScript代码生成器（通过ESTree兼容的AST）。</li>
</ul>
<ul>
<li><strong>JavaScript解释器</strong></li>
</ul>
<ul>
<li><a href="https://github.com/NeilFraser/JS-Interpreter" rel="external nofollow noopener noreferrer" target="_blank">JS-Interpreter</a> - JavaScript中沙箱解释器。</li>
<li><a href="https://github.com/bramblex/jsjs" rel="external nofollow noopener noreferrer" target="_blank">jsjs</a> - 简易的 JavaScript 元循环解释器。</li>
<li><a href="https://github.com/Siubaak/sval" rel="external nofollow noopener noreferrer" target="_blank">sval</a> - 使用JavaScript编写的JavaScript解释器。</li>
</ul>
<ul>
<li><strong>其他</strong></li>
</ul>
<ul>
<li><a href="https://github.com/fkling/astexplorer" rel="external nofollow noopener noreferrer" target="_blank">astexplorer</a> - 使用多种解析器的AST Web可视化工具。</li>
<li><a href="https://github.com/Rich-Harris/estree-walker" rel="external nofollow noopener noreferrer" target="_blank">estree-walker</a> - 用于遍历ESTree兼容树的AST。</li>
<li><a href="https://github.com/Rich-Harris/periscopic" rel="external nofollow noopener noreferrer" target="_blank">periscopic</a> - 用于分析符合ESTree的AST的作用域的工具。</li>
</ul>
<h2 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h2><ul>
<li><a href="https://github.com/dcodeIO/webassembly" rel="external nofollow noopener noreferrer" target="_blank">webassembly</a> - 用于生成和运行 WebAssembly 模块的最小工具包和运行时。</li>
</ul>
<h2 id="设计稿转代码（D2C）"><a href="#设计稿转代码（D2C）" class="headerlink" title="设计稿转代码（D2C）"></a>设计稿转代码（D2C）</h2><ul>
<li><a href="https://github.com/meltingice/psd.js" rel="external nofollow noopener noreferrer" target="_blank">psd.js</a> - 在Node.js和浏览器中解析Photoshop PSD文件。</li>
</ul>
<h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><ul>
<li><a href="https://github.com/patriksimek/vm2" rel="external nofollow noopener noreferrer" target="_blank">vm2</a> - Node.js高级虚拟机/沙箱。</li>
<li><a href="https://github.com/gf3/sandbox" rel="external nofollow noopener noreferrer" target="_blank">sandbox</a> - 用于Node.js漂亮的JavaScript沙箱。</li>
</ul>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul>
<li><a href="https://github.com/rwaldron/johnny-five" rel="external nofollow noopener noreferrer" target="_blank">johnny-five</a> - 基于Firmata的Arduino框架。</li>
<li><a href="https://github.com/voodootikigod/node-serialport" rel="external nofollow noopener noreferrer" target="_blank">serialport</a> - 访问串行端口以进行读写。</li>
<li><a href="https://github.com/nonolith/node-usb" rel="external nofollow noopener noreferrer" target="_blank">usb</a> - USB 库。</li>
<li><a href="https://github.com/fivdi/onoff" rel="external nofollow noopener noreferrer" target="_blank">onoff</a> - GPIO访问和中断检测.</li>
<li><a href="https://github.com/fivdi/pigpio" rel="external nofollow noopener noreferrer" target="_blank">pigpio</a> - 树莓派（Raspberry Pi）上的快速GPIO，PWM，伺服控制，状态更改通知和中断处理。</li>
<li><a href="https://github.com/song940/node-escpos" rel="external nofollow noopener noreferrer" target="_blank">node-escpos</a> - ESC/POS打印机驱动程序。</li>
<li><a href="https://github.com/fivdi/i2c-bus" rel="external nofollow noopener noreferrer" target="_blank">i2c-bus</a> - I2C串行总线访问。</li>
<li><a href="https://github.com/infusion/GPS.js" rel="external nofollow noopener noreferrer" target="_blank">gps</a> - NMEA解析器，用于处理GPS接收器。</li>
<li><a href="https://github.com/song940/node-bluetooth" rel="external nofollow noopener noreferrer" target="_blank">node-bluetooth</a> - Node.js 的蓝牙串口通信。</li>
<li><a href="https://github.com/fivdi/spi-device" rel="external nofollow noopener noreferrer" target="_blank">spi-device</a> - SPI串行总线访问。</li>
</ul>
<h2 id="物联网IoT"><a href="#物联网IoT" class="headerlink" title="物联网IoT"></a>物联网IoT</h2><ul>
<li><a href="https://github.com/zettajs/zetta" rel="external nofollow noopener noreferrer" target="_blank">zetta</a> - 面向物联网的 API 优先的开源软件平台。</li>
<li><a href="https://github.com/ibm-watson-iot/iot-nodejs" rel="external nofollow noopener noreferrer" target="_blank">iot-nodejs</a> - 用于使用 nodejs 连接到 IBM Watson IoT 的客户端库和示例。</li>
</ul>
<h2 id="机器学习-和-神经网络"><a href="#机器学习-和-神经网络" class="headerlink" title="机器学习 和 神经网络"></a>机器学习 和 神经网络</h2><ul>
<li><a href="https://github.com/tensorflow/tfjs" rel="external nofollow noopener noreferrer" target="_blank">tfjs</a> - 一个WebGL加速的JavaScript库，用于训练和部署ML模型（Tensorflow官方）。</li>
<li><a href="https://github.com/lutzroeder/netron" rel="external nofollow noopener noreferrer" target="_blank">netron</a> - 神经网络、深度学习和机器学习模型的可视化工具。</li>
<li><a href="https://github.com/BrainJS/brain.js" rel="external nofollow noopener noreferrer" target="_blank">brain.js</a> - 基于模型训练的神经网络 JS 库，支持浏览器和 Node.js。</li>
<li><a href="https://github.com/alibaba/pipcook" rel="external nofollow noopener noreferrer" target="_blank">pipcook</a> - 为Web开发者提供的机器学习平台。</li>
<li><a href="https://github.com/microsoft/onnxjs" rel="external nofollow noopener noreferrer" target="_blank">onnxjs</a> - 使用JavaScript运行ONNX模型。</li>
<li><a href="https://github.com/yorkie/tensorflow-nodejs" rel="external nofollow noopener noreferrer" target="_blank">tensorflow-nodejs</a> - TensorFlow Node.js为Node.js用户提供常用的JavaScript语言绑定和高级API。</li>
</ul>
<h2 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h2><ul>
<li><a href="https://github.com/spencermountain/compromise" rel="external nofollow noopener noreferrer" target="_blank">compromise</a> - 自然语言处理。</li>
<li><a href="https://github.com/NaturalNode/natural" rel="external nofollow noopener noreferrer" target="_blank">natural</a> - 自然语言设施。</li>
<li><a href="https://github.com/axa-group/nlp.js" rel="external nofollow noopener noreferrer" target="_blank">nlp.js</a> - 构建机器人，具有实体提取、情感分析、自动语言识别等功能。</li>
<li><a href="https://github.com/wooorm/franc" rel="external nofollow noopener noreferrer" target="_blank">franc</a> - 检测文本使用的语言。</li>
<li><a href="https://github.com/thisandagain/sentiment" rel="external nofollow noopener noreferrer" target="_blank">sentiment</a> - 基于AFINN的Node.js情感判断库。</li>
<li><a href="https://github.com/wooorm/retext" rel="external nofollow noopener noreferrer" target="_blank">retext</a> - 一个可扩展的自然语言系统。</li>
<li><a href="https://github.com/sindresorhus/leven" rel="external nofollow noopener noreferrer" target="_blank">leven</a> - 使用Levenshtein距离算法测量两个字符串之间的差异。</li>
</ul>
<h2 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h2><ul>
<li><a href="https://github.com/naptha/tesseract.js" rel="external nofollow noopener noreferrer" target="_blank">tesseract.js</a> - 100 多种语言的纯 Javascript OCR。</li>
<li><a href="https://github.com/axa-group/Parsr" rel="external nofollow noopener noreferrer" target="_blank">Parsr</a> - 将 PDF、文档和图像转换为丰富的结构化数据。</li>
</ul>
<h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><ul>
<li><a href="https://github.com/cjb/GitTorrent" rel="external nofollow noopener noreferrer" target="_blank">GitTorrent</a> - 使用 BitTorrent 和比特币的 GitHub 去中心化。</li>
<li><a href="https://github.com/bitcoinjs/bitcoinjs-lib" rel="external nofollow noopener noreferrer" target="_blank">bitcoinjs-lib</a> - 一个用于 node.js 和浏览器的 javascript 比特币库。</li>
<li><a href="https://github.com/bitpay/bitcore" rel="external nofollow noopener noreferrer" target="_blank">bitcore</a> - 比特币和基于区块链的应用程序的全栈。</li>
</ul>
<h2 id="低代码（Lowcode）"><a href="#低代码（Lowcode）" class="headerlink" title="低代码（Lowcode）"></a>低代码（Lowcode）</h2><p><em>(你也许会喜欢 <a href="https://github.com/taowen/awesome-lowcode" rel="external nofollow noopener noreferrer" target="_blank">awesome-lowcode</a>)</em></p>
<ul>
<li><p><strong>H5/PC</strong></p>
</li>
<li><p><a href="https://github.com/baidu/amis" rel="external nofollow noopener noreferrer" target="_blank">amis</a> - 前端低代码框架，通过 JSON 配置就能生成各种页面。</p>
</li>
</ul>
<ul>
<li><strong>H5</strong></li>
</ul>
<ul>
<li><a href="https://github.com/MrXujiang/h5-Dooring" rel="external nofollow noopener noreferrer" target="_blank">h5-Dooring</a> - 让H5制作像搭积木一样简单, 轻松搭建H5页面, H5网站, PC端网站, 可视化设计,LowCode平台。</li>
<li><a href="https://github.com/ly525/luban-h5" rel="external nofollow noopener noreferrer" target="_blank">luban-h5</a> - 类似易企秀的H5制作、建站工具、可视化搭建系统。</li>
<li><a href="https://github.com/ymm-tech/gods-pen" rel="external nofollow noopener noreferrer" target="_blank">gods-pen</a> - 基于vue的高扩展在线网页制作平台，可自定义组件，可添加脚本，可数据统计。</li>
</ul>
<ul>
<li><strong>PC</strong></li>
</ul>
<ul>
<li><a href="https://github.com/MrXujiang/pc-Dooring" rel="external nofollow noopener noreferrer" target="_blank">pc-Dooring</a> - 让网页制作像搭积木一样简单, 轻松搭建PC页面, Web网站, PC端网站. lowcode(low-code)可视化搭建平台。</li>
</ul>
<ul>
<li><strong>逻辑编排</strong></li>
</ul>
<ul>
<li><a href="https://github.com/node-red/node-red" rel="external nofollow noopener noreferrer" target="_blank">node-red</a> - 事件驱动应用的低代码编程。</li>
<li><a href="https://github.com/ykfe/imove" rel="external nofollow noopener noreferrer" target="_blank">imove</a> - iMove 是一个逻辑可复用的，面向函数的，流程可视化的 JavaScript 工具库。</li>
</ul>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>全网echarts案例资源大总结和echarts的高效使用技巧（细节版）</title>
    <url>/2023/07/27/%E5%85%A8%E7%BD%91echarts%E6%A1%88%E4%BE%8B%E8%B5%84%E6%BA%90%E5%A4%A7%E6%80%BB%E7%BB%93%E5%92%8Cecharts%E7%9A%84%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%88%E7%BB%86%E8%8A%82%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h2 id="theme-mk-cute"><a href="#theme-mk-cute" class="headerlink" title="theme: mk-cute"></a>theme: mk-cute</h2><h5 id="一-前言。"><a href="#一-前言。" class="headerlink" title="一.前言。"></a>一.前言。</h5><p>众所周知，在现今的开发大环境下，数据可视化（大屏化）项目在前端开发中的比重越来越大。而其中使用率最高的插件无疑就是 <a href="https://echarts.apache.org/zh/index.html" rel="external nofollow noopener noreferrer" target="_blank">Apache Echarts</a>。（ps: 以下简称为echarts）。本文就结合vue框架来讲解如何快速、高效、优雅地在项目中使用echarts。当然，本文篇幅也会为读者精心准备目前网络上<strong>最全面、最高效</strong>的<strong>echarts案例资源站集合</strong>。<br><a id="more"></a></p>
<h5 id="二-全网最全的echarts图表案例和实例资源站整理。"><a href="#二-全网最全的echarts图表案例和实例资源站整理。" class="headerlink" title="二. 全网最全的echarts图表案例和实例资源站整理。"></a>二. 全网最全的echarts图表案例和实例资源站整理。</h5><ol>
<li>资源一：<strong><a href="http://chart.majh.top/" rel="external nofollow noopener noreferrer" target="_blank">分享你我</a></strong>  <em>（推荐指数：⭐⭐⭐⭐）</em></li>
</ol>
<ul>
<li>优点：案例资源丰富，有主体分类，可检索，访问速度较快。</li>
<li>缺点：未做分页。</li>
</ul>
<ol start="2">
<li>资源二：<strong><a href="https://www.isqqw.com/homepage#/homepage" rel="external nofollow noopener noreferrer" target="_blank">ISWWQ.com</a></strong>   <em>（推荐指数：⭐⭐⭐⭐）</em></li>
</ol>
<ul>
<li>优点：案例资源丰富，可检索，有主体分类。</li>
<li>缺点：未做分页，访问速度较慢。</li>
</ul>
<ol start="3">
<li>资源三：<strong><a href="http://ppchart.com/#/" rel="external nofollow noopener noreferrer" target="_blank">PPChart</a></strong>  <em>（推荐指数：<strong>⭐⭐⭐⭐⭐</strong>）</em></li>
</ol>
<ul>
<li>优点：案例资源丰富，有主体分类且分类较细，有分页，可检索，访问速度较快。</li>
<li>缺点：暂无。</li>
</ul>
<ol start="4">
<li>资源四：<strong><a href="https://www.makeapie.cn/echarts" rel="external nofollow noopener noreferrer" target="_blank">ECHARTS社区</a></strong>  <em>（推荐指数：⭐⭐⭐）</em></li>
</ol>
<ul>
<li>优点：案例资源丰富，有主体分类且分类较细，有分页，可检索，提供登录和社区。</li>
<li>缺点：访问速度慢，有广告。</li>
</ul>
<ol start="5">
<li>资源五：<strong><a href="https://madeapie.com/#/" rel="external nofollow noopener noreferrer" target="_blank">Made A Pie</a></strong>   <em>（推荐指数：⭐⭐⭐⭐）</em></li>
</ol>
<ul>
<li>优点：案例资源丰富，可检索，有主体分类。</li>
<li>缺点：访问速度较慢，未做分页。</li>
</ul>
<ol start="6">
<li>资源六：<strong><a href="http://echarts.zhangmuchen.top/#/index" rel="external nofollow noopener noreferrer" target="_blank">MCChart</a></strong>   <em>（推荐指数：⭐⭐⭐⭐）</em></li>
</ol>
<ul>
<li>优点：案例资源丰富，可检索，有主体分类。</li>
<li>缺点：详情图例加载慢，图例加载不出。</li>
</ul>
<ol start="7">
<li>资源七：<strong><a href="https://echarts.apache.org/examples/zh/index.html" rel="external nofollow noopener noreferrer" target="_blank">ECharts官方案例</a></strong>  <em>（推荐指数：<strong>⭐⭐⭐⭐⭐</strong>）</em></li>
</ol>
<ul>
<li>优点：官方案例，资源稳定，主体分类多，可调节模式，可直接查看对应案例的配置项。</li>
<li>缺点：案例资源较少，未做分页，未提供检索。</li>
</ul>
<ol start="8">
<li>资源八：<strong><a href="http://192.144.199.210/forum-2-1.html" rel="external nofollow noopener noreferrer" target="_blank">chartsdev.com</a></strong>   <em>（推荐指数：⭐⭐）</em></li>
</ol>
<ul>
<li>优点：案例资源丰富，有主体分类。</li>
<li>缺点：访问速度一般，未能开箱即用，排版较差，适用性较差等。</li>
</ul>
<ol start="9">
<li>资源九：<strong>[仿ECharts]</strong>  <em>（推荐指数：⭐⭐⭐）</em></li>
</ol>
<ul>
<li>优点：资源较稳定，图标效果加载速度较快。</li>
<li>缺点：案例资源较少，未做分页，未提供检索等。</li>
</ul>
<ol start="10">
<li>资源十：<strong><a href="http://analysis.datains.cn/finance-admin/index.html#/chartLib/all" rel="external nofollow noopener noreferrer" target="_blank">DataInsight</a></strong> <em>（推荐指数：⭐⭐）</em></li>
</ol>
<ul>
<li>优点：案例资源较丰富。</li>
<li>缺点：访问速度慢，未做主体分类，未提供检索等。</li>
</ul>
<ol start="11">
<li>资源十一：<strong><a href="https://www.aliyundrive.com/s/hH9wXex8jYa" rel="external nofollow noopener noreferrer" target="_blank">阿里云–原ECharts官方社区Make A Pie案例源码及图表图</a></strong>    <em>（推荐指数：<strong>⭐⭐⭐⭐⭐</strong>）</em></li>
</ol>
<ul>
<li>优点：提供原ECharts官方社区Make A Pie网站的所有案例源码及其对应的图例，可供查阅与开发成共享资源社区或网站。</li>
<li>缺点：未实现开箱即用。</li>
<li>说明：提取码：<strong>6l3t</strong>。</li>
</ul>
<ol start="12">
<li>资源十二：<strong><a href="https://pan.baidu.com/s/1z73BAufIo0aV5_ZGQ66xmg" rel="external nofollow noopener noreferrer" target="_blank">百度云–原ECharts官方社区Make A Pie案例源码及图表图</a></strong>     <em>（推荐指数：<strong>⭐⭐⭐⭐⭐</strong>）</em></li>
</ol>
<ul>
<li>优点：提供原ECharts官方社区Make A Pie网站的所有案例源码及其对应的图例，可供查阅与开发成共享资源社区或网站。</li>
<li>缺点：未实现开箱即用。</li>
<li>说明：提取码：<strong>qqsy</strong>。</li>
</ul>
<h5 id="三-echarts在vue项目中的使用说明和技巧。"><a href="#三-echarts在vue项目中的使用说明和技巧。" class="headerlink" title="三.echarts在vue项目中的使用说明和技巧。"></a>三.echarts在vue项目中的使用说明和技巧。</h5><ol>
<li>安装依赖和注意事项及对应的处理办法。</li>
</ol>
<ul>
<li><p>说明：<br>vue中直接安装最新的echarts依赖包，可能会在运行时报echarts的init方法未定义的异常，此时可先<strong>卸载当前版本的echarts依赖包，重新安装指定稳定版本（如：v4.8.0）</strong>。如若此时还是报init未定义，那么可在入口文件main.js中引入时需按这种方式引入即可解决 —- <strong>import * as echarts from ‘echarts’</strong>。</p>
</li>
<li><p>核心代码和图例：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常规安装</span></span><br><span class="line"> </span><br><span class="line">npm install echarts --save</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//如若按官网的上述依赖安装后报init未定义的话,那可能是由于所安装的当前ECharts版本过高导致,请安装以下版本</span></span><br><span class="line"> </span><br><span class="line">npm uninstall echarts --save   <span class="comment">//卸载当前安装的ECahrts依赖</span></span><br><span class="line"> </span><br><span class="line">npm install echarts@<span class="number">4.8</span><span class="number">.0</span> --save     <span class="comment">//重新安装低版ECahrts依赖</span></span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0841337029424d17b0cd27d9ead59c91~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<ol start="2">
<li>组件化实现每个echarts图表的独立管理，避免不必要的耦合。</li>
</ol>
<ul>
<li>说明：<br>主组件（父组件）只用来存主内容区域和对应echrts图表的外部盒子；用子组件实现真正的容器来装载整个图表和实现对应图表的数据和图表渲染。</li>
</ul>
<ul>
<li>核心代码：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-section bg"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-title"</span>&gt;业务类型占比&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!--以下为子组件--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ywlxzbChart&gt;&lt;/y</span>wlxzbChart&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">子组件（echarts图表核心）：</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    id=<span class="string">"ywlx"</span></span><br><span class="line">    style=<span class="string">"width: 100%; height: 195px"</span></span><br><span class="line">    v-loading=<span class="string">"ywlezbLoading"</span></span><br><span class="line">  &gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">"echarts"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> API <span class="keyword">from</span> <span class="string">"api/home.js"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ywlezbLoading: <span class="literal">false</span>,</span><br><span class="line">      myChartLine: <span class="literal">null</span>,</span><br><span class="line">      formData: [],</span><br><span class="line">      nameData: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  name: <span class="string">"ywlxzbChart"</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">//获取数据,Promise确保执行和绘画顺序</span></span><br><span class="line">    getProfessionalCardsCount() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.ywlezbLoading = <span class="literal">true</span>;</span><br><span class="line">        API.getProfessionalCardsCount()</span><br><span class="line">          .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.ywlezbLoading = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (res.code == <span class="number">200</span>) &#123;</span><br><span class="line">              <span class="keyword">this</span>.formData = res.data.professions;</span><br><span class="line">              <span class="keyword">this</span>.nameData = [];</span><br><span class="line">              <span class="keyword">this</span>.formData.map(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.nameData.push(i.name);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.ywlezbLoading = <span class="literal">false</span>;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    myEcharts() &#123;</span><br><span class="line">      <span class="comment">// 基于准备好的dom，初始化echarts实例</span></span><br><span class="line">      <span class="keyword">this</span>.myChartLine = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">"ywlx"</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 指定图表的配置项和数据</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> option = &#123;</span><br><span class="line">        tooltip: &#123;</span><br><span class="line">          trigger: <span class="string">"item"</span>,</span><br><span class="line">          formatter: <span class="string">"&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        color: [<span class="string">"#31ceee"</span>, <span class="string">"#20adeb"</span>, <span class="string">"#6be7e8"</span>],</span><br><span class="line">        legend: &#123;</span><br><span class="line">          orient: <span class="string">"vertical"</span>,</span><br><span class="line">          x: <span class="string">"right"</span>,</span><br><span class="line">          align: <span class="string">"left"</span>,</span><br><span class="line">          padding: [<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">          data: <span class="keyword">this</span>.nameData,</span><br><span class="line">          formatter: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> oa = option.series[<span class="number">0</span>].data;</span><br><span class="line">            <span class="keyword">var</span> num = oa[<span class="number">0</span>].value + oa[<span class="number">1</span>].value + oa[<span class="number">2</span>].value;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; option.series[<span class="number">0</span>].data.length; i++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (name == oa[i].name) &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        series: [</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">"业务类型占比"</span>,</span><br><span class="line">            type: <span class="string">"pie"</span>,</span><br><span class="line">            radius: <span class="string">"68%"</span>,</span><br><span class="line">            center: [<span class="string">"40%"</span>, <span class="string">"50%"</span>],</span><br><span class="line">            data: <span class="keyword">this</span>.formData,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                label: &#123;</span><br><span class="line">                  show: <span class="literal">true</span>,</span><br><span class="line">                  <span class="comment">//	                            position:'inside',</span></span><br><span class="line">                  formatter: <span class="string">"&#123;b&#125;: &#123;d&#125;%"</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">              labelLine: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            labelLine: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                length: <span class="number">1</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用刚指定的配置项和数据显示图表。</span></span><br><span class="line">      <span class="keyword">this</span>.myChartLine.setOption(option);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">//图的大小自适应</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.myChartLine) &#123;</span><br><span class="line">        <span class="keyword">this</span>.myChartLine.resize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.getProfessionalCardsCount().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.myEcharts();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    <span class="comment">//实例销毁之前调用</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.myChartLine) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.myChartLine.dispose();</span><br><span class="line">    <span class="keyword">this</span>.myChartLine = <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意点：</li>
</ul>
<ol>
<li>将echarts图表的 <strong>数据</strong> 和 <strong>绘制</strong> 分为两部分各自处理，一目了然，层次分明。</li>
<li><strong>真实图表绘制操作务必放在数据请求赋值之后操作</strong>；为了确保执行准确性和可靠性，这里借助了<strong>Promise</strong>来实现。</li>
<li>组件销毁时要重置（销毁）图表。</li>
<li>为了提高用户体验感，强烈建议为图表容器加上loading状态。</li>
</ol>
<ul>
<li>效果图：</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc35b330d6442dbb95ad7822dbde976~tplv-k3u1fbpfcp-watermark.image?" alt="c99d048b8f1f40e98184d0c9ce4d00d8_tplv-k3u1fbpfcp-watermark.gif"></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>一次搞懂数据大屏适配方案 (vw vh、rem、scale)</title>
    <url>/2023/07/27/%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88-vw-vh%E3%80%81rem%E3%80%81scale/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当接到可视化大屏需求时，你是否会有以下疑问👇<br><strong>如何做一款定制化的数据大屏？<br>开发可视化数据大屏如何做自适应？<br>vw vh、rem、scale 到底哪种比较好？<br>时间不够，有没有偷懒的方法？</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eca164ef1c8471eaabd171963d91c5e~tplv-k3u1fbpfcp-watermark.image" alt="sceen-demo.jpg"><br>最近在公司开发了一个可视化大屏，开发定制化大屏，大家可能都一个感受，开发大屏主要是两方面的工作：</p>
<ul>
<li><code>大屏之关键-前期的自适应适配</code></li>
<li><code>根据 ui 稿绘制图表，调细节</code></li>
</ul>
<p>而解决了适配问题后，后面就只是一个慢工出细活，耗时间的事情了。<a id="more"></a></p>
<h3 id="适配方案分析"><a href="#适配方案分析" class="headerlink" title="适配方案分析"></a>适配方案分析</h3><p>看了网上的各种方案，目前大家采用的大概有 3 种👇</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>实现方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>vw vh</strong></td>
<td>1.按照设计稿的尺寸，将<code>px</code>按比例计算转为<code>vw</code>和<code>vh</code></td>
<td>1.可以动态计算图表的宽高，字体等，灵活性较高<br>2.当屏幕比例跟 ui 稿不一致时，不会出现两边留白情况</td>
<td>1.每个图表都需要单独做字体、间距、位移的适配，比较麻烦</td>
</tr>
<tr>
<td><strong>scale</strong></td>
<td>1.通过 <code>scale</code> 属性，根据屏幕大小，对图表进行整体的等比缩放</td>
<td>1.代码量少，适配简单<br>2.一次处理后不需要在各个图表中再去单独适配</td>
<td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况 <br>2.当缩放比例过大时候，字体会有一点点模糊，就一点点 <br>3.当缩放比例过大时候，事件热区会偏移。</td>
</tr>
<tr>
<td><strong>rem + vw vh</strong></td>
<td>1.获得 rem 的基准值<br>2.动态的计算<code>html根元素的font-size</code><br>3.图表中通过 vw vh 动态计算字体、间距、位移等</td>
<td>1.布局的自适应代码量少，适配简单</td>
<td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况<br>2.图表需要单个做字体、间距、位移的适配</td>
</tr>
</tbody>
</table>
<p>以上 3 种方案在实际应用中该怎么选择视具体情况而定，也有看到大家说自适应在地图的适配中会有一些兼容问题，我这边还没有实践过。</p>
<ul>
<li>如果想简单，客户能同意留白，选用 <code>scale</code> 即可</li>
<li>如果需要兼容不同比例的大屏，并且想在不同比例中都有比较好的效果，图表占满屏幕，类似于移动端的响应式，可以采用 vw vh 的方案</li>
<li>至于 rem，个人觉得就是 scale 和 vw vh 的综合，最终的效果跟 <code>scale</code> 差不多</li>
</ul>
<p>接下来介绍下三种方案的具体实现，方案中的代码都以 vue2.0 和 vue-cli3 搭建的 vue 项目为例，因为是 demo，图表的一些细节就没有过多细致的调整了</p>
<h3 id="方案一：vw-vh"><a href="#方案一：vw-vh" class="headerlink" title="方案一：vw vh"></a>方案一：vw vh</h3><h4 id="上效果"><a href="#上效果" class="headerlink" title="上效果"></a>上效果</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06ae40cbdefb4417b34eb00aa3a718bd~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (1).gif"></p>
<p>当屏幕的尺寸比例刚好是 16:9 时</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d57353767aff4d8a920e142fb9606127~tplv-k3u1fbpfcp-watermark.image?" alt="vwh02.jpg"></p>
<p>当屏幕的尺寸比例大于 16:9 时</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/921953ab6a63442a896324bba43320b1~tplv-k3u1fbpfcp-watermark.image?" alt="vwh03.jpg"></p>
<p>当屏幕的尺寸比例小于 16:9 时</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/779df26fb501472ea294178c90b8705a~tplv-k3u1fbpfcp-watermark.image?" alt="vwh09.jpg"></p>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>按照设计稿的尺寸，将<code>px</code>按比例计算转为<code>vw</code>和<code>vh</code>，转换公式如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">假设设计稿尺寸为 <span class="number">1920</span>*<span class="number">1080</span>（做之前一定问清楚 ui 设计稿的尺寸）</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">网页宽度=<span class="number">1920</span>px</span><br><span class="line">网页高度=<span class="number">1080</span>px</span><br><span class="line"></span><br><span class="line">我们都知道</span><br><span class="line">网页宽度=<span class="number">100</span>vw</span><br><span class="line">网页宽度=<span class="number">100</span>vh</span><br><span class="line"></span><br><span class="line">所以，在 <span class="number">1920</span>px*<span class="number">1080</span>px 的屏幕分辨率下</span><br><span class="line"></span><br><span class="line"><span class="number">1920</span>px = <span class="number">100</span>vw</span><br><span class="line"></span><br><span class="line"><span class="number">1080</span>px = <span class="number">100</span>vh</span><br><span class="line"></span><br><span class="line">这样一来，以一个宽 <span class="number">300</span>px 和 <span class="number">200</span>px 的 div 来说，其所占的宽高，以 vw 和 vh 为单位，计算方式如下:</span><br><span class="line"></span><br><span class="line">vwDiv = (<span class="number">300</span>px / <span class="number">1920</span>px ) * <span class="number">100</span>vw</span><br><span class="line">vhDiv = (<span class="number">200</span>px / <span class="number">1080</span>px ) * <span class="number">100</span>vh</span><br><span class="line"></span><br><span class="line">所以，就在 <span class="number">1920</span>*<span class="number">1080</span> 的屏幕分辨率下，计算出了单个 div 的宽高</span><br><span class="line"></span><br><span class="line">当屏幕放大或者缩小时，div 还是以 vw 和 vh 作为宽高的，就会自动适应不同分辨率的屏幕</span><br></pre></td></tr></table></figure>
<h4 id="话不多说，上代码"><a href="#话不多说，上代码" class="headerlink" title="话不多说，上代码"></a>话不多说，上代码</h4><h5 id="css-方案-sass"><a href="#css-方案-sass" class="headerlink" title="css 方案 - sass"></a>css 方案 - sass</h5><p>util.scss</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 使用 scss 的 math 函数，https://sass-lang.com/documentation/breaking-changes/slash-div</span><br><span class="line"><span class="keyword">@use</span> <span class="string">"sass:math"</span>;</span><br><span class="line"></span><br><span class="line">// 默认设计稿的宽度</span><br><span class="line">$designWidth: 1920;</span><br><span class="line">// 默认设计稿的高度</span><br><span class="line">$designHeight: 1080;</span><br><span class="line"></span><br><span class="line">// px 转为 vw 的函数</span><br><span class="line"><span class="keyword">@function</span> vw($px) &#123;</span><br><span class="line">  <span class="keyword">@return</span> math.div($px, $designWidth) * <span class="number">100vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// px 转为 vh 的函数</span><br><span class="line"><span class="keyword">@function</span> vh($px) &#123;</span><br><span class="line">  <span class="keyword">@return</span> math.div($px, $designHeight) * <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>路径配置</strong><br>只需在<code>vue.config.js</code>里配置一下<code>utils.scss</code>的路径，就可以全局使用了</p>
<p>vue.config.js<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">""</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    name: <span class="string">"app name"</span>,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        <span class="string">"@"</span>: resolve(<span class="string">"src"</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  css: &#123;</span><br><span class="line">    <span class="comment">// 全局配置 utils.scs，详细配置参考 vue-cli 官网</span></span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        prependData: <span class="string">`@import "@/styles/utils.scss";`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>在 .vue 中使用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span>&gt;			</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    name: <span class="string">"Box"</span>,</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style lang="scss" scoped="scoped"&gt;</span></span><br><span class="line"><span class="regexp">/</span>* </span><br><span class="line"> 直接使用 vw 和 vh 函数，将像素值传进去，得到的就是具体的 vw vh 单位		 </span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">.box&#123;</span></span><br><span class="line"><span class="regexp">    width: vw(300);</span></span><br><span class="line"><span class="regexp">    height: vh(100);</span></span><br><span class="line"><span class="regexp">    font-size: vh(16);</span></span><br><span class="line"><span class="regexp">    background-color: black;</span></span><br><span class="line"><span class="regexp">    margin-left: vw(10);</span></span><br><span class="line"><span class="regexp">    margin-top: vh(10);</span></span><br><span class="line"><span class="regexp">    border: vh(2) solid red;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>
<h5 id="css-方案-less"><a href="#css-方案-less" class="headerlink" title="css 方案 - less"></a>css 方案 - less</h5><p>utils.less</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@charset &quot;utf-8&quot;;</span><br><span class="line"></span><br><span class="line">// 默认设计稿的宽度</span><br><span class="line">@designWidth: 1920;</span><br><span class="line"></span><br><span class="line">// 默认设计稿的高度</span><br><span class="line">@designHeight: 1080;</span><br><span class="line"></span><br><span class="line">.px2vw(@name, @px) &#123;</span><br><span class="line">  @&#123;name&#125;: (@px / @designWidth) * 100vw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.px2vh(@name, @px) &#123;</span><br><span class="line">  @&#123;name&#125;: (@px / @designHeight) * 100vh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.px2font(@px) &#123;</span><br><span class="line">  font-size: (@px / @designWidth) * 100vw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>路径配置</strong><br>在<code>vue.config.js</code>里配置一下<code>utils.less</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">""</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    name: <span class="string">"app name"</span>,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        <span class="string">"@"</span>: resolve(<span class="string">"src"</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  css: &#123;</span><br><span class="line">    <span class="comment">// 全局配置utils.scss</span></span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      less: &#123;</span><br><span class="line">        additionalData: <span class="string">`@import "@/styles/utils.less";`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>在 .vue 文件中使用</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;			</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    name: &quot;Box&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped=&quot;scoped&quot;&gt;</span><br><span class="line">/* </span><br><span class="line"> 直接使用 vw 和 vh 函数，将像素值传进去，得到的就是具体的 vw vh单位		 </span><br><span class="line"> */</span><br><span class="line">.box&#123;</span><br><span class="line">    .px2vw(width, 300);</span><br><span class="line">    .px2vh(height, 100);</span><br><span class="line">    .px2font(16);</span><br><span class="line">    .px2vw(margin-left, 300);</span><br><span class="line">    .px2vh(margin-top, 100);</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<h5 id="定义-js-样式处理函数"><a href="#定义-js-样式处理函数" class="headerlink" title="定义 js 样式处理函数"></a>定义 js 样式处理函数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义设计稿的宽高</span></span><br><span class="line"><span class="keyword">const</span> designWidth = <span class="number">1920</span>;</span><br><span class="line"><span class="keyword">const</span> designHeight = <span class="number">1080</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// px转vw</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> px2vw = <span class="function">(<span class="params">_px</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (_px * <span class="number">100.0</span>) / designWidth + <span class="string">'vw'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> px2vh = <span class="function">(<span class="params">_px</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (_px * <span class="number">100.0</span>) / designHeight + <span class="string">'vh'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> px2font = <span class="function">(<span class="params">_px</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (_px * <span class="number">100.0</span>) / designWidth + <span class="string">'vw'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="屏幕变化后，图表自动调整"><a href="#屏幕变化后，图表自动调整" class="headerlink" title="屏幕变化后，图表自动调整"></a>屏幕变化后，图表自动调整</h5><p>这种使用方式有个弊端，就是屏幕尺寸发生变化后，需要手动刷新一下才能完成自适应调整</p>
<p>为了解决这个问题，你需要在各个图表中监听页面尺寸变化，重新调整图表，在 vue 项目中，也可以借助<code>element-resize-detector</code>，最好封装个 resize 的指令，在各图表中就只要使用该指令就可以了，毕竟作为程序员，能偷懒就偷懒</p>
<ol>
<li><p>安装 element-resize-detector</p>
<blockquote>
<p>npm install element-resize-detector –save</p>
</blockquote>
</li>
<li><p>引入工具包在组件中使用或者在单独的 js 中使用</p>
<blockquote>
<p>import resizeDetector from ‘element-resize-detector’</p>
</blockquote>
</li>
<li><p>封装 directive</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// directive.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ECharts <span class="keyword">from</span> <span class="string">"echarts"</span>;</span><br><span class="line"><span class="keyword">import</span> elementResizeDetectorMaker <span class="keyword">from</span> <span class="string">"element-resize-detector"</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">const</span> HANDLER = <span class="string">"_vue_resize_handler"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el[HANDLER] = binding.value</span><br><span class="line">    ? binding.value</span><br><span class="line">    : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> chart = ECharts.getInstanceByDom(el);</span><br><span class="line">        <span class="keyword">if</span> (!chart) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chart.resize();</span><br><span class="line">      &#125;;</span><br><span class="line">  <span class="comment">// 监听绑定的div大小变化，更新 echarts 大小</span></span><br><span class="line">  elementResizeDetectorMaker().listenTo(el, el[HANDLER]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unbind</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// window.removeEventListener("resize", el[HANDLER]);</span></span><br><span class="line">  elementResizeDetectorMaker().removeListener(el, el[HANDLER]);</span><br><span class="line">  <span class="keyword">delete</span> el[HANDLER];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义指令：v-chart-resize 示例：v-chart-resize="fn"</span></span><br><span class="line">Vue.directive(<span class="string">"chart-resize"</span>, &#123; bind, unbind &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.js 中引入</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'@/directive/directive'</span>;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>html 代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"linechart"</span>&gt;</span><br><span class="line">    &lt;div ref=<span class="string">"chart"</span> v-chart-resize <span class="class"><span class="keyword">class</span></span>=<span class="string">"chart"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里要注意的是，图表中如果需要 tab 切换动态更新图表数据，在更新数据时一定不要用 echarts 的 dispose 方法先将图表移除，再重新绘制，因为 resize 指令中挂载到的图表实例还是旧的，就监听不到新的 chart 元素的 resize 了，更新数据只需要用 chart 的 setOption 方法重新设置配置项即可。</p>
<h5 id="图表字体、间距、位移等尺寸自适应"><a href="#图表字体、间距、位移等尺寸自适应" class="headerlink" title="图表字体、间距、位移等尺寸自适应"></a>图表字体、间距、位移等尺寸自适应</h5><p>echarts 的字体大小只支持具体数值（像素），不能用百分比或者 vw 等尺寸，一般字体不会去做自适应，当宽高比跟 ui 稿比例出入太大时，会出现文字跟图表重叠的情况</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65eb81b9699b487a80cd98b863e60e9f~tplv-k3u1fbpfcp-watermark.image?" alt="vwh03.jpg"><br>这里我们就需要封装一个工具函数，来处理图表中文字自适应了👇</p>
<ul>
<li><p>默认情况下，这里以你的设计稿是 1920*1080 为例，即网页宽度是 1920px (做之前一定问清楚 ui 设计稿的尺寸）</p>
</li>
<li><p>把这个函数写在一个单独的工具文件<code>dataUtil.js</code>里面，在需要的时候调用</p>
</li>
<li><p>其原理是计算出当前屏幕宽度和默认设计宽度的比值，将原始的尺寸乘以该值</p>
</li>
<li><p>另外，其它 echarts 的配置项，比如间距、定位、边距也可以用该函数</p>
</li>
</ul>
<ol>
<li><p>编写 dataUtil.js 工具函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Echarts图表字体、间距自适应</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fitChartSize = <span class="function">(<span class="params">size,defalteWidth = <span class="number">1920</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> clientWidth = <span class="built_in">window</span>.innerWidth||<span class="built_in">document</span>.documentElement.clientWidth||<span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">  <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span> size;</span><br><span class="line">  <span class="keyword">let</span> scale = (clientWidth / defalteWidth);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Number</span>((size*scale).toFixed(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将函数挂载到原型上</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fitChartSize&#125; <span class="keyword">from</span> <span class="string">'@src/utils/dataUtil.js'</span></span><br><span class="line">Vue.prototype.fitChartFont = fitChartSize;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>这样你可以在<code>.vue</code>文件中直接使用<code>this.fitChartSize()</code>调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"chartsdom"</span> ref=<span class="string">"chart"</span> v-chart-resize&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"dashboardChart"</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      option: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getEchart();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getEchart() &#123;</span><br><span class="line">      <span class="keyword">let</span> myChart = <span class="keyword">this</span>.$echarts.init(<span class="keyword">this</span>.$refs.chart);</span><br><span class="line">      <span class="keyword">const</span> option = &#123;</span><br><span class="line">        backgroundColor: <span class="string">"transparent"</span>,</span><br><span class="line">        tooltip: &#123;</span><br><span class="line">          trigger: <span class="string">"item"</span>,</span><br><span class="line">          formatter: <span class="string">"&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125;%"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        grid: &#123;</span><br><span class="line">          left: <span class="keyword">this</span>.fitChartSize(<span class="number">10</span>),</span><br><span class="line">          right: <span class="keyword">this</span>.fitChartSize(<span class="number">20</span>),</span><br><span class="line">          top: <span class="keyword">this</span>.fitChartSize(<span class="number">20</span>),</span><br><span class="line">          bottom: <span class="keyword">this</span>.fitChartSize(<span class="number">10</span>),</span><br><span class="line">          containLabel: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        calculable: <span class="literal">true</span>,</span><br><span class="line">        series: [</span><br><span class="line">          &#123;</span><br><span class="line">            color: [<span class="string">"#0db1cdcc"</span>],</span><br><span class="line">            name: <span class="string">"计划投入"</span>,</span><br><span class="line">            type: <span class="string">"funnel"</span>,</span><br><span class="line">            width: <span class="string">"45%"</span>,</span><br><span class="line">            height: <span class="string">"70%"</span>,</span><br><span class="line">            x: <span class="string">"5%"</span>,</span><br><span class="line"></span><br><span class="line">            minSize: <span class="string">"10%"</span>,</span><br><span class="line">            funnelAlign: <span class="string">"right"</span>,</span><br><span class="line"></span><br><span class="line">            center: [<span class="string">"50%"</span>, <span class="string">"50%"</span>], <span class="comment">// for pie</span></span><br><span class="line"></span><br><span class="line">            data: [</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">30</span>,</span><br><span class="line">                name: <span class="string">"下单30%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">55</span>,</span><br><span class="line">                name: <span class="string">"咨询55%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">65</span>,</span><br><span class="line">                name: <span class="string">"点击65%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">60</span>,</span><br><span class="line">                name: <span class="string">"访问62%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">80</span>,</span><br><span class="line">                name: <span class="string">"展现80%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            ].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> a.value - b.value;</span><br><span class="line">            &#125;),</span><br><span class="line">            roseType: <span class="literal">true</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                formatter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">                position: <span class="string">"inside"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                borderWidth: <span class="number">0</span>,</span><br><span class="line">                shadowBlur: <span class="keyword">this</span>.fitChartSize(<span class="number">20</span>),</span><br><span class="line">                shadowOffsetX: <span class="number">0</span>,</span><br><span class="line">                shadowOffsetY: <span class="keyword">this</span>.fitChartSize(<span class="number">5</span>),</span><br><span class="line">                shadowColor: <span class="string">"rgba(0, 0, 0, 0.3)"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line">            color: [<span class="string">"#0C66FF"</span>],</span><br><span class="line">            name: <span class="string">"实际投入"</span>,</span><br><span class="line">            type: <span class="string">"funnel"</span>,</span><br><span class="line">            width: <span class="string">"45%"</span>,</span><br><span class="line">            height: <span class="string">"70%"</span>,</span><br><span class="line">            x: <span class="string">"50%"</span>,</span><br><span class="line"></span><br><span class="line">            minSize: <span class="string">"10%"</span>,</span><br><span class="line">            funnelAlign: <span class="string">"left"</span>,</span><br><span class="line"></span><br><span class="line">            center: [<span class="string">"50%"</span>, <span class="string">"50%"</span>], <span class="comment">// for pie</span></span><br><span class="line"></span><br><span class="line">            data: [</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">35</span>,</span><br><span class="line">                name: <span class="string">"下单35%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">40</span>,</span><br><span class="line">                name: <span class="string">"咨询40%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">70</span>,</span><br><span class="line">                name: <span class="string">"访问70%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">90</span>,</span><br><span class="line">                name: <span class="string">"点击90%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">95</span>,</span><br><span class="line">                name: <span class="string">"展现95%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            ].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> a.value - b.value;</span><br><span class="line">            &#125;),</span><br><span class="line">            roseType: <span class="literal">true</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                position: <span class="string">"inside"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                borderWidth: <span class="number">0</span>,</span><br><span class="line">                shadowBlur: <span class="keyword">this</span>.fitChartSize(<span class="number">20</span>),</span><br><span class="line">                shadowOffsetX: <span class="number">0</span>,</span><br><span class="line">                shadowOffsetY: <span class="keyword">this</span>.fitChartSize(<span class="number">5</span>),</span><br><span class="line">                shadowColor: <span class="string">"rgba(0, 0, 0, 0.3)"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;;</span><br><span class="line">      myChart.setOption(option, <span class="literal">true</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style lang="scss" scoped&gt;</span></span><br><span class="line"><span class="regexp">.chartsdom &#123;</span></span><br><span class="line"><span class="regexp">  width: 100%;</span></span><br><span class="line"><span class="regexp">  height: 100%;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="方案二：scale"><a href="#方案二：scale" class="headerlink" title="方案二：scale"></a>方案二：scale</h3><p>通过 css 的 scale 属性，根据屏幕大小，对图表进行整体的等比缩放，从而达到自适应效果</p>
<h4 id="上效果-1"><a href="#上效果-1" class="headerlink" title="上效果"></a>上效果</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f5570596234d8899b564862fce2ccd~tplv-k3u1fbpfcp-watermark.image?" alt="sceen-scale.gif"></p>
<p>当屏幕的尺寸比例刚好是 16:9 时，页面能刚好全屏展示，内容占满显示器</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a1e86da017b4cfd9dfe5377001340a6~tplv-k3u1fbpfcp-watermark.image?" alt="sceen-demo.jpg"></p>
<p>当屏幕的尺寸比例小于 16:9 时，页面上下留白，左右占满并上下居中，显示比例保持 16:9</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5953ad56ba294d4888280ea197d32e74~tplv-k3u1fbpfcp-watermark.image?" alt="sceen-demo-02.jpg"></p>
<p>当屏幕尺寸比例大于 16:9 时，页面左右留白，上下占满并居中，显示比例保持 16:9</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0da5c6e9ad0e440abb7d7d4f93e81057~tplv-k3u1fbpfcp-watermark.image?" alt="sceen-demo-03.jpg"></p>
<h4 id="话不多说，上代码-1"><a href="#话不多说，上代码-1" class="headerlink" title="话不多说，上代码"></a>话不多说，上代码</h4><p><strong>html 部分</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"screen-wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"screen"</span> <span class="attr">id</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>js 部分</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="comment">// 初始化自适应  ----在刚显示的时候就开始适配一次</span></span><br><span class="line">  handleScreenAuto();</span><br><span class="line">  <span class="comment">// 绑定自适应函数   ---防止浏览器栏变化后不再适配</span></span><br><span class="line">  <span class="built_in">window</span>.onresize = <span class="function"><span class="params">()</span> =&gt;</span> handleScreenAuto();</span><br><span class="line">&#125;,</span><br><span class="line">deleted() &#123;</span><br><span class="line">  <span class="built_in">window</span>.onresize = <span class="literal">null</span>;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 数据大屏自适应函数</span></span><br><span class="line">  handleScreenAuto() &#123;</span><br><span class="line">    <span class="keyword">const</span> designDraftWidth = <span class="number">1920</span>; <span class="comment">//设计稿的宽度</span></span><br><span class="line">    <span class="keyword">const</span> designDraftHeight = <span class="number">960</span>; <span class="comment">//设计稿的高度</span></span><br><span class="line">    <span class="comment">// 根据屏幕的变化适配的比例</span></span><br><span class="line">    <span class="keyword">const</span> scale =</span><br><span class="line">      <span class="built_in">document</span>.documentElement.clientWidth /</span><br><span class="line">        <span class="built_in">document</span>.documentElement.clientHeight &lt;</span><br><span class="line">      designDraftWidth / designDraftHeight</span><br><span class="line">        ? <span class="built_in">document</span>.documentElement.clientWidth / designDraftWidth</span><br><span class="line">        : <span class="built_in">document</span>.documentElement.clientHeight / designDraftHeight;</span><br><span class="line">    <span class="comment">// 缩放比例</span></span><br><span class="line">    <span class="built_in">document</span>.querySelector(</span><br><span class="line">      <span class="string">'#screen'</span>,</span><br><span class="line">    ).style.transform = <span class="string">`scale(<span class="subst">$&#123;scale&#125;</span>) translate(-50%, -50%)`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>css部分</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  除了设计稿的宽高是根据您自己的设计稿决定以外，其他复制粘贴就完事</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="selector-class">.screen-root</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    .screen &#123;</span><br><span class="line">        <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line">        width: 1920px;  //设计稿的宽度</span><br><span class="line">        height: 960px;  //设计稿的高度</span><br><span class="line">        <span class="selector-tag">transform-origin</span>: 0 0;</span><br><span class="line">        <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">        <span class="selector-tag">left</span>: 50%;</span><br><span class="line">        <span class="selector-tag">top</span>: 50%;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h4><p><strong>如何缩放</strong></p>
<p>当<code>屏幕宽高比 &lt; 设计稿宽高比</code>，我们需要缩放的比例是<code>屏幕宽度 / 设计稿宽度</code><br>当<code>屏幕宽高比 &gt; 设计稿宽高比</code>，我们需要缩放的比例是<code>屏幕高度 / 设计稿高度</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="built_in">document</span>.documentElement.clientWidth / <span class="built_in">document</span>.documentElement.clientHeight &lt; designDraftWidth / designDraftHeight ?</span><br><span class="line">            (<span class="built_in">document</span>.documentElement.clientWidth / designDraftWidth) :</span><br><span class="line">            (<span class="built_in">document</span>.documentElement.clientHeight / designDraftHeight);</span><br></pre></td></tr></table></figure>
<p>如果我们拿到的设计稿宽高为: 1920 <em> 960 px ，而我们的屏幕大小是 1440 </em> 900 px，那么 1440/900 = 1.6，920/960 = 2</p>
<p>因为 1.6 &lt; 2 （当前屏幕宽高比小于设计稿宽高比）</p>
<p>所以我们需要缩放的比例是：屏幕宽度除以设计稿宽度 = 1440/1920 = 0.75</p>
<p><strong>如何居中</strong><br>首先我们利用 <code>transform:translate(-50%,-50%)</code> ，将动画的基点设为左上角</p>
<blockquote>
<p>transform-origin：设置动画的基点(中心点)，默认点是元素的中心点</p>
</blockquote>
<p>语法</p>
<blockquote>
<p>transform-origin: x-axis y-axis z-axis;</p>
</blockquote>
<p>然后利用<code>transform:translate(-50%,-50%)</code>，将图表沿 x，y 轴移动 50%</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa9186723c634d468d376040c197de4b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>接下来利用<code>绝对定位</code>将图表定位到中间位置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">left</span>: 50%;</span><br><span class="line"><span class="selector-tag">top</span>: 50%;</span><br></pre></td></tr></table></figure>
<h4 id="偷懒方法-插件"><a href="#偷懒方法-插件" class="headerlink" title="偷懒方法-插件"></a>偷懒方法-插件</h4><p><code>v-scale-screen</code>是使用 css 属性 transform 实现缩放效果的一个大屏自适应组件，通过 scale 进行等比例计算，达到等比例缩放的效果，同时也支持铺满全屏，宽度等比，高度等比，等自适应方案,具体可查<a href="https://juejin.cn/post/7075253747567296548" rel="external nofollow noopener noreferrer" target="_blank">大屏自适应终极解决方案</a></p>
<h3 id="方案三：rem-vw-wh"><a href="#方案三：rem-vw-wh" class="headerlink" title="方案三：rem + vw wh"></a>方案三：rem + vw wh</h3><h4 id="上效果-2"><a href="#上效果-2" class="headerlink" title="上效果"></a>上效果</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a517572ce85c40c882394db74a7b5ef8~tplv-k3u1fbpfcp-watermark.image?" alt="rem.gif"></p>
<p>当屏幕的尺寸比例刚好是 16:9 时，页面能刚好全屏展示，内容占满显示器</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/591f96cb9a2a44379892e9a91842c8eb~tplv-k3u1fbpfcp-watermark.image?" alt="rem01.jpg"></p>
<p>当屏幕的尺寸比例小于 16:9 时，页面上下留白，左右占满并上下居中，显示比例保持 16:9</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403500447e734a44be43af9da0809428~tplv-k3u1fbpfcp-watermark.image?" alt="rem02.jpg"></p>
<p>当屏幕尺寸比例大于 16:9 时，页面左右留白，上下占满并居中，显示比例保持 16:9</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11f4908f68fb49ada3597d3d07161a32~tplv-k3u1fbpfcp-watermark.image?" alt="rem03.jpg"></p>
<h4 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h4><p><strong>关于 rem</strong><br><code>rem(font size of the root element)</code>，是 css3 中新增的一个大小单位，即相对于根元素 font-size 值的大小。<br><strong>自适应思路</strong><br>动态的计算出页面的 fontsize 从而改变 rem 的大小。</p>
<ol>
<li>拿 1920 * 1080 的标准屏幕大小为例，将屏幕分为<code>10</code>份，先计算<code>rem 的基准值:</code> 1920 / 10 = 192；</li>
<li>把所有元素的长、宽、位置、字体大小等原来的 px 单位全部转换成 rem；</li>
<li>网页加载后，用 js 去计算当前浏览器的宽度，并设置 html 的 font-size 为 (<code>当前浏览器窗口宽度 / 10</code>) 。<br>这样的话 10rem 就刚好等于浏览器窗口的宽度，也就可以保证 100% 宽度，等比例缩放设计稿的页面了。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/591f96cb9a2a44379892e9a91842c8eb~tplv-k3u1fbpfcp-watermark.image?" alt="rem01.jpg"></li>
</ol>
<p><strong>因此 rem + vw vh 方案要解决三件事</strong></p>
<ol>
<li>获得 rem 的基准值；</li>
<li>页面内写一段 js 代码，动态的计算<code>html根元素的font-size</code>；</li>
<li>屏幕变化后，图表自动调整和图表字体、间距、位移等的自适应。</li>
</ol>
<h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><p><strong>第一点：获得 rem 的基准值</strong></p>
<ol>
<li>首先安装 <code>@njleonzhang/postcss-px-to-rem</code> 这个包</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i @njleonzhang/postcss-px-to-rem -D</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在项目根目录新建<code>.postcssrc.js</code>配置文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;&#125;,</span><br><span class="line">    <span class="string">"@njleonzhang/postcss-px-to-rem"</span>: &#123;</span><br><span class="line">      unitToConvert: <span class="string">'px'</span>, <span class="comment">// (String) 要转换的单位，默认是 px。</span></span><br><span class="line">      widthOfDesignLayout: <span class="number">1920</span>, <span class="comment">// (Number) 设计布局的宽度。对于pc仪表盘，一般是 1920.</span></span><br><span class="line">      unitPrecision: <span class="number">3</span>, <span class="comment">// (Number) 允许 rem 单位增长到的十进制数字.</span></span><br><span class="line">      selectorBlackList: [<span class="string">'.ignore'</span>, <span class="string">'.hairlines'</span>], <span class="comment">// (Array) 要忽略并保留为 px 的选择器.</span></span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// (Number) 设置要替换的最小像素值.</span></span><br><span class="line">      mediaQuery: <span class="literal">false</span> <span class="comment">// (Boolean) 允许在媒体查询中转换 px.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>配置完成后，页面内的 px 就会被转换成 rem 了</li>
</ol>
<p><strong>第二点：动态的计算<code>html根元素的font-size</code></strong></p>
<ol>
<li><p>在工具函数文件中新建一个 rem.js 文件，用于动态计算 font-size</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">screenRatioByDesign = <span class="number">16</span> <span class="regexp">/ 9) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  let docEle = document.documentElement</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  function setHtmlFontSize() &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    var screenRatio = docEle.clientWidth /</span> docEle.clientHeight;</span></span></span><br><span class="line"><span class="function"><span class="params">    var fontSize = (</span></span></span><br><span class="line"><span class="function"><span class="params">      screenRatio &gt; screenRatioByDesign</span></span></span><br><span class="line"><span class="function"><span class="params">        ? (screenRatioByDesign <span class="regexp">/ screenRatio)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">        : 1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    ) * docEle.clientWidth /</span> <span class="number">10</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    docEle.style.fontSize = fontSize.toFixed(<span class="number">3</span></span>) + "<span class="title">px</span>";</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params">docEle.style.fontSize</span>);</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="title">setHtmlFontSize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  <span class="title">window</span>.<span class="title">addEventListener</span>(<span class="params"><span class="string">'resize'</span>, setHtmlFontSize</span>)</span></span><br><span class="line"><span class="function">&#125;)(<span class="params"></span>)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在入口文件 main.js 中引入 rem.js 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./utils/rem.js'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>至此，页面就已经可以实现 16:9 自适应了。</p>
<p><strong>第三点：屏幕变化，图表自适应</strong><br>屏幕变化后，图表自动调整字体、间距、位移等，此处参考上面 vw vh 的实现方式即可，在此就不重复赘述了</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>推荐一个echarts 的案列网站，需要什么直接图表直接在上面去找，可以省去很多查 echarts 配置的时间<br><a href="https://juejin.cn/post/7078834647005822983" rel="external nofollow noopener noreferrer" target="_blank">全网echarts案例资源大总结和echarts的高效使用技巧（细节版）</a></li>
</ul>
<ul>
<li><p>scale 方案参考：<br><a href="https://juejin.cn/post/7148733509744459790" rel="external nofollow noopener noreferrer" target="_blank">数据大屏最简单自适应方案，无需适配rem单位</a></p>
</li>
<li><p>vw vh 方案参考：<br><a href="https://juejin.cn/post/7009081081760579591#heading-31" rel="external nofollow noopener noreferrer" target="_blank">Vue+Echarts企业级大屏项目适配方案</a></p>
</li>
<li><p>rem 方案参考：<a href="https://juejin.cn/post/7035930041498206216#heading-0" rel="external nofollow noopener noreferrer" target="_blank">数据大屏rem适配方案</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>mac item2 ssh 登录云服务器</title>
    <url>/2023/03/14/mac-item2-ssh-%E7%99%BB%E5%BD%95%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-创建脚本文件"><a href="#1-创建脚本文件" class="headerlink" title="1. 创建脚本文件"></a>1. 创建脚本文件</h3><p>新建一个名为tencentServerLogin的文件：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">touch tencenServerLogin</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>将服务器信息写入到该文件中，内容示例如下：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect -f</span></span><br><span class="line"><span class="built_in">set</span> user root</span><br><span class="line"><span class="built_in">set</span> host 33.123.323.41</span><br><span class="line"><span class="built_in">set</span> password 34343Bh-e343476-c</span><br><span class="line"><span class="built_in">set</span> timeout 30</span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$host</span></span><br><span class="line">expect <span class="string">"*assword:*"</span></span><br><span class="line">send <span class="string">"<span class="variable">$password</span>\r"</span></span><br><span class="line">interact</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>
<h3 id="2-新建一个iTerm2-Profile"><a href="#2-新建一个iTerm2-Profile" class="headerlink" title="2. 新建一个iTerm2 Profile"></a>2. 新建一个iTerm2 Profile</h3><ol>
<li>打开iTerm2 -&gt; preferences -&gt; Profiles</li>
<li>点击左下角的”+”号, 新建一个profile</li>
<li>在右边的内容框中,找到Command, 填入expect + 前面新建tencenServerLogin文件的绝对路径</li>
</ol>
<p>示例如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202303141917407" alt></p>
<h3 id="3-iTerm2保持ssh连接不断开"><a href="#3-iTerm2保持ssh连接不断开" class="headerlink" title="3. iTerm2保持ssh连接不断开"></a>3. iTerm2保持ssh连接不断开</h3><p>用iTerm2进行ssh时，空闲了一段时间就会与服务器断开连接。这个问题可以通过添加以下配置来解决，配置示例如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202303141918096" alt></p>
<h3 id="4-使用iTerm2登录云服务器"><a href="#4-使用iTerm2登录云服务器" class="headerlink" title="4. 使用iTerm2登录云服务器"></a>4. 使用iTerm2登录云服务器</h3><p>示例如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202303141918585" alt></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>um3使用tailwindcss</title>
    <url>/2023/02/08/um3%E4%BD%BF%E7%94%A8tailwindcss/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://tailwindcss.com/docs/installation/using-postcss" rel="external nofollow noopener noreferrer" target="_blank">Tailwind CSS</a> 是最近几年很火的 CSS UI 框架，遵循 Atomic/Utility-First 的原则，能够大幅提升样式开发效率。在本篇博客中，我将介绍 UmiJS 项目接入 Tailwind CSS 的流程，并分享遇到的问题及其解决方法。<a id="more"></a></p>
<h2 id="安装-Tailwind"><a href="#安装-Tailwind" class="headerlink" title="安装 Tailwind"></a>安装 Tailwind</h2><h3 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h3><p>Tailwind 依赖 <a href="https://postcss.org" rel="external nofollow noopener noreferrer" target="_blank">PostCSS</a> 提供的样式处理能力。PostCSS 将 CSS 代码解析成 AST 结构，并交由 JS 插件来进行处理，常见的 PostCSS 插件有 <code>autoprefixer</code>、<code>cssnano</code> 等。其中，<code>autoprefixer</code> 用于为 CSS 中的属性添加浏览器特定的前缀，提升 CSS 代码的兼容性。</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>目前，Umi 的稳定版本是 <code>3.5.20</code> ，其（<a href="https://github.com/umijs/umi/blob/master/packages/bundler-webpack/package.json" rel="external nofollow noopener noreferrer" target="_blank">@umijs/bundler-webpack</a>）使用的 PostCSS 版本为 <code>7.0.32</code> ，而 Tailwind 依赖 PostCSS 的版本为 <code>8.x.x</code> 。因此，我们需要安装兼容 PostCSS 7 的 Tailwind 版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add \</span><br><span class="line">  tailwindcss@npm:@tailwindcss/postcss7-compat \</span><br><span class="line">  @tailwindcss/postcss7-compat \</span><br><span class="line">  autoprefixer@^9</span><br></pre></td></tr></table></figure>
<h2 id="修改-Umi-配置"><a href="#修改-Umi-配置" class="headerlink" title="修改 Umi 配置"></a>修改 Umi 配置</h2><p>完成相关依赖的安装后，我们需要修改 Umi 配置文件（<code>.umirc</code> 或 <code>config/config.ts</code>）的 <code>extraPostCSSPlugins</code> 选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &quot;umi&quot;;</span><br><span class="line"></span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  extraPostCSSPlugins: [require(&quot;tailwindcss&quot;), require(&quot;autoprefixer&quot;)],</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>tailwindcss</code> 会识别根目录下的 <code>tailwind.config.js</code> 配置文件。如果我们想指定配置文件的读取路径，可设置 <code>config</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &quot;umi&quot;;</span><br><span class="line"></span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  extraPostCSSPlugins: [</span><br><span class="line">    require(&quot;tailwindcss&quot;)(&#123; config: &quot;[custom_path]/tailwind.config.js&quot; &#125;),</span><br><span class="line">    require(&quot;autoprefixer&quot;),</span><br><span class="line">  ],</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="添加-Tailwind-配置"><a href="#添加-Tailwind-配置" class="headerlink" title="添加 Tailwind 配置"></a>添加 Tailwind 配置</h2><p><code>tailwind.config.js</code> 是 Tailwind 的配置文件，通常存放在项目根目录中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &quot;jit&quot;,</span><br><span class="line">  purge: [&quot;./src/**/*.&#123;ts,tsx,js,jsx&#125;&quot;],</span><br><span class="line">  darkMode: false,</span><br><span class="line">  theme: &#123;&#125;,</span><br><span class="line">  variants: &#123;&#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到在上面的文件中，通过配置 <code>mode</code> 属性为 <code>jit</code> ，我们开启了 Tailwind 的 JIT（Just In Time）编译模式。开启 JIT 模式，有什么好处呢？</p>
<h3 id="JIT-编译模式"><a href="#JIT-编译模式" class="headerlink" title="JIT 编译模式"></a>JIT 编译模式</h3><p>首先，我们需要了解在不开启 JIT 模式（<strong>传统模式</strong>）下的 Tailwind 构建流程：Tailwind 通过读取配置文件，预生成所有的工具类，提供给开发者使用。最后在打包时，通过 PostCSS 提供的 <code>pure</code> 插件，执行 Tree Shaking 操作，移除未被使用的工具类，从而简化产物。在该模式下，如果配置文件有很多自定义的配置，那么就会延长预生成的时间。  </p>
<p>在开启 JIT 模式后，Tailwind 不预生成所有的工具类，而是根据开发者的实际使用，来生成对应的类，大大提升了编译速度。  </p>
<p>此外，JIT 模式支持 <code>w-[100px]</code> 等包含特殊尺寸的工具类生成，而不需要开发者自行编写特定尺寸的 <code>style</code> 或 <code>class</code> ，这也提升了开发体验。</p>
<h2 id="使用-Tailwind"><a href="#使用-Tailwind" class="headerlink" title="使用 Tailwind"></a>使用 Tailwind</h2><p>如下图所示，<a href="https://tailwindcss.com/docs/installation/using-postcss" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>建议我们在项目中引入 <code>base</code>、<code>components</code> 和 <code>utilities</code> 。</p>
<p><img src="https://pic2.zhimg.com/v2-2528ab6ca625c66252d9b99a8e81ff51_r.jpg" alt></p>
<p>Tailwind 官方建议引入的编译指令</p>
<p>经过验证，<code>base</code> 和 <code>components</code> 会影响 Ant Design 的样式，会带来样式问题。因此，在 Umi 项目的 <code>global.less</code> 文件中，我们只需引入 <code>utilities</code> 样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@tailwind utilities;</span><br></pre></td></tr></table></figure>
<h2 id="修复工具类无法生成的问题"><a href="#修复工具类无法生成的问题" class="headerlink" title="修复工具类无法生成的问题"></a>修复工具类无法生成的问题</h2><p>在开启 JIT 模式后，会遇到工具类无法生成的问题。如下图所示，可以发现 Tailwind 并没有为 <code>text-red-500</code> 生成对应的样式规则。</p>
<p><img src="https://pic1.zhimg.com/v2-0183b45405630e6d64c02826b7c9b8b0_r.jpg" alt></p>
<p>Tailwind 工具类无法生成</p>
<p>查看相关 <a href="https://github.com/tailwindlabs/tailwindcss/issues/5132%23issuecomment-894549642" rel="external nofollow noopener noreferrer" target="_blank">Issue</a> 得知，该问题只会在 PostCSS 7 开启 JIT 模式出现，因为 PostCSS 7 不支持 <code>dir-dependency</code> 的消息类型。  </p>
<p>该问题的具体解决办法是在执行 <code>umi start</code> 命令时，配置 <code>TAILWIND_MODE=watch</code> 的环境变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;TAILWIND_MODE=watch umi dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.dute.org/blog/what-is-postcss.html" rel="external nofollow noopener noreferrer" target="_blank">一文搞懂什么是 PostCSS</a></li>
<li><a href="https://github.com/dewfall123/umi-plugin-tailwindcss" rel="external nofollow noopener noreferrer" target="_blank">github.com/dewfall123/umi-plugin-tailwindcss</a></li>
<li><a href="https://iorigina.com/p/%25E5%259C%25A8-umi-%25E4%25B8%25AD%25E4%25BD%25BF%25E7%2594%25A8-tailwindcss/" rel="external nofollow noopener noreferrer" target="_blank">在 Umi 中使用 TailwindCSS</a></li>
<li><a href="https://juejin.cn/post/7025549579495931935" rel="external nofollow noopener noreferrer" target="_blank">Tailwind 适配 Umi H5 方案</a></li>
</ul>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>mac常用的命令</title>
    <url>/2023/02/02/mac%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-最常用终端命令"><a href="#1-最常用终端命令" class="headerlink" title="1.最常用终端命令"></a>1.最常用终端命令</h1><p>Mac OS系统有些文件默认隐藏,如果需要显示,可以通过终端显示隐藏文件或文件夹<a id="more"></a></p>
<ul>
<li>显示隐藏路径的终端命令:defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder</li>
<li>取消隐藏路径的终端命令:defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder</li>
</ul>
<h1 id="2-其他终端命令"><a href="#2-其他终端命令" class="headerlink" title="2.其他终端命令"></a>2.其他终端命令</h1><h2 id="1-目录操作"><a href="#1-目录操作" class="headerlink" title="1.目录操作"></a>1.目录操作</h2><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
<th>使用举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>cd</td>
<td>打开当前目录</td>
<td>cd dirname</td>
</tr>
<tr>
<td>pwd</td>
<td>显示当前目录的路径名</td>
<td>pwd</td>
</tr>
<tr>
<td>ls</td>
<td>显示当前目录的内容</td>
<td>ls -la</td>
</tr>
<tr>
<td>dircmp</td>
<td>比较两个目录的内容</td>
<td>dircmp dir1 dir2</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建一个目录</td>
<td>mkdir dirname</td>
</tr>
<tr>
<td>rmdir</td>
<td>删除一个目录</td>
<td>rmdir dirname</td>
</tr>
<tr>
<td>mvdir</td>
<td>移动或重命名一个目录</td>
<td>mvdir dir1 dir2</td>
</tr>
</tbody>
</table>
<h2 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2.文件操作"></a>2.文件操作</h2><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
<th>使用举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>显示或连接文件</td>
<td>cat filename</td>
</tr>
<tr>
<td>ln</td>
<td>联接文件</td>
<td>ln -s file1 file2</td>
</tr>
<tr>
<td>find</td>
<td>使用匹配表达式查找文件</td>
<td>find . -name “*.c” -print</td>
</tr>
<tr>
<td>file</td>
<td>显示文件类型</td>
<td>file filename</td>
</tr>
<tr>
<td>open</td>
<td>使用默认的程序打开文件</td>
<td>open filename</td>
</tr>
<tr>
<td>od</td>
<td>显示非文本文件的内容</td>
<td>od -c filename</td>
</tr>
<tr>
<td>cp</td>
<td>复制文件或目录</td>
<td>cp file1 file2</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件或目录</td>
<td>rm filename</td>
</tr>
<tr>
<td>mv</td>
<td>改变文件名或所在目录</td>
<td>mv file1 file2</td>
</tr>
<tr>
<td>pg</td>
<td>分页格式化显示文件内容</td>
<td>pg filename</td>
</tr>
<tr>
<td>more</td>
<td>分屏显示文件内容</td>
<td>more filename</td>
</tr>
</tbody>
</table>
<h2 id="3-选择操作"><a href="#3-选择操作" class="headerlink" title="3.选择操作"></a>3.选择操作</h2><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
<th>使用举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>comm</td>
<td>显示两有序文件的公共和非公共行</td>
<td>comm file1 file2</td>
</tr>
<tr>
<td>wc</td>
<td>统计文件的字符数、词数和行数</td>
<td>wc filename</td>
</tr>
<tr>
<td>nl</td>
<td>给文件加上行号</td>
<td>nl file1 &gt;file2</td>
</tr>
<tr>
<td>awk</td>
<td>在文件中查找并处理模式</td>
<td>awk ‘{print $1 $1}’ filename</td>
</tr>
<tr>
<td>sort</td>
<td>排序或归并文件</td>
<td>sort -d -f -u file1</td>
</tr>
<tr>
<td>uniq</td>
<td>去掉文件中的重复行</td>
<td>uniq file1 file2</td>
</tr>
<tr>
<td>diff</td>
<td>比较并显示两个文件的差异</td>
<td>diff file1 file2</td>
</tr>
<tr>
<td>sed</td>
<td>非交互方式流编辑器</td>
<td>sed “s/red/green/g” filename</td>
</tr>
<tr>
<td>cut</td>
<td>显示文件每行中的某些域</td>
<td>cut -f1,7 -d: /etc/passwd</td>
</tr>
<tr>
<td>colrm</td>
<td>从标准输入中删除若干列</td>
<td>colrm 8 20 file2</td>
</tr>
<tr>
<td>paste</td>
<td>横向连接文件</td>
<td>paste file1 file2</td>
</tr>
<tr>
<td>head</td>
<td>显示文件的最初几行</td>
<td>head -20 filename</td>
</tr>
<tr>
<td>tail</td>
<td>显示文件的最后几行</td>
<td>tail -15 filename</td>
</tr>
</tbody>
</table>
<h2 id="4-安全操作"><a href="#4-安全操作" class="headerlink" title="4.安全操作"></a>4.安全操作</h2><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
<th>使用举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>chown</td>
<td>改变文件或目录的属主</td>
<td>chown newowner filename</td>
</tr>
<tr>
<td>chgrp</td>
<td>改变文件或目录的所属组</td>
<td>chgrp staff filename</td>
</tr>
<tr>
<td>xlock</td>
<td>给终端上锁</td>
<td>xlock -remote</td>
</tr>
<tr>
<td>passwd</td>
<td>修改用户密码</td>
<td>passwd</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件或目录的权限</td>
<td>chmod ug+x filename umask</td>
</tr>
<tr>
<td>umask</td>
<td>定义创建文件的权限掩码</td>
<td>umask 027</td>
</tr>
</tbody>
</table>
<h2 id="5-编程操作"><a href="#5-编程操作" class="headerlink" title="5.编程操作"></a>5.编程操作</h2><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
<th>使用举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>touch</td>
<td>更新文件的访问和修改时间</td>
<td>touch -m 05202400 filename</td>
</tr>
<tr>
<td>dbx</td>
<td>命令行界面调试工具</td>
<td>dbx a.out</td>
</tr>
<tr>
<td>xde</td>
<td>图形用户界面调试工具</td>
<td>xde a.out</td>
</tr>
<tr>
<td>make</td>
<td>维护可执行程序的最新版本</td>
<td>make</td>
</tr>
</tbody>
</table>
<h2 id="6-进程操作"><a href="#6-进程操作" class="headerlink" title="6.进程操作"></a>6.进程操作</h2><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
<th>使用举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>nice</td>
<td>改变待执行命令的优先级</td>
<td>nice cc -c *.c</td>
</tr>
<tr>
<td>renice</td>
<td>改变已运行进程的优先级</td>
<td>renice +20 32768</td>
</tr>
<tr>
<td>ps</td>
<td>显示进程当前状态</td>
<td>ps u</td>
</tr>
<tr>
<td>kill</td>
<td>终止进程</td>
<td>kill -9 30142</td>
</tr>
</tbody>
</table>
<h2 id="7-时间操作"><a href="#7-时间操作" class="headerlink" title="7.时间操作"></a>7.时间操作</h2><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
<th>使用举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>date</td>
<td>显示系统的当前日期和时间</td>
<td>date</td>
</tr>
<tr>
<td>cal</td>
<td>显示日历</td>
<td>cal 8 1996</td>
</tr>
<tr>
<td>time</td>
<td>统计程序的执行时间</td>
<td>time a.out</td>
</tr>
</tbody>
</table>
<h2 id="8-网络与通信操作"><a href="#8-网络与通信操作" class="headerlink" title="8.网络与通信操作"></a>8.网络与通信操作</h2><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
<th>使用举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>mail</td>
<td>阅读和发送电子邮件</td>
<td>mail</td>
</tr>
<tr>
<td>write</td>
<td>给另一用户发送报文</td>
<td>write username pts/1</td>
</tr>
<tr>
<td>mesg</td>
<td>允许或拒绝接收报文</td>
<td>mesg n</td>
</tr>
<tr>
<td>ftp</td>
<td>在本地主机与远程主机之间传输文件</td>
<td>ftp ftp.sp.net.edu.cn</td>
</tr>
<tr>
<td>rcp</td>
<td>在本地主机与远程主机之间复制文件</td>
<td>rcp file1 host1:file2</td>
</tr>
<tr>
<td>ping</td>
<td>给一个网络主机发送 回应请求</td>
<td>ping hpc.sp.net.edu.cn</td>
</tr>
<tr>
<td>telnet</td>
<td>远程登录</td>
<td>telnet hpc.sp.net.edu.cn</td>
</tr>
<tr>
<td>rlogin</td>
<td>远程登录</td>
<td>rlogin hostname -l username</td>
</tr>
<tr>
<td>rsh</td>
<td>在远程主机执行指定命令</td>
<td>rsh f01n03 date</td>
</tr>
</tbody>
</table>
<h2 id="9-Korn-Shell-命令"><a href="#9-Korn-Shell-命令" class="headerlink" title="9.Korn Shell 命令"></a>9.Korn Shell 命令</h2><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
<th>使用举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>history</td>
<td>列出最近执行过的几条命令及编号</td>
<td>history</td>
</tr>
<tr>
<td>r</td>
<td>重复执行最近执行过的某条命令</td>
<td>r -2</td>
</tr>
<tr>
<td>alias</td>
<td>给某个命令定义别名</td>
<td>alias del=rm -i</td>
</tr>
<tr>
<td>unalias</td>
<td>取消对某个别名的定义</td>
<td>unalias del</td>
</tr>
</tbody>
</table>
<h2 id="10-其它命令"><a href="#10-其它命令" class="headerlink" title="10.其它命令"></a>10.其它命令</h2><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
<th>使用举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>stty</td>
<td>显示或重置控制键定义</td>
<td>stty -a</td>
</tr>
<tr>
<td>du</td>
<td>查询磁盘使用情况</td>
<td>du -k subdir</td>
</tr>
<tr>
<td>df</td>
<td>显示文件系统的总空间和可用空间</td>
<td>df /tmp</td>
</tr>
<tr>
<td>w</td>
<td>显示当前系统活动的总信息</td>
<td>w</td>
</tr>
<tr>
<td>env</td>
<td>显示当前所有设置过的环境变量</td>
<td>env</td>
</tr>
<tr>
<td>who</td>
<td>列出当前登录的所有用户</td>
<td>who</td>
</tr>
<tr>
<td>whoami</td>
<td>显示当前正进行操作的用户名</td>
<td>whoami</td>
</tr>
<tr>
<td>tty</td>
<td>显示终端或伪终端的名称</td>
<td>tty</td>
</tr>
<tr>
<td>uname</td>
<td>显示操作系统的有关信息</td>
<td>uname -a</td>
</tr>
<tr>
<td>clear</td>
<td>清除屏幕或窗口内容</td>
<td>clear</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>前端工程化</title>
    <url>/2023/01/10/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、前端代码规范工具"><a href="#一、前端代码规范工具" class="headerlink" title="一、前端代码规范工具"></a>一、前端代码规范工具</h2><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>代码规范和质量是编码中很重要的一部分，目前有很多工具可以帮助我们处理。</p>
<p>在使用这些工具的过程中发现，存在一下问题：</p>
<ul>
<li>功能重复</li>
<li>不同工具，相同配置冲突</li>
<li>版本迭代导致配置变更</li>
<li><p>工具相互组合，使用困难</p>
<a id="more"></a>
<p>这篇文章主要从工程化的角度出发，分享以下内容：</p>
</li>
<li><p>1、介绍各种工具的使用（Prettier、ESLint、lint-staged、commitlint、Hooks）</p>
</li>
<li>2、通过Git Hooks来自动化执行这些工具。</li>
<li>3、配置CI在代码提交阶段格式化、检测代码、检测提交信息。</li>
</ul>
<p>学习完这篇文章你将了解：</p>
<ul>
<li>1、了解如何区分这些工具、不同的配置入口</li>
<li>2、在项目中如何配置这些检测工具</li>
<li>3、如果避免每次的全量检测代码</li>
<li>4、如何规范提交代码和描述信息</li>
<li>5、学习Git Hooks知识</li>
<li>6、如何将这些工具通过Hooks自动化处理</li>
<li>7、通过CI将这些流程自动化执行</li>
</ul>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/richLpf/auto-format-demo" rel="external nofollow noopener noreferrer" target="_blank">本文代码示例参考</a></p>
<h2 id="2、工具分类介绍"><a href="#2、工具分类介绍" class="headerlink" title="2、工具分类介绍"></a>2、工具分类介绍</h2><p>检测代码的工具很多，主要分为三类：</p>
<ul>
<li>一类是代码格式化工具，专注代码结构美化，不处理任何有关语法的内容  </li>
</ul>
<ul>
<li><code>[Prettier](https://link.zhihu.com/?target=https%3A//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29e62e3c6c514314b06e0f37aca21b3b~tplv-k3u1fbpfcp-zoom-1.image)</code>：专注代码格式化</li>
<li><code>[Stylelint](https://link.zhihu.com/?target=https%3A//stylelint.io/)</code>：专注CSS语法格式化</li>
</ul>
<ul>
<li>一类是lint类，这些工具也支持处理代码格式，但重点是检测代码语法质量  </li>
</ul>
<ul>
<li><code>[ESLint](https://link.zhihu.com/?target=https%3A//cn.eslint.org/)</code>: 可以配置代码格式规则，也可以检测代码语法质量</li>
</ul>
<ul>
<li>一类是将不同的工具进行合成，成为一个包含子功能或者有定制功能的插件，可以避免Prettier和Lint二者在代码处理上的冲突。  </li>
</ul>
<ul>
<li><code>[eslint-config-prettier](https://link.zhihu.com/?target=https%3A//github.com/prettier/eslint-config-prettier)</code>：ESLint检测和Prettier格式化</li>
<li><code>[tslint-config-prettier](https://link.zhihu.com/?target=https%3A//github.com/alexjoverm/tslint-config-prettier)</code>：TS检测和代码格式化</li>
<li><code>[lint-staged](https://link.zhihu.com/?target=https%3A//github.com/okonet/lint-staged%23readme)</code>：仅过滤Git暂存区上的文件，可以有效避免每次提交处理所有文件。</li>
</ul>
<p><strong>Git暂存区：执行命令git add后，要提交的代码存放的空间</strong></p>
<p>这些工具有小而精的，也有大而全的，具体使用要根据具体场景</p>
<ul>
<li>写一个主题样式，肯定首选Stylelint，重点处理CSS；</li>
<li>开发一个产品，不妨使用大而全。因为项目中有很多格式需要处理，如果都用小而精的处理，会引入很多荣誉的配置。</li>
</ul>
<p><strong>这些工具配置都比较相似，但尤其要注意版本的不同，导致的配置不同。</strong></p>
<h2 id="3、本文环境"><a href="#3、本文环境" class="headerlink" title="3、本文环境"></a>3、本文环境</h2><p>下文依赖的工具和环境</p>
<ul>
<li>OS：mac m1</li>
<li>Git版本：2.24.3</li>
<li>npm版本：7.21.1</li>
<li>Husky版本：7.0.4</li>
<li>Nodejs版本：v16.9.0</li>
</ul>
<h2 id="二、自动化工具原理和配置"><a href="#二、自动化工具原理和配置" class="headerlink" title="二、自动化工具原理和配置"></a>二、自动化工具原理和配置</h2><h2 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h2><p><strong>Prettier、ESLint</strong></p>
<p>两者的工作原理是将代码解析成<code>AST</code>，再通过我们写的配置，还原格式化后的代码，具体转化可以体验下<a href="https://link.zhihu.com/?target=https%3A//cn.eslint.org/parser/%25E3%2580%2582" rel="external nofollow noopener noreferrer" target="_blank">https://cn.eslint.org/parser/。</a></p>
<p><strong>lint-staged、commitlint、husky</strong></p>
<ul>
<li><code>lint-staged</code>是获取git add后暂存区的代码。</li>
<li><code>commitlint</code>是获取git commit的描述信息然后对格式进行规则校验。</li>
<li><code>husky</code>是将git内置的勾子函数暴露出来，便于配置</li>
</ul>
<h2 id="2、配置对比"><a href="#2、配置对比" class="headerlink" title="2、配置对比"></a>2、配置对比</h2><blockquote>
<p>下面这些自动化工具，可以不同的地方进行配置，版本也不同，看起来很复杂，其实并没有，除了注意大版本的不同，其他的配置方式都大同小异。这里我们整理下这些配置通用的部分，下面就不再分开写，只展示package.json这一种方式。</p>
</blockquote>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>package.json关键字</th>
<th>常用配置文件</th>
<th>忽略文件</th>
<th>共享文件</th>
<th>插件</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<ul>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/richLpf/auto-format-demo/tree/main/config" rel="external nofollow noopener noreferrer" target="_blank">配置示例地址</a></li>
<li>package.json中关键字内容和配置文件内容一致</li>
<li>共享配置一般都是导出配置文件，上传npm，规范命名即可</li>
<li>这些工具大都还提供了编辑器集成、CLI等</li>
</ul>
<h2 id="三、代码格式美化：Prettier"><a href="#三、代码格式美化：Prettier" class="headerlink" title="三、代码格式美化：Prettier"></a>三、代码格式美化：Prettier</h2><h2 id="1、初始化项目构建"><a href="#1、初始化项目构建" class="headerlink" title="1、初始化项目构建"></a>1、初始化项目构建</h2><p>新建项目，并在index.html和index.js写一些格式不规范的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir front-demo</span><br><span class="line">cd front-demo</span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line">mkdir src</span><br><span class="line">touch src/index.js</span><br></pre></td></tr></table></figure>
<p>目录结构如图：</p>
<p><img src="https://pic1.zhimg.com/v2-be84b384e89940536470c005f804ee80_r.jpg" alt></p>
<h2 id="2、插件使用"><a href="#2、插件使用" class="headerlink" title="2、插件使用"></a>2、插件使用</h2><p>安装Prettier插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add prettier -D</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn prettier -w .</span><br></pre></td></tr></table></figure>
<p>发现当前所有目录下的文件，都进行了格式化</p>
<p><strong>这里使用yarn prettier是为了读取项目下的prettier指令，如果你安装全局命令或者配置了环境变量，可以不用yarn指令</strong></p>
<p><code>prettier</code>格式有一套默认的格式化规则，一般情况下，选择默认就可以了</p>
<blockquote>
<p>当然也可以自行配置，下面有两种配置方法：  </p>
</blockquote>
<ul>
<li>在package.json中添加关键词<code>prettier</code></li>
<li>在项目根目录下新建<code>.prettierrc</code>文件，js、json、yaml等也可以。</li>
<li>下面就不再写package.json中配置了，具体关键字可以查看上面的表格。我们统一通过配置文件进行配置，其他的工具也是一样的。</li>
<li>规则解释见配置文件<a href="https://link.zhihu.com/?target=https%3A//github.com/richLpf/auto-format-demo/tree/main/config" rel="external nofollow noopener noreferrer" target="_blank">Github地址</a></li>
</ul>
<p>这里在根目录下新建文件<code>.prettierrc</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;singleQuote&quot;: true,</span><br><span class="line">  &quot;printWidth&quot;: 120,</span><br><span class="line">  &quot;arrowParens&quot;: &quot;avoid&quot;,</span><br><span class="line">  &quot;trailingComma&quot;: &quot;none&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时Prettier根据<code>.prettierrc</code>定义的规则，对整个项目做了格式化操作。 但一些场景下需要我们对个别文件进行处理，可以通过覆盖配置来实现</p>
<h2 id="3、覆盖配置"><a href="#3、覆盖配置" class="headerlink" title="3、覆盖配置"></a>3、覆盖配置</h2><p>修改<code>.prettierrc</code>文件，添加<code>overrides</code>字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;semi&quot;: false,</span><br><span class="line">  &quot;overrides&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;files&quot;: &quot;*.test.js&quot;,</span><br><span class="line">      &quot;options&quot;: &#123;</span><br><span class="line">        &quot;semi&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;files&quot;: [&quot;*.html&quot;, &quot;legacy/**/*.js&quot;],</span><br><span class="line">      &quot;options&quot;: &#123;</span><br><span class="line">        &quot;tabWidth&quot;: 4</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样针对<code>test.js</code>文件、<code>html</code>文件和<code>legacy/**/*.js</code>的格式就会按当前配置走。</p>
<h2 id="4、共享配置"><a href="#4、共享配置" class="headerlink" title="4、共享配置"></a>4、共享配置</h2><p>项目的配置一般都不会变化，所以常常多个项目使用同一个配置，特别是针对大点的项目。</p>
<p>下面我们实践下创建一份Prettier配置到npm仓库</p>
<p>1、<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/" rel="external nofollow noopener noreferrer" target="_blank">注册npm账号</a></p>
<p>2、创建一个包、包的命名规则：<code>@prettier/plugin-</code> or <code>prettier-plugin-</code> or <code>@&lt;scope&gt;/prettier-plugin-</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ./config/prettier/prettier-plugin-frontdemo</span><br><span class="line">npm init</span><br><span class="line">mkdir .prettierrc</span><br><span class="line">yarn add -D prettier</span><br><span class="line">echo &quot;/node_modules&quot; &gt; .gitignore</span><br></pre></td></tr></table></figure>
<p>3、发布创建好的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果第一次发布需要创建</span><br><span class="line">npm adduser</span><br><span class="line"></span><br><span class="line"># 如果不是第一次发布，只需要登陆</span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line"># 发布</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/v2-60a66d1de84d7d2923ecc4275c06b780_r.jpg" alt></p>
<p>4、登陆npm官网，即可看到上传的包<code>prettier-plugin-frontdemo</code></p>
<p><img src="https://pic1.zhimg.com/v2-13cca03bdb697a92ed4557173729418c_r.jpg" alt></p>
<p>5、使用包，在<code>package.json</code>中，添加远程仓库地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;prettier&quot;: &quot;prettier -w src/*.js&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;name&quot;: &quot;front-demo&quot;,</span><br><span class="line">  &quot;prettier&quot;: &quot;prettier-plugin-frontdemo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、执行<code>yarn prettier</code></p>
<h2 id="5、忽略文件"><a href="#5、忽略文件" class="headerlink" title="5、忽略文件"></a>5、忽略文件</h2><p>如果想要忽略某个文件的格式化，可以新建文件<code>.prettierignore</code>，添加要忽略的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/dist</span><br><span class="line">*.html</span><br></pre></td></tr></table></figure>
<h2 id="四、代码质量检测：ESLint"><a href="#四、代码质量检测：ESLint" class="headerlink" title="四、代码质量检测：ESLint"></a>四、代码质量检测：ESLint</h2><h2 id="1、安装ESLint插件"><a href="#1、安装ESLint插件" class="headerlink" title="1、安装ESLint插件"></a>1、安装ESLint插件</h2><p><code>yarn add eslint -D</code></p>
<h2 id="2、新建配置文件"><a href="#2、新建配置文件" class="headerlink" title="2、新建配置文件"></a>2、新建配置文件</h2><p><code>yarn add eslint --init</code></p>
<p>上述命令行会弹出选择提示，根据需要选择eslint规则，最后会在根目录下生成<code>.eslintrc.js</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;es2021&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;,</span><br><span class="line">        &quot;plugin:react/recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">            &quot;jsx&quot;: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ecmaVersion&quot;: &quot;latest&quot;,</span><br><span class="line">        &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;react&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>env: 包含了执行环境配置，浏览器环境、node环境或支持es5、es6.</li>
<li>extends: 使用的扩展配置，这里主要是引入一些集成好的检测规则</li>
<li>parseOptioins: 解析器配置</li>
<li>plugins: 引入的eslint插件</li>
<li>rules: 用来定义具体规则，检查缩进，函数是否有返回值等。</li>
</ul>
<p>第一个参数，如果只有一个参数，直接使用字符串或数字就可以了</p>
<ul>
<li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li>
<li><code>&quot;warn&quot;</code> 或 <code>1</code> - 开启规则，使用警告级别的错误：<code>warn</code> (不会导致程序退出，即可以正常提交代码)</li>
<li><code>&quot;error&quot;</code> 或 <code>2</code> - 开启规则，使用错误级别的错误：<code>error</code> (当被触发的时候，程序会退出，存在error告警不能提交代码)</li>
</ul>
<p>第二个参数：你想要的配置参数</p>
<ul>
<li><code>&quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]</code>，如果存在单引号的就报错，终止提交。</li>
<li><code>&quot;quotes&quot;: [&quot;warn&quot;, &quot;double&quot;]</code>，如果存在单引号就告警，但可以正常提交。</li>
</ul>
<p>ESLint的<a href="https://link.zhihu.com/?target=https%3A//cn.eslint.org/docs/rules/" rel="external nofollow noopener noreferrer" target="_blank">配置规则</a></p>
<p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn eslint src/*.js</span><br></pre></td></tr></table></figure>
<p>ESLint对代码进行了检测</p>
<p><img src="https://pic1.zhimg.com/v2-dfb5969183bbd13804b47e9c17009674_r.jpg" alt></p>
<p><strong>注意，如果项目根目录配置了<code>.eslintrc</code>, 那么package.json中配置了eslintConfig将不会生效</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;es2021&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">            &quot;jsx&quot;: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ecmaVersion&quot;: &quot;latest&quot;,</span><br><span class="line">        &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、覆盖ESLint配置"><a href="#3、覆盖ESLint配置" class="headerlink" title="3、覆盖ESLint配置"></a>3、覆盖ESLint配置</h2><p>我们看到不管是共享的配置还是使用官方推荐的配置，如果我们想要在这个基础上修改某个规则怎么办，使用overrides来覆盖，可以指定使用的范围。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;...&#125;,</span><br><span class="line">  &quot;overrides&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;files&quot;: [&quot;./src/*.js&quot;],</span><br><span class="line">      &quot;rules&quot;: &#123;</span><br><span class="line">          &quot;no-console&quot;: &quot;error&quot;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到no-console告警出来了。</p>
<p><img src="https://pic1.zhimg.com/v2-b73e3b7374bcdfed6bb053b3ee31af6c_r.jpg" alt></p>
<p><strong>其实ESLint还提供了创建规则，自定义解析器，编写插件的能力，下面我们主要实践下编写插件</strong></p>
<h2 id="4、共享配置-1"><a href="#4、共享配置-1" class="headerlink" title="4、共享配置"></a>4、共享配置</h2><blockquote>
<p>和Prettier一样，如果每个项目都配置一个太麻烦了，可以整体使用一套</p>
</blockquote>
<p>新建一个项目导出这个js文件，然后上传到npm，直接通过extends字段引用就可以了。发布流程和prettier是一样的，命名还要用eslint-config-开头。<a href="https://link.zhihu.com/?target=https%3A//cn.eslint.org/docs/developer-guide/shareable-configs" rel="external nofollow noopener noreferrer" target="_blank">官网</a></p>
<p><img src="https://pic4.zhimg.com/v2-57c1fb15f72a7a4bc14133587b3f88a7_r.jpg" alt></p>
<p>安装<code>yarn add -D eslint-config-frontdemo</code></p>
<p>修改<code>package.json</code>（修改.eslintrc.js文件也是一样的，这里用了package.json的配置，所以根目录下的.eslintrc.js要删除掉）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;eslint&quot;: &quot;eslint . --fix&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;eslintConfig&quot;: &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;browser&quot;: true,</span><br><span class="line">      &quot;node&quot;: true,</span><br><span class="line">      &quot;es2021&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: &quot;frontdemo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>yarn eslint</code>，成功</p>
<p><img src="https://pic3.zhimg.com/v2-1016e91d71033bc9d2aec41b6b9b143a_r.jpg" alt></p>
<h2 id="五、Git暂存区代码过滤：lint-staged"><a href="#五、Git暂存区代码过滤：lint-staged" class="headerlink" title="五、Git暂存区代码过滤：lint-staged"></a>五、Git暂存区代码过滤：lint-staged</h2><p>在实际使用过程，会遇到这样的问题：</p>
<ul>
<li>每次都要全局处理代码，浪费时间</li>
<li>每个人对所有代码格式化，规则不同，导致大量代码冲突</li>
</ul>
<blockquote>
<p>lint-staged，仅过滤Git暂存区的代码</p>
</blockquote>
<p>1、安装lint-staged</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add lint-staged -D</span><br></pre></td></tr></table></figure>
<p>2、<code>package.json</code>配置lint-staged</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">      &quot;*.js&quot;: &quot;prettier -w .&quot;,</span><br><span class="line">      &quot;*.js&quot;: &quot;eslint . --fix&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改业务代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;test lint-staged&quot;</span><br></pre></td></tr></table></figure>
<p>此时发现，这些命令仅对暂存区<code>*.js</code>的内容进行了格式化。</p>
<h2 id="六、Git提交规范自动化"><a href="#六、Git提交规范自动化" class="headerlink" title="六、Git提交规范自动化"></a>六、Git提交规范自动化</h2><h2 id="1、规范说明"><a href="#1、规范说明" class="headerlink" title="1、规范说明"></a>1、规范说明</h2><blockquote>
<p>如图所示，我们看到优秀的开源项目，对提交代码的描述信息都是很规范的。想要和这些项目一样清晰，我们可以借助插件commitlint</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/v2-2ecdb0297c762bfa6f81b56ab5ddd92b_r.jpg" alt></p>
<p>在此之前我们要了解常用的Git提交规范</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Subject 一句话概述commit主题(必须)</span><br><span class="line">&lt;Body&gt; 详细描述 What 和 Why (可选)</span><br><span class="line">&lt;Footer&gt; 不兼容或关闭 issue 等说明(可选)</span><br><span class="line"></span><br><span class="line">主题(Subject)是 commit 的简短描述，不超过50个字符</span><br><span class="line">- 用一句话说明本次所作的提交, 如果一句话说不清楚，那有可能这个提交得拆分成多次</span><br><span class="line">- 主要采用 Verb + Object + Adverb 的形式描述，常见动词及示例如下</span><br><span class="line">1. feat: 添加代码和逻辑, 如 feat: add xxx field/method/class</span><br><span class="line">2. fix: 修复bug，如 fix: #123, fix xxx error</span><br><span class="line">3. docs: 文档更新，如 docs: change documents</span><br><span class="line">4. style: 样式修改，如 style: add class or change style</span><br><span class="line">5. refactor: 代码重构, 如refactor: rename, move, extract, inline等</span><br><span class="line">6. perf: 代码性能优化，perf: improves performance</span><br><span class="line">7. test: 代码单元测试，test: test menu component</span><br><span class="line">8. build: 项目构建，build: build project</span><br><span class="line">9. ci: 修改CI文件 ci: change gitlab-ci.yml</span><br><span class="line">10. chore: 构建过程或辅助工具的变动 chore: change webpack</span><br><span class="line"></span><br><span class="line">正文(Body)详细描述本次 commit 做了什么、为什么这样做(不是怎么做的)</span><br><span class="line">- 每行不要超过70字符</span><br><span class="line">1. 这个改动解决了什么问题？</span><br><span class="line">2. 这个改动为什么是必要的？</span><br><span class="line">3. 会影响到哪些其他的代码？</span><br><span class="line">  bug fix - 组件 bug 修复；</span><br><span class="line">  breaking change - 不兼容的改动；</span><br><span class="line">  new feature - 新功能</span><br><span class="line"></span><br><span class="line">尾注(Footer) 用于关闭 Issue 或存在不兼容时添加相关说明等</span><br><span class="line">1. breaking change: 与上一个版本不兼容的相关描述、理由及迁移办法</span><br><span class="line">2. close #issue: 关闭相关问题（附链接）</span><br><span class="line">3. revert: 撤销以前的commit</span><br></pre></td></tr></table></figure>
<p>比如我们修改了一个列表Bug：<code>git commit -m &quot;bug: change id columns&quot;</code>，这样我们后面查询起来就很简单了。</p>
<h2 id="2、提交信息规范配置：commitlint"><a href="#2、提交信息规范配置：commitlint" class="headerlink" title="2、提交信息规范配置：commitlint"></a>2、提交信息规范配置：commitlint</h2><p>安装commitlint-cli和commitlint常用配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd font-demo</span><br><span class="line"></span><br><span class="line">yarn add @commitlint/cli @commitlint/config-conventional -D</span><br><span class="line"></span><br><span class="line">touch .commitlint.config.js</span><br></pre></td></tr></table></figure>
<p>.commitlint.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;commitlint&quot;: &#123;</span><br><span class="line">    extends: [</span><br><span class="line">      &apos;@commitlint/config-conventional&apos;</span><br><span class="line">    ],</span><br><span class="line">    rules: &#123;</span><br><span class="line">      &apos;type-enum&apos;: [2, &apos;always&apos;, [</span><br><span class="line">        &apos;feat&apos;, &apos;fix&apos;, &apos;perf&apos;, &apos;refactor&apos;, &apos;build&apos;, &apos;style&apos;, &apos;docs&apos;, &apos;chore&apos;</span><br><span class="line">      ]],</span><br><span class="line">      &apos;type-case&apos;: [0]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@commitlint/config-conventional</code>默认使用这个提交规范</p>
<p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;this is a new feature&quot; | commitlint</span><br><span class="line">echo &quot;feat: this is a new feature&quot; | commitlint</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/v2-e32cb82dc6482ac7307dc6f1e1ec7894_r.jpg" alt></p>
<p>commitlint用来检测Git提交信息是否规范。</p>
<h2 id="3、通过插件来规范提交信息"><a href="#3、通过插件来规范提交信息" class="headerlink" title="3、通过插件来规范提交信息"></a>3、通过插件来规范提交信息</h2><p><strong>虽然我们按照格式提交没有问题，但是很多时候，可能记不住这些命令，我们可以弹出提示信息进行交互式提交</strong></p>
<p>安装依赖<code>@commitlint/cz-commitlint</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add -D @commitlint/cz-commitlint commitizen @commitlint/cli @commitlint/config-conventional</span><br></pre></td></tr></table></figure>
<p>在package.json中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;commit&quot;: &quot;git add . &amp;&amp; git-cz&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;commitizen&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;@commitlint/cz-commitlint&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目根目录下新建文件<code>[commitlint.config.js](https://link.zhihu.com/?target=https%3A//github.com/richLpf/auto-format-demo/blob/main/commitlint.config.js)</code></p>
<p>修改业务代码，并执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn commit</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/v2-0917abb993006cae52e11c90d05913b0_r.jpg" alt></p>
<p>就可以通过选择来提交代码了。</p>
<h2 id="4、一键执行自动化工具"><a href="#4、一键执行自动化工具" class="headerlink" title="4、一键执行自动化工具"></a>4、一键执行自动化工具</h2><p>以上<code>prettier</code>、<code>esliint</code>、<code>lint-staged</code>、<code>commitlint</code>都配置在package.json中，通过命令<code>yarn commit</code>按顺序执行这些工具。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;prettier&quot;: &quot;prettier -w .&quot;,</span><br><span class="line">    &quot;commit&quot;: &quot;git add . &amp;&amp; lint-staged &amp;&amp; git-cz&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prettier&quot;: &quot;@isayme/prettier-config&quot;,</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;commitizen&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;@commitlint/cz-commitlint&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslintConfig&quot;: &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;browser&quot;: true,</span><br><span class="line">      &quot;node&quot;: true,</span><br><span class="line">      &quot;es2021&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: &quot;eslint:recommended&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">    &quot;*.js&quot;: [</span><br><span class="line">      &quot;eslint . --fix&quot;,</span><br><span class="line">      &quot;prettier -w .&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>配置完成后，修改业务代码，执行<code>yarn commit</code>，发现对Git暂存区的文件依次进行了<code>ESLint检测</code>、<code>prettier</code>、<code>commitlint录入</code>，这就完成了简单的自动化工作流。</p>
<p>然而这种方法把git的命令覆盖了，而且可能很多人不想要每次都通过提示提交信息，那么下面我们接着看，如何通过Hooks处理自动化工作流。</p>
<h2 id="七、Git-Hooks"><a href="#七、Git-Hooks" class="headerlink" title="七、Git Hooks"></a>七、Git Hooks</h2><h2 id="1、Git-Hooks介绍"><a href="#1、Git-Hooks介绍" class="headerlink" title="1、Git Hooks介绍"></a>1、Git Hooks介绍</h2><p>要自动化上面的流程，就要用到Git的钩子函数Hooks。</p>
<p>Git Hooks通过一个个钩子，允许Git在每个节点执行一些shell脚本，如果哪个阶段有问题，就会抛出错误，拒绝提交代码。</p>
<p>常见的Git 钩子：</p>
<p><strong>客户端钩子</strong>：</p>
<ul>
<li><code>pre-commit</code>，输入git commit调出提交信息编辑器之前，主要用来代码格式，代码检测、单元测试等。</li>
<li><code>prepare-commit-msg</code> git commit编辑器启动提交信息之前，默认信息被创建之后，主要编辑提交信息</li>
<li><code>commit-msg</code> git commit 信息提交，用来检查提交信息的格式。</li>
<li><code>post-commit</code> 在提交完成后，可以用来发送通知，提醒其他同事等。</li>
</ul>
<p><strong>服务器端钩子</strong>：</p>
<ul>
<li><code>pre-receive</code>：客户端推送代码到服务器时，只会触发一次</li>
<li><code>update</code>：客户端推送代码到服务器，如果多个分支，分别触发一次</li>
<li><code>post-receive</code>：推送完成后。</li>
</ul>
<p>整个钩子触发的时间点可以理解为：在网站上打开一个弹框输入信息，提交信息，关闭弹框的过程</p>
<ul>
<li>1、点击新建按钮，弹框弹出前（pre-commit）</li>
<li>2、弹框获取初始模版信息后（prepare-commit-msg）</li>
<li>3、编辑信息以后，点击提交时（commit-msg），这时可以对提交的信息进行检测</li>
<li>4、点击保存信息完成（post-commit）</li>
</ul>
<h2 id="2、Git-Hooks实践"><a href="#2、Git-Hooks实践" class="headerlink" title="2、Git Hooks实践"></a>2、Git Hooks实践</h2><p>安装Git(默认本地安装了Git)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd front-demo</span><br><span class="line">git init</span><br><span class="line">ls -al</span><br><span class="line">cd .git</span><br><span class="line">cd hooks</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/v2-7670b8f0850038d1375abfbcb08f96c0_r.jpg" alt></p>
<p>Git Hooks每个钩子都有示例文件，这些是git预置的hooks脚本示例，因为加了sample后缀，所以并不会被执行。</p>
<p>我们在当前目录下新建<code>pre-commit</code>脚本，文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">echo &quot;this is a test file&quot;</span><br></pre></td></tr></table></figure>
<p>回到项目根目录下，修改项目内任意文件，提交代码，发现成功提交，但是有告警。</p>
<p><img src="https://pic4.zhimg.com/v2-52982af26f0a01c2d68ff4a94689f2df_r.jpg" alt></p>
<p>因为<code>pre-commit</code>没有执行权限，我们给文件执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x pre-commit</span><br></pre></td></tr></table></figure>
<p>然后再次提交代码，发现git commit后，打印出了<code>this is a test file</code>，我们写在<code>.git/hooks/pre-commit</code>中的代码，这就说明Git Hooks触发了。</p>
<h2 id="3、Husky实践"><a href="#3、Husky实践" class="headerlink" title="3、Husky实践"></a>3、Husky实践</h2><p>Hooks需要更改.git下的配置，非常不方便，所以有了Husky，将Hooks暴露在项目中。</p>
<blockquote>
<p>安装Git Hooks，husky v4版本可以在package.json中配置，v5版本后，husky就独立在项目根目录下配置，这里使用的是<code>7.0.4</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装husky</span><br><span class="line">yarn add husky -D</span><br><span class="line"></span><br><span class="line"># 激活husky的使用</span><br><span class="line">yarn husky install</span><br></pre></td></tr></table></figure>
<p>4.x.x版本在package.json中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">   &quot;hooks&quot;: &#123;</span><br><span class="line">      &quot;pre-commit&quot;: &quot;lint-staged&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.x.x版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加一个钩子脚本，检测Git提交信息规范</span><br><span class="line">yarn husky add .husky/commit-msg &apos;yarn commitlint --edit $1&apos;</span><br></pre></td></tr></table></figure>
<p>我们看到在项目根目录下，生成了.husky文件夹，下面有Hooks相关的脚本。</p>
<p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;264&#39; height=&#39;310&#39;&gt;&lt;/svg" alt></p>
<p><strong>这里不光可以使用shell脚本，用node、python脚本都可以。</strong></p>
<p>提交代码，发现如果没有按标准格式，就会被拦截。</p>
<p><img src="https://pic3.zhimg.com/v2-141a6e22bc6fb8a1606cdff79a9ae18a_r.jpg" alt></p>
<h2 id="4、通过Husky自动化规范"><a href="#4、通过Husky自动化规范" class="headerlink" title="4、通过Husky自动化规范"></a>4、通过Husky自动化规范</h2><p><code>pre-commit</code>钩子：prettier和eslint检测代码格式和代码质量</p>
<p><code>commit-msg</code>钩子：执行commitlint，检测提交信息是否符合格式</p>
<p>首先安装这两个钩子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn husky add .husky/pre-commit &apos;yarn lint-staged --allow-empty&apos;</span><br><span class="line">yarn husky add .husky/commit-msg &apos;yarn commitlint --edit $1&apos;</span><br></pre></td></tr></table></figure>
<p>这里lint-staged 添加允许空提交是为了避免报错<a href="https://link.zhihu.com/?target=https%3A//github.com/okonet/lint-staged/issues/588" rel="external nofollow noopener noreferrer" target="_blank">lint-staged issues</a></p>
<p><img src="https://pic4.zhimg.com/v2-163ae034454e81601e2c9cd256c629a7_r.jpg" alt></p>
<p>然后改动代码src/index.js</p>
<p><img src="https://pic4.zhimg.com/v2-17027c2a3b56f5c9600ff4900c651ebb_r.jpg" alt></p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;test&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/v2-81da88c8b29f34f429cc7f69af985739_r.jpg" alt></p>
<p>发现检测出了不符合eslint规范的编码。</p>
<p><img src="https://pic4.zhimg.com/v2-5ff314138f71a3fb5454833514f70683_r.jpg" alt></p>
<p>修复eslint错误，再次提交，发现报错提交信息不规范，但代码已经格式化过了。</p>
<p><img src="https://pic3.zhimg.com/v2-7068b73ac7133c9a9631f0b57dbb419a_r.jpg" alt></p>
<p>修改提交信息，Ok大功告成，成功提交。</p>
<p><img src="https://pic1.zhimg.com/v2-2f55e05d895bd2b164fccc71e4216aa0_r.jpg" alt></p>
<h2 id="八、通过CI自动化检测代码"><a href="#八、通过CI自动化检测代码" class="headerlink" title="八、通过CI自动化检测代码"></a>八、通过CI自动化检测代码</h2><p>之前介绍的是，本地提交代码的自动化检测。</p>
<p>那么并不是每个开发都会去注意这一块，针对提交上线的代码，除了服务器端钩子来检测，还可以通过CI/CD来检测。这块的工具也很多，常用的有：Gitlab/CI、Github/Action。</p>
<p>这里我们选择Github/Action</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd front-demo</span><br><span class="line">mkdir -p .github/workflows</span><br><span class="line">touch github-action.yml</span><br></pre></td></tr></table></figure>
<p><code>github-action.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: GitHub Actions Demo</span><br><span class="line">on: [push]</span><br><span class="line">jobs:</span><br><span class="line">  eslint:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v2</span><br><span class="line">      - uses: actions/setup-node@v2</span><br><span class="line">      - run: yarn install</span><br><span class="line">      - run: yarn eslint . --fix</span><br><span class="line">      </span><br><span class="line">  prettier:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v2</span><br><span class="line">      - uses: actions/setup-node@v2</span><br><span class="line">      - run: echo &quot;check current commit is prettier&quot;</span><br><span class="line">      - run: yarn install</span><br><span class="line">      - run: yarn prettier:check</span><br></pre></td></tr></table></figure>
<p>每次推送都执行下面两个任务</p>
<ul>
<li>执行eslint校验</li>
<li>执行prettier检查</li>
</ul>
<p>修改front-demo项目下的<code>package.json</code>，运行命令检查是否Prettier格式化</p>
<p><img src="https://pic1.zhimg.com/v2-0b877391a97c36e7caf06e493f68dee8_r.jpg" alt></p>
<p>直接提交代码，推送Github，打开<a href="https://link.zhihu.com/?target=https%3A//github.com/richLpf/auto-format-demo/actions/runs/1979731289" rel="external nofollow noopener noreferrer" target="_blank">Action页面</a></p>
<p><img src="https://pic4.zhimg.com/v2-289867bdddd3baff8daded17d1e9ee83_r.jpg" alt></p>
<p>两个任务执行成功</p>
<p>接着注释掉本地钩子执行的 eslint和prettier，修改代码提交到远程仓库（故意打乱）</p>
<p><img src="https://pic4.zhimg.com/v2-20392b8d0a03fa7ca678459878eec6eb_r.jpg" alt></p>
<p>打开Action页面，发现任务都失败了，并且提示除了错误信息。</p>
<p><img src="https://pic3.zhimg.com/v2-7a2798a19fb02131e0642387c80be2b6_r.jpg" alt></p>
<p>如果任务执行成功，就可以继续执行构建，部署，打包文件检测等。</p>
<p>当然也可以在这个阶段，增加单元测试，代码分析等操作。</p>
<h2 id="九、参考文章"><a href="#九、参考文章" class="headerlink" title="九、参考文章"></a>九、参考文章</h2><ul>
<li><a href="https://link.zhihu.com/?target=https%3A//www.prettier.cn/docs/index.html" rel="external nofollow noopener noreferrer" target="_blank">Prettier</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//cn.eslint.org/docs/user-guide/getting-started" rel="external nofollow noopener noreferrer" target="_blank">ESLint</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/lint-staged" rel="external nofollow noopener noreferrer" target="_blank">lint-staged</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//commitlint.js.org/%23/" rel="external nofollow noopener noreferrer" target="_blank">commitlint</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//typicode.github.io/husky/%23/%3Fid%3Dusage" rel="external nofollow noopener noreferrer" target="_blank">Husky</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//docs.github.com/cn/actions/quickstart" rel="external nofollow noopener noreferrer" target="_blank">Github/Action</a></li>
</ul>
<p>欢迎加入讨论，如果觉得还不错，给个赞吧</p>
<p>本文转自 <a href="https://zhuanlan.zhihu.com/p/487898449" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/487898449</a>，如有侵权，请联系删除。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>git中版本回退的各种方式</title>
    <url>/2022/12/30/git%E4%B8%AD%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>git</code>作为一款版本控制工具，其最核心的功能就是版本回退，没有之一。熟悉<code>git</code>版本回退的操作能够让你真真正正地放开手脚去开发，不用小心翼翼，怕一不小心删除了不该删除的文件。本节除了介绍版本回退的内容之外，还会介绍<code>stash</code>的使用。<a id="more"></a></p>
<h2 id="一、版本回退"><a href="#一、版本回退" class="headerlink" title="一、版本回退"></a>一、版本回退</h2><p>在<code>git</code>中永远有后悔药可吃，总是可以回到<strong>版本库</strong>的某一个时刻，这就叫做<strong>版本回退</strong>；</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301100124.image" alt="image-20200406144058526"></p>
<p>如上图所示：当前<code>master</code>分支指针指向<code>D</code>，通过版本回退可以使<code>master</code>指向<code>C</code>、<code>B</code>或<code>A</code>。进行版本回退的命令大体上有三种：<code>reset</code>、<code>revert</code>和<code>checkout</code>。下面就来一一讲解：</p>
<h3 id="Ⅰ-git-reset"><a href="#Ⅰ-git-reset" class="headerlink" title="Ⅰ.git reset"></a>Ⅰ.<code>git reset</code></h3><h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h4><p><code>reset</code>命令可以添加很多参数，常用的有<code>--mixed</code>、<code>--soft</code>和<code>--hard</code>三种。下图为一次完整提交的四个阶段：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301100185.image" alt="image-20200412192613526"></p>
<p>三个参数大体上的区别为：</p>
<ul>
<li><code>--mixed</code>：为默认值，等同于<code>git reset</code>。作用为：将文件回退到<strong>工作区</strong>，此时会保留<strong>工作区</strong>中的文件，但会丢弃<strong>暂存区</strong>中的文件；</li>
<li><code>--soft</code>：作用为：将文件回退到<strong>暂存区</strong>，此时会保留<strong>工作区</strong>和<strong>暂存区</strong>中的文件；</li>
<li><code>--hard</code>：作用为：将文件回退到<strong>修改前</strong>，此时会丢弃<strong>工作区</strong>和<strong>暂存区</strong>中的文件；</li>
</ul>
<p>下面就来详细地讲解它们的使用方法：</p>
<p>首先在<code>master</code>分支进行四次提交，每次提交在<code>test.txt</code>中添加一行文本信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301100462.image" alt="image-20200406164503683"></p>
<h5 id="mixed"><a href="#mixed" class="headerlink" title="--mixed"></a><code>--mixed</code></h5><p>该参数为默认值，作用为：将文件回退到工作区中：如下图所示，将<code>test.txt</code>文件回退一次提交：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301100251.image" alt="image-20200412194811197"></p>
<p>可以看到第四次提交对<code>test.txt</code>的修改操作被回退到了工作区当中，并且保留了工作区中第四次提交对<code>test.txt</code>所做的修改，所以工作区中的<code>test.txt</code>文件内容与回退前一致。</p>
<h5 id="soft"><a href="#soft" class="headerlink" title="--soft"></a><code>--soft</code></h5><p>该参数的作用为：将文件回退到暂存区中：如下图所示，将<code>test.txt</code>文件回退一次提交：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301100965.image" alt="image-20200412195321082"></p>
<p>可以看到第四次提交对<code>test.txt</code>的修改操作被回退到了暂存区当中，并且保留了工作区和暂存区中第四次提交对<code>test.txt</code>所做的修改，所以，工作区中的文件内容与回退前一致。</p>
<h5 id="hard"><a href="#hard" class="headerlink" title="--hard"></a><code>--hard</code></h5><p>该参数的作用为：将文件回退到修改前：如下图所示，将<code>test.txt</code>文件回退一次提交：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101322.image" alt="image-20200412205112201"></p>
<p>可以看到<code>test.txt</code>直接回到了进行第四次提交前，此时删除了工作区和暂存区中第四次提交对<code>test.txt</code>所做的修改。所以，工作区变得干净了，<code>test.txt</code>文件内容回退到刚完成第三次提交时。</p>
<h4 id="2-写法"><a href="#2-写法" class="headerlink" title="2.写法"></a>2.写法</h4><p>为了方便演示<code>reset</code>的各种使用方法，下面的指令都采用<code>--hard</code>参数。</p>
<h5 id="git-reset-hard-HEAD"><a href="#git-reset-hard-HEAD" class="headerlink" title="git reset --hard HEAD^"></a><code>git reset --hard HEAD^</code></h5><p><strong>该命令的作用为回退一次提交：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101863.image" alt="image-20200406164628192"></p>
<p>回退后的状态为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101780.image" alt="image-20200406164713774"></p>
<p>可以看到，该方法会同时改变了<code>HEAD</code>和<code>master</code>指针的指向；</p>
<h5 id="git-reset-hard-HEAD-1"><a href="#git-reset-hard-HEAD-1" class="headerlink" title="git reset --hard HEAD^^"></a><code>git reset --hard HEAD^^</code></h5><p><strong>该命令的作用为回退两次提交：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101325.image" alt="image-20200406170323254"></p>
<p>回退后的状态为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101015.image" alt="image-20200406170352024"></p>
<p>同样，使用<code>--hard</code>参数回退，工作区是干净的；可以看到，该方法也会同时改变<code>HEAD</code>和<code>master</code>指针的指向；</p>
<h5 id="git-reset-hard-HEAD-n"><a href="#git-reset-hard-HEAD-n" class="headerlink" title="git reset --hard HEAD~n"></a><code>git reset --hard HEAD~n</code></h5><p><strong>该命令的作用为回退<code>n</code>次提交：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101546.image" alt="image-20200406203027868"></p>
<p>可以看到使用了<code>--hard</code>参数，回退结果符合预期，并且该方法也会同步修改<code>HEAD</code>和分支<code>master</code>指针的指向。</p>
<p><strong>注意：该方式只能向前回退，不能向后回退</strong>。</p>
<blockquote>
<p>上述命令中的<code>HEAD</code>可以更换为分支名，比如<code>master</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; git reset --hard master~n</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>该命令表示将<code>master</code>分支回退<code>n</code>次提交。由于<code>HEAD</code>始终指向当前分支，所以使用分支名和使用<code>HEAD</code>效果是一样的。</p>
</blockquote>
<h5 id="git-reset-hard-commit-id"><a href="#git-reset-hard-commit-id" class="headerlink" title="git reset --hard commit_id"></a><code>git reset --hard commit_id</code></h5><p>**该指令的作用为回退到指定的<code>commit id</code>的提交版本；<strong>由于<code>commit id</code>是不会重复的，一般只需要写前几（<code>6</code>）位就可以识别出来。通过<code>commit id</code>的回退方式</strong>既可以向前回退，也可以向后回退。**如下所示，从<code>1st commit</code>往后回退到<code>4th commit</code>，其中<code>4th commit</code>的<code>commit id = bdb373...</code>。</p>
<p>为了熟悉该指令，我们分两种方式进行回退：使用<code>--hard</code>参数与使用默认参数。</p>
<ul>
<li><p><strong>使用<code>--hard</code>参数</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102731.image" alt="image-20200406193422130"></p>
<p>从图中可以看出：通过第四次提交的<code>commit_id: bdb373</code>顺利地从第一次提交向后回退到了第四次提交，并且工作区干净。该方法也同时修改了<code>HEAD</code>和分支<code>master</code>的指向，具体过程为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102485.image" alt="image-20200414171228274"></p>
</li>
<li><p><strong>使用默认参数</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102009.image" alt="image-20200406193005200"></p>
<p>可以看到切换回了<code>4th commit</code>，但是工作区的<code>test.txt</code>文件并没有变化；这是因为，在<code>4th -&gt; 1st</code>的过程中，需要在工作区中删除<code>test.txt</code>文件中的<code>2nd line、3rd line、4th line</code>。通过默认参数<code>--mixed</code>，将<code>4th commit</code>对文件的修改回退到了工作区当中，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102806.image" alt="image-20200406202451310"></p>
<p>这个过程丢弃了<strong>暂存区</strong>中对文件的删除操作，但是保留了<strong>工作区</strong>中对文件的删除操作。所以，工作区中的<code>test.txt</code>文件仍然处于删除了三行内容的状态。</p>
<p>此时只需要将修改操作从阶段<code>1</code>移动到修改前的阶段<code>0</code>，即可将文件恢复到修改前的状态，并清空工作区。可以采用<code>git restore test.txt</code>实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102098.image" alt="image-20200406202716247"></p>
</li>
</ul>
<h3 id="Ⅱ-git-revert"><a href="#Ⅱ-git-revert" class="headerlink" title="Ⅱ.git revert"></a>Ⅱ.<code>git revert</code></h3><p><code>revert</code>是回滚，重做的意思。不同于<code>reset</code>直接通过改变分支指向来进行版本回退，并且不产生新的提交；<code>revert</code>是通过额外创建一次提交，来取消分支上指定的某次提交的方式，来实现版本回退的。如下图所示，假如想要重做提交<code>B</code>，重做前与重做后的状态为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102830.image" alt="image-20200413234440432"></p>
<p>所谓重做提交<code>B</code>，指的是在新建的提交<code>B&#39;</code>中取消提交<code>B</code>中所做的一切操作。也就是说<code>revert</code>的思想为：通过创建一个新提交来取消不要的提交。所以，提交数会增加。</p>
<h4 id="1-参数-1"><a href="#1-参数-1" class="headerlink" title="1.参数"></a>1.参数</h4><p><code>git</code>同样为<code>revert</code>提供了许多参数，常用的有以下三种。为了演示它们的作用，首先需要设置对应的测试环境：在<code>dev</code>分支上进行四次提交，每次提交都为<code>test.txt</code>添加一行内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102855.image" alt="image-20200414000404304"></p>
<h5 id="e"><a href="#e" class="headerlink" title="-e"></a><code>-e</code></h5><p><code>-e</code>参数是<code>--edit</code>的缩写，为<code>revert</code>指令的默认参数，即<code>git revert -e</code>等同于<code>git revert</code>。该参数的作用为在重做过程中，新建一次提交的同时编辑提交信息。比如通过以下命令重做上述的<code>dev2</code>提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert f4a95</span><br></pre></td></tr></table></figure>
<p>执行该指令后会创建一次新的提交来取消提交<code>dev2</code>所做的一切操作，并且会进入<code>vim</code>编辑器，编辑新提交的提交注释：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301103107.image" alt="image-20200414115052089"></p>
<p>如下图所示，提交<code>dev2</code>为文件<code>test.txt</code>添加的<code>dev2</code>文本被取消了，并且<code>dev</code>分支上多了一次提交：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301103439.image" alt="image-20200414114945783"></p>
<h5 id="no-edit"><a href="#no-edit" class="headerlink" title="--no-edit"></a><code>--no-edit</code></h5><p>该参数的作用为不编辑由于<code>revert</code>重做，所新增提交的注释信息。如下图所示，通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert --no-edit f4a95b</span><br></pre></td></tr></table></figure>
<p>重做提交<code>dev2</code>的过程中，并不会进入<code>vim</code>编辑器编辑新增提交的注释信息，而是采用默认的注释信息：<code>Revert &quot;dev2&quot;</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301103973.image" alt="image-20200414114748865"></p>
<h5 id="n"><a href="#n" class="headerlink" title="-n"></a><code>-n</code></h5><p><code>-n</code>参数是<code>--no-commit</code>的简写形式，作用为对<code>revert</code>重做某次提交时所产生的修改，不进行提交，也就是不会新增一次提交；</p>
<p>如下图所示，这是<code>revert</code>指令通过新建提交<code>B&#39;</code>来取消提交<code>B</code>的过程，分为<code>0~4</code>个阶段。不添加<code>-n</code>参数时，<code>revert</code>指令会产生一次额外提交<code>B&#39;</code>，此时处于下图中的第<code>3</code>阶段。而使用<code>-n</code>参数时，虽然<code>revert</code>指令也会通过新建提交<code>B&#39;</code>来重做提交<code>B</code>。但是，此时还处于生成提交<code>B&#39;</code>的过程，还没有完全生成提交<code>B&#39;</code>，也就是处于下图中的第<code>2</code>阶段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301103671.image" alt="image-20200414002942670"></p>
<p>这种做法的好处是，允许我们干涉<code>revert</code>重做过程，手动进行提交。如下图所示，通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert -n f4a95</span><br></pre></td></tr></table></figure>
<p>重做提交<code>dev2</code>的过程中，手动暂停了重做过程。虽然提交<code>dev2</code>对<code>test.txt</code>所做的修改已被撤销，但是这一重做操作还未进行提交：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301103050.image" alt="image-20200414120436217"></p>
<p>这样我们既可以修改重做过程中不满意的地方，也可以随意添加注释。修改完后，通过手动提交的方式，完成重做（<code>REVERTING</code>）操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301104376.image" alt="image-20200414121147251"></p>
<h4 id="2-写法-1"><a href="#2-写法-1" class="headerlink" title="2.写法"></a>2.写法</h4><p><code>revert</code>指令也有多种写法，下面介绍主要的几种。为了方便演示，下列指令都采用默认参数<code>-e</code>手动编辑每次新增提交的注释信息。</p>
<h5 id="git-revert-commit-id"><a href="#git-revert-commit-id" class="headerlink" title="git revert commit_id"></a><code>git revert commit_id</code></h5><p>这是最常用的写法，通过<code>commit_id</code>精准地选择想要重做的提交。分两种情况：</p>
<ul>
<li><p>**情况一：**重做最新一次提交，不会发生冲突。</p>
<p>例如：通过以下指令，重做<code>dev</code>分支上最新的一次提交<code>dev2</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert f4a95b</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>首先进入`vim`编辑器编辑新增提交的注释信息：

![image-20200414135326937](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301104770.image)

随后完成重做操作，如下图所示；可见提交`dev2`给`test.txt`添加的`dev2`内容被删除了，并且多出一次提交，说明重做成功：

![image-20200414140040443](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301104069.image)
</code></pre><ul>
<li><p>**情况二：**重做非最新一次提交，会发生冲突。</p>
<p>例如：通过以下指令，重做<code>dev</code>分支上的第三次提交<code>dev1</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert dbde45</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>会出现合并冲突：

![image-20200414140502098](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301104296.image)

使用`git mergetool`指令，通过`vim`编辑器的工具`vimdiff`显示冲突文件`test.txt`：

![image-20200414140645448](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301104090.image)

回车进入`vim`编辑器界面，解决冲突：

![image-20200414141354304](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105846.image)

解决冲突之后，手动进行一次提交，完成`revert`过程：

![image-20200414142323103](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105788.image)
</code></pre><ul>
<li><p><strong>为什么会出现冲突？</strong></p>
<p>通过上面的例子不难看出，<code>revert</code>操作生成的<strong>新提交其实是通过两次提交合并而成</strong>的。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105796.image" alt="image-20200414143430837"></p>
<ul>
<li>首先，将被重做的提交<code>dev1</code>的前一次提交<code>2nd</code>复制一份，即图中的<code>2nd&#39;</code>；</li>
<li>然后，将它与当前分支的最新提交<code>dev2</code>进行合并，由此生成<code>revert</code>操作新增的提交；</li>
</ul>
<p>知道了<code>revert</code>操作新增的提交的由来后，就不难解释为什么会出现合并冲突了，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105276.image" alt="image-20200414144109389"></p>
<p>合并的两次提交中，文件<code>test.txt</code>的内容不一样。<code>git</code>不知道以哪个版本为准，自然会导致自动合并失败，需要手动合并。</p>
</li>
</ul>
<h5 id="git-revert-HEAD"><a href="#git-revert-HEAD" class="headerlink" title="git revert HEAD"></a><code>git revert HEAD</code></h5><p>该指令的作用为重做所在分支的最新一次提交，并且不会发生冲突：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105655.image" alt="image-20200414150640086"></p>
<h5 id="git-revert-HEAD-1"><a href="#git-revert-HEAD-1" class="headerlink" title="git revert HEAD^"></a><code>git revert HEAD^</code></h5><p>该指令的作用为重做所在分支的倒数第二次提交，会发生冲突，需要手动合并，完成重做操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105229.image" alt="image-20200414151002143"></p>
<h5 id="git-revert-HEAD-2"><a href="#git-revert-HEAD-2" class="headerlink" title="git revert HEAD^^"></a><code>git revert HEAD^^</code></h5><p>该指令的作用为重做所在分支的倒数第三次提交，会发生冲突，需要手动合并，完成重做操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106374.image" alt="image-20200414180953703"></p>
<h5 id="git-revert-HEAD-n"><a href="#git-revert-HEAD-n" class="headerlink" title="git revert HEAD~n"></a><code>git revert HEAD~n</code></h5><p>该指令的作用为重做所在分支的倒数第<code>n+1</code>次提交，会发生冲突，需要手动合并，完成重做操作。过程与上述一致，这里就不再赘述了。</p>
<blockquote>
<p>**总结：**常用<code>git revert commit_id</code>这种方式。</p>
</blockquote>
<h4 id="3-撤销revert操作"><a href="#3-撤销revert操作" class="headerlink" title="3.撤销revert操作"></a>3.撤销<code>revert</code>操作</h4><p>思路很简单，再次通过<code>revert</code>操作取消上一次的<code>revert</code>操作（即所谓”负负得正”）。</p>
<p>操作前，<code>dev</code>分支上的提交记录和<code>test.txt</code>文件内容如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106645.image" alt="image-20200414153206034"></p>
<p>通过：<code>git revert --no-edit f4a95</code>重做提交<code>dev2</code>（<code>--no-edit</code>表示不修改新增提交的注释）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106538.image" alt="image-20200414153456451"></p>
<p>重做后，多了一次提交，并且<code>test.txt</code>文件中删除了<code>dev2</code>这一行内容。此时，可以通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert --no-edit 582d127</span><br></pre></td></tr></table></figure>
<p>重做上一次重做操作，以此达到取消上一次重做操作的目的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106590.image" alt="image-20200414153724455"></p>
<p>如上图所示，虽然多出了一次提交，但是<code>test.txt</code>文件中被删除的<code>dev2</code>内容被恢复了，这样就撤销了<code>revert</code>操作。</p>
<h3 id="Ⅲ-git-checkout"><a href="#Ⅲ-git-checkout" class="headerlink" title="Ⅲ.git checkout"></a>Ⅲ.<code>git checkout</code></h3><h4 id="1-git-checkout-commit-id"><a href="#1-git-checkout-commit-id" class="headerlink" title="1.git checkout commit_id"></a>1.<code>git checkout commit_id</code></h4><p>使用<code>checkout</code>可以进行版本回退，如直接使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout cb214</span><br></pre></td></tr></table></figure>
<p>回退到提交<code>3rd</code>，此时会出现如下提示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106736.image" alt="image-20200311111540863"></p>
<p>注意到，切换后<code>HEAD</code>指向的不再是<code>master</code>分支，而是<code>cb214...</code>即第三次提交，查看历史提交记录：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106205.image" alt="image-20200311111719389"></p>
<p>可看到只有<code>3</code>次提交，什么意思呢？如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106569.image" alt="image-20200412001646768"></p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107947.image" alt="image-20200311112656834"></p>
<p>通过<code>git checkout</code>让<code>HEAD</code>指针指向了第<code>3</code>次提交，可以将它想象为一个新的分支。但是却没有实际创建分支，即此时<code>head</code>指向的由提交<code>1~3</code>组成的<code>commit</code>对象链条处于游离状态；</p>
<p>接着，在<code>HEAD</code>还指向游离的提交节点<code>3</code>的基础上对文件做出新的修改：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107564.image" alt="image-20200311113237150"></p>
<ul>
<li>此时如果我们切换回<code>master</code>分支，会出现下列错误</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107178.image" alt="image-20200311113209483"></p>
<p>提示显示：如果没有保存就从游离的提交上切换到<code>master</code>分支，这一修改就会被<code>checkout</code>命令覆盖。我们可以在切换前进行一次提交操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107915.image" alt="image-20200311113625297"></p>
<p>此时的状态为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107738.image" alt="image-20200412002213790"></p>
<ul>
<li>在游离的<code>Commit</code>对象链中进行了一次提交之后，再次通过：<code>git checkout master</code>切换到<code>master</code>分支：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107243.image" alt="image-20200311114055018"></p>
<p>提示大意为：如果没有任何分支指向刚才在游离的<code>Commit</code>对象链中进行的提交，那么该提交就会被忽略。此时的状态如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108718.image" alt="image-20200412002655921"></p>
<p>如果想要创建一个分支保存（指向）这条游离的<code>Commit</code>对象链，现在就是很好的时机。根据上述提示的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch mycommit  c4d5cc3</span><br></pre></td></tr></table></figure>
<p>创建指向<code>commit_id</code>为<code>c4d5cc3</code>的提交（即上述的提交节点<code>5</code>）的分支<code>mycommit</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108392.image" alt="image-20200311115117279"></p>
<p>由此游离的<code>commit</code>对象链得以被新分支所指向，并得到了保存，此时的状态如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108526.image" alt="image-20200412004042471"></p>
<blockquote>
<p><strong>总结：</strong></p>
<ul>
<li>通过<code>checkout</code>进行版本回退会造成游离的提交对象链，需要额外创建一个分支进行保存；</li>
<li>因此，使用<code>checkout</code>进行版本回退的思路为，先切换到想要回退的提交版本，再删除进行版本回退的分支<code>dev</code>。最后，创建一个新的<code>dev</code>分支指向游离的提交对象链，完成分支<code>dev</code>的版本回退，简称”偷天换日”；</li>
<li>只要有分支指向，提交就不会被丢弃。</li>
</ul>
</blockquote>
<h3 id="Ⅳ-revert与reset的选择"><a href="#Ⅳ-revert与reset的选择" class="headerlink" title="Ⅳ.revert与reset的选择"></a>Ⅳ.<code>revert</code>与<code>reset</code>的选择</h3><p>由于<code>checkout</code>会造成游离的提交对象链，所以，一般不使用<code>checkout</code>而是使用<code>reset</code>和<code>revert</code>进行版本回退：</p>
<ul>
<li><code>revert</code>通过创建一个新提交的方式来撤销某次操作，该操作之前和之后的提交记录都会被保留，并且会将该撤销操作作为最新的提交；</li>
<li><code>reset</code>是通过改变<code>HEAD</code>和分支指针指向的方式，进行版本回退，该操作之后的提交记录不会被保留，并且不会创建新的提交；</li>
</ul>
<p>在个人开发上，建议使用<code>reset</code>；但是在团队开发中建议使用<code>revert</code>，特别是公共的分支（比如<code>master</code>)，这样能够完整保留提交历史，方便回溯。</p>
<h3 id="Ⅴ-回退方法汇总"><a href="#Ⅴ-回退方法汇总" class="headerlink" title="Ⅴ.回退方法汇总"></a>Ⅴ.回退方法汇总</h3><p>版本回退主要有<strong>三大方式</strong>：<code>reset</code>、<code>revert</code>和<code>checkout</code>，各方式的比较如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>效果</th>
<th>向前回退</th>
<th>向后回退</th>
<th>同步修改<code>HEAD</code>与分支指向</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git reset --hard HEAD^</code></td>
<td>往前回退<code>1</code>次提交</td>
<td>能</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><code>git reset --hard HEAD^^</code></td>
<td>往前回退<code>2</code>次提交</td>
<td>能</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><code>git reset --hard HEAD~n</code></td>
<td>往前回退<code>n</code>次提交</td>
<td>能</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><code>git reset --hard &lt;commit_id&gt;</code></td>
<td>回退到指定<code>commit id</code>的提交</td>
<td>能</td>
<td>能</td>
<td>是</td>
</tr>
<tr>
<td><code>git revert HEAD</code></td>
<td>重做最新一次提交</td>
<td>能</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><code>git revert HEAD^</code></td>
<td>重做倒数第二次提交</td>
<td>能</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><code>git revert HEAD^^</code></td>
<td>重做倒数第三次提交</td>
<td>能</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><code>git revert HEAD~n</code></td>
<td>重做倒数第<code>n+1</code>次提交</td>
<td>能</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><code>git revert commit_id</code></td>
<td>重做指定<code>commit_id</code>的提交</td>
<td>能</td>
<td>能</td>
<td>是</td>
</tr>
<tr>
<td><code>git checkout commit_id</code></td>
<td>回退到指定<code>commit id</code>的提交</td>
<td>能</td>
<td>能</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>从上表可知，只有下列三种方式可以自由地向前向后回退：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br><span class="line">git revert commit_id</span><br><span class="line">git checkout commit_id</span><br></pre></td></tr></table></figure>
<p>但是，使用<code>checkout</code>进行回退会出现游离的提交，需要创建一个新分支进行保存，所以不常用。</p>
<h2 id="二、git-stash"><a href="#二、git-stash" class="headerlink" title="二、git stash"></a>二、<code>git stash</code></h2><h4 id="1-git-stash的作用"><a href="#1-git-stash的作用" class="headerlink" title="1.git stash的作用"></a>1.<code>git stash</code>的作用</h4><p><code>git stash</code>指令的作用为：对没有提交到版本库的，位于工作区或暂存区中游离的修改进行保存，在需要时可进行恢复。具体应用场景如下：</p>
<p>在<code>master</code>分支进行两次提交：<code>1st</code>和<code>2nd</code>，随后创建并切换到<code>dev</code>分支。在<code>dev</code>分支上进行一次提交（<code>dev1</code>），此时两分支的状态为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108081.image" alt="image-20200412235844426"></p>
<p>随后在<code>dev</code>分支上给文件<code>test.txt</code>添加一行<code>dev2</code>，但是不提交到暂存区，直接切换到<code>master</code>分支，会出现如下错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108229.image" alt="image-20200413001632846"></p>
<p>图中显示的错误大意为：在<code>dev</code>分支上的修改会被<code>checkout</code>操作覆盖。下面我们来看看，将<code>dev</code>分支上的这一修改操作添加到暂存区后，再切换分支，是否还会出现同样的问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108839.image" alt="image-20200413001752227"></p>
<p>可见还是会出现该错误，这初步验证了位于工作区和暂存区中的修改都会被<code>checkout</code>操作覆盖的结论。原因如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109688.image" alt="image-20200413001917190"></p>
<p>虽然在<code>dev</code>分支上修改了文件，但是没有将这一修改操作进行提交。这样就不会产生提交节点，就如上图所示，修改<code>dev2</code>是游离的，在切换分支的时候会被丢弃。</p>
<p>这种情况在日常开发中很常见，当在<code>develop</code>分支上开发新功能的时候，<code>master</code>分支出现紧急情况需要切换回去进行修复。但是，当前分支的新功能还没开发完全，贸然切换分支，原来开发的内容就会因被覆盖而丢失，怎么办呢？</p>
<p>有人可能会说进行一次<code>commit</code>不就可以了吗？确实可以。但是，这样不符合提交的代码就是正确代码的原则。更好的解决方法为使用<code>git stash</code>，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109677.image" alt="image-20200413002115302"></p>
<p>可见<code>git stash</code>可以将当前<code>dev</code>分支上，位于在工作区或暂存区中的修改，在未提交的情况下进行了保存；并且将分支回退到修改前的状态，保存过后，就可以很顺畅地切换回<code>master</code>分支了。</p>
<blockquote>
<p>图中的<code>WIP</code>（<code>working in progress</code>）表示的是正在进行的工作；</p>
</blockquote>
<p>当我们在<code>master</code>分支上完成了工作，再次切换回<code>dev</code>分支时，查看<code>test.txt</code>文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109078.image" alt="image-20200413002256321"></p>
<p>发现切换分支前所做的修改<code>dev2</code>消失了，这是为什么呢？</p>
<ul>
<li><p>其实，上面通过<code>git stash</code>将<code>dev</code>分支上工作区或暂存区中的修改，提交到了<code>stash</code>区域进行保存，并将<code>dev</code>分支回退到修改前的状态。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109676.image" alt="image-20200413003349365"></p>
</li>
<li><p>切换到<code>master</code>分支时<code>test</code>分支上的修改依旧会被覆盖。所以，再次回到<code>dev</code>分支时需要从<code>stash</code>区域中恢复切换分支前保存的修改；</p>
</li>
</ul>
<p>怎样恢复通过<code>git stash</code>保存到<code>stash</code>中的修改呢？可以通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<p>查看该分支上被<code>stash</code>保存的修改：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109221.image" alt="image-20200413224408623"></p>
<p>继续给<code>test.txt</code>文件添加内容：<code>dev3</code>，并通过以下指令保存修改的同时添加注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash save &apos;注释&apos;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109732.image" alt="image-20200413225024618"></p>
<ul>
<li>首先，通过上述命令可以修改<code>stash</code>中存储修改的备注信息；</li>
<li>其次，虽然在<code>test</code>分支上进行了两次修改，但是使用<code>git stash</code>保存修改后，文件<code>test.txt</code>并没有实际被修改；</li>
</ul>
<h4 id="2-恢复stash存储的修改"><a href="#2-恢复stash存储的修改" class="headerlink" title="2.恢复stash存储的修改"></a>2.恢复<code>stash</code>存储的修改</h4><p>方法有很多，主要有以下三种：</p>
<h5 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a><code>git stash pop</code></h5><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109359.image" alt="image-20200413225140030"></p>
<p>如图所示，通过上述命令将<code>stash</code>中存储的最新一次修改恢复了。相信你已经发现了，<code>stash</code>与<strong>栈</strong>非常类似：先保存的修改，排在最后，序号最大；后保存的修改，排在最前，序号最小；</p>
<p>恢复了最新一次修改后，再次查看<code>stash</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110445.image" alt="image-20200413225221071"></p>
<p>可以看到存储的修改只剩下一条了，由此可推断出<code>git stash pop</code>作用为：</p>
<ul>
<li>**第一：**恢复<code>stash</code>中存储的最新一次修改；</li>
<li>**第二：**将该修改从<code>stash</code>中删除；</li>
</ul>
<h5 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a><code>git stash apply</code></h5><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110409.image" alt="image-20200413225457480"></p>
<p>如上图所示，使用该指令时发生了合并冲突。这是因为，<code>stash</code>中保存的每一次修改代表的都是一个版本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110310.image" alt="image-20200413231349820"></p>
<ul>
<li>如上图所示，在<code>test</code>分支上，进行第一次修改后，通过<code>git stash</code>将该修改作为修改<code>0</code>保存到<code>stash</code>中，此时分支中的文件并没有发生改变；</li>
<li>进行第二次修改后，通过<code>git stash</code>将修改作为修改<code>1</code>保存到<code>stash</code>中，分支中的文件依旧没有发生改变；此时的<code>stash</code>中相当于保存着同一分支上两个修改后的版本；</li>
<li>此时通过**<code>git stash pop</code><strong>取出修改<code>0</code>，与<code>test</code>分支进行合并；再通过</strong><code>git stash pop</code>**取出修改<code>1</code>，再次与<code>test</code>分支进行合并，两个版本合并自然会产生冲突。</li>
</ul>
<p>手动解决冲突后，要进行一次提交才算完成了手动合并；随后查看<code>stash</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110378.image" alt="image-20200413230750201"></p>
<p>修改<code>0</code>仍然存在，说明**<code>git stash apply</code>**的作用为取出<code>stash</code>中最新（前面）的修改并与分支进行合并。但是，<code>stash</code>中存储的该修改并不会被删除；</p>
<h5 id="git-stash-apply-stash-n"><a href="#git-stash-apply-stash-n" class="headerlink" title="git stash apply stash@{n}"></a><code>git stash apply stash@{n}</code></h5><p>这是最常用的方法，作用为从<code>stash</code>中恢复特定的修改，并且不删除<code>stash</code>中的该修改。</p>
<p>将<code>test.txt</code>的两次修改通过<code>git stash</code>存储到<code>stash</code>中，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110739.image" alt="image-20200413232024080"></p>
<p>通过<code>git stash apply stash@{1}</code>恢复<code>stash</code>中存储的修改<code>1</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110148.image" alt="image-20200413232309330"></p>
<p>如上图所示，成功地恢复了<code>stash</code>中的修改<code>1</code>，并且<code>stash</code>中的修改<code>1</code>并没有被删除；</p>
<p><strong>总结：</strong></p>
<ul>
<li><code>git stash pop</code>：恢复并删除<code>stash</code>中存储的最新修改；</li>
<li><code>git stash apply</code>：恢复但不删除<code>stash</code>中存储的最新修改；</li>
<li><code>git stash apply stash@{0}</code>：恢复但不删除<code>stash</code>中存储的特定提交；</li>
</ul>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>mac上git同时关联gitlab和github</title>
    <url>/2022/12/29/mac%E4%B8%8Agit%E5%90%8C%E6%97%B6%E5%85%B3%E8%81%94gitlab%E5%92%8Cgithub/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、生成ssh密钥并配置"><a href="#一、生成ssh密钥并配置" class="headerlink" title="一、生成ssh密钥并配置"></a>一、生成ssh密钥并配置</h2><p>分别对gitlab和github生成对应的密钥（默认情况下本地生成的秘钥位于/Users/用户名/.ssh/）<a id="more"></a></p>
<h3 id="1-、生成gitlab密钥并配置"><a href="#1-、生成gitlab密钥并配置" class="headerlink" title="1 、生成gitlab密钥并配置"></a>1 、生成gitlab密钥并配置</h3><pre><code>打开Timinal终端，输入命令：
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “公司邮箱地址”</span><br></pre></td></tr></table></figure>
<p>生成对应的<code>gitlab</code>密钥：id_rsa和id_rsa.pub，将gitlab公钥即id_rsa.pub（Mac下路径为/Users/用户名/.ssh/）中的内容配置到公司的gitlab上。</p>
<h3 id="2、生成github密钥并配置"><a href="#2、生成github密钥并配置" class="headerlink" title="2、生成github密钥并配置"></a>2、生成github密钥并配置</h3><p>在Timinal终端中输入命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “github邮箱地址” -f  ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure></p>
<p>生成对应的github密钥：github_rsa和github_rsa.pub，将github公钥即github_rsa.pub中的内容配置到自己的github上。</p>
<h3 id="3、配置git，访问不同host时使用不同的密钥。"><a href="#3、配置git，访问不同host时使用不同的密钥。" class="headerlink" title="3、配置git，访问不同host时使用不同的密钥。"></a>3、配置git，访问不同host时使用不同的密钥。</h3><p>进入密钥生成的位置（/Users/用户名/.ssh/），手动创建一个config文件（注意这个config文件要无后缀）。<br>在新建的config文件里面配置如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User xxx@xxx.com       //user后边为github的邮箱</span><br><span class="line">IdentityFile ~/.ssh/github_rsa</span><br><span class="line"></span><br><span class="line">Host gitlab.xxx.cn    //host后边为公司gitlab域名</span><br><span class="line">HostName gitlab.xxx.cn   //同上为公司gitlab域名</span><br><span class="line">User xxx@xxx.com          //user后为gitlab的邮箱</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">备注：公司内网地址，设置HostName时需要注意，复制公司gitlab或者自己的github地址时，需要把”https://&quot; 去掉。</span><br></pre></td></tr></table></figure></p>
<h3 id="二、验证是否设置成功"><a href="#二、验证是否设置成功" class="headerlink" title="二、验证是否设置成功"></a>二、验证是否设置成功</h3><p> 打开Timinal终端，分别输入命令：<br>测试github<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<p>测试gitlab(@符后面的为公司gitlab地址)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@gitlab.xxx.com</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 全局配置</span><br><span class="line">$ git config --global user.name  &apos;gitlab账号名&apos; </span><br><span class="line">$ git config --global user.email  &apos;gitlab账号邮箱&apos;</span><br><span class="line"></span><br><span class="line">// 本地配置</span><br><span class="line">$ git config --local user.name  &apos;github账号名&apos;   </span><br><span class="line">$ git config --local user.email  &apos;github邮箱&apos;</span><br></pre></td></tr></table></figure>
<p>到这里，多账号的配置基本上已经完成了，但是还有一个不足的地方就是虽然私钥根据域名自动选择了，但是提交的配置还是共享 .gitconfig 中的配置，例如 user.name 和 user.email，能不能根据仓库所在的不同位置选择不同的全局配置文件呢？ 答案是可以的，打开 ~/.gitconfig 文件，在末尾添加下面的配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[includeIf &quot;gitdir:~/work/gitlab/&quot;]</span><br><span class="line">    path = .gitconfig-gitlab</span><br></pre></td></tr></table></figure></p>
<p>然后再建一个 ~/.gitconfig-gitlab 文件，里面写全局配置，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = keliq</span><br><span class="line">    email = keliq</span><br></pre></td></tr></table></figure></p>
<p>那么只要仓库被放到了 ~/work/gitlab 目录下面，默认就会使用这个配置了！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>你需要知道的git子模块</title>
    <url>/2022/12/21/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84git%E5%AD%90%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>先引用 <code>git</code> 的官方定义描述：</p>
<blockquote>
<p>A submodule is a repository embedded inside another repository. The submodule has its own history; the repository it is embedded in is called a superproject.</p>
</blockquote>
<p>子模块（<code>submodule</code>）是一个内嵌在其他 git 仓库（父工程）中的 git 仓库，子模块有自己的 git 记录。</p>
<p>通常，如果一个仓库存在子模块，父工程目录下的 <code>.git/modules/</code> 目录中会存在一个 <code>git</code> 目录，子模块的仓库目录会存在于父工程的仓库目录中，并且子模块的仓库目录中也会存在一个 <code>.git</code> 目录；<a id="more"></a></p>
<p>使用场景：</p>
<ul>
<li>想要在一个工程中使用另一个工程，但是那个工程包含了单独的提交记录，<code>submodule</code> 就可以实现在一个工程中引入另一个工程，同时保留二者的提交记录并且区分开来；目前 <code>submodule</code> 还能实现单独开发子工程，并且不会影响父工程，父工程可以在需要的时候更新子模块的版本；</li>
<li>想要把一个工程拆分成多个仓库并进行集中管理，这可以用来实现 <code>git</code> 当前的限制，实现更细粒度的访问，解决当仓库过于庞大时所出现的传输量大、提交记录冗杂、权限分设等问题；</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="新增子模块"><a href="#新增子模块" class="headerlink" title="新增子模块"></a>新增子模块</h3><p>向一个项目中添加子模块：</p>
<pre><code>git submodule add https://github.com/yyy/xxx.git
</code></pre><p>之后会 <code>clone</code> 该子模块对应的远程项目文件到本地父项目目录下的同名文件夹中（<code>./xxx/</code>），父项目下也会多一个叫 <code>.gitmodules</code> 的文件，内容大致为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[submodule &quot;xxx&quot;]</span><br><span class="line">	path = xxx</span><br><span class="line">	url = git@github.com:yyy/xxx.git</span><br></pre></td></tr></table></figure></p>
<p>如果存在多个子模块，则会继续向该文件中追加与上面相同格式的内容；</p>
<p>同时父项目下的 <code>.git</code> 目录中也会新增 <code>/modules/xxx/</code> 目录，里面的内容对应子模块仓库中原有的 <code>.git</code> 目录中的文件，此时虽然子模块目录下的 <code>.git</code> 依然存在，但是已经由一个文件夹变成了文件，内容为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitdir: ../.git/modules/xxx</span><br></pre></td></tr></table></figure></p>
<p>即指向了父项目的 <code>.git/modules/xxx</code> 目录；如果运行 <code>git config --list</code> 查看项目的配置，也会发现多了类似下面两行的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">submodule.xxx.url=git@github.com:yyy/xxx.git</span><br><span class="line">submodule.xxx.active=true</span><br></pre></td></tr></table></figure></p>
<p>如果修改 <code>submodule.xxx.url</code> 的值，则会覆盖 <code>.gitmodules</code> 文件中对应的 <code>url</code> 值；</p>
<h3 id="查看子模块"><a href="#查看子模块" class="headerlink" title="查看子模块"></a>查看子模块</h3><p>查看当前项目下的子模块：</p>
<blockquote>
<p><code>git submodule</code></p>
</blockquote>
<p> 或者</p>
<blockquote>
<p><code>git submodule status</code></p>
</blockquote>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">70c316ecb7c41a5bdf8a37ff93bf866d3b903388 xxx (heads/master)</span><br></pre></td></tr></table></figure></p>
<p>如果将父项目推送到远程仓库（如 Github），在网页浏览该项目时子模块所在的目录会多一个类似 <strong><code>@70c316e</code></strong> 的后缀，即上面查看子模块命令输出内容的 hash 值的前面部分，点击这个目录会跳转到这个子模块对应的仓库地址（另一个 url）；</p>
<p>如果执行：</p>
<pre><code>git submodule deinit
</code></pre><p>删除了子模块，则再次查看时输出会是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-70c316ecb7c41a5bdf8a37ff93bf866d3b903388 xxx</span><br></pre></td></tr></table></figure></p>
<h3 id="拉取子模块"><a href="#拉取子模块" class="headerlink" title="拉取子模块"></a>拉取子模块</h3><p>如果要 <code>clone</code> 一个项目，并且包含其子模块的文件，则需要给 <code>git clone</code> 命令最后加上 <code>--recurse-submodules</code> 或者 <code>--recursive</code> 参数（<strong>否则</strong>只会下载一个空的子模块文件）：</p>
<pre><code>git clone https://github.com/yyy/xxx.git --recursive
</code></pre><p>当然，克隆时忘记了加这个参数，后续也有办法去拉取子模块的文件，首先执行：</p>
<pre><code>git submodule init
</code></pre><p>这会初始化子模块相关配置，比如自动在 <code>config</code> 中加入下面两行内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">submodule.xxx.url=git@github.com:yyy/xxx.git</span><br><span class="line">submodule.xxx.active=true</span><br></pre></td></tr></table></figure></p>
<p>然后执行：</p>
<pre><code>git submodule update
</code></pre><p>就可以拉取到子模块仓库中的文件了，也可以将这两步命令合并为一步：</p>
<pre><code>git submodule update --init
</code></pre><p>要拉取所有层层嵌套的子模块，则执行：</p>
<pre><code>git submodule update --init --recursive
</code></pre><p>之前 <code>clone</code> 时加参数不过是自动执行初始化配置并拉取子模块（甚至嵌套的子模块）中的文件罢了；</p>
<p>命令默认拉取<strong>主分支</strong>（<code>master</code>），想要修改这个默认拉取分支可以修改 <code>.gitmodules</code> 文件中子模块对应的 <code>branch</code> 值，或者执行：</p>
<pre><code>git config submodule.xxx.branch dev
</code></pre><p>或者执行同时将配置写入文件，这样其他人拉取父项目也会获取该配置：</p>
<pre><code>git config -f .gitmodules submodule.xxx.branch dev
</code></pre><h3 id="更新子模块"><a href="#更新子模块" class="headerlink" title="更新子模块"></a>更新子模块</h3><h4 id="拉取更新"><a href="#拉取更新" class="headerlink" title="拉取更新"></a>拉取更新</h4><p>获取子模块仓库的最新提交，同步远程分支的变更，可以直接在子模块目录下执行：</p>
<pre><code>git pull
</code></pre><p>或者在父目录下执行：</p>
<pre><code>git submodule update --remote
</code></pre><p>这里给 <code>git submodule update</code> 加上 <strong><code>--remote</code></strong> 是为了直接从子模块的当前分支的远程追踪分支获取最新变更，不加则是默认从父项目的 <code>SHA-1</code> 记录中获取变更；当有多个子模块时，该命令默认拉取<strong>所有</strong>子模块的变更，指定更新子模块 <code>xxx</code> 需要执行：</p>
<pre><code>git submodule update --remote xxx
</code></pre><p>如果将修改子模块的相关变更推送到父项目的远程，其他人拉取代码时，只用 <code>git pull</code> 的话只会把子模块的相关修改拉取到父项目，具体变更并<strong>不会更新</strong>到子模块中，在父项目里执行：</p>
<blockquote>
<p><code>git diff --submodule</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Submodule xxx a6e2962..70c316e (rewind):</span><br><span class="line">  &lt; add file</span><br></pre></td></tr></table></figure>
<p>注意子模块提交记录中前的 <strong><code>&lt;</code></strong> 符号，表示变更未更新到子模块文件夹里，所以更新子模块变更需要执行：</p>
<pre><code>git submodule update --init --recursive
</code></pre><p>或者直接在父项目拉取时同时更新子模块（需要子模块已经 <code>init</code>，否则仍然拉取不到文件）：</p>
<pre><code>git pull --recurse-submodules
</code></pre><h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p>更新完子模块（<code>git submodule update</code>）后，虽然会将文件变更同步到子模块目录下，但是此时子模块并没有处于任何已有分支下，去子模块目录下检查一下分支就会发现：</p>
<blockquote>
<p><code>git branch -vv</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* (HEAD detached at 16d1b6b) 16d1b6b mod file</span><br><span class="line">  master                     16d1b6b [origin/master] mod file</span><br></pre></td></tr></table></figure>
<p>当前分支并不是 <code>master</code>，而是一个 <code>detached</code> 状态的编号分支，官方文档称为“游离的 HEAD”，虽然可以提交，但是并没有本地分支跟踪这些更改，意味着下次更新子模块就会<strong>丢失</strong>这些更改；</p>
<p>所以在子模块下开始开发前，需要先<strong>切换</strong>到某个已有分支或者创建新的分支，比如进入主分支：</p>
<pre><code>git checkout master
</code></pre><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>除了默认的分支同步更新操作，也可以执行其他类型的分支更新行为，比如 <code>merge</code>，<code>rebase</code> 等；如将父项目中记录的子模块最新变更（分支是 <code>submodule.xxx.branch</code> 中配置的，默认主分支 <code>master</code>）<code>merge</code> 到子模块的当前分支中，则执行：</p>
<pre><code>git submodule update --remote --merge
</code></pre><p><code>rebase</code> 到子模块当前分支则执行：</p>
<pre><code>git submodule update --remote --rebase
</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果其他人修改了子模块的内容并提交了记录，父项目也提交并推送了远程仓库，但是子模块<strong>没有</strong>推送其对应的远程仓库，<br>那么其他人拉取父项目代码变更时没有问题，但是<strong>更新</strong>子模块时就会遇到下面的问题：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: remote error: upload-pack: not our ref 16d1b6b94e3245f3a7fb4f43e5b6f44b14027fbb</span><br><span class="line">Fetched in submodule path &apos;xxx&apos;, but it did not contain 16d1b6b94e3245f3a7fb4f43e5b6f44b14027fbb.</span><br><span class="line">Direct fetching of that commit failed.</span><br></pre></td></tr></table></figure></p>
<p>即由于其他人没有及时将子模块的提交 <code>push</code> 的子模块的远程仓库，我们本地父项目有了关于子模块最新的变更，但是在子模块的仓库中却找不到，就报错了，让对方在子模块下 <code>push</code> 一下这边再重新更新就行了；</p>
<p>为了避免制造这一不必要的麻烦，可以把在父项目中推送远程的命令替换为：</p>
<pre><code>git push --recurse-submodules=check
</code></pre><p>这样如果子模块（与父项目记录的对应分支）存在未 <code>push</code> 的提交，就会报错，并且子模块有推送失败的，父项目也会推送失败；需要在推送父项目时自动推送未推送的子模块，则执行：</p>
<pre><code>git push --recurse-submodules=on-demand
</code></pre><p>觉得每次手输太麻烦，就直接将其写入配置：</p>
<pre><code>git config push.recurseSubmodules check
</code></pre><p>如果父项目中子模块的仓库地址（<code>submodule.xxx.url</code>）被其他协作者修改了，那么我们再更新子模块时就可能遇到问题，需要执行：</p>
<pre><code>git submodule sync --recursive
</code></pre><p>同步完 <code>url</code>，然后再重新初始化更新：</p>
<pre><code>git submodule update --int --recursive
</code></pre><h3 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h3><p>在确认移除子模块前，需要先将其取消注册（<code>unregister</code>），即删除该子模块相关的配置文件（<code>git config</code>），比如要移除子模块 <code>xxx</code>，则执行：</p>
<pre><code>git submodule deinit xxx
</code></pre><p>然后子模块的相关配置会被删除（<code>.gitmodules</code> 和 <code>.git/modules/xxx</code> 中的配置会保留），子模块对应的目录也会被清空（子模块目录本身会保留），再运行 <code>git submodule status</code> 查看子模块则会输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-70c316ecb7c41a5bdf8a37ff93bf866d3b903388 xxx</span><br></pre></td></tr></table></figure></p>
<p>前缀 <strong><code>-</code></strong> 表示该子模块已经被取消注册，可理解为暂时移除，想必官方这样做也是给我们提供反悔的余地，因为想要<strong>恢复</strong>刚才删除的子模块，重新执行 <code>git submodule update --init xxx</code> 就能重新初始子模块并拉取文件；</p>
<p>由于还有一些配置文件仍然被保留，所以想要<strong>彻底删除</strong>的话，需要继续手动删除这里配置文件，即：</p>
<ul>
<li>删除子模块对应的目录 <code>xxx</code>；</li>
<li>删除 <code>.gitmoduls</code> 中子模块 <code>xxx</code> 对应的区块配置；</li>
<li>删除 <code>.git/modules/</code> 目录下的子模块目录 <code>xxx</code>；</li>
<li>删除子模块的缓存：<code>git rm --cached xxx</code>；</li>
</ul>
<p>然后再执行 <code>git submodule</code> 就没有任何输出了，清除完毕；</p>
<h3 id="子模块与父项目的联系"><a href="#子模块与父项目的联系" class="headerlink" title="子模块与父项目的联系"></a>子模块与父项目的联系</h3><p>父项目和子模块有着分开的 <code>git</code> 仓库，所以可以分别在父项目和子模块的目录下使用 <code>git</code> 命令，操作的也是<strong>各自</strong>的仓库，比如分别在父项目和子模块中执行 <code>git branch -a</code> 或者 <code>git remote -v</code> 的输出结果是不同的；</p>
<p>虽然二者有个分开的仓库与提交记录，但是又是关联起来的（这正是 <code>submodule</code> 所做的工作），举个例子，在子模块目录 <code>xxx/</code> 下新增一个文件 <code>test.txt</code>，然后在子模块目录中执行 <code>git satus</code> 会输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        xxx/test.txt</span><br></pre></td></tr></table></figure></p>
<p>此时在父项目下执行 <code>git status</code> 输出的是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">  (commit or discard the untracked or modified content in submodules)</span><br><span class="line">        modified:   xxx (untracked content)</span><br></pre></td></tr></table></figure></p>
<p>即提示需要先在子模块下提交修改记录；</p>
<p>然后子模块下提交记录，执行：</p>
<pre><code>git add .
git commit -m &quot;add file&quot;
</code></pre><p>这时再分别运行 <code>git status</code>，子模块的输出是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<p>而父项目的输出是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   xxx (new commits)</span><br></pre></td></tr></table></figure></p>
<p>提示子模块中有了新的提交（<code>new commits</code>）；</p>
<p>假如再把子模块下的这个 <code>test.txt</code> 文件删除，则子模块的状态是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        deleted:    xxx/test.txt</span><br></pre></td></tr></table></figure></p>
<p>但是父项目的状态依然是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   xxx (new commits)</span><br></pre></td></tr></table></figure></p>
<p>子模块撤销刚才的删除操作，将新增文件的记录 <code>git push</code> 到远程（这会推送到子模块<strong>自己</strong>的远程仓库），此时子模块的工作区状态是清空状态，但是父项目的依旧是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   xxx (new commits)</span><br></pre></td></tr></table></figure></p>
<p>所以，父项目与子模块的关联便是，父模块只是单纯的识别子模块的<strong>总体变化</strong>，而不会在意具体是新增、修改还是删除，甚至修改已经提交推送到子模块所属的远程仓库，只是将这些调整统一识别为 <code>modified</code> 状态，然后需要提交并推送到自己（父项目）所属的远程仓库；</p>
<p>在父项目中使用 <code>git diff</code> 可以查看当前的变更，会输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diff --git a/xxx b/xxx</span><br><span class="line">index 70c316e..a6e2962 160000</span><br><span class="line">--- a/xxx</span><br><span class="line">+++ b/xxx</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Subproject commit 70c316ecb7c41a5bdf8a37ff93bf866d3b903388</span><br><span class="line">+Subproject commit a6e29629904538e8f70694df607617084d2659ca</span><br></pre></td></tr></table></figure></p>
<p>如果想要查看具体子模块的变动，可以执行：</p>
<blockquote>
<p><code>git diff --submodule</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Submodule xxx 70c316e..a6e2962:</span><br><span class="line">  &gt; add file</span><br></pre></td></tr></table></figure>
<p>输出会列出当前子模块的所有变动的提交日志；也可以直接日志中关联的子模块提交记录，执行：</p>
<blockquote>
<p><code>git log -p --submodule</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit 909a721e3755affb7620316b44df8fbc1b3488f2 (HEAD -&gt; master)</span><br><span class="line">Author: ******</span><br><span class="line">Date:   ******</span><br><span class="line"></span><br><span class="line">    mod submodule</span><br><span class="line"></span><br><span class="line">Submodule xxx 70c316e..a6e2962:</span><br><span class="line">  &gt; add file</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>父项目从含有子模块的分支切换到没有子模块的分支时，默认会<strong>保留</strong>子模块对应的目录，所以这使得切换过去时本地会保留关于子模块的修改记录，显然这不太合理，所以从包含子模块的分支切换到 <code>xxx</code> 时，需要这样执行：</p>
<pre><code>git checkout xxx --recurse-submodules
</code></pre><p>当父项目存在许多子模块时，有时需要对多个子模块执行相同的操作，这时就可以使用 <strong><code>foreach</code></strong> 功能，比如批量存储：</p>
<pre><code>git submodule foreach &apos;git stash&apos;
</code></pre><p>或者在每个子模块中新建切换分支：</p>
<pre><code>git submodule foreach &apos;git checkout -b new&apos;
</code></pre>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>你需要知道的git命令和用法</title>
    <url>/2022/12/13/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84git%E5%91%BD%E4%BB%A4%E5%92%8C%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在平时的 Coding 过程中，我们还是需要一定的 Git 操作的能力的。但是总还是存在一些场景自己突然想不起来，某个场景，应该使用什么 Git 命令可以满足自己的诉求，这个时候又需要打开 Google / Baidu，各种搜索一番，与其把时间消磨在这一次次的重复工作中，倒不如好好研究一下我们常用的命令的玩法。在这里，本文也将提供一系列的案例，为大家介绍这些常用的 Git 的体系和命令的应用场景以及大体的使用方式。<br>当然，除了我们需要了解 Git 的命令使用方式之外，我们也应该来了解下 Git 是的整个体系结构是怎么样的，这样才能更加清晰的知道我们每天操作的命令都是在做什么。<a id="more"></a></p>
<h2 id="Git-体系"><a href="#Git-体系" class="headerlink" title="Git 体系"></a>Git 体系</h2><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212211907078.png" alt></p>
<h2 id="Git-区域理解"><a href="#Git-区域理解" class="headerlink" title="Git 区域理解"></a>Git 区域理解</h2><ul>
<li>远程仓库区：也就是我们代码最终提交的归宿，没啥好说的。</li>
<li>远端分支本地副本：这个其实主要储存了远程仓库各分支数据在本地的一个副本，你可以打开你 Git 项目下的 .git 文件，里面有个 refs/remotes，这里就主要存的就是远程仓库的分支信息，一般你执行 push 或者 pull、fetch 都会往这里进行更新。</li>
<li>本地分支：这里就是我们经常会打交道的区域，你在执行 commit 之后，本质上就是提交到了这个区域，你可以查看你的 .git 目录下的 refs/heads 目录，里面存的就是我们本地的分支代码信息。</li>
<li>暂存区：这个区域就是我们每次执行 git add 之后会存到的区域，用来与本地仓库之间做一个缓存，同时也是 Git 底层设计上来说也算是比较重要的一个区域，它能帮助 Git 在做 diff 的时候提高查找性能。</li>
<li>工作区：这个一般就是我们写代码的地方，比如你的 vscode 打开的项目，你可以进行代码编辑的地方。</li>
</ul>
<h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>除此之外，还有一个特殊的区域，那就是本地的 git 储存区，它是用来干嘛的呢？一般来说你可能在某些场景下会用到它，我们有的时候本地改了代码，但是突然有个人过来问你另一个分支的问题，同时这个时候你在实现某个功能，实现一半，又不想提交到 Git 仓库中，那么你就可以考虑使用 git stash save “临时存一下”，这个时候它就会帮你存到这个储存区，你去其他分支做完事情回来，再 git stash pop就好了。</p>
<p>但笔者还是不是很建议使用这个功能，因为哪天你切走了再切回来，忘记了这个存储，又写了点其他的，这个时候你到时候被坑一把就哭吧。当然了，这个功能还是很有用的，但是的确需要细心点用。</p>
<h3 id="Git-简单工作流理解"><a href="#Git-简单工作流理解" class="headerlink" title="Git 简单工作流理解"></a>Git 简单工作流理解</h3><p>日常工作中，我们可能在 Git 使用上频繁交互的流程大致会是这样的（不同规范下会有一些区别，但是大差不大）：</p>
<ol>
<li>来了一个新需求，我们会从 master checkout 一个新的 feature 分支出来进行开发。</li>
<li>开发完某个功能点，我们会执行 git add 将代码提交到暂存区。</li>
<li>执行 git commit 将代码提交到本地仓库</li>
<li>执行 git push 将代码提交到远端分支</li>
<li>当我们开发完所有需求之后，可能会设立一个专门的测试分支比如名叫 dev 的分支，那么我们就把代码合并到这个测试分支上，发布测试环境进行测试。</li>
<li>测试完毕之后，我们就需要合代码了，这个时候，我们可以发起一个 merge request，将我们的代码走 CR 流程合并到 master 分支。</li>
<li>在提交 MR 的过程中，我们一般需要先自己预先将 master 分支的代码合并到当前需要被合并的分支，提交并解决冲突。</li>
</ol>
<p>以上流程大致概括了一般常规的 Git flow 流程，不同的公司可能会设计自己的规范，这里就不过多指示了。</p>
<h2 id="命令概览"><a href="#命令概览" class="headerlink" title="命令概览"></a>命令概览</h2><ul>
<li>git stash</li>
<li>git clone</li>
<li>git init</li>
<li>git remote</li>
<li>git branch</li>
<li>git checkout</li>
<li>git add</li>
<li>git commit</li>
<li>git rm</li>
<li>git push</li>
<li>git pull</li>
<li>git fetch</li>
<li>git merge</li>
<li>git log</li>
<li>git reset</li>
<li>git reflog</li>
<li>git revert</li>
<li>git cherry-pick</li>
<li>git tag</li>
<li>git rebase</li>
</ul>
<p>乍一看，眼花缭乱，当场决定放弃，还是用可视化工具吧。莫慌，且让笔者为你娓娓道来。</p>
<h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><p>一般来说，我们本地如果想要使用 Git 管理一些资源文件，首先我们需要有一个仓库才行。常用的方式莫过于，第一去 Gitlab / Github 先创建一个仓库，然后再拉到本地，那这个时候我们就可以用到我们的 clone 命令了。</p>
<h3 id="git-stash（临时插进来快速介绍一下）"><a href="#git-stash（临时插进来快速介绍一下）" class="headerlink" title="git stash（临时插进来快速介绍一下）"></a>git stash（临时插进来快速介绍一下）</h3><p>上面也有初步介绍这个命令的用法，就是用来临时存一下不想被提交的代码变更的，常用命令如下：</p>
<ul>
<li>git stash save ‘xxx’: 储存变更</li>
<li>git stash list: 查看储存区所有提交列表</li>
<li>git stash pop: 弹出并应用最近的一次储存区的代码提交</li>
<li>git stash drop stash@{n}: 删除某次储存记录</li>
<li>git stash clear: 清楚所有 stash 信息</li>
</ul>
<p>它的数据将被存在你仓库 .git 文件下的 refs/stash 里。</p>
<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>最基础也是最常用的用法莫过于直接使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone xxx.git</span><br></pre></td></tr></table></figure></p>
<p>这样就能轻松把一个仓库代码拉到本地了，但仅仅知道这一点似乎还不太够。一般我们直接 clone 下来不带参数的话，它会默认停留在 master 分支，有的时候我们依旧需要一些其他诉求，比如怎么拉到本地之后自动切到指定分支呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone xxx.git -b branch1</span><br></pre></td></tr></table></figure></p>
<p>有了仓库之后，我们总不能一直在 master 分支搞事吧，一般是不是都需要开个新分支改代码，再最后完事了再合到 master，那就需要用到下面介绍 git branch 命令了，不过呢，在讲到具体的分支操作之前呢，笔者还是要先补一下有关于本地仓库的初始化的流程。</p>
<h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>除了我们从远端建仓库，有的时候我们自己本地也是可以自己初始化一个 Git 仓库来操作的，这个时候我们就直接使用 git init 就能轻松为当前目录创建一个 git 仓库，也就能开始对当前目录的改动纳入版本管理库了。<br>不过本地 init 的仓库没法和远端进行交互，所以我们还是需要去 github/gitlab 创建一个远端仓库，然后关联一下，也就是 git remote 命令了。</p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>用于和远程仓库进行关系绑定处理等等操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add: 添加一个远程版本库关联</span><br><span class="line">git remote rm: 删除某个远程版本库关联</span><br></pre></td></tr></table></figure>
<p>比如我们本地有个初始化好的仓库，同时还有一个创建好的远程空仓库，那么我们就可以执行一下操作让他们关联起来：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin xxx.git先添加到本地仓库</span><br><span class="line">git push -u origin master：表示把当前仓库的 master 分支和远端仓库的 master 分支关联起来，后面我们执行 push 或者 pull 都可以非常方便的进行操作了。</span><br></pre></td></tr></table></figure></p>
<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>在拿到一个项目之后，你首先还是应该看一下当前仓库现在有哪些分支，不要待会创建新分支发现名字重复之类的问题，那这个时候我们就可以使用 git branch 来查看一下相关的分支了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch：查看本地所有分支信息</span><br><span class="line">git branch -r：查看远程仓库所有分支</span><br><span class="line">git branch -a：查看本地和远程仓库所有分支</span><br></pre></td></tr></table></figure>
<p>一般来说如果分支太多的话，还是建议使用可视化工具来查看分支信息，比如 vscode 或者 source tree 等软件等等。</p>
<p>当然 IDEA 也是可以的。</p>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>如果我们想以当前分支为基准，创建一个新的分支并切换过去，可以使用如下命令。</p>
<p>创建并切换到指定新分支：git checkout -b branch1</p>
<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>我们在某个分支更改了代码之后，想要把它提交一下，那么你第一步要做的就是，执行 git add</p>
<ul>
<li>git add [file1] [file2]: 添加一个或多个文件到暂存区</li>
</ul>
<p>一般我们平时在使用的时候，用的比较多的应该还是：</p>
<ul>
<li>git add .：把当前目录下得所有文件改动都添加到暂存区</li>
<li>git add -A：把当前仓库内所有文件改动都添加到暂存区</li>
</ul>
<p>对笔者来说，用的最多的还是这个 git add -A 命令，因为大多数情况，我们都应该把所有变更都加到暂存区里，如果没有，那大概率是忘了。</p>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>文件添加到暂存区之后，我们就可以执行下一步操作了。</p>
<ul>
<li>git commit [file1] … -m [message]：将暂存区的内容提交到本地 git 版本仓库中</li>
</ul>
<p>-m 表示的是当前提交的信息<br>-a 对于已经被纳入 git 管理的文件（该文件你之前提交过 commit），那么这个命令就相当于帮你执行了上述 git add -A，你就不用再 add 一下了；对于未被 git 管理过的（也就是新增的文件），那么还是需要你先执行一下 git add -A，才能正确被 commit 到本地 git 库。</p>
<p>通常情况下，我们用的比较多得应该是 git commit -m ‘feat: do something’，设置当前提交的信息。当然，如果你没有强诉求需要 git add 和 git commit 一定要分开，那你大可选择 git commit -am，方便又快捷。</p>
<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>这个其实也挺有用的，比如我们项目中有个文件叫 .env，这个文件是一个私有的，不能被提交到远程的，但是我们不小心提交到了本地仓库中，这个时候我们把这个文件添加到 .gitignore 文件中，表示需要被 git 忽略提交，但是由于我们已经提交到本地仓库了，所以如果不先从 git 仓库删除是没用的。<br>如果直接右键删除，那么这个文件的记录还是会被保存到远端仓库，别人还是能看得到你这个信息，所以我们需要先从 git 仓库中删掉这个文件才行。</p>
<ul>
<li><p>git rm .env：执行完这个命令就表示 .env 文件从 git 仓库中删除了，配合 .gitignore 就能保证以后所有的 .env 文件变更都不用担心被提交到远程仓库。</p>
</li>
<li><p>git rm -r dist：如果我们要删除的是一个目录，那么加上 -r 参数就好了。</p>
</li>
</ul>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>接下来我们想要把刚创建好得分支推送到远端，一般来说我们可能会需要用到 git push，但我们这是个新分支，根本没和远端仓库建立任何联系，那么我们就需要加点参数，让他们关联上：</p>
<ul>
<li>推送分支并建立关联关系：git push –set-upstream origin branch1</li>
</ul>
<p>完事之后我们可以再去远程仓库看一眼就会发现我们创建的新分支已经推上去了。接下来可能会有小伙伴要问了，那如果远端仓库已经有了这个分支名咋整？<br>这里就分两种：</p>
<ol>
<li>一种就是你本地的代码和远端代码没有冲突的情况下，并且你本地有新增提交，那么你可以仍然执行上述命令，这样就会直接将当前本地分支合远程分支关联上，同时把你的改动提交上去。</li>
<li>另一种就是本地分支和远端分支存在冲突，这个时候你执行上述命令就会出现提示冲突，那么接下来就需要你先把远端当前分支的代码拉下来，解决一下冲突了，就需要用到 git pull 命令了。</li>
</ol>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>通常情况下，如果当前分支已经和远端分支建立了联系，那么我们想要合并一下远端分支，只需要执行 git pull 就好了，不用带其他参数，但如果和上面提到的 git push 时产生了冲突，还没有建立联系的时候，我们就需要指定需要拉取哪个分支的代码下来进行合并了。</p>
<ul>
<li>拉取指定远端分支合并到本地当前分支：git pull origin branch1</li>
</ul>
<p>这里的 origin 是我们对远端仓库的命名，想改也是可以的，不过一般都是用的 origin。<br>回到上面提到的冲突问题，我们可以直接使用 git pull 然后指定合并当前本地分支想要建立联系的远程分支，然后本地解决一下冲突，然后提交一下改动，再执行 git push –set-upstream origin branch1 命令就大功告成了。</p>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>了解完上面描述的 git pull，命令之后，其实这个命令也很好理解了，特定时候，可能我们只是想把远端仓库对应分支的变更拉到本地而已，并不想自动合并到我的工作区（你当前正在进行代码变更的工作区），等晚些时候我写完了某部分的代码之后再考虑合并，那么你就可以先使用 git fetch。<br>fetch 完毕之后，我提交了自己当前工作去的变更到本地仓库，然后想合并一下远端分支的更改，这个时候执行一下 git merge origin/[当前分支名]（默认一般是用 origin 表示远端的分支前缀）即可。</p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>合并指定分支代码到当前分支。一般来说，我们用的比较多的场景可能是，远端仓库 master 分支有变更了，同时这个时候我们准备提 MR 了，那么就需要先合一下 master 的代码，有冲突就解决下冲突，那这个时候我们可以做以下操作：</p>
<ol>
<li>切到 master 分支，git pull 拉一下最新代码</li>
<li>切回开发分支，执行 git merge master 合并一下 master 代码</li>
</ol>
<p>同理，上面介绍的 git merge origin/xxx 也是一样的用法。</p>
<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>顾名思义，就是日志的意思，执行这个命令之后，我们能看到当前分支的提交记录信息，比如 commitId 和提交的时间描述等等，大概长下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit e55c4d273141edff401cbc6642fe21e14681c258 (HEAD -&gt; branch1, origin/branch1)</span><br><span class="line">Author: 陌小路 &lt;44311619+STDSuperman@users.noreply.github.com&gt;</span><br><span class="line">Date:   Mon Aug 1 23:16:11 2022 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit</span><br></pre></td></tr></table></figure>
<p>这个时候可能有读者会问了，这个都用来干啥的，简单的用法呢就是看看有谁提交了啥，还有更重要的用法呢就是进行代码版本的回滚，或者其他有意思的操作，且听笔者为你微微道来。</p>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>git reset [–soft | –mixed | –hard] [HEAD]</p>
<h3 id="关于-HEAD："><a href="#关于-HEAD：" class="headerlink" title="关于 HEAD："></a>关于 HEAD：</h3><ul>
<li>HEAD 表示当前版本</li>
<li>HEAD^ 上一个版本</li>
<li>HEAD^^ 上上一个版本</li>
<li>HEAD^^^ 上上上一个版本</li>
<li>HEAD~n 回撤 n 个版本，这种也是更加方便的</li>
</ul>
<h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>以下解析均基于后接参数为 HEAD^，也就是git reset HEAD^。</p>
<ul>
<li>–soft: 重置你最新一次提交版本，不会修改你的暂存区和工作区。</li>
<li>–mixed: 默认参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。</li>
<li>–hard: 重置所有提交到上一个版本，并且修改你的工作区，会彻底回到上一个提交版本，在代码中看不到当前提交的代码，也就是你的工作区改动也被干掉了。</li>
</ul>
<p>说了半天似乎不是很好理解，我们举个栗子理解下：<br>比如：</p>
<ol>
<li>我改动了我的 README 文件，在我们的工作区就产生了一次改动，但是这个时候还没有提交到暂存区，在 vscode 里会显示为工作区修改的标记</li>
<li>接着我们执行 git add，这个时候你查看暂存区，会发现这次改动被提交进去了，同时被 vscode 标记为已被提交至暂存区</li>
<li>然后再执行 git commit，这个时候就完成了一次提交</li>
</ol>
<p>接下来我们想撤回这次提交，以上三种参数所体现的表现会是这样的：</p>
<ul>
<li>–soft：我们对 README 的更改状态现在变成已被提交至暂存区，也就是上面 2 的步骤。</li>
<li>–mixed： 我们对 README 的更改变成还未被提交至暂存区，也就是上面 1 的步骤。</li>
<li>–hard：我们对 README 的所有更改全没了，git log 中也找不到我们对 README 刚刚那次修改的痕迹。</li>
</ul>
<p>默认情况下我们不加参数，就是 –mixed，也就是重置暂存区的文件到上一次提交的版本，文件内容不动。一般会在什么时候用到呢？</p>
<h4 id="场景一（撤销-git-add）"><a href="#场景一（撤销-git-add）" class="headerlink" title="场景一（撤销 git add）"></a>场景一（撤销 git add）</h4><p>可能大部分情况下，比如 vscode 其实大家更习惯于使用可视化的撤销能力，但是呢，这里我们其实也可以稍微了解下这其中的奥秘，其实也很简单：</p>
<ul>
<li>方式一：git reset</li>
<li>方式二：git reset HEAD</li>
</ul>
<p>其实一二都是一样，如果 reset 后面不跟东西就是默认 HEAD。</p>
<h4 id="场景二-撤销-git-commit"><a href="#场景二-撤销-git-commit" class="headerlink" title="场景二 (撤销 git commit)"></a>场景二 (撤销 git commit)</h4><p>当你某个改动提交到本地仓库之后，也就是 commit 之后，这个时候你想撤回来，再改点其他的，那么就可以直接使用 git reset HEAD^。这个时候你会惊奇的发现，你上一版的代码改动，全部变成了未被提交到暂存区的状态，这个时候你再改改代码，然后再提交到暂存区，然后一起再 commit 就可满足你的需求了。<br>除了这种基础用法，我们还可以配合其他命令操作一下。</p>
<h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h4><p>某一天你老板跟你说，昨天新加的功能不要了，给我切回之前的版本看看效果，那么这个时候，你可能就需要将工作区的代码回滚到上一个 commit 版本了，操作也十分简单：</p>
<ul>
<li>git log 查看上一个 commit 记录，并复制 commitId</li>
<li>git reset –hard commitId 直接回滚。</li>
</ul>
<h4 id="场景四"><a href="#场景四" class="headerlink" title="场景四"></a>场景四</h4><p>如果某一个你开发需求正开心呢，突然发现，自己以前改的某个东西怎么不见了，你想起来好像是某次合并，没注意被其他提交冲掉了，你心一想，完了，写了那么多，怎么办？很简单，回到有这份代码的那个版本就好了（前提你提交过到本地仓库）。<br>假设我们有这么两个提交记录，我们需要下面那个 365 开头 commitId 的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit e62b559633387ab3a5324ead416f09bf347d8e4a (HEAD -&gt; master)</span><br><span class="line">Author: xiaohang.lin &lt;xiaohang.lin@alibaba-inc.com&gt;</span><br><span class="line">Date:   Sun Aug 14 18:08:56 2022 +0800</span><br><span class="line"></span><br><span class="line">    merge</span><br><span class="line"></span><br><span class="line">commit 36577ea21d79350845f104eee8ae3e740f19e038 (origin/master, origin/HEAD)</span><br><span class="line">Author: 陌小路 &lt;44311619+STDSuperman@users.noreply.github.com&gt;</span><br><span class="line">Date:   Sun Aug 14 15:57:34 2022 +0800</span><br><span class="line"> </span><br><span class="line">  Update README.md</span><br></pre></td></tr></table></figure>
<ol>
<li>抢救第一步 git log 找到有你这个代码的那个 commitId（也就是 36577ea21d79350845f104eee8ae3e740f19e038）</li>
<li>抢救第二步 git reset –hard commitId</li>
<li>第三步：Ctrl + c 你的目标代码</li>
</ol>
<p>这个时候你想把复制好的代码写回去，该怎么办呢，你可能会再 git log 看一下我们 reset 之前的 commitId，你会发现，完了，之前的 commitId 都没了，只有这个 365 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit 36577ea21d79350845f104eee8ae3e740f19e038 (origin/master, origin/HEAD)</span><br><span class="line">Author: 陌小路 &lt;44311619+STDSuperman@users.noreply.github.com&gt;</span><br><span class="line">Date:   Sun Aug 14 15:57:34 2022 +0800</span><br><span class="line"></span><br><span class="line">Update README.md</span><br></pre></td></tr></table></figure>
<p>不要慌，请记住一句话，只要你不删你本地的 .git 仓库，你都能找回以前所有的提交。</p>
<p>git log 看不到的话，我们就可以祭出我们的绝招了：git reflog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">36577ea (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@&#123;0&#125;: reset: moving to 36577ea21d79350845f104eee8ae3e740f19e038</span><br><span class="line">e62b559 HEAD@&#123;1&#125;: reset: moving to e62b559633387ab3a5324ead416f09bf347d8e4a</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到两行记录，一个是我们执行 reset 到 365 的记录，另一条不知道是啥，不重要，我们想回到我们刚刚 reset 之前的状态也很简单，直接复制它上一次的变动也就是这个 e62b559，然后执行 git reset –hard e62b559，然后你会惊奇的发现，你之前的代码又回来了。</p>
<p>接下来把你以前版本的代码，再 Ctrl + v 放进来就完成了。</p>
<h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>介绍：用来查看你的所有操作记录。<br>既然 git log 看不到我之前 commitId 了，那么就回到 reset 之前的状态吧！</p>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>当然了，如果是针对 master 的操作，为了安全起见，一般还是建议使用 revert 命令，他也能实现和 reset 一样的效果，只不过区别来说，reset 是向后的，而 revert 是向前的，怎么理解呢？简单来说，把这个过程当做一次时光穿梭，reset 表示你犯了一个错，他会带你回到没有犯错之前，而 revert 会给你一个弥补方案，采用这个方案之后让你得到的结果和没犯错之前一样。</p>
<p>举个栗子：<br>假设你改了 README 的描述，新增了一行文字，提交上去了，过一会你觉得这个写了有问题，想要撤销一下，但是又不想之前那个提交消失在当前历史当中，那么你就可以选择使用 git revert [commitId]，那么它就会产生一次新的提交，提交的内容就是帮你删掉你上面新增的内容，相当于是一个互补的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS D:\Code\other\git-practice&gt; git revert 3b18a20ad39eea5264b52f0878efcb4f836931ce</span><br><span class="line">On branch branch2</span><br><span class="line">Your branch is ahead of &apos;origin/branch2&apos; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure>
<p>这个时候，它会提示你可以把新的改动 push 上去了。<br>其实你如果在 gitlab 进行 mr 之后，想要回滚这个 mr，一般它会给你一个 revert 的按钮选项，让你进行更安全的回滚操作。</p>
<h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>其实对于我们工作中大部分场景下应该用不到这个功能，但是呢有的时候这个命令又能挽救你于水火之间，那就是当某个倒霉蛋忘记切分支，然后在 master 分支上改了代码，并且提交到了本地仓库中，这个时候使用git cherry-pick简直就是神器了。</p>
<ul>
<li>git cherry-pick：将执行分支的指定提交合并到当前分支。</li>
</ul>
<p>一听介绍就来精神了，雀氏有点东西，比如我在 master 分支提交了某个需求的代码，同时还没提交到远程分支，那么你就可以先 <code>git log</code>查看一下当前的提交，找到 <code>master</code> 分支正常提交之后的所有 <code>commitId</code>，然后复制出来，然后再切到你建好的开发分支，接着执行 <code>git cherry-pick master commitId1 commitId2 commitId4</code>。<br>完事之后记得清理一下作案现场，把你的 master 分支代码恢复到正常的提交上去。</p>
<h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>顾名思义，也就是打标签的意思。一般可能会在你发布了某个版本，需要给当前版本打个标签，你可以翻阅 vite 的官方 git 仓库，查看它的 tag 信息，它这里就标注了各个版本发布时候的 tag 标签。<br>它有两种标签形式，一种是轻量标签，另一种是附注标签。</p>
<h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><ul>
<li>创建方式：git tag v1.0.0</li>
</ul>
<p>它有点像是对某个提交的引用，从表现上来看，它又有点像基于当前分支提交给你创建了一个不可变的分支，它是支持你直接 checkout 到这个分支上去，但是它和普通分支还是有着本质的区别的，如果你切换到了这个 tag “分支”，你去修改代码同时产生了一次提交，亦或者是 reset 版本，这对于该 tag 本身不会有任何影响，而是为你生成了一个独立的提交，但是却在你的分支历史中是找不到的，你只能通过 commitId 来切换到本次提交，看图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212201169.png" alt></p>
<p>那如果你从其他分支通过 commitId 切换到这个改动上，它会提示你以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note: switching to &apos;be276009&apos;.</span><br><span class="line"></span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by switching back to a branch.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -c with the switch command. Example:</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">Or undo this operation with:</span><br><span class="line"></span><br><span class="line">  git switch -</span><br></pre></td></tr></table></figure>
<p>大致意思就是你可以选择丢弃或者保留当前更改，如果需要保留的话直接使用下面的 git switch 命令创建一个新分支即可。</p>
<h3 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h3><ul>
<li>创建方式：git tag -a v1.0.1 -m “发布正式版 1.0.1”</li>
</ul>
<p>引用官方文档的描述：</p>
<blockquote>
<p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。</p>
</blockquote>
<p>从概念上看，轻量标签更像是一个临时的标签，而附注标签更加正式一点，能够保留更多的信息。它创建的方式和轻量标签区别主要是 -a 和 -m 参数，如果你的 -m 参数不传，那么编辑器会让你手动填写。</p>
<h4 id="对比标签信息"><a href="#对比标签信息" class="headerlink" title="对比标签信息"></a>对比标签信息</h4><p>打完标签之后，我们可以使用 git show 命令来看看这两种标签最终体现的信息有哪些。<br><strong>轻量标签</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit dcbd335be87f51eaa0cc1852400e64e9f46e84d8 (HEAD -&gt; test-branch1, tag: v1.0.2, tag: v1.0.1)</span><br><span class="line">Author: STDSuperman &lt;2750556766@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 16 22:54:36 2022 +0800</span><br><span class="line"></span><br><span class="line">xx</span><br><span class="line"></span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 715766a..b4cdea6 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line">-# git-practice</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+# git-practice</span><br><span class="line">+</span><br><span class="line">+test tag</span><br></pre></td></tr></table></figure>
<p><strong>附注标签</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag v1.0.1</span><br><span class="line">Tagger: STDSuperman &lt;2750556766@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 16 22:58:27 2022 +0800</span><br><span class="line"></span><br><span class="line">发布正式版 1.0.0</span><br><span class="line"></span><br><span class="line">commit dcbd335be87f51eaa0cc1852400e64e9f46e84d8 (HEAD -&gt; test-branch1, tag: v1.0.1)</span><br><span class="line">Author: STDSuperman &lt;2750556766@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 16 22:54:36 2022 +0800</span><br><span class="line"></span><br><span class="line">xx</span><br><span class="line"></span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 715766a..b4cdea6 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br></pre></td></tr></table></figure>
<p>从信息丰富度上来说，附注标签能保留的信息会更多。</p>
<h3 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h3><ul>
<li>git push origin tagName</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&gt; git push origin v1.0.1</span><br><span class="line">Enumerating objects: 6, done.</span><br><span class="line">Counting objects: 100% (6/6), done.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (4/4), 448 bytes | 448.00 KiB/s, done.</span><br><span class="line">Total 4 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To github.com:STDSuperman/git-practice.git</span><br><span class="line"></span><br><span class="line">* [new tag]         v1.0.1 -&gt; v1.0.1</span><br></pre></td></tr></table></figure>
<p>当然，附注标签和轻量标签都是可以被推送到远端的。</p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul>
<li>查看标签：git tag</li>
<li>筛选标签：git tag -l v1.0.1</li>
<li>删除标签：git tag -d v1.0.1</li>
<li><p>删除远程标签：git push origin –delete v1.0.2</p>
</li>
<li><p>另一种删除远程方式（表示将“:”前面空值替换到远程，也不失为一种方式）：<code>git push origin :refs/tags/v1.0.1</code></p>
</li>
</ul>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>使用 Git 已经好几年了，却始终只是熟悉一些常用的操作。对于 Git Rebase 却很少用到，直到这一次，不得不用。</p>
<h4 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h4><p>上线构建的过程中扫了一眼代码变更，突然发现，commit 提交竟然多达 62 次。我们来看看都提交了什么东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212207584.png" alt></p>
<p>这里我们先不说 git 提交规范，就单纯这么多次无用的 commit 就很让人不舒服。可能很多人觉得无所谓，无非是多了一些提交纪录。</p>
<p>然而，并非如此，你可能听过破窗效应，编程也是如此！</p>
<h4 id="二、导致问题"><a href="#二、导致问题" class="headerlink" title="二、导致问题"></a>二、导致问题</h4><ol>
<li><p>不利于代码 review<br>设想一下，你要做 code review ，结果一个很小的功能，提交了 60 多次，会不会有一些崩溃？</p>
</li>
<li><p>会造成分支污染<br>你的项目充满了无用的 commit 纪录，如果有一天线上出现了紧急问题，你需要回滚代码，却发现海量的 commit 需要一条条来看。</p>
</li>
</ol>
<p>遵循项目规范才能提高团队协作效率，而不是随心所欲。</p>
<h4 id="三、Rebase-场景一：如何合并多次提交纪录？"><a href="#三、Rebase-场景一：如何合并多次提交纪录？" class="headerlink" title="三、Rebase 场景一：如何合并多次提交纪录？"></a>三、Rebase 场景一：如何合并多次提交纪录？</h4><p>基于上面所说问题，我们不难想到：每一次功能开发， 对多个 commit 进行合并处理。</p>
<p>这时候就需要用到 git rebase 了。这个命令没有太难，不常用可能源于不熟悉，所以我们来通过示例学习一下。</p>
<p>1.我们来合并最近的 4 次提交纪录，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure>
<p>2.这时候，会自动进入 vi 编辑模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s cacc52da add: qrcode</span><br><span class="line">s f072ef48 update: indexeddb hack</span><br><span class="line">s 4e84901a feat: add indexedDB floder</span><br><span class="line">s 8f33126c feat: add test2.js</span><br><span class="line"></span><br><span class="line"># Rebase 5f2452b2..8f33126c onto 5f2452b2 (4 commands)</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Commands:</span><br><span class="line"></span><br><span class="line"># p, pick = use commit</span><br><span class="line"></span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"></span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"></span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"></span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"></span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"></span><br><span class="line"># d, drop = remove commit</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line"></span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>有几个命令需要注意一下：</p>
<ul>
<li>p, pick = use commit</li>
<li>r, reword = use commit, but edit the commit message</li>
<li>e, edit = use commit, but stop for amending</li>
<li>s, squash = use commit, but meld into previous commit</li>
<li>f, fixup = like “squash”, but discard this commit’s log message</li>
<li>x, exec = run command (the rest of the line) using shell</li>
<li>d, drop = remove commit<br>按照如上命令来修改你的提交纪录：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s cacc52da add: qrcode</span><br><span class="line">s f072ef48 update: indexeddb hack</span><br><span class="line">s 4e84901a feat: add indexedDB floder</span><br><span class="line">p 8f33126c feat: add test2.js</span><br></pre></td></tr></table></figure>
<p>3.如果保存的时候，你碰到了这个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: cannot &apos;squash&apos; without a previous commit</span><br></pre></td></tr></table></figure>
<p>注意不要合并先前提交的东西，也就是已经提交远程分支的纪录。</p>
<p>4.如果你异常退出了 vi 窗口，不要紧张：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --edit-todo</span><br></pre></td></tr></table></figure>
<p>这时候会一直处在这个编辑的模式里，我们可以回去继续编辑，修改完保存一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>
<p>5.查看结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>三次提交合并成了一次，减少了无用的提交信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212211635.png" alt></p>
<h4 id="四、Rebase-场景二：分支合并"><a href="#四、Rebase-场景二：分支合并" class="headerlink" title="四、Rebase 场景二：分支合并"></a>四、Rebase 场景二：分支合并</h4><p>1.我们先从 master 分支切出一个 dev 分支，进行开发：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:(master) git checkout -b feature1</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212212787.png" alt><br>2.这时候，你的同事完成了一次 <code>hotfix</code>，并合并入了 <code>master</code> 分支，此时 <code>master</code>已经领先于你的<code>feature1</code> 分支了：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212213205.png" alt><br>3.恰巧，我们想要同步 master 分支的改动，首先想到了 merge，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:(feature1) git merge master</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212213592.png" alt><br>图中绿色的点就是我们合并之后的结果，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:(feature1) git log</span><br></pre></td></tr></table></figure>
<p>就会在记录里发现一些 merge 的信息，但是我们觉得这样污染了 commit 记录，想要保持一份干净的 commit，怎么办呢？这时候，git rebase 就派上用场了。</p>
<p>4.让我们来试试 git rebase ，先回退到同事 hotfix 后合并 master 的步骤：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212214539.png" alt><br>5.使用 rebase 后来看看结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:(feature1) git rebase master</span><br></pre></td></tr></table></figure>
<p>这里补充一点：rebase 做了什么操作呢？</p>
<p>首先，git 会把 feature1 分支里面的每个 commit 取消掉；<br>其次，把上面的操作临时保存成 patch 文件，存在 .git/rebase 目录下；<br>然后，把 feature1 分支更新到最新的 master 分支；<br>最后，把上面保存的 patch 文件应用到 feature1 分支上；</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212215385.png" alt></p>
<p>从 commit 记录我们可以看出来，feature1 分支是基于 hotfix 合并后的 master ，自然而然的成为了最领先的分支，而且没有 merge 的 commit 记录，是不是感觉很舒服了。</p>
<p>6.在 rebase 的过程中，也许会出现冲突 conflict。在这种情况，git 会停止 rebase 并会让你去解决冲突。在解决完冲突后，用 git add 命令去更新这些内容。</p>
<p>注意，你无需执行 git-commit，只要执行 continue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>
<p>这样 git 会继续应用余下的 patch 补丁文件。</p>
<p>7.在任何时候，我们都可以用 –abort 参数来终止 rebase 的行动，并且分支会回到 rebase 开始前的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase —abort</span><br></pre></td></tr></table></figure>
<h4 id="五、更多-Rebase-的使用场景"><a href="#五、更多-Rebase-的使用场景" class="headerlink" title="五、更多 Rebase 的使用场景"></a>五、更多 Rebase 的使用场景</h4><p>git-rebase 存在的价值是：对一个分支做「变基」操作。</p>
<p>1.当我们在一个过时的分支上面开发的时候，执行 rebase 以此同步 master 分支最新变动；<br>2.假如我们要启动一个放置了很久的并行工作，现在有时间来继续这件事情，很显然这个分支已经落后了。这时候需要在最新的基准上面开始工作，所以 rebase 是最合适的选择。</p>
<h4 id="六、为什么会是危险操作？"><a href="#六、为什么会是危险操作？" class="headerlink" title="六、为什么会是危险操作？"></a>六、为什么会是危险操作？</h4><p>根据上文来看，git-rebase 很完美，解决了我们的两个问题：<br>1.合并 commit 记录，保持分支整洁；<br>2.相比 merge 来说会减少分支合并的记录；</p>
<p>如果你提交了代码到远程，提交前是这样的：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212216598.png" alt></p>
<p>提交后远程分支变成了这样：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212216406.png" alt></p>
<p>而此时你的同事也在 feature1 上开发，他的分支依然还是：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212217646.png" alt></p>
<p>那么当他 pull 远程 master 的时候，就会有丢失提交纪录。这就是为什么我们经常听到有人说 git rebase 是一个危险命令，因为它改变了历史，我们应该谨慎使用。</p>
<p>除非你可以肯定该 feature1 分支只有你自己使用，否则请谨慎操作。</p>
<p>结论：只要你的分支上需要 rebase 的所有 commits 历史还没有被 push 过，就可以安全地使用 git-rebase来操作。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>你需要知道的前端鉴权方式</title>
    <url>/2021/08/27/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%89%8D%E7%AB%AF%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 web 开发中，鉴权是非常常用的。而且鉴权的方式也有很多种，有各自的优缺点和使用场景。这里笔者就对当下几种常用的鉴权手段进行一个整理，方便大家的学习巩固和自己的复习<a id="more"></a></p>
<h2 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a>HTTP Basic Authentication</h2><p>这种授权方式是浏览器遵守 http 协议实现的基本授权方式,HTTP 协议进行通信的过程中，HTTP 协议定义了基本认证认证允许 HTTP 服务器对客户端进行用户身份证的方法。</p>
<p><strong>认证过程：</strong> </p>
<p>1． 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个 ajax 异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get /index.html HTTP/1.0</span><br><span class="line">Host:www.google.com</span><br></pre></td></tr></table></figure>
<p>2． <strong>服务器向客户端发送验证请求代码 401</strong>,（<code>WWW-Authenticate: Basic realm=”google.com”</code>这句话是关键，如果没有客户端不会<strong>弹出用户名和密码输入界面</strong>）服务器返回的数据大抵如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 401 Unauthorised</span><br><span class="line">Server: SokEvo/1.0</span><br><span class="line">WWW-Authenticate: Basic realm=”google.com”</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: xxx</span><br></pre></td></tr></table></figure>
<p>3． 当符合 http1.0 或 1.1 规范的客户端（如 IE，FIREFOX）收到 401 返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。</p>
<p>4． 用户输入用户名和密码后，将<strong>用户名及密码以 BASE64 加密方式加密(base64 不安全!)</strong>，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get /index.html HTTP/1.0</span><br><span class="line">Host:www.google.com</span><br><span class="line">Authorization: Basic d2FuZzp3YW5n</span><br></pre></td></tr></table></figure>
<p>注：d2FuZzp3YW5n 表示加密后的用户名及密码（用户名：密码 然后通过 base64 加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）</p>
<p>5． 服务器收到上述请求信息后，将 Authorization 字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端</p>
<p>效果：<br>客户端未未认证的时候，会弹出用户名密码输入框，这个时候请求时属于 pending 状态， 这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带 Authentication 头的请求。</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/20210827065501.png" alt></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/20210827065408.png" alt></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/20210827065546.png" alt></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/blog/20210827065740.png" alt></p>
<p>当然有登陆就有注销，我们会发现当我们认证成功后每次请求请求头都会带上 Authentication 及里面的内容，那么如何做到让这次登陆失效的？</p>
<p>网上查了半天，目前最有效的方式就是在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的 Authentication 信息为注销用户名密码的时候纠就带便注销成功了，而客户端在注销操作的时候，手动的的去修改请求头重的 Authentication，将他设置未服务器默认的注销账号和密码。</p>
<p>通过上面的简单讲解 其实我们已经可以返现这种验证方式的缺陷加密方式简单，仅仅是 base64 加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。</p>
<p>总结:</p>
<p>正式因为这样，这种加密方式一般多被用在内部安全性要求不高的的系统上，只是相对的多，总的来说现在使用这种鉴权比较少了。如果项目需要部署在公网上，这种方式不推荐。</p>
<h2 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session-cookie"></a>session-cookie</h2><p>第二种这个方式是利用服务器端的 session（会话）和浏览器端的 cookie 来实现前后端的认证，由于 http 请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话(seesion),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建 seesion，如果有则已经认证成功了，否则就没有认证。<br>session-cookie 认证主要分四步：</p>
<ol>
<li><p>服务器在接受客户端首次访问时在服务器端创建 seesion，然后保存 seesion(我们可以将 seesion 保存在内存中，也可以保存在 redis 中，推荐使用后者)，然后给这个 session 生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。</p>
</li>
<li><p>签名。这一步只是对 sid 进行加密处理，服务端会根据这个 secret 密钥进行解密。（非必需步骤）</p>
</li>
<li><p>浏览器中收到请求响应的时候会解析响应头，然后将 sid 保存在本地 cookie 中，浏览器在下次 http 请求 de 请求头中会带上该域名下的 cookie 信息，</p>
</li>
<li><p>服务器在接受客户端请求时会去解析请求头 cookie 中的 sid，然后根据这个 sid 去找服务器端保存的该客户端的 session，然后判断该请求是否合法。<br><img src="https://gitee.com/wangyuan0108/image/raw/master/blog/20210827070926.png" alt></p>
</li>
</ol>
<h2 id="Token（jwt"><a href="#Token（jwt" class="headerlink" title="Token（jwt)"></a>Token（jwt)</h2><p>使用基于 Token 的身份验证方法，大概的流程是这样的：</p>
<ul>
<li><p>客户端使用用户名跟密码请求登录</p>
</li>
<li><p>服务端收到请求，去验证用户名与密码</p>
</li>
<li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p>
</li>
<li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p>
</li>
<li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p>
</li>
<li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p>
</li>
</ul>
<p>总的来说就是客户端在首次登陆以后，服务端再次接收 http 请求的时候，就只认 token 了，请求只要每次把 token 带上就行了，服务器端会拦截所有的请求，然后校验 token 的合法性，合法就放行，不合法就返回 401（鉴权失败）。</p>
<p>乍的一看好像和前面的 seesion-cookie 有点像，seesion-cookie 是通过 seesionid 来作为浏览器和服务端的链接桥梁，而 token 验证方式貌似是 token 来起到 seesionid 的角色。其实这两者差别是很大的。</p>
<ol>
<li>sessionid 他只是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的 seesion，这里面才保存着用户的登陆状态。但是 token 本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个 token 是否合法就行。</li>
<li>session-cookie 是需要 cookie 配合的，居然要 cookie，那么在 http 代理客户端的选择上就是只有浏览器了，因为只有浏览器才会去解析请求响应头里面的 cookie,然后每次请求再默认带上该域名下的 cookie。但是我们知道 http 代理客户端不只有浏览器，还有原生 APP 等等，这个时候 cookie 是不起作用的，或者浏览器端是可以禁止 cookie 的(虽然可以，但是这基本上是属于吃饱没事干的人干的事)…，但是 token 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的 cookie,storage，或者内存中，然后再下一次请求的请求头重带上这个 token 就行了。简单点来说 cookie-session 机制他限制了客户端的类型，而 token 验证机制丰富了客户端类型。</li>
<li>时效性。session-cookie 的 sessionid 实在登陆的时候生成的而且在登出事时一直不变的，在一定程度上安全就会低，而 token 是可以在一段时间内动态改变的。</li>
<li>可扩展性。token 验证本身是比较灵活的，一是 token 的解决方案有许多，常用的是 JWT,二来我们可以基于 token 验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。</li>
</ol>
<p>下面就拿最常用的 <code>JWT（JSON WEB TOKEN）</code>来说：</p>
<p>JWT 是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成 json 对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个 token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。<br>JWT 对象通常由三部分构成：</p>
<ul>
<li>Headers： 包括类别（typ）、加密算法（alg）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">&quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Claims ：包括需要传递的用户信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">&quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">&quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Signature： 根据 alg 算法与私有秘钥进行加密得到的签名字串， 这一段是最重要的敏感信息，只能在服务端解密；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(  </span><br><span class="line"> base64UrlEncode(Headers) + &quot;.&quot; +</span><br><span class="line">base64UrlEncode(Claims),</span><br><span class="line">SECREATE_KEY</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>编码之后的 JWT 看起来是这样的一串字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>
<h2 id="OAuth-开放授权"><a href="#OAuth-开放授权" class="headerlink" title="OAuth(开放授权)"></a>OAuth(开放授权)</h2><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供 OAuth 认证服务的厂商有支付宝，QQ,微信。<br>OAuth 协议又有 1.0 和 2.0 两个版本。相比较 1.0 版，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。</p>
<p>假设是微信授权登录，OAuth 2.0 涉及的关键参与方有：</p>
<ul>
<li>Resource Owner：资源所有者。这里指微信用户。</li>
<li>Third-party application：第三方应用。这里指个人网站。。</li>
<li>Authorization server：授权服务器。这里指微信开放平台的授权服务。</li>
<li>Resource server：资源服务器，用来存储、获取用户资源。这里指的是微信开放平台的服务器。</li>
</ul>
<p>OAuth 的基本流程</p>
<p>OAuth2.0 主要包含两个关键步骤：</p>
<ol>
<li>第三方应用取得用户的授权</li>
<li>第三方应用访问用户资源</li>
</ol>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/blog/20210827071851.png" alt></p>
<p>如图所示，access token 的获取分为两步：</p>
<ol>
<li>获取授权码 code，这是临时授权凭证：步骤 A、B、C、D</li>
<li>通过 code 交换 access token，这是正式授权凭证：步骤 E、F<br>获取 access token 是重点</li>
</ol>
<p>1、请求用户授权<br>第三方应用，将资源所有者导向一个特定的地址，并在地址里带上如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response_type：必选，请求类型。这里固定为&quot;code&quot;。</span><br><span class="line">client_id：必选，标识第三方应用的id。很多地方也用apppid来代替。</span><br><span class="line">edirect_uri：可选，授权完成后重定向的地址。当取得用户授权后，授权服务会重定向到这个地址，并在地址里带上授权码。</span><br><span class="line">scope：可选，第三方请求的资源范围。比如是想获取基本信息、敏感信息等。</span><br><span class="line">state：推荐，用于状态保持，可以是任意字符串。授权服务会原封不动地返回。</span><br></pre></td></tr></table></figure>
<p>对于redirect_uri是可选的，大家可能会有疑惑。在实际中，redirect_uri 一般在应用后台就完成了填写和验证，因此可以是选填的。</p>
<p>2、用户授权返回<br>资源所有者，同意授权第三方应用访问受限资源后，请求返回，跳转到 redirect_uri 指定的地址。<br>地址中带了如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code：必选，授权码。后续步骤中，用来交换access token。</span><br><span class="line">state：必选（如果授权请求中，带上了state），这里原封不动地回传。</span><br></pre></td></tr></table></figure>
<p>3、请求 access token<br>第三方应用，向授权服务请求获取 access token。请求参数包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant_type：必选，许可类型，这里固定为“authorization_code”。</span><br><span class="line">code：必选，授权码。在用户授权步骤中，授权服务返回的。</span><br><span class="line">redirect_uri：必选，如果在授权请求步骤中，带上了redirect_uri，那么这里也必须带上，且值相同。</span><br><span class="line">client_id：必选，第三方应用id。</span><br></pre></td></tr></table></figure>
<p>4、返回 access token<br>请求合法且授权验证通过，那么授权服务将 access token 返回给第三方应用。<br>关键返回字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">access token：必选，访问令牌，第三方应用访问用户资源的凭证。</span><br><span class="line">expires_in：推荐，access token的有效时长。</span><br><span class="line">refresh token：可选，更新access token的凭证。当access token过期，可以refresh token为凭证，获取新的access token。</span><br></pre></td></tr></table></figure>
<p>下图为微信统一登录的时序图：</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/20211015153839.png" alt></p>
<p>步骤分解如下：</p>
<p>1、请求用户授权：步骤 2、3、4<br>带上 appid、redirect_uri、response_type、scope、state。其中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appid：应用id，就是前面提到的client_id。</span><br><span class="line">redirect_uri：授权回调的地址，在微信管理后台填写。</span><br><span class="line">response_type：响应类型，固定为&quot;code&quot;。</span><br><span class="line">scope：授权许可范围，固定为&quot;snsapi_login&quot;。</span><br><span class="line">state：可选，授权服务回传。</span><br></pre></td></tr></table></figure>
<p>2、用户授权返回：步骤 5<br>用户同意授权，重定向到 redirect_uri， 并返回临时票据 code。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redirect_uri?code=CODE&amp;state=STATE</span><br></pre></td></tr></table></figure>
<p>3、请求 access token<br>应用拿到临时票据后，用临时票据去换取真实票据 access token。所需参数如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appid：必选，应用id。</span><br><span class="line">secret：必选，应用秘钥，在微信后台生成。</span><br><span class="line">code：必选，前面获取的授权码。</span><br><span class="line">grant_type：必选，值固定为&quot;authorization_code&quot;</span><br></pre></td></tr></table></figure></p>
<p>4、返回 access token<br>微信后台经过验证，确认请求合法后，将 access token 返回给第三方应用。<br>返回例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span><br><span class="line">&quot;expires_in&quot;:7200,</span><br><span class="line">&quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">&quot;openid&quot;:&quot;OPENID&quot;,</span><br><span class="line">&quot;scope&quot;:&quot;SCOPE&quot;,</span><br><span class="line">&quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除前面提到的 access_token、refresh_token、expires_in，这里还返回了 openid、unionid，这两者是用户信息，微信体系特有的。</p>
<h2 id="sso（单点登录鉴权）"><a href="#sso（单点登录鉴权）" class="headerlink" title="sso（单点登录鉴权）"></a>sso（单点登录鉴权）</h2>]]></content>
      <categories>
        <category>WEB 前端</category>
      </categories>
  </entry>
  <entry>
    <title>你需要知道的在小程序中使用cookie</title>
    <url>/2021/07/29/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8cookie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近由于项目需要，需要开发一个h5。然后这h5是内嵌到小程序中使用的，在小程序中的web-view使用h5也是遇到了一些问题，主要是cookie的共享问题，还有一些奇怪的现象，这里简单记录下，方便遇到同样问题的有个参考<a id="more"></a></p>
<p>小程序中的cookie是无法带到接口上的</p>
<p>由于受到web开发的思路影响，觉得只要设置了cookie，那么在请求的时候就会自动带上cookie。在写小程序的cookie鉴权的时候，当时也是这样想的，但是事实是虽然是可以写入cookie，不过在请求接口的时候并不会自动带上cookie。果然还是太年轻了。</p>
<h2 id="小程序请求如何带上cookie"><a href="#小程序请求如何带上cookie" class="headerlink" title="小程序请求如何带上cookie"></a>小程序请求如何带上cookie</h2><p>因为请求不能够自动带上cookie，那就没得办法只能手动把cookie存下来然后在写入到请求头中，让每个请求都带上cookie</p>
<p>这样小程序的每次接口请求就都带上了cookie和web端的请求自动带cookie就功能相同了</p>
<h2 id="web-view中的h5如何使用cookie达到同步鉴权"><a href="#web-view中的h5如何使用cookie达到同步鉴权" class="headerlink" title="web-view中的h5如何使用cookie达到同步鉴权"></a>web-view中的h5如何使用cookie达到同步鉴权</h2><p>按照正常思路，最好的方式就是h5中能够直接获取到小程序中的cookie。这样就简单了，但是小程序是不会让你如愿的。事实证明你在h5是无法拿到cookie。因为它们是两个独立的域，可以理解为小程序调用的是原生的能力，来发请求的，而且小程序的运行机制和web也不一样，web-view中的h5拿不到cookie倒是也能理解。然而小程序中的web-view和微信中直接打开的h5，因为用的是同一个浏览器内核，所以，它们的cookie、storage是可以共享的。</p>
<p>但是这个cookie是无论如何又需要共享的，所以还是要来解决这个问题。那没有办法，那就在跳转到web-view中页面的时候把小程序中的cookie作为url的参数传递过去，然后在h5中把cookie拿到，然后存储到cookie中。自此cookie共享就完成了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie = `cookie=$&#123;history.location.query.cookie&#125;`;</span><br></pre></td></tr></table></figure>
<p>这样就把cookie共享搞定了。</p>
<h2 id="使用js-cookie库设置的cookie在web-view中不生效"><a href="#使用js-cookie库设置的cookie在web-view中不生效" class="headerlink" title="使用js-cookie库设置的cookie在web-view中不生效"></a>使用js-cookie库设置的cookie在web-view中不生效</h2><p>有简单的设置cookie的包，那就拿来用一下喽。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add js-cookie</span><br><span class="line">​</span><br><span class="line">import cookies from &apos;js-cookie&apos;</span><br><span class="line">​</span><br><span class="line">cookies.set(&apos;key&apos;,value)</span><br></pre></td></tr></table></figure>
<p>这样cookie就设置成功了，h5在浏览器中使用也是生效的。但是当把h5接入到web-view中就出现问题了。看了下js-cookie的源码实现，发现也就多了加解码的过程保证字符串不改变，按道理是没有什么问题的。所以这里还是使用了原生的方式来写cookie，用这个库的老铁遇到这个问题可以先用原生的方法代替，具体为什么有知道的大佬告诉我一下，我也在找找是什么原因</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>大概记录下小程序和web-view共享cookie遇到的问题和解决方法，对自己是个记录，希望对你有所帮助，欢迎点赞！！！谢谢！！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>使用umijs开发移动端h5</title>
    <url>/2021/07/05/%E4%BD%BF%E7%94%A8umijs%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AFh5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于最近业务原因，需要开发一些移动端h5页面。之前是使用vue技术栈开发，这里因为一些原因需要使用react技术栈开发，在后台系统方面这里选择的是umijs作为开发框架。所以在h5开发的也选用umijs来进行开发，这里记录下框架搭建的基础过程，方便直接使用，少走弯路<a id="more"></a></p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>首先得有 <a href="https://nodejs.org/en/" rel="external nofollow noopener noreferrer" target="_blank">node</a>，并确保 node 版本是 10.13 或以上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">v10.13.0</span><br></pre></td></tr></table></figure>
<h4 id="使用脚手架创建"><a href="#使用脚手架创建" class="headerlink" title="使用脚手架创建"></a>使用脚手架创建</h4><ul>
<li>先创建一个目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir myapp &amp;&amp; cd myapp</span><br></pre></td></tr></table></figure>
<ul>
<li>通过脚手架创建项目</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn create @umijs/umi-app</span><br><span class="line"># 或 npx @umijs/create-umi-app</span><br><span class="line"></span><br><span class="line">Copy:  .editorconfig</span><br><span class="line">Write: .gitignore</span><br><span class="line">Copy:  .prettierignore</span><br><span class="line">Copy:  .prettierrc</span><br><span class="line">Write: .umirc.ts</span><br><span class="line">Copy:  mock/.gitkeep</span><br><span class="line">Write: package.json</span><br><span class="line">Copy:  README.md</span><br><span class="line">Copy:  src/pages/index.less</span><br><span class="line">Copy:  src/pages/index.tsx</span><br><span class="line">Copy:  tsconfig.json</span><br><span class="line">Copy:  typings.d.ts</span><br></pre></td></tr></table></figure>
<ul>
<li>安装依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn</span><br><span class="line"></span><br><span class="line">yarn install v1.21.1</span><br><span class="line">[1/4] 🔍  Resolving packages...</span><br><span class="line">success Already up-to-date.</span><br><span class="line">✨  Done in 0.71s.</span><br></pre></td></tr></table></figure>
<ul>
<li>启动项目</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn start</span><br><span class="line"></span><br><span class="line">Starting the development server...</span><br><span class="line"></span><br><span class="line">✔ Webpack</span><br><span class="line">  Compiled successfully in 17.84s</span><br><span class="line"></span><br><span class="line"> DONE  Compiled successfully in 17842ms                                       8:06:31 PM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  App running at:</span><br><span class="line">  - Local:   http://localhost:8000 (copied to clipboard)</span><br><span class="line">  - Network: http://192.168.12.34:8000</span><br></pre></td></tr></table></figure>
<h2 id="配置h5相关"><a href="#配置h5相关" class="headerlink" title="配置h5相关"></a>配置h5相关</h2><h4 id="配置移动端适配"><a href="#配置移动端适配" class="headerlink" title="配置移动端适配"></a>配置移动端适配</h4><p>这里使用的是rem适配的方案，这个适配也可以改成其他的比如vw合vh。大家自行百度，就不多说了。rem适配的方案需要安装<code>amfe-flexible</code>和<code>postcss-pxtorem</code>。 前一个是用来缩放根节点字体大小的，后面一个是对css的px单位进行转换成对应的rem单位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add amfe-flexible</span><br><span class="line">yarn add postcss-pxtorem --dev</span><br></pre></td></tr></table></figure>
<p>然后在global.js中引入amfe-flexible</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;amfe-flexible/index&apos;</span><br></pre></td></tr></table></figure>
<p>global.js这个文件是全局的js文件，详细说明请参看umijs的文档</p>
<p>在使用postcss-pxtorem插件的时候需要配置转换的参考基数，大部分是以750px的设计稿来作为参考，这里就写下750px作为参考的配置，在umijs的配置文件.umirc.js中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">extraPostCSSPlugins: [</span><br><span class="line">    pxtorem(&#123;</span><br><span class="line">      rootValue: <span class="number">75</span>, <span class="comment">// 换算的基数</span></span><br><span class="line">      <span class="comment">// 忽略转换正则匹配项。插件会转化所有的样式的px。比如引入了三方UI，也会被转化。目前我使用 selectorBlackList字段，来过滤</span></span><br><span class="line">      <span class="comment">//如果个别地方不想转化px。可以简单的使用大写的 PX 或 Px 。</span></span><br><span class="line">      <span class="comment">// selectorBlackList: ["am"],</span></span><br><span class="line">      exclude: <span class="regexp">/node_modules/i</span>,</span><br><span class="line">      propList: [<span class="string">'*'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure>
<h4 id="ui库"><a href="#ui库" class="headerlink" title="ui库"></a>ui库</h4><p>移动端的ui库也没有多少，大家可以选用自己喜欢的。这里umijs中集成了antd-mobile，所以就直接使用这个库了。</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>本地开发需要配置代理，在配置文件.umirc.js中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    &apos;/api&apos;: &#123;</span><br><span class="line">      target: &apos;http:/www.baidu.com/&apos;,</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">      pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h4 id="调试日志"><a href="#调试日志" class="headerlink" title="调试日志"></a>调试日志</h4><p>由于移动端h5要在移动端打开进行调试，所以调试起来如果看不到日志也是非常麻烦的。这里使用vconsole库让移动端显示出调试日志</p>
<ul>
<li>安装vconsole</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add vconsole --dev</span><br></pre></td></tr></table></figure>
<ul>
<li>使用vconsole</li>
</ul>
<p>在global.js中实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import VConsole from &apos;vconsole&apos;;</span><br><span class="line">new VConsole();</span><br></pre></td></tr></table></figure>
<h4 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h4><p>如果直接是部署在服务器根路径，直接打包生成dist目录就行了。如果不是根目录还需要添加一些配置如下，在.umirc.js中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据环境进行区分</span></span><br><span class="line">publicPath: process.env.NODE_ENV === <span class="string">'development'</span> ? <span class="string">'/'</span> : <span class="string">'/h5/'</span>,</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以上步骤，一个简单的umijs开发h5的基础框架就算完成了，可以进行业务开发了，希望对大家有帮助，觉得有帮助的给个赞，谢谢！！！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>umijs</tag>
      </tags>
  </entry>
  <entry>
    <title>你需要知道的vue开发公众号网页</title>
    <url>/2021/05/11/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84vue%E5%BC%80%E5%8F%91%E5%85%AC%E4%BC%97%E5%8F%B7%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>因为项目需要，近期做了一个公众号网页开发。在此期间也踩了一些坑，解决这些坑之后，准备对这个项目进行复盘。记录下项目从开发到上线所解决的问题，并对使用vue进行公众号开发的步骤进行一个总结。方便以后有问题进行查阅。希望对你有所帮助<a id="more"></a></p>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>主要就是一个h5页面，涉及的功能不是很难，主要很久没有开发公众号，对整个开发步骤有些生疏。其中包括对微信sdk的调用方式、用户的微信授权和sdk的接入等。主要围绕开发步骤进行梳理。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>因为是一个h5页面，整体而言项目不大，然后在项目技术选型的时候确定使用vue框架进行开发。使用vue开发h5，个人整体感觉还是效率比较高的。在ui库方面选择的是vant库，组件整体而言还是不错的，支持自定义主题方便样式自定义比较适合h5的开发。</p>
<h2 id="通过vue-cli创建项目"><a href="#通过vue-cli创建项目" class="headerlink" title="通过vue-cli创建项目"></a>通过vue-cli创建项目</h2><p>安装脚手架工具<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"># OR</span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure></p>
<p>创建一个项目<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create water_project</span><br></pre></td></tr></table></figure></p>
<p>然后就创建了项目目录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── jsconfig.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   └── index.html</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   ├── api</span><br><span class="line">│   ├── assets</span><br><span class="line">│   ├── components</span><br><span class="line">│   ├── global.less</span><br><span class="line">│   ├── main.js</span><br><span class="line">│   ├── mock</span><br><span class="line">│   ├── router</span><br><span class="line">│   ├── store</span><br><span class="line">│   ├── utils</span><br><span class="line">│   └── views</span><br><span class="line">└── vue.config.js</span><br></pre></td></tr></table></figure></p>
<h2 id="关于移动的适配"><a href="#关于移动的适配" class="headerlink" title="关于移动的适配"></a>关于移动的适配</h2><p>因为是移动端网页，所以需要做适配。网上有很多适配方案这里就不展开说了，主要说下本项目使用的方案是<code>amfe-flexible</code>结合<code>rem</code>来做的，是淘宝的一种解决方案。关于设计稿的单位<code>px</code>转换为<code>rem</code>使用的是<code>postcss</code>的<code>postcss-pxtorem</code>方案。其实用<code>webpack</code>的<code>loader</code>来做也是可以的，具体方案自行百度。</p>
<ol>
<li>安装<code>amfe-flexible</code>包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i amfe-flexible -S</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装<code>postcss-pxtorem</code>插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i postcss-pxtorem -D</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在main.js中引入<code>amfe-flexible</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"amfe-flexible"</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在vue.config.js中配置postcss插件</li>
</ol>
<p>项目中如果没有vue.config.js文件就手动创建一个，这个是vue cli的配置文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      postcss: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">          autoprefixer(),</span><br><span class="line">          pxtorem(&#123;</span><br><span class="line">            rootValue: <span class="number">37.5</span>,</span><br><span class="line">            propList: [<span class="string">"*"</span>],</span><br><span class="line">          &#125;),</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>到此样式适配已经完成，至于rootValue为什么是37.5.主要是为了vant的适配，所以设计稿以375px为参考。如果没有使用第三方ui库可以设计稿以750为参考，此时rootValue为75。</p>
<h2 id="使用-normalize-css"><a href="#使用-normalize-css" class="headerlink" title="使用 normalize.css"></a>使用 normalize.css</h2><p>使用normalize.css来消除浏览器之间的基础样式差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i normalize.css -S</span><br></pre></td></tr></table></figure>
<p>在<code>main.js</code>中引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"normalize.css"</span></span><br></pre></td></tr></table></figure>
<h2 id="接入vant库"><a href="#接入vant库" class="headerlink" title="接入vant库"></a>接入vant库</h2><p>vant是有赞出品的一个ui库，站在巨人的肩膀上效率当然是要快很多。这种第三方库只能作为基础，在有设计稿的情况下要对样式进行定制。简单的样式vant都支持主题定制化还是比较方便的，如果有一些样式没有提供自定义主题，就只能写样式进行覆盖了。</p>
<ul>
<li>下载安装vant</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i vant -S</span><br></pre></td></tr></table></figure>
<ul>
<li>引入组件有3种方式，官网也有介绍，<a href="https://vant-contrib.gitee.io/vant/#/zh-CN/quickstart" rel="external nofollow noopener noreferrer" target="_blank">详情可以查看官网</a>，简单说下使用方式：</li>
</ul>
<h3 id="方式一-自动按需引入组件-推荐"><a href="#方式一-自动按需引入组件-推荐" class="headerlink" title="方式一. 自动按需引入组件 (推荐)"></a>方式一. 自动按需引入组件 (推荐)</h3><p><a href="https://github.com/ant-design/babel-plugin-import" rel="external nofollow noopener noreferrer" target="_blank">babel-plugin-import</a> 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装插件</span></span><br><span class="line">npm i babel-plugin-import -D</span><br><span class="line">// 在.babelrc 中添加配置</span><br><span class="line">// 注意：webpack 1 无需设置 libraryDirectory</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>, &#123;</span><br><span class="line">      <span class="string">"libraryName"</span>: <span class="string">"vant"</span>,</span><br><span class="line">      <span class="string">"libraryDirectory"</span>: <span class="string">"es"</span>,</span><br><span class="line">      <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对于使用 babel7 的用户，可以在 babel.config.js 中配置</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [<span class="string">'import'</span>, &#123;</span><br><span class="line">      libraryName: <span class="string">'vant'</span>,</span><br><span class="line">      libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">      style: <span class="literal">true</span></span><br><span class="line">    &#125;, <span class="string">'vant'</span>]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接着你可以在代码中直接引入 Vant 组件</span></span><br><span class="line"><span class="comment">// 插件会自动将代码转化为方式二中的按需引入形式</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'vant'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="方式二-手动按需引入组件"><a href="#方式二-手动按需引入组件" class="headerlink" title="方式二. 手动按需引入组件"></a>方式二. 手动按需引入组件</h3><p>在不使用插件的情况下，可以手动引入需要的组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'vant/lib/button'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/button/style'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="方式三-导入所有组件"><a href="#方式三-导入所有组件" class="headerlink" title="方式三. 导入所有组件"></a>方式三. 导入所有组件</h3><p>Vant 支持一次性导入所有组件，引入所有组件会增加代码包体积，因此不推荐这种做法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vant <span class="keyword">from</span> <span class="string">'vant'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/index.css'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vant);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 配置按需引入后，将不允许直接导入所有组件。</p>
</blockquote>
<h2 id="定制vant主题"><a href="#定制vant主题" class="headerlink" title="定制vant主题"></a>定制vant主题</h2><h3 id="步骤一-引入样式源文件"><a href="#步骤一-引入样式源文件" class="headerlink" title="步骤一 引入样式源文件"></a>步骤一 引入样式源文件</h3><p>定制主题时，需要引入组件对应的 Less 样式文件，支持按需引入和手动引入两种方式。</p>
<h4 id="按需引入样式（推荐）"><a href="#按需引入样式（推荐）" class="headerlink" title="按需引入样式（推荐）"></a>按需引入样式（推荐）</h4><p>在 babel.config.js 中配置按需引入样式源文件，注意 babel6 不支持按需引入样式，请手动引入样式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'import'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: <span class="string">'vant'</span>,</span><br><span class="line">        libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">        <span class="comment">// 指定样式路径</span></span><br><span class="line">        style: <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>/style/less`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'vant'</span>,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="手动引入样式"><a href="#手动引入样式" class="headerlink" title="手动引入样式"></a>手动引入样式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入全部样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/index.less'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入单个组件样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/button/style/less'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="步骤二-修改样式变量"><a href="#步骤二-修改样式变量" class="headerlink" title="步骤二 修改样式变量"></a>步骤二 修改样式变量</h3><p>使用 Less 提供的 <a href="http://lesscss.org/usage/#using-less-in-the-browser-modify-variables" rel="external nofollow noopener noreferrer" target="_blank">modifyVars</a> 即可对变量进行修改，下面是参考的 webpack 配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="comment">// ...其他 loader 配置</span></span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'less-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            <span class="comment">// 若 less-loader 版本小于 6.0，请移除 lessOptions 这一级，直接配置选项。</span></span><br><span class="line">            lessOptions: &#123;</span><br><span class="line">              modifyVars: &#123;</span><br><span class="line">                <span class="comment">// 直接覆盖变量</span></span><br><span class="line">                <span class="string">'text-color'</span>: <span class="string">'#111'</span>,</span><br><span class="line">                <span class="string">'border-color'</span>: <span class="string">'#eee'</span>,</span><br><span class="line">                <span class="comment">// 或者可以通过 less 文件覆盖（文件路径为绝对路径）</span></span><br><span class="line">                hack: <span class="string">`true; @import "your-less-file-path.less";`</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果 vue-cli 搭建的项目，可以在 <code>vue.config.js</code> 中进行配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      less: &#123;</span><br><span class="line">        <span class="comment">// 若 less-loader 版本小于 6.0，请移除 lessOptions 这一级，直接配置选项。</span></span><br><span class="line">        lessOptions: &#123;</span><br><span class="line">          modifyVars: &#123;</span><br><span class="line">            <span class="comment">// 直接覆盖变量</span></span><br><span class="line">            <span class="string">'text-color'</span>: <span class="string">'#111'</span>,</span><br><span class="line">            <span class="string">'border-color'</span>: <span class="string">'#eee'</span>,</span><br><span class="line">            <span class="comment">// 或者可以通过 less 文件覆盖（文件路径为绝对路径）</span></span><br><span class="line">            hack: <span class="string">`true; @import "your-less-file-path.less";`</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="引入微信jssdk"><a href="#引入微信jssdk" class="headerlink" title="引入微信jssdk"></a>引入微信jssdk</h2><p>引入jsssdk有两种方式，一种是用js链接直接引入，写在index.html中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://res2.wx.qq.com/open/js/jweixin-1.6.0.js "</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在使用的地方就调用window.wx.xxx就能使用sdk提供的方法了。</p>
<p>第二种就是使用npm包的方式</p>
<ul>
<li>安装weixin-js-sdk</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i weixin-js-sdk -S</span><br></pre></td></tr></table></figure>
<ul>
<li>在main.js中使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wx <span class="keyword">from</span> <span class="string">"weixin-js-sdk"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂在vue的原型上方便使用</span></span><br><span class="line">Vue.prototype.$wx = wx;</span><br></pre></td></tr></table></figure>
<p>这样引入之后就可以用this.$wx.xx来使用相应的方法了比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$wx.config(&#123;</span><br><span class="line">         debug: <span class="literal">false</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">         appId: res.data.appId, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">         timestamp: <span class="built_in">String</span>(res.data.timestamp), <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">         nonceStr: <span class="built_in">String</span>(res.data.nonceStr), <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">         signature: res.data.signature, <span class="comment">// 必填，签名，见附录1</span></span><br><span class="line">         jsApiList: [</span><br><span class="line">           <span class="string">"getNetworkType"</span>,</span><br><span class="line">           <span class="string">"getLocation"</span>,</span><br><span class="line">         ], <span class="comment">// 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span></span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="注册验证sdk才可以使用api"><a href="#注册验证sdk才可以使用api" class="headerlink" title="注册验证sdk才可以使用api"></a>注册验证sdk才可以使用api</h3><p>其实注册的重要逻辑都在后端，提供一个获取配置信息的接口，前端直接调用sdk的config方法进行注册就好了。这里把sdk的注册逻辑写在app.vue文件中</p>
<ul>
<li>封装一个注册sdk的方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> getWxJssdkConf() &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.$api.getSdkConfig(&#123;</span><br><span class="line">        url: <span class="built_in">window</span>.location.href.split(<span class="string">"#"</span>)[<span class="number">0</span>],</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$wx.config(&#123;</span><br><span class="line">          debug: <span class="literal">false</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">          appId: res.data.appId, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">          timestamp: <span class="built_in">String</span>(res.data.timestamp), <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">          nonceStr: <span class="built_in">String</span>(res.data.nonceStr), <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">          signature: res.data.signature, <span class="comment">// 必填，签名，见附录1</span></span><br><span class="line">          jsApiList: [</span><br><span class="line">            <span class="string">"getNetworkType"</span>,</span><br><span class="line">            <span class="string">"getLocation"</span>,</span><br><span class="line">          ], <span class="comment">// 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.$wx.ready(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.$wx.checkJsApi(&#123;</span><br><span class="line">            jsApiList: [<span class="string">"getNetworkType"</span>, <span class="string">"getLocation"</span>], <span class="comment">// 需要检测的JS接口列表，所有JS接口列表见附录2,</span></span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">"checkJsApi"</span>, res);</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.$wx.error(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"wx.error"</span>, res);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getWxJssdkConf();</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>其中<code>this.$api.getSdkConfig</code>为调用后台的接口，这里是给api也挂载到了vue的原型上，方便使用不用每个页面都去引入api</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$api = api</span><br></pre></td></tr></table></figure>
<p>在app.vue中注册成功后，就可以使用sdk的api了。</p>
<h2 id="微信的授权"><a href="#微信的授权" class="headerlink" title="微信的授权"></a>微信的授权</h2><p>如果要获取用户的信息，就必须让用户进行授权。在授权的时候使用的是微信提供的接口，<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html" rel="external nofollow noopener noreferrer" target="_blank">详细请看这里</a>，如果是只获取用户的openid只用静默授权就可以了，不用用户主动授权。具体请看文档，这里只需要openid就使用静默授权如下：</p>
<ul>
<li>在需要授权的主入口使用，比如这里是主页Home，要先调用微信的接口获取code，在用code去后端换取openid</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: 获取授权code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getCode() &#123;</span><br><span class="line">      <span class="comment">// 从 window.location.href 中截取 code 并且赋值</span></span><br><span class="line">      <span class="comment">// window.location.href.split('#')[0]</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.location.href.indexOf(<span class="string">"state"</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = qs.parse(</span><br><span class="line">          <span class="built_in">window</span>.location.href.split(<span class="string">"#"</span>)[<span class="number">0</span>].split(<span class="string">"?"</span>)[<span class="number">1</span>]</span><br><span class="line">        ).code;</span><br><span class="line">      &#125; </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.code) &#123;</span><br><span class="line">          <span class="comment">// 存在 code 直接调用接口</span></span><br><span class="line">          <span class="keyword">this</span>.handGetUserInfo(<span class="keyword">this</span>.code);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.handLogin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: 获取用户授权登陆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    handLogin() &#123;</span><br><span class="line">      <span class="comment">// 重定向地址重定到当前页面，在路径获取 code</span></span><br><span class="line">      <span class="keyword">const</span> hrefUrl = <span class="built_in">window</span>.location.href;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.code === <span class="string">""</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.location.replace(<span class="string">`</span></span><br><span class="line"><span class="string">						https://open.weixin.qq.com/connect/oauth2/authorize</span></span><br><span class="line"><span class="string">						?appid=XXXXXXXX</span></span><br><span class="line"><span class="string">						&amp;redirect_uri=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(hrefUrl)&#125;</span></span></span><br><span class="line"><span class="string">						&amp;response_type=code</span></span><br><span class="line"><span class="string">						&amp;scope=snsapi_base</span></span><br><span class="line"><span class="string">						&amp;state=h5#wechat_redirect</span></span><br><span class="line"><span class="string">					`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">code</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    handGetUserInfo(code) &#123;</span><br><span class="line">      <span class="comment">// 调用后台接口</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>这里就是授权的主要逻辑，没啥意外就基本走通了。</p>
<h2 id="断网进行提示"><a href="#断网进行提示" class="headerlink" title="断网进行提示"></a>断网进行提示</h2><p>如果用户的网络断了，就跳转到断网提示页。主要使用的是html提供的方法进行判断，判断逻辑写在app.vue文件中，因为每个页面都会提示，就直接在主入口进行处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"online"</span>, <span class="keyword">this</span>.updateOnlineStatus);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"offline"</span>, <span class="keyword">this</span>.updateOnlineStatus);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line"> methods: &#123;</span><br><span class="line"> 		updateOnlineStatus(e) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; type &#125; = e;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"type=============="</span>, type);</span><br><span class="line">      <span class="keyword">this</span>.onLine = type === <span class="string">"online"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> beforeDestroy() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">"online"</span>, <span class="keyword">this</span>.updateOnlineStatus);</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">"offline"</span>, <span class="keyword">this</span>.updateOnlineStatus);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>主要就是这个方法来检查用户网络连接情况</p>
<h2 id="判断是不是微信打开的网页"><a href="#判断是不是微信打开的网页" class="headerlink" title="判断是不是微信打开的网页"></a>判断是不是微信打开的网页</h2><p>这里主要使用的是vue-router的导航守卫来做的，在跳转之前对浏览器进行判断，如果不是微信内置浏览器就直接跳转到异常提示页</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ua = navigator.userAgent.toLowerCase();</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    to.path !== <span class="string">"/notwx"</span> &amp;&amp;</span><br><span class="line">    !(ua.match(<span class="regexp">/MicroMessenger/i</span>) == <span class="string">"micromessenger"</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    next(<span class="string">"/notwx"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有时跳转页面，页面的滚动高度会保留在上个页面的滚动高度，这里也是在导航守卫中解决的，主动给滚动到顶部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此整个开发流程简单记录完毕，也是对自己开发的一个梳理，也方便以后查阅。希望对看到文章的你有所帮助，个人见解，如有问题欢迎指正，觉得有帮助，欢迎点个赞，谢谢。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>你需要知道的36道js手写</title>
    <url>/2021/04/08/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8436%E9%81%93js%E6%89%8B%E5%86%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="为什么要写这类文章"><a href="#为什么要写这类文章" class="headerlink" title="为什么要写这类文章"></a>为什么要写这类文章</h3><p>作为一个程序员，代码能力毋庸置疑是非常非常重要的，就像现在为什么大厂面试基本都问什么 API 怎么实现可见其重要性。我想说的是居然手写这么重要，那我们就必须掌握它，所以文章标题用了死磕，一点也不过分，也希望不被认为是标题党。</p>
<p>作为一个普通前端，我是真的写不出 Promise A+ 规范，但是没关系，我们可以站在巨人的肩膀上，要相信我们现在要走的路，前人都走过，所以可以找找现在社区已经存在的那些优秀的文章，比如工业聚大佬写的 100 行代码实现 Promises/A+ 规范，找到这些文章后不是收藏夹吃灰，得找个时间踏踏实实的学，一行一行的磨，直到搞懂为止。我现在就是这么干的。<a id="more"></a></p>
<h3 id="能收获什么"><a href="#能收获什么" class="headerlink" title="能收获什么"></a>能收获什么</h3><p>这篇文章总体上分为 2 类手写题，前半部分可以归纳为是常见需求，后半部分则是对现有技术的实现；</p>
<ul>
<li>对常用的需求进行手写实现，比如数据类型判断函数、深拷贝等可以直接用于往后的项目中，提高了项目开发效率；</li>
<li>对现有关键字和 API 的实现，可能需要用到别的知识或 API，比如在写 forEach 的时候用到了无符号位右移的操作，平时都不怎么能够接触到这玩意，现在遇到了就可以顺手把它掌握了。所以手写这些实现能够潜移默化的扩展并巩固自己的 JS 基础；</li>
<li>通过写各种测试用例，你会知道各种 API 的边界情况，比如 Promise.all， 你得考虑到传入参数的各种情况，从而加深了对它们的理解及使用；<h3 id="阅读的时候需要做什么"><a href="#阅读的时候需要做什么" class="headerlink" title="阅读的时候需要做什么"></a>阅读的时候需要做什么</h3></li>
</ul>
<p>阅读的时候，你需要把每行代码都看懂，知道它在干什么，为什么要这么写，能写得更好嘛？比如在写图片懒加载的时候，一般我们都是根据当前元素的位置和视口进行判断是否要加载这张图片，普通程序员写到这就差不多完成了。而大佬程序员则是会多考虑一些细节的东西，比如性能如何更优？代码如何更精简？比如 yeyan1996 写的图片懒加载就多考虑了 2 点：比如图片全部加载完成的时候得把事件监听给移除；比如加载完一张图片的时候，得把当前 img 从 imgList 里移除，起到优化内存的作用。</p>
<p>除了读通代码之外，还可以打开 Chrome 的 Script snippet 去写测试用例跑跑代码，做到更好的理解以及使用。</p>
<p>在看了几篇以及写了很多测试用例的前提下，尝试自己手写实现，看看自己到底掌握了多少。条条大路通罗马，你还能有别的方式实现嘛？或者你能写得比别人更好嘛？</p>
<p>好了，还楞着干啥，开始干活。</p>
<h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><p>typeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function typeOf(obj) &#123;</span><br><span class="line">-   let res = Object.prototype.toString.call(obj).split(&apos; &apos;)[1]</span><br><span class="line">-   res = res.substring(0, res.length - 1).toLowerCase()</span><br><span class="line">-   return res</span><br><span class="line">// 评论区里提到的更好的写法</span><br><span class="line">+   return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line">typeOf([])        // &apos;array&apos;</span><br><span class="line">typeOf(&#123;&#125;)        // &apos;object&apos;</span><br><span class="line">typeOf(new Date)  // &apos;date&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal() &#123;</span><br><span class="line">    this.colors = [&apos;black&apos;, &apos;white&apos;]</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getColor = function() &#123;</span><br><span class="line">    return this.colors</span><br><span class="line">&#125;</span><br><span class="line">function Dog() &#123;&#125;</span><br><span class="line">Dog.prototype =  new Animal()</span><br><span class="line"></span><br><span class="line">let dog1 = new Dog()</span><br><span class="line">dog1.colors.push(&apos;brown&apos;)</span><br><span class="line">let dog2 = new Dog()</span><br><span class="line">console.log(dog2.colors)  // [&apos;black&apos;, &apos;white&apos;, &apos;brown&apos;]</span><br></pre></td></tr></table></figure>
<p>原型链继承存在的问题：</p>
<p>问题1：原型中包含的引用类型属性将被所有实例共享；<br>问题2：子类在实例化的时候不能给父类构造函数传参；</p>
<h3 id="借用构造函数实现继承"><a href="#借用构造函数实现继承" class="headerlink" title="借用构造函数实现继承"></a>借用构造函数实现继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.getName = function() &#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Dog(name) &#123;</span><br><span class="line">    Animal.call(this, name)</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype =  new Animal()</span><br></pre></td></tr></table></figure>
<p>借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.colors = [&apos;black&apos;, &apos;white&apos;]</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getName = function() &#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">function Dog(name, age) &#123;</span><br><span class="line">    Animal.call(this, name)</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype =  new Animal()</span><br><span class="line">Dog.prototype.constructor = Dog</span><br><span class="line"></span><br><span class="line">let dog1 = new Dog(&apos;奶昔&apos;, 2)</span><br><span class="line">dog1.colors.push(&apos;brown&apos;)</span><br><span class="line">let dog2 = new Dog(&apos;哈赤&apos;, 1)</span><br><span class="line">console.log(dog2) </span><br><span class="line">// &#123; name: &quot;哈赤&quot;, colors: [&quot;black&quot;, &quot;white&quot;], age: 1 &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承已经相对完善了，但还是存在问题，它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。</p>
<p>所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。</p>
<p>寄生式组合继承写法上和组合继承基本类似，区别是如下这里：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Dog.prototype =  new Animal()</span><br><span class="line">- Dog.prototype.constructor = Dog</span><br><span class="line"></span><br><span class="line">+ function F() &#123;&#125;</span><br><span class="line">+ F.prototype = Animal.prototype</span><br><span class="line">+ let f = new F()</span><br><span class="line">+ f.constructor = Dog</span><br><span class="line">+ Dog.prototype = f</span><br></pre></td></tr></table></figure></p>
<p>稍微封装下上面添加的代码后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = o</span><br><span class="line">    return new F()</span><br><span class="line">&#125;</span><br><span class="line">function inheritPrototype(child, parent) &#123;</span><br><span class="line">    let prototype = object(parent.prototype)</span><br><span class="line">    prototype.constructor = child</span><br><span class="line">    child.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Dog, Animal)</span><br></pre></td></tr></table></figure></p>
<p>如果你嫌弃上面的代码太多了，还可以基于组合继承的代码改成最简单的寄生式组合继承：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Dog.prototype =  new Animal()</span><br><span class="line">- Dog.prototype.constructor = Dog</span><br><span class="line"></span><br><span class="line">+ Dog.prototype =  Object.create(Animal.prototype)</span><br><span class="line">+ Dog.prototype.constructor = Dog</span><br></pre></td></tr></table></figure></p>
<h3 id="class-实现继承"><a href="#class-实现继承" class="headerlink" title="class 实现继承"></a>class 实现继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125; </span><br><span class="line">    getName() &#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        super(name)</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>ES5 实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var res = arr.filter(function(item, index, array) &#123;</span><br><span class="line">        return array.indexOf(item) === index</span><br><span class="line">    &#125;)</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES6 实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var unique = arr =&gt; [...new Set(arr)]</span><br></pre></td></tr></table></figure></p>
<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, [2, [3]]].flat(2)  // [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>现在就是要实现 flat 这种效果。</p>
<p>ES5 实现：递归。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function flatten(arr) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (Array.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES6 实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function flatten(arr) &#123;</span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>浅拷贝：只考虑对象类型。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function shallowCopy(obj) &#123;</span><br><span class="line">    if (typeof obj !== &apos;object&apos;) return</span><br><span class="line">    </span><br><span class="line">    let newObj = obj instanceof Array ? [] : &#123;&#125;</span><br><span class="line">    for (let key in obj) &#123;</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单版深拷贝：只考虑普通对象属性，不考虑内置对象和函数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">    if (typeof obj !== &apos;object&apos;) return;</span><br><span class="line">    var newObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">    for (var key in obj) &#123;</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = typeof obj[key] === &apos;object&apos; ? deepClone(obj[key]) : obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复杂版深克隆：基于简单版的基础上，还考虑了内置对象比如 Date、RegExp 等对象和函数以及解决了循环引用的问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isObject = (target) =&gt; (typeof target === &quot;object&quot; || typeof target === &quot;function&quot;) &amp;&amp; target !== null;</span><br><span class="line"></span><br><span class="line">function deepClone(target, map = new WeakMap()) &#123;</span><br><span class="line">    if (map.get(target)) &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取当前值的构造函数：获取它的类型</span><br><span class="line">    let constructor = target.constructor;</span><br><span class="line">    // 检测当前对象target是否与正则、日期格式对象匹配</span><br><span class="line">    if (/^(RegExp|Date)$/i.test(constructor.name)) &#123;</span><br><span class="line">        // 创建一个新的特殊对象(正则类/日期类)的实例</span><br><span class="line">        return new constructor(target);  </span><br><span class="line">    &#125;</span><br><span class="line">    if (isObject(target)) &#123;</span><br><span class="line">        map.set(target, true);  // 为循环引用的对象做标记</span><br><span class="line">        const cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        for (let prop in target) &#123;</span><br><span class="line">            if (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">                cloneTarget[prop] = deepClone(target[prop], map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cloneTarget;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="事件总线（发布订阅模式）"><a href="#事件总线（发布订阅模式）" class="headerlink" title="事件总线（发布订阅模式）"></a>事件总线（发布订阅模式）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class EventEmitter &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.cache = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    on(name, fn) &#123;</span><br><span class="line">        if (this.cache[name]) &#123;</span><br><span class="line">            this.cache[name].push(fn)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.cache[name] = [fn]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    off(name, fn) &#123;</span><br><span class="line">        let tasks = this.cache[name]</span><br><span class="line">        if (tasks) &#123;</span><br><span class="line">            const index = tasks.findIndex(f =&gt; f === fn || f.callback === fn)</span><br><span class="line">            if (index &gt;= 0) &#123;</span><br><span class="line">                tasks.splice(index, 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    emit(name, once = false, ...args) &#123;</span><br><span class="line">        if (this.cache[name]) &#123;</span><br><span class="line">            // 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span><br><span class="line">            let tasks = this.cache[name].slice()</span><br><span class="line">            for (let fn of tasks) &#123;</span><br><span class="line">                fn(...args)</span><br><span class="line">            &#125;</span><br><span class="line">            if (once) &#123;</span><br><span class="line">                delete this.cache[name]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">let eventBus = new EventEmitter()</span><br><span class="line">let fn1 = function(name, age) &#123;</span><br><span class="line">	console.log(`$&#123;name&#125; $&#123;age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">let fn2 = function(name, age) &#123;</span><br><span class="line">	console.log(`hello, $&#123;name&#125; $&#123;age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">eventBus.on(&apos;aaa&apos;, fn1)</span><br><span class="line">eventBus.on(&apos;aaa&apos;, fn2)</span><br><span class="line">eventBus.emit(&apos;aaa&apos;, false, &apos;布兰&apos;, 12)</span><br><span class="line">// &apos;布兰 12&apos;</span><br><span class="line">// &apos;hello, 布兰 12&apos;</span><br></pre></td></tr></table></figure>
<h2 id="解析-URL-参数为对象"><a href="#解析-URL-参数为对象" class="headerlink" title="解析 URL 参数为对象"></a>解析 URL 参数为对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parseParam(url) &#123;</span><br><span class="line">    const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来</span><br><span class="line">    const paramsArr = paramsStr.split(&apos;&amp;&apos;); // 将字符串以 &amp; 分割后存到数组中</span><br><span class="line">    let paramsObj = &#123;&#125;;</span><br><span class="line">    // 将 params 存到对象中</span><br><span class="line">    paramsArr.forEach(param =&gt; &#123;</span><br><span class="line">        if (/=/.test(param)) &#123; // 处理有 value 的参数</span><br><span class="line">            let [key, val] = param.split(&apos;=&apos;); // 分割 key 和 value</span><br><span class="line">            val = decodeURIComponent(val); // 解码</span><br><span class="line">            val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字</span><br><span class="line">    </span><br><span class="line">            if (paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值</span><br><span class="line">                paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">            &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值</span><br><span class="line">                paramsObj[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; // 处理没有 value 的参数</span><br><span class="line">            paramsObj[param] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function render(template, data) &#123;</span><br><span class="line">    const reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/; // 模板字符串正则</span><br><span class="line">    if (reg.test(template)) &#123; // 判断模板里是否有模板字符串</span><br><span class="line">        const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段</span><br><span class="line">        template = template.replace(reg, data[name]); // 将第一个模板字符串渲染</span><br><span class="line">        return render(template, data); // 递归的渲染并返回渲染后的结构</span><br><span class="line">    &#125;</span><br><span class="line">    return template; // 如果模板没有模板字符串直接返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let template = &apos;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&apos;;</span><br><span class="line">let person = &#123;</span><br><span class="line">    name: &apos;布兰&apos;,</span><br><span class="line">    age: 12</span><br><span class="line">&#125;</span><br><span class="line">render(template, person); // 我是布兰，年龄12，性别undefined</span><br></pre></td></tr></table></figure></p>
<h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>与普通的图片懒加载不同，如下这个多做了 2 个精心处理：</p>
<ul>
<li>图片全部加载完成后移除事件监听；</li>
<li>加载完的图片，从 imgList 移除；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let imgList = [...document.querySelectorAll(&apos;img&apos;)]</span><br><span class="line">let length = imgList.length</span><br><span class="line"></span><br><span class="line">const imgLazyLoad = function() &#123;</span><br><span class="line">    let count = 0</span><br><span class="line">    // 修正错误，需要加上自执行</span><br><span class="line">-   return function() &#123;</span><br><span class="line">+   return (function() &#123;</span><br><span class="line">        let deleteIndexList = []</span><br><span class="line">        imgList.forEach((img, index) =&gt; &#123;</span><br><span class="line">            let rect = img.getBoundingClientRect()</span><br><span class="line">            if (rect.top &lt; window.innerHeight) &#123;</span><br><span class="line">                img.src = img.dataset.src</span><br><span class="line">                deleteIndexList.push(index)</span><br><span class="line">                count++</span><br><span class="line">                if (count === length) &#123;</span><br><span class="line">                    document.removeEventListener(&apos;scroll&apos;, imgLazyLoad)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        imgList = imgList.filter((img, index) =&gt; !deleteIndexList.includes(index))</span><br><span class="line">-   &#125;</span><br><span class="line">+   &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里最好加上防抖处理</span><br><span class="line">document.addEventListener(&apos;scroll&apos;, imgLazyLoad)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。</p>
<p>简单版：函数内部支持使用 this 和 event 对象；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(function()&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var node = document.getElementById(&apos;layout&apos;)</span><br><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    console.log(this, e)  // 分别打印：node 这个节点 和 MouseEvent</span><br><span class="line">    node.innerHTML = count++;</span><br><span class="line">&#125;;</span><br><span class="line">node.onmousemove = debounce(getUserAction, 1000)</span><br></pre></td></tr></table></figure></p>
<p>最终版：除了支持 this 和 event 外，还支持以下功能：</p>
<ul>
<li>支持立即执行；</li>
<li>函数可能有返回值；</li>
<li>支持取消功能；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timeout, result;</span><br><span class="line">    </span><br><span class="line">    var debounced = function () &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        </span><br><span class="line">        if (timeout) clearTimeout(timeout);</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            // 如果已经执行过，不再执行</span><br><span class="line">            var callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(function()&#123;</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timeout = setTimeout(function()&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var setUseAction = debounce(getUserAction, 10000, true);</span><br><span class="line">// 使用防抖</span><br><span class="line">node.onmousemove = setUseAction</span><br><span class="line"></span><br><span class="line">// 取消防抖</span><br><span class="line">setUseAction.cancel()</span><br></pre></td></tr></table></figure></p>
<h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>触发高频事件，且 N 秒内只执行一次。</p>
<p>简单版：使用时间戳来实现，立即执行一次，然后每 N 秒执行一次。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var context, args;</span><br><span class="line">    var previous = 0;</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        var now = +new Date();</span><br><span class="line">        context = this;</span><br><span class="line">        args = arguments;</span><br><span class="line">        if (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终版：支持取消节流；另外通过传入第三个参数，options.leading 来表示是否可以立即执行一次，opitons.trailing 表示结束调用的时候是否还要执行一次，默认都是 true。 注意设置的时候不能同时将 leading 或 trailing 设置为 false。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(func, wait, options) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous = 0;</span><br><span class="line">    if (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var later = function() &#123;</span><br><span class="line">        previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class="line">        timeout = null;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        if (!timeout) context = args = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var throttled = function() &#123;</span><br><span class="line">        var now = new Date().getTime();</span><br><span class="line">        if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line">        var remaining = wait - (now - previous);</span><br><span class="line">        context = this;</span><br><span class="line">        args = arguments;</span><br><span class="line">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            if (!timeout) context = args = null;</span><br><span class="line">        &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    throttled.cancel = function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        previous = 0;</span><br><span class="line">        timeout = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节流的使用就不拿代码举例了，参考防抖的写就行。</p>
<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。还不懂？来举个例子。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a, b, c) &#123;</span><br><span class="line">    return a + b + c</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3)</span><br><span class="line">let addCurry = curry(add)</span><br><span class="line">addCurry(1)(2)(3)</span><br></pre></td></tr></table></figure></p>
<p>现在就是要实现 curry 这个函数，使函数从一次调用传入多个参数变成多次调用每次传一个参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curry(fn) &#123;</span><br><span class="line">    let judge = (...args) =&gt; &#123;</span><br><span class="line">        if (args.length == fn.length) return fn(...args)</span><br><span class="line">        return (...arg) =&gt; judge(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">    return judge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。举个例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a, b, c) &#123;</span><br><span class="line">    return a + b + c</span><br><span class="line">&#125;</span><br><span class="line">let partialAdd = partial(add, 1)</span><br><span class="line">partialAdd(2, 3)</span><br></pre></td></tr></table></figure></p>
<p>发现没有，其实偏函数和函数柯里化有点像，所以根据函数柯里化的实现，能够能很快写出偏函数的实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function partial(fn, ...args) &#123;</span><br><span class="line">    return (...arg) =&gt; &#123;</span><br><span class="line">        return fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上这个功能比较简单，现在我们希望偏函数能和柯里化一样能实现占位功能，比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function clg(a, b, c) &#123;</span><br><span class="line">    console.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">let partialClg = partial(clg, &apos;_&apos;, 2)</span><br><span class="line">partialClg(1, 3)  // 依次打印：1, 2, 3</span><br></pre></td></tr></table></figure></p>
<p>_ 占的位其实就是 1 的位置。相当于：partial(clg, 1, 2)，然后 partialClg(3)。明白了原理，我们就来写实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function partial(fn, ...args) &#123;</span><br><span class="line">    return (...arg) =&gt; &#123;</span><br><span class="line">        args[index] = </span><br><span class="line">        return fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 核心原理：script 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const jsonp = (&#123; url, params, callbackName &#125;) =&gt; &#123;</span><br><span class="line">    const generateUrl = () =&gt; &#123;</span><br><span class="line">        let dataSrc = &apos;&apos;</span><br><span class="line">        for (let key in params) &#123;</span><br><span class="line">            if (params.hasOwnProperty(key)) &#123;</span><br><span class="line">                dataSrc += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;`</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dataSrc += `callback=$&#123;callbackName&#125;`</span><br><span class="line">        return `$&#123;url&#125;?$&#123;dataSrc&#125;`</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        const scriptEle = document.createElement(&apos;script&apos;)</span><br><span class="line">        scriptEle.src = generateUrl()</span><br><span class="line">        document.body.appendChild(scriptEle)</span><br><span class="line">        window[callbackName] = data =&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            document.removeChild(scriptEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getJSON = function(url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Mscrosoft.XMLHttp&apos;);</span><br><span class="line">        xhr.open(&apos;GET&apos;, url, false);</span><br><span class="line">        xhr.setRequestHeader(&apos;Accept&apos;, &apos;application/json&apos;);</span><br><span class="line">        xhr.onreadystatechange = function() &#123;</span><br><span class="line">            if (xhr.readyState !== 4) return;</span><br><span class="line">            if (xhr.status === 200 || xhr.status === 304) &#123;</span><br><span class="line">                resolve(xhr.responseText);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reject(new Error(xhr.responseText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现数组原型方法"><a href="#实现数组原型方法" class="headerlink" title="实现数组原型方法"></a>实现数组原型方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.forEach2 = function(callback, thisArg) &#123;</span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;this is null or not defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &apos; is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)  // this 就是当前的数组</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0  // 后面有解释</span><br><span class="line">    let k = 0</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line">            callback.call(thisArg, O[k], k, O);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>O.length &gt;&gt;&gt; 0 是什么操作？就是无符号右移 0 位，那有什么意义嘛？就是为了保证转换后的值为正整数。其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。感兴趣可以阅读 something &gt;&gt;&gt; 0是什么意思?。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>基于 forEach 的实现能够很容易写出 map 的实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span><br><span class="line">+ Array.prototype.map2 = function(callback, thisArg) &#123;</span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;this is null or not defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &apos; is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">-   let k = 0</span><br><span class="line">+   let k = 0, res = []</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line">-           callback.call(thisArg, O[k], k, O);</span><br><span class="line">+           res[k] = callback.call(thisArg, O[k], k, O);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">+   return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>同样，基于 forEach 的实现能够很容易写出 filter 的实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span><br><span class="line">+ Array.prototype.filter2 = function(callback, thisArg) &#123;</span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;this is null or not defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &apos; is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">-   let k = 0</span><br><span class="line">+   let k = 0, res = []</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line">-           callback.call(thisArg, O[k], k, O);</span><br><span class="line">+           if (callback.call(thisArg, O[k], k, O)) &#123;</span><br><span class="line">+               res.push(O[k])                </span><br><span class="line">+           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">+   return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>同样，基于 forEach 的实现能够很容易写出 some 的实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span><br><span class="line">+ Array.prototype.some2 = function(callback, thisArg) &#123;</span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;this is null or not defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &apos; is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">    let k = 0</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line">-           callback.call(thisArg, O[k], k, O);</span><br><span class="line">+           if (callback.call(thisArg, O[k], k, O)) &#123;</span><br><span class="line">+               return true</span><br><span class="line">+           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">+   return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.reduce2 = function(callback, initialValue) &#123;</span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;this is null or not defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &apos; is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">    let k = 0, acc</span><br><span class="line">    </span><br><span class="line">    if (arguments.length &gt; 1) &#123;</span><br><span class="line">        acc = initialValue</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 没传入初始值的时候，取数组中第一个非 empty 的值为初始值</span><br><span class="line">        while (k &lt; len &amp;&amp; !(k in O)) &#123;</span><br><span class="line">            k++</span><br><span class="line">        &#125;</span><br><span class="line">        if (k &gt; len) &#123;</span><br><span class="line">            throw new TypeError( &apos;Reduce of empty array with no initial value&apos; );</span><br><span class="line">        &#125;</span><br><span class="line">        acc = O[k++]</span><br><span class="line">    &#125;</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line">            acc = callback(acc, O[k], k, O)</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    return acc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现函数原型方法"><a href="#实现函数原型方法" class="headerlink" title="实现函数原型方法"></a>实现函数原型方法</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>使用一个指定的 this 值和一个或多个参数来调用一个函数。</p>
<p>实现要点：</p>
<ul>
<li>this 可能传入 null；</li>
<li>传入不固定个数的参数；</li>
<li>函数可能有返回值；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.call2 = function (context) &#123;</span><br><span class="line">    var context = context || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply 和 call 一样，唯一的区别就是 call 是传入不固定个数的参数，而 apply 是传入一个数组。</p>
<p>实现要点：</p>
<ul>
<li>this 可能传入 null；</li>
<li>传入一个数组；</li>
<li>函数可能有返回值；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.apply2 = function (context, arr) &#123;</span><br><span class="line">    var context = context || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var args = [];</span><br><span class="line">        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&apos;arr[&apos; + i + &apos;]&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind 方法会创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<p>实现要点：</p>
<ul>
<li>bind() 除了 this 外，还可传入多个参数；</li>
<li>bing 创建的新函数可能传入多个参数；</li>
<li>新函数可能被当做构造函数调用；</li>
<li>函数可能有返回值；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind2 = function (context) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fNOP = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var fBound = function () &#123;</span><br><span class="line">        var bindArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = this.prototype;</span><br><span class="line">    fBound.prototype = new fNOP();</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="实现-new-关键字"><a href="#实现-new-关键字" class="headerlink" title="实现 new 关键字"></a>实现 new 关键字</h2><p>new 运算符用来创建用户自定义的对象类型的实例或者具有构造函数的内置对象的实例。</p>
<p>实现要点：</p>
<ul>
<li>new 会产生一个新对象；</li>
<li>新对象需要能够访问到构造函数的属性，所以需要重新指定它的原型；</li>
<li>构造函数可能会显示返回；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function objectFactory() &#123;</span><br><span class="line">    var obj = new Object()</span><br><span class="line">    Constructor = [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    var ret = Constructor.apply(obj, arguments);</span><br><span class="line">    </span><br><span class="line">    // ret || obj 这里这么写考虑了构造函数显示返回 null 的情况</span><br><span class="line">    return typeof ret === &apos;object&apos; ? ret || obj : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function person(name, age) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line">let p = objectFactory(person, &apos;布兰&apos;, 12)</span><br><span class="line">console.log(p)  // &#123; name: &apos;布兰&apos;, age: 12 &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现-instanceof-关键字"><a href="#实现-instanceof-关键字" class="headerlink" title="实现 instanceof 关键字"></a>实现 instanceof 关键字</h2><p>instanceof 就是判断构造函数的 prototype 属性是否出现在实例的原型链上。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function instanceOf(left, right) &#123;</span><br><span class="line">    let proto = left.__proto__</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (proto === null) return false</span><br><span class="line">        if (proto === right.prototype) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        proto = proto.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的 left.proto 这种写法可以换成 Object.getPrototypeOf(left)。</p>
<h2 id="实现-Object-create"><a href="#实现-Object-create" class="headerlink" title="实现 Object.create"></a>实现 Object.create</h2><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.create2 = function(proto, propertyObject = undefined) &#123;</span><br><span class="line">    if (typeof proto !== &apos;object&apos; &amp;&amp; typeof proto !== &apos;function&apos;) &#123;</span><br><span class="line">        throw new TypeError(&apos;Object prototype may only be an Object or null.&apos;)</span><br><span class="line">    if (propertyObject == null) &#123;</span><br><span class="line">        new TypeError(&apos;Cannot convert undefined or null to object&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = proto</span><br><span class="line">    const obj = new F()</span><br><span class="line">    if (propertyObject != undefined) &#123;</span><br><span class="line">        Object.defineProperties(obj, propertyObject)</span><br><span class="line">    &#125;</span><br><span class="line">    if (proto === null) &#123;</span><br><span class="line">        // 创建一个没有原型对象的对象，Object.create(null)</span><br><span class="line">        obj.__proto__ = null</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现-Object-assign"><a href="#实现-Object-assign" class="headerlink" title="实现 Object.assign"></a>实现 Object.assign</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.assign2 = function(target, ...source) &#123;</span><br><span class="line">    if (target == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;Cannot convert undefined or null to object&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    let ret = Object(target) </span><br><span class="line">    source.forEach(function(obj) &#123;</span><br><span class="line">        if (obj != null) &#123;</span><br><span class="line">            for (let key in obj) &#123;</span><br><span class="line">                if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                    ret[key] = obj[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现-JSON-stringify"><a href="#实现-JSON-stringify" class="headerlink" title="实现 JSON.stringify"></a>实现 JSON.stringify</h2><p>JSON.stringify([, replacer [, space]) 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 replacer 和第三个参数 space，如果对这两个参数的作用还不了解，建议阅读 MDN 文档。</p>
<ol>
<li>基本数据类型：</li>
</ol>
<ul>
<li>undefined 转换之后仍是 undefined(类型也是 undefined)</li>
<li>boolean 值转换之后是字符串 “false”/“true”</li>
<li>number 类型(除了 NaN 和 Infinity)转换之后是字符串类型的数值</li>
<li>symbol 转换之后是 undefined</li>
<li>null 转换之后是字符串 “null”</li>
<li>string 转换之后仍是string</li>
<li>NaN 和 Infinity 转换之后是字符串 “null”</li>
</ul>
<ol start="2">
<li>函数类型：转换之后是 undefined</li>
<li>如果是对象类型(非函数)</li>
</ol>
<ul>
<li>如果是一个数组：如果属性值中出现了 undefined、任意的函数以及 symbol，转换成字符串 “null” ；</li>
<li>如果是 RegExp 对象：返回 {} (类型是 string)；</li>
<li>如果是 Date 对象，返回 Date 的 toJSON 字符串值；</li>
<li>如果是普通对象；<ul>
<li>如果有 toJSON() 方法，那么序列化 toJSON() 的返回值。</li>
<li>如果属性值中出现了 undefined、任意的函数以及 symbol 值，忽略。</li>
<li>所有以 symbol 为属性键的属性都会被完全忽略掉。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function jsonStringify(data) &#123;</span><br><span class="line">    let dataType = typeof data;</span><br><span class="line">    </span><br><span class="line">    if (dataType !== &apos;object&apos;) &#123;</span><br><span class="line">        let result = data;</span><br><span class="line">        //data 可能是 string/number/null/undefined/boolean</span><br><span class="line">        if (Number.isNaN(data) || data === Infinity) &#123;</span><br><span class="line">            //NaN 和 Infinity 序列化返回 &quot;null&quot;</span><br><span class="line">            result = &quot;null&quot;;</span><br><span class="line">        &#125; else if (dataType === &apos;function&apos; || dataType === &apos;undefined&apos; || dataType === &apos;symbol&apos;) &#123;</span><br><span class="line">            //function 、undefined 、symbol 序列化返回 undefined</span><br><span class="line">            return undefined;</span><br><span class="line">        &#125; else if (dataType === &apos;string&apos;) &#123;</span><br><span class="line">            result = &apos;&quot;&apos; + data + &apos;&quot;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        //boolean 返回 String()</span><br><span class="line">        return String(result);</span><br><span class="line">    &#125; else if (dataType === &apos;object&apos;) &#123;</span><br><span class="line">        if (data === null) &#123;</span><br><span class="line">            return &quot;null&quot;</span><br><span class="line">        &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &apos;function&apos;) &#123;</span><br><span class="line">            return jsonStringify(data.toJSON());</span><br><span class="line">        &#125; else if (data instanceof Array) &#123;</span><br><span class="line">            let result = [];</span><br><span class="line">            //如果是数组</span><br><span class="line">            //toJSON 方法可以存在于原型链中</span><br><span class="line">            data.forEach((item, index) =&gt; &#123;</span><br><span class="line">                if (typeof item === &apos;undefined&apos; || typeof item === &apos;function&apos; || typeof item === &apos;symbol&apos;) &#123;</span><br><span class="line">                    result[index] = &quot;null&quot;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result[index] = jsonStringify(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            result = &quot;[&quot; + result + &quot;]&quot;;</span><br><span class="line">            return result.replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //普通对象</span><br><span class="line">            /**</span><br><span class="line">             * 循环引用抛错(暂未检测，循环引用时，堆栈溢出)</span><br><span class="line">             * symbol key 忽略</span><br><span class="line">             * undefined、函数、symbol 为属性值，被忽略</span><br><span class="line">             */</span><br><span class="line">            let result = [];</span><br><span class="line">            Object.keys(data).forEach((item, index) =&gt; &#123;</span><br><span class="line">                if (typeof item !== &apos;symbol&apos;) &#123;</span><br><span class="line">                    //key 如果是symbol对象，忽略</span><br><span class="line">                    if (data[item] !== undefined &amp;&amp; typeof data[item] !== &apos;function&apos;</span><br><span class="line">                        &amp;&amp; typeof data[item] !== &apos;symbol&apos;) &#123;</span><br><span class="line">                        //键值如果是 undefined、函数、symbol 为属性值，忽略</span><br><span class="line">                        result.push(&apos;&quot;&apos; + item + &apos;&quot;&apos; + &quot;:&quot; + jsonStringify(data[item]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="实现-JSON-parse"><a href="#实现-JSON-parse" class="headerlink" title="实现 JSON.parse"></a>实现 JSON.parse</h2><p>介绍 2 种方法实现：</p>
<ul>
<li>eval 实现；</li>
<li>new Function 实现；<h3 id="eval-实现"><a href="#eval-实现" class="headerlink" title="eval 实现"></a>eval 实现</h3>第一种方式最简单，也最直观，就是直接调用 eval，代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var json = &apos;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&apos;;</span><br><span class="line">var obj = eval(&quot;(&quot; + json + &quot;)&quot;);  // obj 就是 json 反序列化之后得到的对象</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是直接调用 eval 会存在安全问题，如果数据中可能不是 json 数据，而是可执行的 JavaScript 代码，那很可能会造成 XSS 攻击。因此，在调用 eval 之前，需要对数据进行校验。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rx_one = /^[\],:&#123;&#125;\s]*$/;</span><br><span class="line">var rx_two = /\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g;</span><br><span class="line">var rx_three = /&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;</span><br><span class="line">var rx_four = /(?:^|:|,)(?:\s*\[)+/g;</span><br><span class="line"></span><br><span class="line">if (</span><br><span class="line">    rx_one.test(</span><br><span class="line">        json.replace(rx_two, &quot;@&quot;)</span><br><span class="line">            .replace(rx_three, &quot;]&quot;)</span><br><span class="line">            .replace(rx_four, &quot;&quot;)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    var obj = eval(&quot;(&quot; +json + &quot;)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="new-Function-实现"><a href="#new-Function-实现" class="headerlink" title="new Function 实现"></a>new Function 实现</h3><p>Function 与 eval 有相同的字符串参数特性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var json = &apos;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&apos;;</span><br><span class="line">var obj = (new Function(&apos;return &apos; + json))();</span><br></pre></td></tr></table></figure></p>
<h2 id="实现-Promise"><a href="#实现-Promise" class="headerlink" title="实现 Promise"></a>实现 Promise</h2><p>实现 Promise 需要完全读懂 Promise A+ 规范，不过从总体的实现上看，有如下几个点需要考虑到：</p>
<ul>
<li>then 需要支持链式调用，所以得返回一个新的 Promise；</li>
<li>处理异步问题，所以得先用 onResolvedCallbacks 和 onRejectedCallbacks 分别把成功和失败的回调存起来；</li>
<li>为了让链式调用正常进行下去，需要判断 onFulfilled 和 onRejected 的类型；</li>
<li>onFulfilled 和 onRejected 需要被异步调用，这里用 setTimeout 模拟异步；</li>
<li>处理 Promise 的 resolve；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PENDING = &apos;pending&apos;;</span><br><span class="line">const FULFILLED = &apos;fulfilled&apos;;</span><br><span class="line">const REJECTED = &apos;rejected&apos;;</span><br><span class="line"></span><br><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this.status = PENDING;</span><br><span class="line">        this.value = undefined;</span><br><span class="line">        this.reason = undefined;</span><br><span class="line">        this.onResolvedCallbacks = [];</span><br><span class="line">        this.onRejectedCallbacks = [];</span><br><span class="line">        </span><br><span class="line">        let resolve = (value) = &gt; &#123;</span><br><span class="line">            if (this.status === PENDING) &#123;</span><br><span class="line">                this.status = FULFILLED;</span><br><span class="line">                this.value = value;</span><br><span class="line">                this.onResolvedCallbacks.forEach((fn) = &gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        let reject = (reason) = &gt; &#123;</span><br><span class="line">            if (this.status === PENDING) &#123;</span><br><span class="line">                this.status = REJECTED;</span><br><span class="line">                this.reason = reason;</span><br><span class="line">                this.onRejectedCallbacks.forEach((fn) = &gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        // 解决 onFufilled，onRejected 没有传值的问题</span><br><span class="line">        onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : (v) = &gt; v;</span><br><span class="line">        // 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获</span><br><span class="line">        onRejected = typeof onRejected === &quot;function&quot; ? onRejected : (err) = &gt; &#123;</span><br><span class="line">            throw err;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 每次调用 then 都返回一个新的 promise</span><br><span class="line">        let promise2 = new Promise((resolve, reject) = &gt; &#123;</span><br><span class="line">            if (this.status === FULFILLED) &#123;</span><br><span class="line">                //Promise/A+ 2.2.4 --- setTimeout</span><br><span class="line">                setTimeout(() = &gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x = onFulfilled(this.value);</span><br><span class="line">                        // x可能是一个proimise</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            if (this.status === REJECTED) &#123;</span><br><span class="line">                //Promise/A+ 2.2.3</span><br><span class="line">                setTimeout(() = &gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x = onRejected(this.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (this.status === PENDING) &#123;</span><br><span class="line">                this.onResolvedCallbacks.push(() = &gt; &#123;</span><br><span class="line">                    setTimeout(() = &gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x = onFulfilled(this.value);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, 0);</span><br><span class="line">                &#125;);</span><br><span class="line">            </span><br><span class="line">                this.onRejectedCallbacks.push(() = &gt; &#123;</span><br><span class="line">                    setTimeout(() = &gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x = onRejected(this.reason);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, 0);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        return promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const resolvePromise = (promise2, x, resolve, reject) = &gt; &#123;</span><br><span class="line">    // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1</span><br><span class="line">    if (promise2 === x) &#123;</span><br><span class="line">        return reject(</span><br><span class="line">            new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    // Promise/A+ 2.3.3.3.3 只能调用一次</span><br><span class="line">    let called;</span><br><span class="line">    // 后续的条件要严格判断 保证代码能和别的库一起使用</span><br><span class="line">    if ((typeof x === &quot;object&quot; &amp;&amp; x != null) || typeof x === &quot;function&quot;) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1</span><br><span class="line">            let then = x.then;</span><br><span class="line">            if (typeof then === &quot;function&quot;) &#123;</span><br><span class="line">            // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3</span><br><span class="line">                then.call(</span><br><span class="line">                    x, (y) = &gt; &#123;</span><br><span class="line">                        // 根据 promise 的状态决定是成功还是失败</span><br><span class="line">                        if (called) return;</span><br><span class="line">                        called = true;</span><br><span class="line">                        // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1</span><br><span class="line">                        resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                    &#125;, (r) = &gt; &#123;</span><br><span class="line">                        // 只要失败就失败 Promise/A+ 2.3.3.3.2</span><br><span class="line">                        if (called) return;</span><br><span class="line">                        called = true;</span><br><span class="line">                        reject(r);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            // Promise/A+ 2.3.3.2</span><br><span class="line">            if (called) return;</span><br><span class="line">            called = true;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Promise 写完之后可以通过 promises-aplus-tests 这个包对我们写的代码进行测试，看是否符合 A+ 规范。不过测试前还得加一段代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// promise.js</span><br><span class="line">// 这里是上面写的 Promise 全部代码</span><br><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">    let dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    return dfd;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Promise;</span><br></pre></td></tr></table></figure></p>
<p>全局安装：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i promises-aplus-tests -g</span><br></pre></td></tr></table></figure></p>
<p>终端下执行验证命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promises-aplus-tests promise.js</span><br></pre></td></tr></table></figure></p>
<p>上面写的代码可以顺利通过全部 872 个测试用例。</p>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve = function(value) &#123;</span><br><span class="line">    // 如果是 Promsie，则直接输出它</span><br><span class="line">    if(value instanceof Promise)&#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise(resolve =&gt; resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.reject = function(reason) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 的规则是这样的：</p>
<ul>
<li>传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；</li>
<li>只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；</li>
<li>只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.all = function(promiseArr) &#123;</span><br><span class="line">    let index = 0, result = []</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">            Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">                index++</span><br><span class="line">                result[i] = val</span><br><span class="line">                if (index === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.race = function(promiseArr) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        promiseArr.forEach(p =&gt; &#123;</span><br><span class="line">            Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                rejecte(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Promise.allSettled<br>Promise.allSettled 的规则是这样：</p>
<ul>
<li>所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise，且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象；</li>
<li>如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.allSettled = function(promiseArr) &#123;</span><br><span class="line">    let result = []</span><br><span class="line">        </span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">            Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    status: &apos;fulfilled&apos;,</span><br><span class="line">                    value: val</span><br><span class="line">                &#125;)</span><br><span class="line">                if (result.length === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    status: &apos;rejected&apos;,</span><br><span class="line">                    reason: err</span><br><span class="line">                &#125;)</span><br><span class="line">                if (result.length === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>Promise.any 的规则是这样：</p>
<ul>
<li>空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；</li>
<li>只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；</li>
<li>其他情况都会返回一个 pending 的新实例；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.any = function(promiseArr) &#123;</span><br><span class="line">    let index = 0</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        if (promiseArr.length === 0) return </span><br><span class="line">        promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">            Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">                </span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                index++</span><br><span class="line">                if (index === promiseArr.length) &#123;</span><br><span class="line">                  reject(new AggregateError(&apos;All promises were rejected&apos;))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>后话<br>能看到这里的对代码都是真爱了，毕竟代码这玩意看起来是真的很枯燥，但是如果看懂了后，就会像打游戏赢了一样开心，而且这玩意会上瘾，当你通关了越多的关卡后，你的能力就会拔高一个层次。用标题的话来说就是：搞懂后，提升真的大。加油吧💪，干饭人</p>
<p>噢不，代码人。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>使用eggjs和sequelize管理数据库</title>
    <url>/2021/03/16/%E4%BD%BF%E7%94%A8eggjs%E5%92%8Csequelize%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为什么使用eggjs自不必言说，前端开发者想搞一下服务器接口啥的，最低学习成本的就是nodejs。加之koa是nodejs的封装库，使得nodejs更加好用。然而在eggjs的约定大于配置的前提下，对koa做了封装，使得上手成本更低，固然选择eggjs来作为写接口的框架。数据库使用sequelize的缘由自不必说了，让多人开发合作更加简单规范！！！<a id="more"></a></p>
<h2 id="eggjs快速上手"><a href="#eggjs快速上手" class="headerlink" title="eggjs快速上手"></a>eggjs快速上手</h2><h4 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h4><p>快速生成基础项目，提高开发效率，这里推荐使用脚手架快速生成项目。具体命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir egg-example &amp;&amp; cd egg-example</span><br><span class="line">npm init egg --type=simple</span><br><span class="line">npm i</span><br><span class="line">npm run dev</span><br><span class="line">// 打开一下链接</span><br><span class="line">http://localhost:7001</span><br></pre></td></tr></table></figure>
<h4 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a>项目目录介绍</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egg-project</span><br><span class="line">├── package.json</span><br><span class="line">├── app.js (可选)</span><br><span class="line">├── agent.js (可选)</span><br><span class="line">├── app</span><br><span class="line">|   ├── router.js</span><br><span class="line">│   ├── controller</span><br><span class="line">│   |   └── home.js</span><br><span class="line">│   ├── service (可选)</span><br><span class="line">│   |   └── user.js</span><br><span class="line">│   ├── middleware (可选)</span><br><span class="line">│   |   └── response_time.js</span><br><span class="line">│   ├── schedule (可选)</span><br><span class="line">│   |   └── my_task.js</span><br><span class="line">│   ├── public (可选)</span><br><span class="line">│   |   └── reset.css</span><br><span class="line">│   ├── view (可选)</span><br><span class="line">│   |   └── home.tpl</span><br><span class="line">│   └── extend (可选)</span><br><span class="line">│       ├── helper.js (可选)</span><br><span class="line">│       ├── request.js (可选)</span><br><span class="line">│       ├── response.js (可选)</span><br><span class="line">│       ├── context.js (可选)</span><br><span class="line">│       ├── application.js (可选)</span><br><span class="line">│       └── agent.js (可选)</span><br><span class="line">├── config</span><br><span class="line">|   ├── plugin.js</span><br><span class="line">|   ├── config.default.js</span><br><span class="line">│   ├── config.prod.js</span><br><span class="line">|   ├── config.test.js (可选)</span><br><span class="line">|   ├── config.local.js (可选)</span><br><span class="line">|   └── config.unittest.js (可选)</span><br><span class="line">└── test</span><br><span class="line">    ├── middleware</span><br><span class="line">    |   └── response_time.test.js</span><br><span class="line">    └── controller</span><br><span class="line">        └── home.test.js</span><br></pre></td></tr></table></figure>
<p>如上，由框架约定的目录：</p>
<ul>
<li><code>app/router.js</code> 用于配置 URL 路由规则，具体参见 <a href="https://eggjs.org/zh-cn/basics/router.html" rel="external nofollow noopener noreferrer" target="_blank">Router</a>。</li>
<li><code>app/controller/**</code> 用于解析用户的输入，处理后返回相应的结果，具体参见 <a href="https://eggjs.org/zh-cn/basics/controller.html" rel="external nofollow noopener noreferrer" target="_blank">Controller</a>。</li>
<li><code>app/service/**</code> 用于编写业务逻辑层，可选，建议使用，具体参见 <a href="https://eggjs.org/zh-cn/basics/service.html" rel="external nofollow noopener noreferrer" target="_blank">Service</a>。</li>
<li><code>app/middleware/**</code> 用于编写中间件，可选，具体参见 <a href="https://eggjs.org/zh-cn/basics/middleware.html" rel="external nofollow noopener noreferrer" target="_blank">Middleware</a>。</li>
<li><code>app/public/**</code> 用于放置静态资源，可选，具体参见内置插件 <a href="https://github.com/eggjs/egg-static" rel="external nofollow noopener noreferrer" target="_blank">egg-static</a>。</li>
<li><code>app/extend/**</code> 用于框架的扩展，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/extend.html" rel="external nofollow noopener noreferrer" target="_blank">框架扩展</a>。</li>
<li><code>config/config.{env}.js</code> 用于编写配置文件，具体参见<a href="https://eggjs.org/zh-cn/basics/config.html" rel="external nofollow noopener noreferrer" target="_blank">配置</a>。</li>
<li><code>config/plugin.js</code> 用于配置需要加载的插件，具体参见<a href="https://eggjs.org/zh-cn/basics/plugin.html" rel="external nofollow noopener noreferrer" target="_blank">插件</a>。</li>
<li><code>test/**</code> 用于单元测试，具体参见<a href="https://eggjs.org/zh-cn/core/unittest.html" rel="external nofollow noopener noreferrer" target="_blank">单元测试</a>。</li>
<li><code>app.js</code> 和 <code>agent.js</code> 用于自定义启动时的初始化工作，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/app-start.html" rel="external nofollow noopener noreferrer" target="_blank">启动自定义</a>。关于<code>agent.js</code>的作用参见<a href="https://eggjs.org/zh-cn/core/cluster-and-ipc.html#agent-机制" rel="external nofollow noopener noreferrer" target="_blank">Agent机制</a>。</li>
</ul>
<p>由内置插件约定的目录：</p>
<ul>
<li><code>app/public/**</code> 用于放置静态资源，可选，具体参见内置插件 <a href="https://github.com/eggjs/egg-static" rel="external nofollow noopener noreferrer" target="_blank">egg-static</a>。</li>
<li><code>app/schedule/**</code> 用于定时任务，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/schedule.html" rel="external nofollow noopener noreferrer" target="_blank">定时任务</a>。</li>
</ul>
<p><strong>若需自定义自己的目录规范，参见 <a href="https://eggjs.org/zh-cn/advanced/loader.html" rel="external nofollow noopener noreferrer" target="_blank">Loader API</a></strong></p>
<ul>
<li><code>app/view/**</code> 用于放置模板文件，可选，由模板插件约定，具体参见<a href="https://eggjs.org/zh-cn/core/view.html" rel="external nofollow noopener noreferrer" target="_blank">模板渲染</a>。</li>
<li><code>app/model/**</code> 用于放置领域模型，可选，由领域类相关插件约定，如 <a href="https://github.com/eggjs/egg-sequelize" rel="external nofollow noopener noreferrer" target="_blank">egg-sequelize</a>。</li>
</ul>
<p>由此一个基础项目已经创建完成，详细的eggjs如何使用可自行查看官方文档<a href="https://eggjs.org/zh-cn/" rel="external nofollow noopener noreferrer" target="_blank">https://eggjs.org/zh-cn/</a></p>
<h2 id="eggjs使用sequelize"><a href="#eggjs使用sequelize" class="headerlink" title="eggjs使用sequelize"></a>eggjs使用sequelize</h2><ol>
<li>安装并配置 <a href="https://github.com/eggjs/egg-sequelize" rel="external nofollow noopener noreferrer" target="_blank">egg-sequelize</a> 插件（它会辅助我们将定义好的 Model 对象加载到 app 和 ctx 上）和 <a href="https://github.com/sidorares/node-mysql2" rel="external nofollow noopener noreferrer" target="_blank">mysql2</a> 模块：</li>
</ol>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save egg-sequelize mysql2</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>config/plugin.js</code> 中引入 egg-sequelize 插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.sequelize = &#123;</span><br><span class="line">  enable: true,</span><br><span class="line">  package: &apos;egg-sequelize&apos;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>config/config.default.js</code> 中编写 sequelize 配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.sequelize = &#123;</span><br><span class="line">  dialect: &apos;mysql&apos;,</span><br><span class="line">  host: &apos;127.0.0.1&apos;,</span><br><span class="line">  port: 3306,</span><br><span class="line">  database: &apos;egg-sequelize-doc-default&apos;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以在不同的环境配置中配置不同的数据源地址，用于区分不同环境使用的数据库，例如我们可以新建一个 <code>config/config.unittest.js</code> 配置文件，写入如下配置，将单测时连接的数据库指向 <code>egg-sequelize-doc-unittest</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.sequelize = &#123;</span><br><span class="line">  dialect: &apos;mysql&apos;,</span><br><span class="line">  host: &apos;127.0.0.1&apos;,</span><br><span class="line">  port: 3306,</span><br><span class="line">  database: &apos;egg-sequelize-doc-unittest&apos;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完成上面的配置之后，一个使用 sequelize 的项目就初始化完成了。<a href="https://github.com/eggjs/egg-sequelize" rel="external nofollow noopener noreferrer" target="_blank">egg-sequelize</a> 和 <a href="http://docs.sequelizejs.com/" rel="external nofollow noopener noreferrer" target="_blank">sequelize</a> 还支持更多的配置项，可以在他们的文档中找到。</p>
<ol start="2">
<li>sequelize 提供了 <a href="https://github.com/sequelize/cli" rel="external nofollow noopener noreferrer" target="_blank">sequelize-cli</a> 工具来管理，我们也可以在 egg 项目中引入 sequelize-cli。</li>
</ol>
<ul>
<li>安装 sequelize-cli</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev sequelize-cli</span><br></pre></td></tr></table></figure>
<p>在 egg 项目中，我们希望将所有数据库 Migrations 相关的内容都放在 <code>database</code> 目录下，所以我们在项目根目录下新建一个 <code>.sequelizerc</code> 配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  config: path.join(__dirname, &apos;database/config.json&apos;),</span><br><span class="line">  &apos;migrations-path&apos;: path.join(__dirname, &apos;database/migrations&apos;),</span><br><span class="line">  &apos;seeders-path&apos;: path.join(__dirname, &apos;database/seeders&apos;),</span><br><span class="line">  &apos;models-path&apos;: path.join(__dirname, &apos;app/model&apos;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后查看下sequelize-cli的所有命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequelize &lt;命令&gt;</span><br><span class="line"></span><br><span class="line">命令：</span><br><span class="line">  sequelize db:migrate                        Run pending migrations</span><br><span class="line">  sequelize db:migrate:schema:timestamps:add  Update migration table to have timestamps</span><br><span class="line">  sequelize db:migrate:status                 List the status of all migrations</span><br><span class="line">  sequelize db:migrate:undo                   Reverts a migration</span><br><span class="line">  sequelize db:migrate:undo:all               Revert all migrations ran</span><br><span class="line">  sequelize db:seed                           Run specified seeder</span><br><span class="line">  sequelize db:seed:undo                      Deletes data from the database</span><br><span class="line">  sequelize db:seed:all                       Run every seeder</span><br><span class="line">  sequelize db:seed:undo:all                  Deletes data from the database</span><br><span class="line">  sequelize db:create                         Create database specified by configuration</span><br><span class="line">  sequelize db:drop                           Drop database specified by configuration</span><br><span class="line">  sequelize init                              Initializes project</span><br><span class="line">  sequelize init:config                       Initializes configuration</span><br><span class="line">  sequelize init:migrations                   Initializes migrations</span><br><span class="line">  sequelize init:models                       Initializes models</span><br><span class="line">  sequelize init:seeders                      Initializes seeders</span><br><span class="line">  sequelize migration:generate                Generates a new migration file  [aliases: migration:create]                                         </span><br><span class="line">  sequelize model:generate                    Generates a model and its migration   [aliases: model:create]                                              </span><br><span class="line">  sequelize seed:generate                     Generates a new seed file       [aliases: seed:create]</span><br></pre></td></tr></table></figure>
<p>接下来就简单介绍下使用方式</p>
<h4 id="使用命令操作数据库"><a href="#使用命令操作数据库" class="headerlink" title="使用命令操作数据库"></a>使用命令操作数据库</h4><ol>
<li>初始化数据库相关</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx sequelize init</span><br></pre></td></tr></table></figure>
<p>这将创建以下文件夹:</p>
<ul>
<li>config, 包含配置文件，它告诉CLI如何连接数据库</li>
<li>models,包含您的项目的所有模型</li>
<li>migrations, 包含所有迁移文件</li>
<li>seeders, 包含所有种子文件</li>
</ul>
<p>在建立模型之前，应先修改database/config.json，以告诉 CLI 如何连接到数据库。database/config.json内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;development&quot;: &#123;</span><br><span class="line">    &quot;username&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;12345678&quot;,</span><br><span class="line">    &quot;database&quot;: &quot;egg_test&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;dialect&quot;: &quot;mysql&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;test&quot;: &#123;</span><br><span class="line">    &quot;username&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;23456789&quot;,</span><br><span class="line">    &quot;database&quot;: &quot;database_test&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;dialect&quot;: &quot;mysql&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;production&quot;: &#123;</span><br><span class="line">    &quot;username&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;12345679&quot;,</span><br><span class="line">    &quot;database&quot;: &quot;database_production&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;dialect&quot;: &quot;mysql&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用如下命令创建数据库：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx sequelize db:create</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用如下命令删除数据库：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx sequelize db:drop</span><br></pre></td></tr></table></figure>
<h3 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h3><p>我们将使用 model:generate 命令。 此命令需要两个选项：</p>
<ul>
<li>name, 模型的名称</li>
<li>attributes, 模型的属性列表</li>
</ul>
<p>创建一个名叫 User 的模型：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">npx</span> <span class="selector-tag">sequelize</span> <span class="selector-tag">model</span><span class="selector-pseudo">:generate</span> <span class="selector-tag">--name</span> <span class="selector-tag">User</span> <span class="selector-tag">--attributes</span> <span class="selector-tag">firstName</span><span class="selector-pseudo">:string</span>,<span class="selector-tag">lastName</span><span class="selector-pseudo">:string</span>,<span class="selector-tag">email</span><span class="selector-pseudo">:string</span></span><br></pre></td></tr></table></figure>
<p>这将创建一下文件:</p>
<ul>
<li>在 models 文件夹中创建了一个 user 模型文件</li>
<li>在 migrations 文件夹中创建了一个名字像 XXXXXXXXXXXXXX-create-user.js 的迁移文件</li>
</ul>
<p>注意: _Sequelize 将只使用模型文件，它是表描述。另一边，迁移文件是该模型的更改，或更具体的是说 CLI 所使用的表。 处理迁移，如提交或日志，以进行数据库的某些更改。</p>
<p>这里感觉这样用命令创建模型有点繁琐，主要是如果字段太多，命令行岂不是要写很多，我的理解是这样的不知道有其他好的方法不，初次使用这个。</p>
<p>我是先创建migrations文件，然后在手动创建模型文件。具体如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx sequelize migration:generate --name=init-users</span><br></pre></td></tr></table></figure>
<p>执行完后会在 <code>database/migrations</code> 目录下生成一个 migration 文件(<code>${timestamp}-init-users.js</code>)，我们修改它来处理初始化 <code>users</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 在执行数据库升级时调用的函数，创建 users 表</span><br><span class="line">  up: async (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    const &#123; INTEGER, DATE, STRING &#125; = Sequelize;</span><br><span class="line">    await queryInterface.createTable(&apos;users&apos;, &#123;</span><br><span class="line">      id: &#123; type: INTEGER, primaryKey: true, autoIncrement: true &#125;,</span><br><span class="line">      name: STRING(30),</span><br><span class="line">      age: INTEGER,</span><br><span class="line">      created_at: DATE,</span><br><span class="line">      updated_at: DATE,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 在执行数据库降级时调用的函数，删除 users 表</span><br><span class="line">  down: async queryInterface =&gt; &#123;</span><br><span class="line">    await queryInterface.dropTable(&apos;users&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行 migrate 进行数据库变更</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 升级数据库</span><br><span class="line">npx sequelize db:migrate</span><br><span class="line"># 如果有问题需要回滚，可以通过 `db:migrate:undo` 回退一个变更</span><br><span class="line"># npx sequelize db:migrate:undo</span><br><span class="line"># 可以通过 `db:migrate:undo:all` 回退到初始状态</span><br><span class="line"># npx sequelize db:migrate:undo:all</span><br></pre></td></tr></table></figure>
<p>执行之后，我们的数据库初始化就完成了。</p>
<p>现在终于可以开始编写代码实现业务逻辑了，首先我们来在 <code>app/model/</code> 目录下编写 user 这个 Model：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">module.exports = app =&gt; &#123;</span><br><span class="line">  const &#123; STRING, INTEGER, DATE &#125; = app.Sequelize;</span><br><span class="line"></span><br><span class="line">  const User = app.model.define(&apos;user&apos;, &#123;</span><br><span class="line">    id: &#123; type: INTEGER, primaryKey: true, autoIncrement: true &#125;,</span><br><span class="line">    name: STRING(30),</span><br><span class="line">    age: INTEGER,</span><br><span class="line">    created_at: DATE,</span><br><span class="line">    updated_at: DATE,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return User;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后就可以结合eggjs的模式来进行数据库的处理了。</p>
<p>说下可以使用的cli命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx sequelize db:migrate:status // 看一下当前状态</span><br></pre></td></tr></table></figure>
<blockquote>
<p>撤销迁移      </p>
<p>db:migrate:undo        - 撤销上一次的迁移操作      </p>
<p>db:migrate:undo:all        - 撤销所有的迁移操作      </p>
<p>db:migrate:undo –name 具体迁移脚本</p>
</blockquote>
<p>我们现在要添加一个字段 lastname，新建一个迁移文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx sequelize migration:create --name addLastname</span><br></pre></td></tr></table></figure>
<p><strong>queryInterface</strong>文档： <a href="https://sequelize.org/master/class/lib/dialects/abstract/query-interface.js~QueryInterface.html" rel="external nofollow noopener noreferrer" target="_blank">https://sequelize.org/master/class/lib/dialects/abstract/query-interface.js~QueryInterface.html</a></p>
<h3 id="种子文件"><a href="#种子文件" class="headerlink" title="种子文件"></a>种子文件</h3><p>种子文件      </p>
<blockquote>
<p>迁移文件是用来构建数据库以及表结构的，种子文件是用来构建数据的      </p>
<p>seed:generate –name demo-user （自定义的名字）    </p>
<p>种子文件脚本与迁移脚本类似，由up于down函数组成，传入的参数也是一致的</p>
</blockquote>
<p>先生成种子文件 name 后边接的是自定义的名字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx sequelize seed:generate --name userseed</span><br></pre></td></tr></table></figure>
<p>会在database/seeders下创建一个种子文件以userseed结尾，然后手动修改这个文件添加点测试数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  up: (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    return queryInterface.bulkInsert(&apos;users&apos;, [&#123;</span><br><span class="line">      id: 1,</span><br><span class="line">      name: &apos;man&apos;,</span><br><span class="line">      age: 18,</span><br><span class="line">    &#125;], &#123;&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  down: (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    return queryInterface.bulkDelete(&apos;users&apos;, null, &#123;&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行种子</p>
<blockquote>
<p>db:seed 指定种子文件        运行指定种子文件      </p>
<p>db:seed:all        运行所有种子文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx sequelize db:seed:all</span><br></pre></td></tr></table></figure>
<p>然后查看数据库，添加上了一条数据</p>
<h3 id="撤销种子执行"><a href="#撤销种子执行" class="headerlink" title="撤销种子执行"></a>撤销种子执行</h3><blockquote>
<p>db:seed:undo –seed 指定种子文件        撤销指定种子文件      </p>
<p>db:seed:undo:all        撤销所有种子文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx sequelize db:seed:undo:all</span><br></pre></td></tr></table></figure>
<p>具体使用请查看官方文档</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>js中的aop</title>
    <url>/2021/03/10/js%E4%B8%AD%E7%9A%84aop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h2><p>简介<br>AOP （面向切面编程），缩写为Aspect Oriented Programming，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是JAVA 中Spring框架的一个重要内容，是函数式编程的一种衍生范型。<a id="more"></a>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<ol>
<li>主要功能</li>
<li>日志记录</li>
<li>性能统计</li>
<li>安全控制</li>
<li>事务处理</li>
<li>异常处理</li>
</ol>
<p>等等。</p>
<h3 id="主要意图"><a href="#主要意图" class="headerlink" title="主要意图"></a>主要意图</h3><p>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</p>
<blockquote>
<p>注：请慎重的在JS的中使用AOP！因为部分JS的方法是异步的。必要时使用ES7中的async/await/Promise，以保证代码的顺序执行。</p>
</blockquote>
<h2 id="AOP在JS中的实现原理"><a href="#AOP在JS中的实现原理" class="headerlink" title="AOP在JS中的实现原理"></a>AOP在JS中的实现原理</h2><p>js中aop的实现原理主要依靠Function的两个函数:apply和call。</p>
<h3 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h3><ul>
<li><p>Function.apply(obj, args);</p>
</li>
<li><p>apply方法能劫持另外一个对象的方法，继承另外一个对象的属性</p>
</li>
<li><p>Function.apply(obj, args)方法能接收两个参数</p>
</li>
<li><p>obj：这个对象将代替Function类里this对象</p>
</li>
<li><p>args：这个是数组，它将作为参数传给Function（args–&gt;arguments）</p>
</li>
</ul>
<p>利用Function.apply()的参数数组化来提升程序的性能</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dosomething(a,b,c)&#123;</span><br><span class="line">    console.log(&apos;do something.&apos;, a, b, c);</span><br><span class="line">    // 预期结果：   do something. see say run</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let something = [&apos;see&apos;, &apos;say&apos;, &apos;run&apos;];</span><br><span class="line">dosomething.apply(this, something);</span><br></pre></td></tr></table></figure></p>
<h3 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h3><ul>
<li>Function.call(obj, arg, arg, …);</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dosomething(a,b,c)&#123;</span><br><span class="line">    console.log(&apos;do something.&apos;, a, b, c);</span><br><span class="line">    // 预期结果：   do something. see say run</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dosomething.call(this, &apos;see&apos;, &apos;say&apos;, &apos;run&apos;);</span><br></pre></td></tr></table></figure>
<p>推荐：使用apply函数。call函数和apply函数的效果是一样，但是call函数的参数不够灵活，在写法上参数无法灵活伸缩；apply函数，只需要把参数放到数组里即可。apply比call函数更适合在项目实际开发中使用，并且apply比call的性能要好。</p>
<h2 id="AOP在JS中的实现"><a href="#AOP在JS中的实现" class="headerlink" title="AOP在JS中的实现"></a>AOP在JS中的实现</h2><p>从事过Java Web开发的童鞋，一定用过Spring框架。在Spring的框架中有before（前置通知）、after（后置通知）、around（环绕通知）。<br>今天我们在JS中实现的这三种通知。</p>
<ol>
<li>before（前置通知）<br>before函数，用来实现函数的前置通知。在目标函数的前面执行一些前置操作。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// AOP 前置通知函数声明</span><br><span class="line">/**</span><br><span class="line"> * 给方法加入前置切片函数</span><br><span class="line"> * 可以在执行方法之前执行一些操作,</span><br><span class="line"> * 前置切片的返回值为false时，不影响原方法的执行</span><br><span class="line"> * @param func &#123;Function&#125; 被前置执行的函数</span><br><span class="line"> * @return &#123;Function&#125; 加入前置通知的函数</span><br><span class="line"> */</span><br><span class="line">Function.prototype._before = function(func)&#123;</span><br><span class="line">    var __self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        func.apply(__self, arguments);</span><br><span class="line">        return __self.apply(__self, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码</span><br><span class="line">function a()&#123;</span><br><span class="line">    console.log(&apos;I\&apos;m a&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = a._before(function()&#123;</span><br><span class="line">    console.log(&apos;before&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a();</span><br><span class="line">// 结果：</span><br><span class="line">// before</span><br><span class="line">// I&apos;m a</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>after（后置通知）<br>after函数，用来实现函数的后置通知。在目标函数的后面面执行一些后置操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// AOP 后置通知函数声明</span><br><span class="line">/**</span><br><span class="line"> * 给方法加入后置切片函数</span><br><span class="line"> * 可以在执行方法之之后执行一些操作</span><br><span class="line"> * 后置切片的返回值为false时，不影响原方法的执行</span><br><span class="line"> * @param func &#123;Function&#125; 被后置执行的函数</span><br><span class="line"> * @return &#123;Function&#125; 加入后置通知的函数</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">Function.prototype._after = function(func)&#123;</span><br><span class="line">    var __self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var ret = __self.apply(__self, arguments);</span><br><span class="line">        func.apply(__self, arguments);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码</span><br><span class="line">function b()&#123;</span><br><span class="line">    console.log(&apos;I\&apos;m b&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = b._after(function()&#123;</span><br><span class="line">    console.log(&apos;after&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">b();</span><br><span class="line">// 结果：</span><br><span class="line">// I&apos;m b</span><br><span class="line">// after</span><br></pre></td></tr></table></figure>
</li>
<li><p>around（环绕通知）<br>在around函数中，引入了一个JoinPoint对象。JoinPoint对象封装了目标函数和目标函数的参数。在调用JoinPoint对象的invoke函数时，会去调用原来的目标函数。在调用invoke时，如果需要改变目标函数的this对象，需要将对象传入到invoke的参数中。around函数，可以在目标函数的前面和后面随意加入逻辑代码，也可以根据条件判断是否执行目标函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// AOP 环绕通知函数声明</span><br><span class="line">/**</span><br><span class="line"> * 切入点对象</span><br><span class="line"> * 不允许切入对象多次调用</span><br><span class="line"> * @param obj   对象</span><br><span class="line"> * @param args  参数</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">function JoinPoint(obj, args)&#123;</span><br><span class="line">    var isapply = false;                       // 判断是否执行过目标函数</span><br><span class="line">    var result = null;                         // 保存目标函数的执行结果</span><br><span class="line"></span><br><span class="line">    this.source = obj;                         // 目标函数对象</span><br><span class="line">    this.args = args;                          // 目标函数对象传入的参数</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 目标函数的代理执行函数</span><br><span class="line">     * 如果被调用过，不能重复调用</span><br><span class="line">     * @return &#123;object&#125; 目标函数的返回结果</span><br><span class="line">     */</span><br><span class="line">    this.invoke = function(thiz)&#123;              </span><br><span class="line">        if(isapply)&#123; return; &#125;</span><br><span class="line">        isapply = true;</span><br><span class="line">        result = this.source.apply(thiz || this.source, this.args);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 获取目标函数执行结果</span><br><span class="line">    this.getResult = function()&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 方法环绕通知</span><br><span class="line"> * 原方法的执行需在环绕通知方法中执行</span><br><span class="line"> * @param func &#123;Function&#125; 环绕通知的函数</span><br><span class="line"> *     程序会往func中传入一个JoinPoint(切入点)对象, 在适当的时机</span><br><span class="line"> *     执行JoinPoint对象的invoke函数，调用目标函数</span><br><span class="line"> * </span><br><span class="line"> * @return &#123;Function&#125; 切入环绕通知后的函数，</span><br><span class="line"> */</span><br><span class="line">Function.prototype._around = function(func)&#123;</span><br><span class="line">    var __self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = [new JoinPoint(__self, arguments)];</span><br><span class="line">        return func.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码</span><br><span class="line"></span><br><span class="line">var isAdmin = true;</span><br><span class="line"></span><br><span class="line">function c()&#123;</span><br><span class="line">    console.log(&apos;show user list&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = c._around(function(joinpoint)&#123;</span><br><span class="line">    if(isAdmin)&#123;    // 满足条件时，执行目标函数</span><br><span class="line">        console.log(&apos;is admin&apos;);</span><br><span class="line">        joinpoint.invoke(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">c();</span><br><span class="line">// 结果</span><br><span class="line">// if isAdmin == true</span><br><span class="line">//     is admin</span><br><span class="line">//     show user list</span><br><span class="line">// if isAdmin == false</span><br><span class="line">//</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="AOP在JS中的应用"><a href="#AOP在JS中的应用" class="headerlink" title="AOP在JS中的应用"></a>AOP在JS中的应用</h2><h3 id="AOP在数据库方面的应用"><a href="#AOP在数据库方面的应用" class="headerlink" title="AOP在数据库方面的应用"></a>AOP在数据库方面的应用</h3><p>记录sql的执行记录(AOP的前置通知)<br>记录sql的执行时间(AOP的环绕通知)<br>sql执行完后自动释放连接(AOP的环绕通知)</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>容易混淆的umi创建命令</title>
    <url>/2021/03/04/%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84umi%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 react 开发中，不得不提的就是 umijs 框架。这个框架把 react 全家桶打了一个包，整合在了一起。让开发者不必苦于配置初始开发环境。在 umijs2.x 升级到 umijs3.x 之后，在创建新项目的命令也发生了变化，让人容易模糊，而且 npm 和 yarn 的使用命令也不相同。这里做个简单的分享，方便以后查阅。<a id="more"></a></p>
<h2 id="Umi-2-x"><a href="#Umi-2-x" class="headerlink" title="Umi 2.x"></a>Umi 2.x</h2><p>通过官网得知，2.x 版本 umi 通过 create-umi 提供脚手架能力来创建的新项目。使用方式如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir myapp &amp;&amp; <span class="built_in">cd</span> myapp</span><br><span class="line">$ yarn create umi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以通过 yarn create umi 或 npm create umi 使用 create-umi。推荐使用 yarn create 命令，能确保每次使用最新的脚手架。</p>
</blockquote>
<p>这里当时其实是很疑惑的，为啥使用的是 create-umi 脚手架来创建的项目，却不是 npm run create-umi 这样的使用命令？最后查阅资料得知，其实 yarn create umi 其实做了两步操作，根据 yarn 的官方文档。</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/20210304175413.png" alt></p>
<p>而 npm create 确实平时不怎么见，而且文档也没有这个命令。最后多方查找说是 npm init 的别名，这里的作用就和 yarn create 一样随便用吧。大概就这样一段野史可证！！</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/20210304175456.png" alt></p>
<p>由此创建项目的脚本命令就清楚了，就是使用了 create-umi 脚手架生成的。那么对以往的总结可以有以下方式来创建项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn create umi // 创建文件在当前文件夹，执行脚本并更新create-umi包</span><br><span class="line">npm create umi  // 创建文件在当前文件夹，只执行脚本不更新create-umi包</span><br><span class="line">yarn create umi water // 创建文件在water文件夹，执行脚本并更新create-umi包</span><br><span class="line">npm create umi water	// 创建文件在water文件夹，只执行脚本不更新create-umi包</span><br><span class="line">// npx方式</span><br><span class="line">npx create-umi</span><br><span class="line">npx create-umi</span><br><span class="line"></span><br><span class="line">第二种方式</span><br><span class="line">1. yarn global add create-umi/npm install create-umi -g // 先安装包</span><br><span class="line">2.</span><br><span class="line">	create-umi // 在当前文件夹创建项目</span><br><span class="line">	create-umi water //在water文件中创建项目</span><br></pre></td></tr></table></figure>
<h2 id="Umi-3-x"><a href="#Umi-3-x" class="headerlink" title="Umi 3.x"></a>Umi 3.x</h2><p>有以上的文字参考，3.x 版本的创建也就容易理解了。主要使用的是@umijs/create-umi-app 包来创建项目的。官网文档是这样写的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir myapp &amp;&amp; cd myapp</span><br><span class="line">$ yarn create @umijs/umi-app</span><br><span class="line"># 或 npx @umijs/create-umi-app</span><br></pre></td></tr></table></figure>
<p>由以上命令来说，总结下创建的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn create @umijs/umi-app</span><br><span class="line">npm create @umijs/umi-app</span><br><span class="line">// 带文件夹</span><br><span class="line">yarn create @umijs/umi-app water</span><br><span class="line">npm create @umijs/umi-app water</span><br><span class="line">// npx方式</span><br><span class="line">npx @umijs/create-umi-app</span><br><span class="line">npx @umijs/create-umi-app water</span><br><span class="line">// 直接使用包创建</span><br><span class="line">1. 先安装包</span><br><span class="line">@umijs/create-umi-app</span><br><span class="line">2. 创建带不带文件夹</span><br><span class="line">create-umi-app</span><br><span class="line">create-umi-app water</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体就是用以上用命令通过脚手架包来创建项目的总结，希望对你有所帮助！！！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>react中的同构</title>
    <url>/2021/01/19/react%E4%B8%AD%E7%9A%84%E5%90%8C%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>随着越来越多新型前端框架的推出，SSR 这个概念在前端开发领域的流行度越来越高，也有越来越多的项目采用这种技术方案进行了实现。SSR 产生的背景是什么？适用的场景是什么？实现的原理又是什么？希望大家在这篇文章中能够找到你想要的答案。<a id="more"></a></p>
<p>说到 SSR，很多人的第一反应是“服务器端渲染”，但我更倾向于称之为“同构”，所以首先我们来对“客户端渲染”，“服务器端渲染”，“同构”这三个概念简单的做一个分析：</p>
<p><strong>客户端渲染</strong>：客户端渲染，页面初始加载的 HTML 页面中无网页展示内容，需要加载执行JavaScript 文件中的 React 代码，通过 JavaScript 渲染生成页面，同时，JavaScript 代码会完成页面交互事件的绑定，详细流程可参考下图（图片取材自 <a href="https://link.zhihu.com/?target=http%3A//fullstackacademy.com" rel="external nofollow noopener noreferrer" target="_blank">http://fullstackacademy.com</a>）：</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/v2-721ab4c7d9e55d6b22da5109787a6617_r.jpg" alt="img"></p>
<p><strong>服务器端渲染</strong>：用户请求服务器，服务器上直接生成 HTML 内容并返回给浏览器。服务器端渲染来，页面的内容是由 Server 端生成的。一般来说，服务器端渲染的页面交互能力有限，如果要实现复杂交互，还是要通过引入 JavaScript 文件来辅助实现。服务器端渲染这个概念，适用于任何后端语言。</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/v2-8fa23eb7918b58d1436e9aaffe3cc25b_r.jpg" alt="img"></p>
<p><strong>同构</strong>：同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。我们把页面的展示内容和交互写在一起，让代码执行两次。在服务器端执行一次，用于实现服务器端渲染，在客户端再执行一次，用于接管页面交互，详细流程可参考下图（图片取材自 <a href="https://link.zhihu.com/?target=http%3A//fullstackacademy.com" rel="external nofollow noopener noreferrer" target="_blank">http://fullstackacademy.com</a>）:</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/v2-221bc777b5190dbdcf86db3d4870691d_r.jpg" alt="img"></p>
<p>一般情况下，当我们使用 React 编写代码时，页面都是由客户端执行 JavaScript 逻辑动态挂 DOM 生成的，也就是说这种普通的单页面应用实际上采用的是客户端渲染模式。在大多数情况下，客户端渲染完全能够满足我们的业务需求，那为什么我们还需要 SSR 这种同构技术呢？</p>
<h2 id="使用-SSR-技术的主要因素："><a href="#使用-SSR-技术的主要因素：" class="headerlink" title="使用 SSR 技术的主要因素："></a>使用 SSR 技术的主要因素：</h2><ol>
<li>CSR 项目的 TTFP（Time To First Page）时间比较长，参考之前的图例，在 CSR 的页面渲染流程中，首先要加载 HTML 文件，之后要下载页面所需的 JavaScript 文件，然后 JavaScript 文件渲染生成页面。在这个渲染过程中至少涉及到两个 HTTP 请求周期，所以会有一定的耗时，这也是为什么大家在低网速下访问普通的 React 或者 Vue 应用时，初始页面会有出现白屏的原因。</li>
<li>CSR 项目的 SEO 能力极弱，在搜索引擎中基本上不可能有好的排名。因为目前大多数搜索引擎主要识别的内容还是 HTML，对 JavaScript 文件内容的识别都还比较弱。如果一个项目的流量入口来自于搜索引擎，这个时候你使用 CSR 进行开发，就非常不合适了。</li>
</ol>
<p>SSR 的产生，主要就是为了解决上面所说的两个问题。在 React 中使用 SSR 技术，我们让 React 代码在服务器端先执行一次，使得用户下载的 HTML 已经包含了所有的页面展示内容，这样，页面展示的过程只需要经历一个 HTTP 请求周期，TTFP 时间得到一倍以上的缩减。</p>
<p>同时，由于 HTML 中已经包含了网页的所有内容，所以网页的 SEO 效果也会变的非常好。之后，我们让 React 代码在客户端再次执行，为 HTML 网页中的内容添加数据及事件的绑定，页面就具备了 React 的各种交互能力。</p>
<p>但是，SSR 这种理念的实现，并非易事。我们来看一下在 React 中实现 SSR 技术的架构图：</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/v2-744285853e079518979f68f981c5c821_r.jpg" alt="img"></p>
<p>使用 SSR 这种技术，将使原本简单的 React 项目变得非常复杂，项目的可维护性会降低，代码问题的追溯也会变得困难。</p>
<p>所以，使用 SSR 在解决问题的同时，也会带来非常多的副作用，有的时候，这些副作用的伤害比起 SSR 技术带来的优势要大的多。从个人经验上来说，我一般建议大家，除非你的项目特别依赖搜索引擎流量，或者对首屏时间有特殊的要求，否则不建议使用 SSR。</p>
<p>好，如果你确实遇到了 React 项目中要使用 SSR 的场景并决定使用 SSR，那么接下来我们就结合上面这张 SSR 架构图，开启 SSR 技术点的难点剖析。</p>
<p>在开始之前，我们先来分析下虚拟 DOM 和 SSR 的关系。</p>
<h2 id="SSR-之所以能够实现，本质上是因为虚拟-DOM-的存在"><a href="#SSR-之所以能够实现，本质上是因为虚拟-DOM-的存在" class="headerlink" title="SSR 之所以能够实现，本质上是因为虚拟 DOM 的存在"></a>SSR 之所以能够实现，本质上是因为虚拟 DOM 的存在</h2><p>上面我们说过，SSR 的工程中，React 代码会在客户端和服务器端各执行一次。你可能会想，这没什么问题，都是 JavaScript 代码，既可以在浏览器上运行，又可以在 Node 环境下运行。但事实并非如此，如果你的 React 代码里，存在直接操作 DOM 的代码，那么就无法实现 SSR 这种技术了，因为在 Node 环境下，是没有 DOM 这个概念存在的，所以这些代码在 Node 环境下是会报错的。</p>
<p>好在 React 框架中引入了一个概念叫做虚拟 DOM，虚拟 DOM 是真实 DOM 的一个 JavaScript 对象映射，React 在做页面操作时，实际上不是直接操作 DOM，而是操作虚拟 DOM，也就是操作普通的 JavaScript 对象，这就使得 SSR 成为了可能。在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。</p>
<p>其他的一些框架，比如 Vue，它能够实现 SSR 也是因为引入了和 React 中一样的虚拟 DOM 技术。</p>
<p>好，接下来我们回过头看流程图，前两步不说了，服务器端渲染肯定要先向 Node 服务器发送请求。重点是第 3 步，大家可以看到，服务器端要根据请求的地址，判断要展示什么样的页面了，这一步叫做服务器端路由。</p>
<p>我们再看第 10 步，当客户端接收到 JavaScript 文件后，要根据当前的路径，在浏览器上再判断当前要展示的组件，重新进行一次客户端渲染，这个时候，还要经历一次客户端路由（前端路由）。</p>
<p>那么，我们下面要说的就是服务器端路由和客户端路由的区别。</p>
<h2 id="SSR-中客户端渲染与服务器端渲染路由代码的差异"><a href="#SSR-中客户端渲染与服务器端渲染路由代码的差异" class="headerlink" title="SSR 中客户端渲染与服务器端渲染路由代码的差异"></a>SSR 中客户端渲染与服务器端渲染路由代码的差异</h2><p>实现 React 的 SSR 架构，我们需要让相同的 React 代码在客户端和服务器端各执行一次。大家注意，这里说的相同的 React 代码，指的是我们写的各种组件代码，所以在同构中，只有组件的代码是可以公用的，而路由这样的代码是没有办法公用的，大家思考下这是为什么呢？其实原因很简单，在服务器端需要通过请求路径，找到路由组件，而在客户端需通过浏览器中的网址，找到路由组件，是完全不同的两套机制，所以这部分代码是肯定无法公用。我们来看看在 SSR 中，前后端路由的实现代码：</p>
<p><strong>客户端路由：</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/'</span> component=&#123;Home&#125;&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;App/</span>&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>))</span><br></pre></td></tr></table></figure>
<p>客户端路由代码非常简单，大家一定很熟悉，BrowserRouter 会自动从浏览器地址中，匹配对应的路由组件显示出来。</p>
<p><strong>服务器端路由代码：</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/'</span> component=&#123;Home&#125;&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>StaticRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Return ReactDom.renderToString(&lt;App/</span>&gt;)</span><br></pre></td></tr></table></figure>
<p>服务器端路由代码相对要复杂一点，需要你把 location（当前请求路径）传递给 StaticRouter 组件，这样 StaticRouter 才能根据路径分析出当前所需要的组件是谁。（PS：StaticRouter 是 React-Router 针对服务器端渲染专门提供的一个路由组件。）</p>
<p>通过 BrowserRouter 我们能够匹配到浏览器即将显示的路由组件，对浏览器来说，我们需要把组件转化成 DOM，所以需要我们使用 ReactDom.render 方法来进行 DOM 的挂载。而 StaticRouter 能够在服务器端匹配到将要显示的组件，对服务器端来说，我们要把组件转化成字符串，这时我们只需要调用 ReactDom 提供的 renderToString 方法，就可以得到 App 组件对应的 HTML 字符串。</p>
<p>对于一个 React 应用来说，路由一般是整个程序的执行入口。在 SSR 中，服务器端的路由和客户端的路由不一样，也就意味着服务器端的入口代码和客户端的入口代码是不同的。</p>
<p>我们知道， React 代码是要通过 Webpack 打包之后才能运行的，也就是第 3 步和第10 步运行的代码，实际上是源代码打包过后生成的代码。上面也说到，服务器端和客户端渲染中的代码，只有一部分一致，其余是有区别的。所以，针对代码运行环境的不同，要进行有区别的 Webpack 打包。</p>
<h2 id="服务器端代码和客户端代码的打包差异"><a href="#服务器端代码和客户端代码的打包差异" class="headerlink" title="服务器端代码和客户端代码的打包差异"></a>服务器端代码和客户端代码的打包差异</h2><p>简单写两个 Webpack 配置文件作为 DEMO：</p>
<p><strong>客户端 Webpack 配置</strong>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: './src/client/index.js',</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: 'index.js',</span><br><span class="line">    path: path.resolve(__dirname, 'public')</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.js?$/,</span><br><span class="line">      loader: 'babel-loader'</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: /\.css?$/,</span><br><span class="line">      use: ['style-loader', &#123;</span><br><span class="line">        loader: 'css-loader',</span><br><span class="line">        options: &#123;modules: true&#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: /\.(png|jpeg|jpg|gif|svg)?$/,</span><br><span class="line">      loader: 'url-loader',</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: 8000,</span><br><span class="line">        publicPath: '/'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>服务器端 Webpack 配置</strong>:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  target: 'node',</span><br><span class="line">  entry: './src/server/index.js',</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: 'bundle.js',</span><br><span class="line">    path: path.resolve(__dirname, 'build')</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.js?$/,</span><br><span class="line">      loader: 'babel-loader'</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: /\.css?$/,</span><br><span class="line">      use: ['isomorphic-style-loader', &#123;</span><br><span class="line">        loader: 'css-loader',</span><br><span class="line">        options: &#123;modules: true&#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: /\.(png|jpeg|jpg|gif|svg)?$/,</span><br><span class="line">      loader: 'url-loader',</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: 8000,</span><br><span class="line">        outputPath: '../public/',</span><br><span class="line">        publicPath: '/'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面我们说了，在 SSR 中，服务器端渲染的代码和客户端的代码的入口路由代码是有差异的，所以在 Webpack 中，Entry 的配置首先肯定是不同的。</p>
<p>在服务器端运行的代码，有时我们需要引入 Node 中的一些核心模块，我们需要 Webpack 做打包的时候能够识别出类似的核心模块，一旦发现是核心模块，不必把模块的代码合并到最终生成的代码中，解决这个问题的方法非常简单，在服务器端的 Webpack配置中，你只要加入 target: node 这个配置即可。</p>
<p>服务器端渲染的代码，如果加载第三方模块，这些第三方模块也是不需要被打包到最终的源码中的，因为 Node 环境下通过 NPM 已经安装了这些包，直接引用就可以，不需要额外再打包到代码里。为了解决这个问题，我们可以使用 webpack-node-externals 这个插件，代码中的 nodeExternals 指的就是这个插件，通过这个插件，我们就能解决这个问题。关于 Node 这里的打包问题，可能看起来有些抽象，不是很明白的同学可以仔细读一下 webpack-node-externals 相关的文章或文档，你就能很好的明白这里存在的问题了。</p>
<p>接下来我们继续分析，当我们的 React 代码中引入了一些 CSS 样式代码时，服务器端打包的过程会处理一遍 CSS，而客户端又会处理一遍。查看配置，我们可以看到，服务器端打包时我们用了 isomorphic-style-loader，它处理 CSS 的时候，只在对应的 DOM 元素上生成 class 类名，然后返回生成的 CSS 样式代码。</p>
<p>而在客户端代码打包配置中，我们使用了 css-loader 和 style-loader，css-loader 不但会在 DOM 上生成 class 类名，解析好的 CSS 代码，还会通过 style-loader 把代码挂载到页面上。不过这么做，由于页面上的样式实际上最终是由客户端渲染时添加上的，所以页面可能会存在一开始没有样式的情况，为了解决这个问题， 我们可以在服务器端渲染时，拿到 isomorphic-style-loader 返回的样式代码，然后以字符串的形式添加到服务器端渲染的 HTML 之中。</p>
<p>而对于图片等类型的文件引入，url-loader 也会在服务器端代码和客户端代码打包的过程中分别进行打包，这里，我偷了一个懒，无论服务器端打包还是客户端打包，我都让打包生成的文件存储在 public 目录下，这样，虽然文件会打包出来两遍，但是后打包出来的文件会覆盖之前的文件，所以看起来还是只有一份文件。</p>
<p>当然，这样做的性能和优雅性并不高，只是给大家提供一个小的思路，如果想进行优化，你可以让图片的打包只进行一次，借助一些 Webpack 的插件，实现这个也并非难事，你甚至可以自己也写一个 loader，来解决这样的问题。</p>
<p>如果你的 React 应用中没有异步数据的获取，单纯的做一些静态内容展示，经过上面的配置，你会发现一个简单的 SSR 应用很快的就可以被实现出来了。但是，真正的一个 React 项目中，我们肯定要有异步数据的获取，绝大多数情况下，我们还要使用 Redux 管理数据。而如果想在 SSR 应用中实现，就不是这么简单了。</p>
<h2 id="SSR-中异步数据的获取-Redux-的使用"><a href="#SSR-中异步数据的获取-Redux-的使用" class="headerlink" title="SSR 中异步数据的获取 + Redux 的使用"></a>SSR 中异步数据的获取 + Redux 的使用</h2><p>客户端渲染中，异步数据结合 Redux 的使用方式遵循下面的流程（对应图中第 12 步）：</p>
<ol>
<li>创建 Store</li>
<li>根据路由显示组件</li>
<li>派发 Action 获取数据</li>
<li>更新 Store 中的数据</li>
<li>组件 Rerender</li>
</ol>
<p>而在服务器端，页面一旦确定内容，就没有办法 Rerender 了，这就要求组件显示的时候，就要把 Store 的数据都准备好，所以服务器端异步数据结合 Redux 的使用方式，流程是下面的样子（对应图中第 4 步）：</p>
<ol>
<li>创建 Store</li>
<li>根据路由分析 Store 中需要的数据</li>
<li>派发 Action 获取数据</li>
<li>更新Store 中的数据</li>
<li>结合数据和组件生成 HTML，一次性返回</li>
</ol>
<p>下面，我们分析下<strong>服务器端渲染</strong>这部分的流程：</p>
<ol>
<li>创建 Store：这一部分有坑，要注意避免，大家知道，客户端渲染中，用户的浏览器中永远只存在一个 Store，所以代码上你可以这么写：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer, defaultState)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<p>然而在服务器端，这么写就有问题了，因为服务器端的 Store 是所有用户都要用的，如果像上面这样构建 Store，Store 变成了一个单例，所有用户共享 Store，显然就有问题了。所以在服务器端渲染中，Store 的创建应该像下面这样，返回一个函数，每个用户访问的时候，这个函数重新执行，为每个用户提供一个独立的 Store：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getStore = <span class="function">(<span class="params">req</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> createStore(reducer, defaultState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getStore;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据路由分析 Store 中需要的数据： 要想实现这个步骤，在服务器端，首先我们要分析当前出路由要加载的所有组件，这个时候我们可以借助一些第三方的包，比如说 react-router-config, 具体这个包怎么使用，不做过多说明，大家可以查看文档，使用这个包，传入服务器请求路径，它就会帮助你分析出这个路径下要展示的所有组件。</li>
<li>派发 Action 获取数据: 接下来，我们在每个组件上增加一个获取数据的方法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Home.loadData = <span class="function">(<span class="params">store</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> store.dispatch(getHomeList())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法需要你把服务器端渲染的 Store 传递进来，它的作用就是帮助服务器端的 Store 获取到这个组件所需的数据。 所以，组件上有了这样的方法，同时我们也有当前路由所需要的所有组件，依次调用各个组件上的 loadData 方法，就能够获取到路由所需的所有数据内容了。</p>
<ol>
<li>更新 Store 中的数据: 其实，当我们执行第三步的时候，已经在更新 Store 中的数据了，但是，我们要在生成 HTML 之前，保证所有的数据都获取完毕，这怎么处理呢？</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// matchedRoutes 是当前路由对应的所有需要显示的组件集合</span></span><br><span class="line">matchedRoutes.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item.route.loadData) &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      item.route.loadData(store).then(resolve).catch(resolve);</span><br><span class="line">    &#125;)</span><br><span class="line">    promises.push(promise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 生成 HTML 逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里，我们使用 Promise 来解决这个问题，我们构建一个 Promise 队列，等待所有的 Promise 都执行结束后，也就是所有 store.dispatch 都执行完毕后，再去生成 HTML。这样的话，我们就实现了结合 Redux 的 SSR 流程。</p>
<p>在上面，我们说到，服务器端渲染时，页面的数据是通过 loadData 函数来获取的。而在客户端，数据获取依然要做，因为如果这个页面是你访问的第一个页面，那么你看到的内容是服务器端渲染出来的，但是如果经过 react-router 路由跳转道第二个页面，那么这个页面就完全是客户端渲染出来的了，所以客户端也要去拿数据。</p>
<p>在客户端获取数据，使用的是我们最习惯的方式，通过 componentDidMount 进行数据的获取。这里要注意的是，componentDidMount 只在客户端才会执行，在服务器端这个生命周期函数是不会执行的。所以我们不必担心 componentDidMount 和 loadData 会有冲突，放心使用即可。这也是为什么数据的获取应该放到 componentDidMount 这个生命周期函数中而不是 componentWillMount 中的原因，可以避免服务器端获取数据和客户端获取数据的冲突。</p>
<h2 id="Node-只是一个中间层"><a href="#Node-只是一个中间层" class="headerlink" title="Node 只是一个中间层"></a>Node 只是一个中间层</h2><p>上一部分我们说到了获取数据的问题，在 SSR 架构中，一般 Node 只是一个中间层，用来做 React 代码的服务器端渲染，而 Node 需要的数据通常由 API 服务器单独提供。</p>
<p>这样做一是为了工程解耦，二也是为了规避 Node 服务器的一些计算性能问题。</p>
<p>请大家关注图中的第 4 步和第 12，13 步，我们接下来分析这几个步骤。</p>
<p>服务器端渲染时，直接请求 API 服务器的接口获取数据没有任何问题。但是在客户端，就有可能存在跨域的问题了，所以，这个时候，我们需要在服务器端搭建 Proxy 代理功能，客户端不直接请求 API 服务器，而是请求 Node 服务器，经过代理转发，拿到 API 服务器的数据。</p>
<p>这里你可以通过 express-http-proxy 这样的工具帮助你快速搭建 Proxy 代理功能，但是记得配置的时候，要让代理服务器不仅仅帮你转发请求，还要把 cookie 携带上，这样才不会有权限校验上的一些问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node 代理功能实现代码</span></span><br><span class="line">app.use(<span class="string">'/api'</span>, proxy(<span class="string">'http://apiServer.com'</span>, &#123;</span><br><span class="line">  proxyReqPathResolver: <span class="function"><span class="keyword">function</span> (<span class="params">req</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'/ssr'</span> + req.url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>到这里，整个 SSR 的流程体系中关键知识点的原理就串联起来了，如果你之前适用过 SSR 框架，那么这些知识点的整理我相信可以从原理层面很好的帮助到你。</p>
<p>当然，我也考虑到阅读本篇文章的同学可能有很大一部分对 SSR 的基础知识非常有限，看了文章可能会云里雾里，这里为了帮助这些同学，我编写了一个非常简单的 SSR 框架，代码放在这里：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//files.alicdn.com/tpsservice/bf46acacaab649752e9c9121bdfb7f70.zip" rel="external nofollow noopener noreferrer" target="_blank">https://files.alicdn.com/tpsservice/bf46acacaab649752e9c9121bdfb7f70.zip</a></p>
<p>初学者结合上面的流程图，一步步梳理流程图中的逻辑，梳理结束后，回来再看一遍这篇文章，相信大家就豁然开朗了。</p>
<p>当然在真正实现 SSR 架构的过程中，难点有时不是实现的思路，而是细节的处理。比如说如何针对不同页面设置不同的 title 和 description 来提升 SEO 效果，这时候，我们其实可以用 react-helmet 这样的工具帮我们达成目标，这个工具对客户端和服务器端渲染的效果都很棒，值得推荐。还有一些诸如工程目录的设计，404，301 重定向情况的处理等等，不过这些问题，我们只需要在实践中遇到的时候逐个攻破就可以了。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>你需要知道的js中的this指向</title>
    <url>/2021/01/12/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84js%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于前端从业者来说，this的指向一直是绕不开的话题。也是对js基础掌握的好不好的一个体现。这里就this的一些指向做一个简单的整理，一方面方便不太清楚的同学查阅，另一方面也是让自己掌握的更加清楚。希望大家都对this有一个清楚的认识。<a id="more"></a></p>
<h2 id="this指向的规则"><a href="#this指向的规则" class="headerlink" title="this指向的规则"></a>this指向的规则</h2><p>函数的this是在调用的时候绑定的，也就是说this的指向完全取决于函数的调用。为了搞清楚this的指向，必须知道函数是如何调用的。不同的调用方式执行上下文不同，理解的关键就是上下文的确定。而箭头函数没有自己的this，确定this的方式是看定义箭头函数的地方。</p>
<h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>非严格模式和严格模式中this都是指向顶层对象（浏览器中是window，node中是global）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span> === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">this</span> === <span class="built_in">window</span>;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">'water'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// water</span></span><br></pre></td></tr></table></figure>
<h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p><strong>普通函数调用模式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">func(); <span class="comment">// 'window'</span></span><br></pre></td></tr></table></figure>
<p>你可能会误以为window.func()是调用的，所以是指向window。虽然本例中window.func确实等于func。name等于window.name。上面代码中这是因为在ES5中，全局变量是挂载在顶层对象（浏览器是window）中。<br>事实上，并不是如此。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// true, undefined</span></span><br></pre></td></tr></table></figure>
<p>这个例子中let没有给顶层对象中（浏览器是window）添加属性，window.name和window.func都是undefined。<br>严格模式中，普通函数中的this则表现不同，表现为undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">this</span> === <span class="string">'undefined'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">func(); <span class="comment">// true，// 报错，因为this是undefined</span></span><br></pre></td></tr></table></figure>
<p>一些书上将这种叫做默认绑定。<br>对call，apply熟悉的会类比为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.call(<span class="literal">undefined</span>);</span><br><span class="line">func.apply(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p>效果是一样的，call，apply作用之一就是用来修改函数中的this指向为第一个参数的。<br>第一个参数是undefined或者null，非严格模式下，是指向window。严格模式下，就是指向第一个参数。后文详细解释。<br>经常有这类代码（回调函数），其实也是普通函数调用模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'water'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 语法</span></span><br><span class="line">setTimeout(fn | code, <span class="number">0</span>, arg1, arg2, ...)</span><br><span class="line"><span class="comment">// 也可以是一串代码。也可以传递其他函数</span></span><br><span class="line"><span class="comment">// 类比 setTimeout函数内部调用fn或者执行代码`code`。</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>, arg1, arg2, ...);</span><br></pre></td></tr></table></figure>
<p><strong>对象中的函数（方法）调用模式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="string">'water'</span>,</span><br><span class="line">    func: func,</span><br><span class="line">    other: &#123;</span><br><span class="line">        name: <span class="string">'other'</span>,</span><br><span class="line">        func: func,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.func(); <span class="comment">// 'water'</span></span><br><span class="line">student.other.func(); <span class="comment">// 'other'</span></span><br><span class="line"><span class="comment">// 用call类比则为：</span></span><br><span class="line">student.doSth.call(student);</span><br><span class="line"><span class="comment">// 用call类比则为：</span></span><br><span class="line">student.other.doSth.call(student.other);</span><br></pre></td></tr></table></figure>
<p>但往往会有以下场景，把对象中的函数赋值成一个变量了。<br>这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> studentFunc = student.func;</span><br><span class="line">studentFunc(); <span class="comment">// 'window'</span></span><br><span class="line"><span class="comment">// 用call类比则为：</span></span><br><span class="line">studentFunc.call(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p><strong>call、apply、bind 调用模式</strong><br>上文提到call、apply，这里详细解读一下。先通过MDN认识下call和apply<br>MDN 文档：<code>Function.prototype.call()</code><br>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p><strong>thisArg</strong><br>在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。<br><strong>arg1, arg2, …</strong><br>指定的参数列表<br><strong>返回值</strong><br>返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。<br>apply和call类似。只是参数不一样。它的参数是数组（或者类数组）。<br>根据参数thisArg的描述，可以知道，call就是改变函数中的this指向为thisArg，并且执行这个函数，这也就使JS灵活很多。严格模式下，thisArg是原始值是值类型，也就是原始值。不会被包装成对象。举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">func.call(<span class="number">2</span>, <span class="string">'water'</span>); <span class="comment">// Number&#123;2&#125;, 'water'</span></span><br><span class="line"><span class="keyword">var</span> me = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">me.call(<span class="number">2</span>, <span class="string">'water'</span>); <span class="comment">// 2, 'water'</span></span><br></pre></td></tr></table></figure>
<p>虽然一般不会把thisArg参数写成值类型。但还是需要知道这个知识。<br>模拟实现JS的call和apply方法<br>就是利用对象上的函数this指向这个对象，来模拟实现call和apply的。bind和call和apply类似，第一个参数也是修改this指向，只不过返回值是新函数，新函数也能当做构造函数（new）调用。<br><code>MDN Function.prototype.bind</code></p>
<blockquote>
<p>bind()方法创建一个新的函数， 当这个新函数被调用时this键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。</p>
</blockquote>
<p><strong>语法</strong>：</p>
<p><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>
<p><strong>参数</strong>：</p>
<p><code>thisArg</code><br>调用绑定函数时作为this参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用bind在setTimeout中创建一个函数（作为回调提供）时，作为thisArg传递的任何原始值都将转换为object。如果没有提供绑定的参数，则执行作用域的this被视为新函数的thisArg。<br><code>arg1, arg2, ...</code><br>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</p>
<p><strong>返回值</strong></p>
<p>返回由指定的this值和初始化参数改造的原函数拷贝。<br>利用call和apply指向这个thisArg参数，来模拟实现bind的。</p>
<p><strong>构造函数调用模式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// &#123;name: '若川'&#125;</span></span><br><span class="line">    <span class="comment">// 相当于返回了</span></span><br><span class="line">    <span class="comment">// return this;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> Student(<span class="string">'若川'</span>);</span><br></pre></td></tr></table></figure>
<p>使用new操作符调用函数，会自动执行以下步骤。</p>
<blockquote>
<ol>
<li>创建了一个全新的对象。</li>
<li>这个对象会被执行[[Prototype]]（也就是<strong>proto</strong>）链接。</li>
<li>生成的新对象会绑定到函数调用的this。</li>
<li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</li>
<li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。</li>
</ol>
</blockquote>
<p>由此可以知道：new操作符调用时，this指向生成的新对象。<br><strong>特别提醒一下，new调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">// return function f()&#123;&#125;;</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> Student(<span class="string">'water'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); &#123;<span class="attr">name</span>: <span class="string">'water'</span>&#125;</span><br><span class="line"><span class="comment">// 如果返回函数f，则result是函数f，如果是对象&#123;&#125;，则result是对象&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>很多人或者文章都忽略了这一点，直接简单用typeof判断对象。虽然实际使用时不会显示返回，但面试官会问到。</p>
<p><strong>原型链中的调用模式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'water'</span>);</span><br><span class="line">Student.prototype.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">s1.func(); <span class="comment">// 'water'</span></span><br></pre></td></tr></table></figure>
<p>会发现这个似曾相识。这就是对象上的方法调用模式。自然是指向生成的新对象。<br>如果该对象继承自其它对象。同样会通过原型链查找。<br>上面代码使用<br>ES6中class写法则是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    func()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> Student(<span class="string">'water'</span>);</span><br><span class="line">s1.func();</span><br></pre></td></tr></table></figure>
<p><strong>箭头函数调用模式</strong><br>先看箭头函数和普通函数的重要区别：</p>
<blockquote>
<ol>
<li>没有自己的this、super、arguments和new.target绑定。</li>
<li>不能使用new来调用。</li>
<li>没有原型对象。</li>
<li>不可以改变this的绑定。</li>
<li>形参名称不能重复。</li>
<li>箭头函数中没有this绑定，必须通过查找作用域链来决定其值。</li>
</ol>
</blockquote>
<p>如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this的值则被设置为全局对象。<br>比如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="string">'water'</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// var self = this;</span></span><br><span class="line">        <span class="keyword">var</span> arrowFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(self.name);</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        arrowFunc();</span><br><span class="line">    &#125;,</span><br><span class="line">    arrowFunc2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.func(); <span class="comment">// 'water'</span></span><br><span class="line">student.arrowFunc2(); <span class="comment">// 'window'</span></span><br></pre></td></tr></table></figure>
<p>其实就是相当于箭头函数外的this是缓存的该箭头函数上层的普通函数的this。如果没有普通函数，则是全局对象（浏览器中则是window）。<br>也就是说无法通过call、apply、bind绑定箭头函数的this(它自身没有this)。而call、apply、bind可以绑定缓存箭头函数上层的普通函数的this。<br>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="string">'water'</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'arrowFn:'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'person'</span>,</span><br><span class="line">&#125;</span><br><span class="line">student.func().call(person); <span class="comment">// 'water'  'arrowFn:' 'water'</span></span><br><span class="line">student.func.call(person)(); <span class="comment">// 'person' 'arrowFn:' 'person'</span></span><br></pre></td></tr></table></figure>
<p><strong>DOM事件处理函数调用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">addEventerListener、attachEvent、onclick</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span>onclick<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span></span><br><span class="line"><span class="javascript">    button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === ev.currentTarget); <span class="comment">// true</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> list = <span class="built_in">document</span>.querySelector(<span class="string">'.list'</span>);</span></span><br><span class="line"><span class="javascript">    list.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === list); <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === ev.currentTarget); <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(ev.target);</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>onclick和addEventerListener是指向绑定事件的元素。一些浏览器，比如IE6~IE8下使用attachEvent，this指向是window。<br><strong>顺便提下</strong>：面试官也经常考察ev.currentTarget和ev.target的区别。ev.currentTarget是绑定事件的元素，而ev.target是当前触发事件的元素。比如这里的分别是ul和li。但也可能点击的是ul，这时ev.currentTarget和ev.target就相等了。<br><strong>内联事件处理函数调用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn1"</span> <span class="attr">onclick</span>=<span class="string">"console.log(this === document.querySelector('.btn1'))"</span>&gt;</span>点我呀<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"console.log((function()&#123;return this&#125;)());"</span>&gt;</span>再点我呀<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一个是button本身，所以是true，第二个是window。这里跟严格模式没有关系。当然我们现在不会这样用了，但有时不小心写成了这样，也需要了解。其实this的使用场景还有挺多，比如对象object中的getter、setter的this，new Function()、eval。但掌握以上几种，去分析其他的，就自然迎刃而解了。使用比较多的还是普通函数调用、对象的函数调用、new调用、call、apply、bind调用、箭头函数调用。那么他们的优先级是怎样的呢。</p>
<p><strong>优先级</strong></p>
<p>而箭头函数的this是上层普通函数的this或者是全局对象（浏览器中是window），所以排除，不算优先级。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'person'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'return:'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">'water'</span>,</span><br><span class="line">    func: func,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通函数调用</span></span><br><span class="line">func(); <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 对象上的函数调用</span></span><br><span class="line">Student.func(); <span class="comment">// 'water'</span></span><br><span class="line"><span class="comment">// call、apply 调用</span></span><br><span class="line">Student.func.call(person); <span class="comment">// 'person'</span></span><br><span class="line"><span class="keyword">new</span> Student.func.call(person);</span><br></pre></td></tr></table></figure>
<p>试想一下，如果是Student.func.call(person)先执行的情况下，那new执行一个函数。是没有问题的。<br>然而事实上，这代码是报错的。运算符优先级是new比点号低，所以是执行new (Student.func.call)(person)<br>而Function.prototype.call，虽然是一个函数（apply、bind也是函数），跟箭头函数一样，不能用new调用。所以报错了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Uncaught TypeError: Student.doSth.call is not a constructor</span><br></pre></td></tr></table></figure>
<p>这是因为函数内部有两个不同的方法：[[Call]]和[[Constructor]]。<br>当使用普通函数调用时，[[Call]]会被执行。当使用构造函数调用时，[[Constructor]]会被执行。call、apply、bind和箭头函数内部没有[[Constructor]]方法。<br>从上面的例子可以看出普通函数调用优先级最低，其次是对象上的函数。<br>call（apply、bind）调用方式和new调用方式的优先级，在《你不知道的JavaScript》是对比bind和new，引用了mdn的bind的ployfill实现，new调用时bind之后的函数，会忽略bind绑定的第一个参数，(mdn的实现其实还有一些问题，感兴趣的读者，可以看我之前的文章：面试官问：能否模拟实现JS的bind方法)，说明new的调用的优先级最高。<br>所以它们的优先级是new 调用 &gt; call、apply、bind 调用 &gt; 对象上的函数调用 &gt; 普通函数调用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果要判断一个运行中函数的 this 绑定， 就需要找到这个函数的直接调用位置。 找到之后<br>就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p>
<ol>
<li>new 调用：绑定到新创建的对象，注意：显示return函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。</li>
<li>call 或者 apply（ 或者 bind） 调用：严格模式下，绑定到指定的第一个参数。非严格模式下，null和undefined，指向全局对象（浏览器中是window），其余值指向被new Object()包装的对象。</li>
<li>对象上的函数调用：绑定到那个对象。</li>
<li>普通函数调用： 在严格模式下绑定到 undefined，否则绑定到全局对象。</li>
</ol>
<p>ES6 中的箭头函数：不会使用上文的四条标准的绑定规则， 而是根据当前的词法作用域来决定this， 具体来说， 箭头函数会继承外层函数，调用的 this 绑定（ 无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是window）。 这其实和 ES6 之前代码中的 self = this 机制一样。</p>
<p>DOM事件函数：一般指向绑定事件的DOM元素，但有些情况绑定到全局对象（比如IE6~IE8的attachEvent）。</p>
<p>一定要注意，有些调用可能在无意中使用普通函数绑定规则。 如果想“ 更安全” 地忽略 this 绑<br>定， 你可以使用一个对象， 比如 ø = Object.create(null)， 以保护全局对象。</p>
<p>面试官考察this指向就可以考察new、call、apply、bind，箭头函数等用法。从而扩展到作用域、闭包、原型链、继承、严格模式等。这就是面试官乐此不疲的原因。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序中踩过的坑，你得注意下喽</title>
    <url>/2020/12/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%EF%BC%8C%E4%BD%A0%E5%BE%97%E6%B3%A8%E6%84%8F%E4%B8%8B%E5%96%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>因为之前一直做的是pc端的开发，而且大部分是用的vue或者react技术栈。并页所做的web网页基本也都不需要兼容低版本浏览器，所以在开发过程中对于兼容的处理其实比较少的。然而当开始接触微信小程序原生开发之后，也开始遇到并解决了一些坑，有些是兼容性导致的，这里就简单记录下自己遇到并解决的坑，希望对你也有所帮助，不用在此浪费时间！<a id="more"></a></p>
<h2 id="text标签不要换行，view中如果也只有文本也不要换行"><a href="#text标签不要换行，view中如果也只有文本也不要换行" class="headerlink" title="text标签不要换行，view中如果也只有文本也不要换行"></a>text标签不要换行，view中如果也只有文本也不要换行</h2><p>这个问题真的是写div写的习惯了，特别喜欢把标签换行就像这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	中国</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而当在小程序中也这样写的时候，问题就出现了。在小程序中渲染完成后会发现在文字的前后会加一行空格，所以就导致了文字前后的上下间距加大，所以导致页面与设计不符合。因此小程序中不能换行！</p>
<h2 id="bind绑定事件在低版本不能带有冒号"><a href="#bind绑定事件在低版本不能带有冒号" class="headerlink" title="bind绑定事件在低版本不能带有冒号"></a>bind绑定事件在低版本不能带有冒号</h2><p>这个是在input输入框的时候，绑定了一个事件。但是当时是用的是bind:事件这样的写法，在高版本的微信使用是没有问题的，但是当在低版本微信的时候，事件并没有生效。然后查了下文档，文档说是在比较低的版本只支持不带：的绑定写法，所以为了兼容性可以看最低需要支持的微信版本，适度使用不带：的绑定事件。</p>
<h2 id="setData异步问题"><a href="#setData异步问题" class="headerlink" title="setData异步问题"></a>setData异步问题</h2><p>文档有写到setData方法是个异步的方法，所以在需要依赖这个更改值的地方，需要写到回调函数里，类似于react的setState方法。还有个需要注意的问题是，在需要更新ui的值才放到data中用setData进行更改，因为setData更改数据比较消耗性能，如果是js中需要使用的变量不涉及到更新ui界面，可以直接放到this下，更改值的时候直接这样修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.flag = <span class="string">'123'</span></span><br></pre></td></tr></table></figure>
<p>这样的话一方面避免的性能问题，一方面也解决了更改数据的异步问题。</p>
<h2 id="禁止滑动穿透要定义一个catch事件touchmove事件"><a href="#禁止滑动穿透要定义一个catch事件touchmove事件" class="headerlink" title="禁止滑动穿透要定义一个catch事件touchmove事件"></a>禁止滑动穿透要定义一个catch事件touchmove事件</h2><p>在封装一个弹出层模态框的时候，当蒙层盖在页面上，滑动蒙层会穿透滑动页面，要禁止这个穿透滑动只需要用catch定义一个touchmove的空事件方法就可以了。</p>
<h2 id="wxml中不能使用一些js方法"><a href="#wxml中不能使用一些js方法" class="headerlink" title="wxml中不能使用一些js方法"></a>wxml中不能使用一些js方法</h2><p>在web开发的时候，比如react，通常如果数据需要简单的处理下，可以直接在jsx中对数据进行处理。比如保留2位小数这样的需求。但是如果在小程序中直接使用js的api进行数据处理是行不通的，所以要想对数据再次处理有两个方法：</p>
<ol>
<li>直接在js文件中把数据先处理好</li>
<li>在wxs中定义一个处理函数，然后在wxml中进行调用</li>
</ol>
<h2 id="wx-scanCode在安卓和iOS下表现不一致"><a href="#wx-scanCode在安卓和iOS下表现不一致" class="headerlink" title="wx.scanCode在安卓和iOS下表现不一致"></a>wx.scanCode在安卓和iOS下表现不一致</h2><p>这个坑是真的难受，当在进入页面判断调用wx.scanCode之后，在成功的回调进行赋值。结果发现安卓下赋值总是晚于onShow生命周期函数，但是在iOS上是成功的回调函数先于onShow生命周期函数。最后经过反复论证，得出的结论是</p>
<blockquote>
<p>调用扫一扫api在安卓下，回调函数是晚于onShow。而在iOS下回调函数会早于onShow</p>
</blockquote>
<h2 id="开发版和正式版本有本地缓存记录，体验版没有"><a href="#开发版和正式版本有本地缓存记录，体验版没有" class="headerlink" title="开发版和正式版本有本地缓存记录，体验版没有"></a>开发版和正式版本有本地缓存记录，体验版没有</h2><p>在测试小程序的时候，难免会接触到开发版、体验版和正式版。这个坑就是这三个版本之间会有差异，所以不到正式版测试一下，其它的版本只能做一个参考。举个例子：就是有个人数据永久存储到本地，但是体验版在每次进入的时候却并没有保存。所以开发小程序每个版本都要试试，有差异要以正式版为主</p>
<h2 id="小程序之间跳转的extraData下的参数安卓和iOS表现不同"><a href="#小程序之间跳转的extraData下的参数安卓和iOS表现不同" class="headerlink" title="小程序之间跳转的extraData下的参数安卓和iOS表现不同"></a>小程序之间跳转的extraData下的参数安卓和iOS表现不同</h2><p>在做小程序跳转的时候需要携带一些参数，文档指出在extraData下有携带的数据，但是实践得知，在安卓和iOS存在不同，安卓携带的数据是一直存在的，内部页面的跳转也携带有参数。而iOS只在跳转的那个页面存在数据，在之后的内部跳转数据是消失不存在的</p>
<h2 id="app-onShow中不可以获取页面栈"><a href="#app-onShow中不可以获取页面栈" class="headerlink" title="app onShow中不可以获取页面栈"></a>app onShow中不可以获取页面栈</h2><h2 id="跳转会触发page的onload方法"><a href="#跳转会触发page的onload方法" class="headerlink" title="跳转会触发page的onload方法"></a>跳转会触发page的onload方法</h2><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是开发小程序中遇到的问题，简单总结下，绝对有帮助谢谢给个赞。如果发现有问题欢迎指正！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>使用padding实现自适应图片</title>
    <url>/2020/12/02/%E4%BD%BF%E7%94%A8padding%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%80%82%E5%BA%94%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一、CSS 百分比 padding 都是相对宽度计算的<br>在默认的水平文档流方向下，CSS margin 和 padding 属性的垂直方向的百分比值都是相对于宽度计算的，这个和 top, bottom 等属性的百分比值不一样。</p>
<p>对于 padding 属性而言，任意方向的百分比 padding 都现对于宽度计算可以让我们轻松实现固定比例的块级容器，<a id="more"></a>举个例子，假设现在有个<code>&lt;div&gt;</code>元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123; padding: 50%; &#125;</span><br><span class="line">// 或者：</span><br><span class="line"></span><br><span class="line">div &#123; padding: 100% 0 0; &#125;</span><br><span class="line">// 或者：</span><br><span class="line"></span><br><span class="line">div &#123; padding-bottom: 100%; &#125;</span><br></pre></td></tr></table></figure>
<p>则这个<code>&lt;div&gt;</code>元素尺寸就是一个宽高 1:1 的正方形，无论其父容器宽度是多少，这个<code>&lt;div&gt;</code>元素总能保持比例不变。</p>
<p>这种能固定比例的特性什么作用呢？</p>
<p>对于绝大多数都布局，我们并不要求非要比例固定，但是有一种情况例外，那就是图片，因为图片原始尺寸它是固定的。在传统的固定宽度的布局下，我们会通过给图片设定具体的宽度和高度值，来保证我们的图片占据区域稳固；但是在移动端或者在响应式开发情况下，图片最终展现的宽度很可能是不确定的，例如手机端的一个通栏广告，iPhone7 下宽度是 375，iPhone7 Plus 下是 414，还有 360 等尺寸，此时需要的不是对图片进行固定尺寸设定，而是比例设定。</p>
<p>通常有如下一些实现：</p>
<ol>
<li>固定一个高度，然后使用 background-size 属性控制，如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    .banner &#123;</span><br><span class="line">    height: 40px;</span><br><span class="line">    background-size: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实时效果如下：</p>
<p>可以看到随着宽度的变化，总会有部分图片区域（宽度或高度）无法显示，并不是完美的做法。</p>
<ol start="2">
<li>使用视区宽度单位 vw，如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.banner &#123;</span><br><span class="line">height: 15.15vw;</span><br><span class="line">background-size: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对兼容性要求不是很高，使用 vw 也是一个不错的做法，至少理解起来要更轻松一点。</p>
<p>但是，如果我们的图片不是通栏，而是需要离左右各 1rem 的距离，此时，我们的 CSS 代码就要啰嗦点了，想要保持完美比例，就使用借助 CSS3 calc()计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.banner &#123;</span><br><span class="line">height: calc(0.1515 \* (100vw - 2rem));</span><br><span class="line">background-size: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果，图片距离两侧的宽度是动态不确定的，则，此时 calc()也捉襟见肘了，但，恰恰是普普通通其貌不扬的 padding 属性，其兼容性和适应性都一级棒。</p>
<ol start="3">
<li>使用百分比 padding，如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.banner &#123;</span><br><span class="line">padding: 15.15% 0 0;</span><br><span class="line">background-size: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时无论图片的外部元素怎么变动，比例都是恒定不变的。</p>
<p>二、CSS 百分比 padding 与宽度自适应图片布局<br>但是有时候我们的图片是不方便作为背景图呈现的，而是内联的<img>，百分比 padding 也是可以轻松应对的，求套路是比较固定的，图片元素外面需要一个固定比例的容器元素，例如下面的 HTML 结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;banner&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;&quot;banner.jpg&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><code>.banner</code> 元素同样负责控制比例，然后图片填充<code>.banner</code> 元素即可，CSS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.banner &#123;</span><br><span class="line">padding: 15.15% 0 0;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.banner &gt; img &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 100%; height: 100%;</span><br><span class="line">left: 0; top: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，我之前一直低估百分比 padding 的实际应用价值，因为有 vw 单位的存在，毕竟理解 vw 看上去要更简单一些，所以，一直就没做相关技巧的介绍。但是，随着图片相关布局处理越来越多，我发现，百分比 padding 的实用价值要比想象的大，要比 vw 单位适用场景更多，兼容性更好（百分比特性 IE6+支持，图片 100%覆盖 IE8+支持）。</p>
<p>对于复杂布局，如果图片的宽度是不固定的自适应的，我们通常会想到这么一个取巧的做法，就是只设定图片的宽度，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img &#123; width: 100%; &#125;</span><br></pre></td></tr></table></figure>
<p>此时浏览器默认会保持图片比例显示，图片宽度大了，高度也跟着一起变大；图片宽度小了，高度也跟着一起变小。开发人员似乎无需关心图片真实比例是怎样的。</p>
<p>然而这种技巧有一个非常不好的体验问题，那就是随着页面加载的进行，图片占据的高度会有一个从 0 到计算高度的图片变化，视觉上会有明显的元素跳动，代码层面会有布局重计算。</p>
<p>所以对图片高宽进行同时约定还是有必要的，但是同时要保证宽度自适应，似乎有点难度。记住，如果遇到这种需求场景，没有比百分比 padding 布局更好的做法！</p>
<p>缩小浏览器宽度可以看到不同宽度下的布局效果，Gif 效果截图如下：</p>
<p>此 demo 难点就是图片自适应同时保持比例，以及页面刷新的时候没有布局稳固不晃动，其核心 HTML 和 CSS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;works-item-t&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./150x200.png&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.works-item-t &#123;</span><br><span class="line">    padding-bottom: 133%;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.works-item-t &gt; img &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 100%; height: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当把垂直方向 <code>padding</code> 值只使用 <code>padding-bottom</code> 表示的时候，如果没有 <code>text-align</code> 属性干扰，<code>&lt;img&gt;</code>元素的 <code>left:0;top:0</code> 是可以省略的。</p>
<p>对于这种图片宽度 100%容器，高度按比例的场景，<code>padding-bottom</code> 的百分比值大小就是图片元素的高宽比，就这么简单。</p>
<p>但，有时候，图片宽度并不是 100%容器的，例如，图片宽度 50%容器宽度，图片高宽比 4:3，此时，CSS 垂直方向百分比就 666 了，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.img-box &#123;</span><br><span class="line">padding: 0 50% 66.66% 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序创建页面和组件文件夹命令行工具</title>
    <url>/2020/11/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9B%E5%BB%BA%E9%A1%B5%E9%9D%A2%E5%92%8C%E7%BB%84%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做微信小程序开发的过程中，都需要用到微信开发者工具。在这个工具中，可以用来调试微信小程序，也可以用来作为代码编辑器。但是个人觉得作为编辑器不太好用，所以现在的开发模式是用微信开发者工具调试代码，而用vscode作为代码编辑器。在开发中还有一些开发体验不是很好的，比如当想创建一个页面或者一个组件文件的的时候，如果在vscode中创建的话，那么会有很多需要创建的文件，因为一个文件夹默认需要四个文件。<a id="more"></a>如果不想一个个创建文件的话，就需要到微信开发者工具中右键点击生成。在开发中，这两种方式都使用过，感觉都是痛点。于是就主动做了个命令行工具，通过在命令行中执行命令生成想要的文件，达到一种相对较好的体验。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>想要做一个这样的工具，初步思考是用node来实现，先定义一个默认的模版文件夹，然后在执行命令的时候，带上需要生成的分包名、页面名、组件名，然后通过这些参数在项目根目录中生成相应的文件夹，然后把默认的模版文件拷贝到新生成的文件夹中，到此命令行生成项目文件夹结束。<a href="https://www.npmjs.com/package/@waterpack/wx-cli" rel="external nofollow noopener noreferrer" target="_blank">wx-cli已上传npm包点击可查看详情</a></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个工具主要是通过node来实现的，利用node的api来对项目文件进行操作。也用到一些优化命令行交互的包，比如为了输出文字好看一点的，简单列举下使用的依赖包。</p>
<ul>
<li>commander 方便获取命令行参数，并确定命令行的命令</li>
<li>ora 优化交互比如：加个执行状态</li>
<li>chalk 改变输出文字的颜色</li>
</ul>
<h4 id="1-先使用commander来定义创建的命令"><a href="#1-先使用commander来定义创建的命令" class="headerlink" title="1. 先使用commander来定义创建的命令"></a>1. 先使用commander来定义创建的命令</h4><ul>
<li>wx-cli -pack xx  生成一个新的分包</li>
<li>wx-cli -p xx   生成一个新的页面</li>
<li>wx-cli -c xx  生成一个新的组件</li>
</ul>
<p>这里简单说下命令，下面会列出各种使用方式，npm包中也有详细文档。</p>
<h4 id="2-使用fs模块来对文件进行操作，实现主要的逻辑。"><a href="#2-使用fs模块来对文件进行操作，实现主要的逻辑。" class="headerlink" title="2. 使用fs模块来对文件进行操作，实现主要的逻辑。"></a>2. 使用fs模块来对文件进行操作，实现主要的逻辑。</h4><ul>
<li>用fs.readFileSync来读取project.config.json文件，简单判断下是不是在小程序项目目录的根目录。如果不是的话，就直接报错并提示不是根目录。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> projectConfig = <span class="built_in">JSON</span>.parse(fs.readFileSync(<span class="string">`<span class="subst">$&#123;path.resolve()&#125;</span>/project.config.json`</span>, <span class="string">'utf8'</span>))</span><br><span class="line">      projectName = projectConfig.projectname</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      spinner.fail(chalk.red(<span class="string">'没有在项目根路径执行命令，请检查执行命令的根目录'</span>))</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    spinner.warn(chalk.yellow(<span class="string">'该项目与所选项目不符，请查看选择对应的项目'</span>))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用fs.mkdirSync来创建新的文件夹</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.mkdirSync(<span class="string">`<span class="subst">$&#123;pack&#125;</span>/pages`</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用fs.statSync来判断新创建的文件夹是否存在，如果已经存不在重新创建并提示</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fs.statSync(pack)) &#123;</span><br><span class="line">        spinner.warn(chalk.yellow(<span class="string">'已经存在该目录不在重新创建'</span>))</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用fs.copyFileSync来把默认的模版复制到新创建的文件夹中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.copyFileSync(<span class="string">`<span class="subst">$&#123;pagePath&#125;</span>/<span class="subst">$&#123;item&#125;</span>`</span>, <span class="string">`<span class="subst">$&#123;pack&#125;</span>/pages/<span class="subst">$&#123;page&#125;</span>/<span class="subst">$&#123;item&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>
<p>基本的实现原理就是用以上方式，具体代码可自行查看。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>创建包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 命令</span><br><span class="line">wx-cli -pack </span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">➜  water git:(develop) ✗ wx-cli -pack wPack</span><br><span class="line"></span><br><span class="line">// 目录</span><br><span class="line">├── wPack</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建页面</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 命令</span><br><span class="line">wx-cli -pack wPack -p wPage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">➜  water git:(develop) ✗ wx-cli -pack wPack -p wPage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">ℹ page is ===========&gt; wPage</span><br><span class="line">✔ 操作成功</span><br><span class="line"></span><br><span class="line">// 目录</span><br><span class="line">wPack</span><br><span class="line"></span><br><span class="line">└── pages</span><br><span class="line"></span><br><span class="line">​    └── wPage</span><br><span class="line"></span><br><span class="line">​        ├── index.js</span><br><span class="line"></span><br><span class="line">​        ├── index.json</span><br><span class="line"></span><br><span class="line">​        ├── index.wxml</span><br><span class="line"></span><br><span class="line">​        ├── index.wxss</span><br><span class="line"></span><br><span class="line">​        └── strings.js</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>同时创建包和页面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 命令</span><br><span class="line">wx-cli -pack wPack -p wPage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">➜  water git:(develop) ✗ wx-cli -pack wPack -p wPage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">ℹ page is ===========&gt; wPage</span><br><span class="line">✔ 操作成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 目录</span><br><span class="line"></span><br><span class="line">wPack</span><br><span class="line"></span><br><span class="line">└── pages</span><br><span class="line"></span><br><span class="line">​    └── wPage</span><br><span class="line"></span><br><span class="line">​        ├── index.js</span><br><span class="line"></span><br><span class="line">​        ├── index.json</span><br><span class="line"></span><br><span class="line">​        ├── index.wxml</span><br><span class="line"></span><br><span class="line">​        ├── index.wxss</span><br><span class="line"></span><br><span class="line">​        └── strings.js</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>app.json添加分包路径</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​        "root": "wPack",</span><br><span class="line"></span><br><span class="line">​        "pages": [</span><br><span class="line"></span><br><span class="line">​            "pages/wPage/index"</span><br><span class="line"></span><br><span class="line">​        ]</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>创建全局组件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 命令</span><br><span class="line">wx-cli -c wComponent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">➜  water git:(develop) wx-cli -c wComponent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">➜  water git:(develop) wx-cli -c wComponent</span><br><span class="line"></span><br><span class="line">ℹ 创建全局公用组件</span><br><span class="line">component is ===========&gt; wComponent</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>创建分包组件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 命令</span><br><span class="line"></span><br><span class="line">wx-cli -pack wPack -c wComponent</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>创建分包页面组件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 命令</span><br><span class="line">wx-cli -pack wPack -p wPage -c wComponent</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>自定义页面和组件模版</li>
</ol>
<p>在项目根目录下建立<code>template</code>文件夹，其中包括页面的模版文件夹<code>page</code>和组件的模版文件夹<code>comp</code>,文件夹里面的文件就是自定义的模版，会按模版生成自定义的页面和组件。文件目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template</span><br><span class="line"></span><br><span class="line">├── comp</span><br><span class="line"></span><br><span class="line">│   ├── index.js</span><br><span class="line"></span><br><span class="line">│   ├── index.json</span><br><span class="line"></span><br><span class="line">│   ├── index.wxml</span><br><span class="line"></span><br><span class="line">│   └── index.wxss</span><br><span class="line"></span><br><span class="line">└── page</span><br><span class="line"></span><br><span class="line">​    ├── index.js</span><br><span class="line"></span><br><span class="line">​    ├── index.json</span><br><span class="line"></span><br><span class="line">​    ├── index.wxml</span><br><span class="line"></span><br><span class="line">​    └── index.wxss</span><br></pre></td></tr></table></figure>
<p>你可以自定义文件，如果根目录没有自定义模版，则生成默认的页面。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体就是为了偷懒，减少创建的成本，而思考开发的一个小工具，如果觉得有帮助。欢迎送个赞，先行谢过！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>nodejs</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>css伪元素实现尾随三角形</title>
    <url>/2020/11/13/css%E4%BC%AA%E5%85%83%E7%B4%A0%E5%AE%9E%E7%8E%B0%E5%B0%BE%E9%9A%8F%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在写页面中，不可避免的会用css去实现一些小的图标。其中三角形最常用，比如在实现类似气泡的弹框效果。普通的用div实现三角形已经有<a href="https://wangyuanweb.top/2018/03/25/div-css画三角形的方法和原理/" rel="external nofollow noopener noreferrer" target="_blank">文章</a>写过，有兴趣的可以自行查看。这里我主要记录下我在开发过程中遇到的问题，需要写一个类似气泡的小箭头，就是一个尾随的三角形，这里我觉得用伪元素特别适合这个场景，我就简单记录下实现的方法。<a id="more"></a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>先说伪元素和伪类的区别：</p>
<blockquote>
<p>伪类是针对CSS，而伪元素是针对HTML，伪类选择器是CSS选择器的一种，而伪类是“假”的HTML标签伪类（选择器）本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；伪元素本质上是创建了一个有内容的虚拟容器；在CSS3中，伪类和伪元素的语法得到了进一步的调整（一个冒号和两个冒号）；在开发当中，可以同时使用多个伪类，而只能同时使用一个伪元素；</p>
</blockquote>
<h2 id="实现实心三角形"><a href="#实现实心三角形" class="headerlink" title="实现实心三角形"></a>实现实心三角形</h2><p>用伪元素实现一个实心的三角形，其实和之前的div+css实现的方式差不多，只是把css的代码写到了伪元素中，话不多说，直接上代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#demo</span>&#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 右边三角</span><br><span class="line"><span class="selector-id">#demo</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">34px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: solid <span class="number">15px</span> transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: solid <span class="number">15px</span> black;</span><br><span class="line">  <span class="attribute">border-bottom</span>: solid <span class="number">15px</span> transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上边三角</span><br><span class="line"><span class="selector-id">#demo</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">border-right</span>: solid <span class="number">15px</span> transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: solid <span class="number">15px</span> transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: solid <span class="number">15px</span> black;</span><br><span class="line">&#125;</span><br><span class="line">// 下边三角</span><br><span class="line"><span class="selector-id">#demo</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">border-top</span>: solid <span class="number">15px</span> black;</span><br><span class="line">  <span class="attribute">border-right</span>: solid <span class="number">15px</span> transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: solid <span class="number">15px</span> transparent;</span><br><span class="line">&#125;</span><br><span class="line">// 左边三角</span><br><span class="line"><span class="selector-id">#demo</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: solid <span class="number">15px</span> transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: solid <span class="number">15px</span> black;</span><br><span class="line">  <span class="attribute">border-bottom</span>: solid <span class="number">15px</span> transparent;</span><br><span class="line">&#125;</span><br><span class="line">// 直角三角</span><br><span class="line"><span class="selector-id">#demo</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">34px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: solid <span class="number">15px</span> transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: solid <span class="number">15px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20201113142259204.png" alt="image-20201113142259204"></p>
<h2 id="实现实心三角形简写方式"><a href="#实现实心三角形简写方式" class="headerlink" title="实现实心三角形简写方式"></a>实现实心三角形简写方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;water_top&quot;&gt;&lt;/div&gt;         &lt;!--三角形在上边--&gt;</span><br><span class="line">&lt;div class=&quot;water_right&quot;&gt;&lt;/div&gt;       &lt;!--三角形在右边--&gt;</span><br><span class="line">&lt;div class=&quot;water_bottom&quot;&gt;&lt;/div&gt;      &lt;!--三角形在底边--&gt;</span><br><span class="line">&lt;div class=&quot;water_left&quot;&gt;&lt;/div&gt;        &lt;!--三角形在左边--&gt;</span><br><span class="line"></span><br><span class="line">.water_top,</span><br><span class="line">.water_right,</span><br><span class="line">.water_bottom,</span><br><span class="line">.water_left &#123;</span><br><span class="line">  width: 150px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: #cccccc;</span><br><span class="line">  border-radius: 8px;</span><br><span class="line">  margin: 50px;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">/*上三角*/</span><br><span class="line">.water_top:before &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  border: 10px solid transparent;</span><br><span class="line">  border-bottom-color: red;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: -20px;</span><br><span class="line">  left: 65px;</span><br><span class="line">&#125;</span><br><span class="line">/*右三角*/</span><br><span class="line">.water_right:before &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  border: 10px solid transparent;</span><br><span class="line">  border-left-color: yellow;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 40px;</span><br><span class="line">  left: 150px;</span><br><span class="line">&#125;</span><br><span class="line">/*下三角*/</span><br><span class="line">.water_bottom:before &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  border: 10px solid transparent;</span><br><span class="line">  border-top-color: blue;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 100px;</span><br><span class="line">  left: 70px;</span><br><span class="line">&#125;</span><br><span class="line">/*左三角*/</span><br><span class="line">.water_left:before &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  border: 10px solid transparent;</span><br><span class="line">  border-right-color: green;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 40px;</span><br><span class="line">  left: -20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20201113143330128.png" alt="image-20201113143330128"></p>
<h2 id="实现空心三角形"><a href="#实现空心三角形" class="headerlink" title="实现空心三角形"></a>实现空心三角形</h2><p>这里的实现空心三角形思路是用两个三角形重叠，达到空心的视觉效果。通过前后两个伪元素实现，单个的三角形实现上以上实心三角方法一致，只是这两个三角形大小不一样，达到了空心有边框，上demo代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.water_top, .water_right, .water_bottom, .water_left&#123;</span><br><span class="line">                width: 150px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                border: 1px solid #000000;</span><br><span class="line">                border-radius: 8px;</span><br><span class="line">                margin: 50px 50px;</span><br><span class="line">                position: relative;</span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line">            .water_top:before&#123;</span><br><span class="line">                content: &quot;&quot;;</span><br><span class="line">                width: 0px;</span><br><span class="line">                height: 0px;</span><br><span class="line">                border-left: 15px solid transparent;</span><br><span class="line">                border-right: 15px solid transparent;</span><br><span class="line">                border-bottom: 15px solid #000000;</span><br><span class="line">                position: absolute;</span><br><span class="line">                top: -15px;</span><br><span class="line">                left: 65px;</span><br><span class="line">            &#125;</span><br><span class="line">            .water_top:after&#123;</span><br><span class="line">                content: &quot;&quot;;</span><br><span class="line">                width: 0px;</span><br><span class="line">                height: 0px;</span><br><span class="line">                border-left: 14px solid transparent;</span><br><span class="line">                border-right: 14px solid transparent;</span><br><span class="line">                border-bottom: 14px solid #FFFFFF;</span><br><span class="line">                position: absolute;</span><br><span class="line">                top: -14px;</span><br><span class="line">                left: 66px;</span><br><span class="line">            &#125;</span><br><span class="line">            .water_right:before&#123;</span><br><span class="line">                content: &quot;&quot;;</span><br><span class="line">                width: 0px;</span><br><span class="line">                height: 0px;</span><br><span class="line">                border-top: 15px solid transparent;</span><br><span class="line">                border-bottom: 15px solid transparent;</span><br><span class="line">                border-left: 15px solid #000000;</span><br><span class="line">                position: absolute;</span><br><span class="line">                top: 39px;</span><br><span class="line">                left: 150px;</span><br><span class="line">            &#125;</span><br><span class="line">            .water_right:after&#123;</span><br><span class="line">                content: &quot;&quot;;</span><br><span class="line">                width: 0px;</span><br><span class="line">                height: 0px;</span><br><span class="line">                border-top: 14px solid transparent;</span><br><span class="line">                border-bottom: 14px solid transparent;</span><br><span class="line">                border-left: 14px solid #FFFFFF;</span><br><span class="line">                position: absolute;</span><br><span class="line">                top: 40px;</span><br><span class="line">                left: 149px;</span><br><span class="line">            &#125;</span><br><span class="line">            .water_bottom:before&#123;</span><br><span class="line">                content: &quot;&quot;;</span><br><span class="line">                width: 0px;</span><br><span class="line">                height: 0px;</span><br><span class="line">                border-top: 15px solid #000000;</span><br><span class="line">                border-left: 15px solid transparent;</span><br><span class="line">                border-right: 15px solid transparent;</span><br><span class="line">                position: absolute;</span><br><span class="line">                top: 101px;</span><br><span class="line">                left: 69px;</span><br><span class="line">            &#125;</span><br><span class="line">            .water_bottom:after&#123;</span><br><span class="line">                content: &quot;&quot;;</span><br><span class="line">                width: 0px;</span><br><span class="line">                height: 0px;</span><br><span class="line">                border-top: 14px solid #FFFFFF;</span><br><span class="line">                border-left: 14px solid transparent;</span><br><span class="line">                border-right: 14px solid transparent;</span><br><span class="line">                position: absolute;</span><br><span class="line">                top: 100px;</span><br><span class="line">                left: 70px;</span><br><span class="line">            &#125;</span><br><span class="line">            .water_left:before&#123;</span><br><span class="line">                content: &quot;&quot;;</span><br><span class="line">                width: 0px;</span><br><span class="line">                height: 0px;</span><br><span class="line">                border-top: 15px solid transparent;</span><br><span class="line">                border-bottom: 15px solid transparent;</span><br><span class="line">                border-right: 15px solid #000000;</span><br><span class="line">                position: absolute;</span><br><span class="line">                top: 40px;</span><br><span class="line">                left: -15px;</span><br><span class="line">            &#125;</span><br><span class="line">            .water_left:after&#123;</span><br><span class="line">                content: &quot;&quot;;</span><br><span class="line">                width: 0px;</span><br><span class="line">                height: 0px;</span><br><span class="line">                border-top: 14px solid transparent;</span><br><span class="line">                border-bottom: 14px solid transparent;</span><br><span class="line">                border-right: 14px solid #FFFFFF;</span><br><span class="line">                position: absolute;</span><br><span class="line">                top: 41px;</span><br><span class="line">                left: -14px;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &lt;div class=&quot;water_top&quot;&gt;&lt;/div&gt;         &lt;!--三角形在上边--&gt;</span><br><span class="line">        	&lt;div class=&quot;water&quot;&gt;&lt;/div&gt;              &lt;!--三角形在右边--&gt;</span><br><span class="line">        	&lt;div class=&quot;water_bottom&quot;&gt;&lt;/div&gt;      &lt;!--三角形在底边--&gt;</span><br><span class="line">        	&lt;div class=&quot;water_left&quot;&gt;&lt;/div&gt;        &lt;!--三角形在左边--&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20201113144207110.png" alt="image-20201113144207110"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以上的对比。相信大家也能看出其中的原理。总结出了一个道理：<strong>三角形往哪个方向，那个方向无需设置border，而相反方向设置border颜色，相邻两边的border设为透明。</strong>这样就可实现各个方向的三角形。实心三角形利用CSS中的伪元素（:before）实现，再利用border的transparent属性即可达到效果。而空心三角形是在空心三角形的基础上再加上伪元素（:after）实现。伪元素（:before）实现的是一个实心的三角形，伪元素（:after）实现的是空心的三角形，进而把实心的三角形覆盖，利用绝对定位的top与left的差值绝对了三角形线的粗细而达到如图的效果。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>用css画出一个半圆和环形进度条</title>
    <url>/2020/10/30/%E7%94%A8css%E7%94%BB%E5%87%BA%E4%B8%80%E4%B8%AA%E5%8D%8A%E5%9C%86%E5%92%8C%E7%8E%AF%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何使用-css-画一个半圆呢？介绍三种方法"><a href="#如何使用-css-画一个半圆呢？介绍三种方法" class="headerlink" title="如何使用 css 画一个半圆呢？介绍三种方法"></a>如何使用 css 画一个半圆呢？介绍三种方法</h1><h2 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h2><p>boder-radius 属性也支持单边设置弧度，不同的弧度可以绘制不同的图形，今天来画一个半圆<a id="more"></a></p>
<p>直接上代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"half_circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"half_circle1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"half_circle2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"half_circle3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#half_circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#half_circle1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#half_circle2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#half_circle3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>border-radius 的值顺序是左上、右上、右下、左下顺时针，盒子的宽高要求是 1:2 或者 2:1，border-radius 值不能是百分比，应该与短边一致</p>
<h2 id="clip"><a href="#clip" class="headerlink" title="clip"></a>clip</h2><p>css3 中的 clip 属性可以剪裁绝对定位元素，画半圆的思想就是先画一个圆，然后用 clip 剪切掉一半</p>
<p>看代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"half_circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"half_circle1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.half_circle</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>, <span class="number">200px</span>, <span class="number">100px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.half_circle1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">220px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>, <span class="number">200px</span>, <span class="number">200px</span>, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clip 唯一合法的形状值是：rect (top, right, bottom, left)</p>
<h2 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h2><p>思想还是先画一个圆，然后利用背景线性渐变展示一半</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"half_circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.half_circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(transparent <span class="number">50%</span>, black <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上，有其他方法再补充~</p>
<h1 id="实现一个环形进度条"><a href="#实现一个环形进度条" class="headerlink" title="实现一个环形进度条"></a>实现一个环形进度条</h1><p>遇到一个需求，需要实现一个环形进度条，下面是一种方法</p>
<h2 id="环形进度条"><a href="#环形进度条" class="headerlink" title="环形进度条"></a>环形进度条</h2><p>实现思路：背景画一个圆形，在圆形上左右两边各覆盖一个半圆，顺时针旋转右边的半圆直至180deg，此时右边的半圆转到了左边，左右两个半圆完全重叠，下一步恢复右边半圆到初始位置，且背景色设置为与背景圆形一致，接着顺时针旋转左边半圆180deg（因为左边半圆渲染层级在右半圆的下方），即可完成一个完整的旋转进度，在上方盖一个同心小圆即可实现环形进度条的效果。</p>
<p>层级旋转效果：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span> * &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>, <span class="number">100px</span>, <span class="number">200px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>, <span class="number">200px</span>, <span class="number">200px</span>, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">90%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">90%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, .<span class="number">5</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> blockEl = <span class="built_in">document</span>.querySelector(<span class="string">'.block'</span>);</span><br><span class="line"><span class="keyword">let</span> leftEl = <span class="built_in">document</span>.querySelector(<span class="string">'.left'</span>);</span><br><span class="line"><span class="keyword">let</span> rightEl = <span class="built_in">document</span>.querySelector(<span class="string">'.right'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> percent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  percent++;</span><br><span class="line">  <span class="keyword">if</span>(percent &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    rightEl.style.transform = <span class="string">'rotate('</span> + (<span class="number">3.6</span> * percent) + <span class="string">'deg)'</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rightEl.style.transform = <span class="string">'rotate(0)'</span>;</span><br><span class="line">    rightEl.style.background = <span class="string">'black'</span>;</span><br><span class="line">    leftEl.style.transform = <span class="string">'rotate('</span> + <span class="number">3.6</span> * (percent - <span class="number">50</span>) + <span class="string">'deg)'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (percent &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(step);</span><br></pre></td></tr></table></figure>
<p>完整实现：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span> * &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">  <span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>, <span class="number">100px</span>, <span class="number">200px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">  <span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>, <span class="number">200px</span>, <span class="number">200px</span>, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">90%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">90%</span>;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> leftEl = <span class="built_in">document</span>.querySelector(<span class="string">'.left'</span>);</span><br><span class="line"><span class="keyword">let</span> rightEl = <span class="built_in">document</span>.querySelector(<span class="string">'.right'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> percent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  percent++;</span><br><span class="line">  <span class="keyword">if</span>(percent &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    rightEl.style.transform = <span class="string">'rotate('</span> + (<span class="number">3.6</span> * percent) + <span class="string">'deg)'</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rightEl.style.transform = <span class="string">'rotate(0)'</span>;</span><br><span class="line">    rightEl.style.background = <span class="string">'red'</span>;</span><br><span class="line">    leftEl.style.transform = <span class="string">'rotate('</span> + <span class="number">3.6</span> * (percent - <span class="number">50</span>) + <span class="string">'deg)'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (percent &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(step);</span><br></pre></td></tr></table></figure>
<h2 id="中间透明的环形进度条"><a href="#中间透明的环形进度条" class="headerlink" title="中间透明的环形进度条"></a>中间透明的环形进度条</h2><p>又想，如果要求中间带透明度的或者中间完全透明的环形进度条怎么实现呢？</p>
<p>稍微调整一下，将半圆用border显示，底层背景用内阴影shadow表示，即可实现效果</p>
<p>代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span> pink;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span> * &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">12px</span> solid black;</span><br><span class="line">  <span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>, <span class="number">100px</span>, <span class="number">200px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">12px</span> solid black;</span><br><span class="line">  <span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>, <span class="number">200px</span>, <span class="number">200px</span>, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">90%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">90%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, .<span class="number">3</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> leftEl = <span class="built_in">document</span>.querySelector(<span class="string">'.left'</span>);</span><br><span class="line"><span class="keyword">let</span> rightEl = <span class="built_in">document</span>.querySelector(<span class="string">'.right'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> percent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  percent++;</span><br><span class="line">  <span class="keyword">if</span>(percent &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    rightEl.style.transform = <span class="string">'rotate('</span> + (<span class="number">3.6</span> * percent) + <span class="string">'deg)'</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rightEl.style.transform = <span class="string">'rotate(0)'</span>;</span><br><span class="line">    rightEl.style.borderColor = <span class="string">'pink'</span>;</span><br><span class="line">    leftEl.style.transform = <span class="string">'rotate('</span> + <span class="number">3.6</span> * (percent - <span class="number">50</span>) + <span class="string">'deg)'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (percent &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(step);</span><br></pre></td></tr></table></figure>
<p>以上~</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>git的.gitignore文件的规则</title>
    <url>/2020/10/23/git%E7%9A%84-gitignore%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于经常使用 Git 的朋友来说，.gitignore 配置一定不会陌生。废话不说多了，接下来就来说说这个.gitignore 的使用。首先要强调一点，这个文件的完整文件名就是”.gitignore”，注意最前面有个“.”。一般来说每个 Git 项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉 Git 哪些文件不需要添加到版本管理中。实际项目中，很多文件都是不需要版本管理的，比如 Python 的.pyc 文件和一些包含密码的配置文件等等。这个文件的内容是一些规则，Git 会根据这些规则来判断是否将文件添加到版本控制中。<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h4 id="下面我们看看常用的规则："><a href="#下面我们看看常用的规则：" class="headerlink" title="下面我们看看常用的规则："></a>下面我们看看常用的规则：</h4><ol>
<li>/mtk/ 过滤整个文件夹</li>
<li>*.zip 过滤所有.zip 文件</li>
<li>/mtk/do.c 过滤某个具体文件</li>
</ol>
<p>很简单吧，被过滤掉的文件就不会出现在 git 仓库中（gitlab 或 github）了，当然本地库中还有，只是 push 的时候不会上传。</p>
<p>需要注意的是，gitignore 还可以指定要将哪些文件添加到版本管理中：</p>
<ol>
<li>!*.zip</li>
<li>!/mtk/one.txt</li>
</ol>
<p>唯一的区别就是规则开头多了一个感叹号，Git 会将满足这类规则的文件添加到版本管理中。</p>
<h4 id="为什么要有两种规则呢？"><a href="#为什么要有两种规则呢？" class="headerlink" title="为什么要有两种规则呢？"></a>为什么要有两种规则呢？</h4><p>想象一个场景：假如我们只需要管理/mtk/目录中的 one.txt 文件，这个目录中的其他文件都不需要管理，那么我们就需要使用：</p>
<ol>
<li><p>/mtk/</p>
</li>
<li><p>!/mtk/one.txt</p>
</li>
</ol>
<p>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了 one.txt 以外的所有文件都写出来！</p>
<p>最后需要强调的一点是，如果你不慎在创建.gitignore 文件之前就 push 了项目，那么即使你在.gitignore 文件中写入新的过滤规则，这些规则也不会起作用，Git 仍然会对所有文件进行版本管理。</p>
<p>简单来说，出现这种问题的原因就是 Git 已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。因此一定要养成在项目开始就创建.gitignore 文件的习惯，否则一旦 push，处理起来会非常麻烦。</p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>.gitignore 配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为版本管理带来很大的便利，以下是对于配置.gitignore 的一些心得记录：</p>
<ol>
<li><strong>配置语法：</strong><br>以斜杠“/”开头表示目录；<br>以星号“*”通配多个字符；<br>以问号“?”通配单个字符<br>以方括号“[]”包含单个字符的匹配列表；<br>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</li>
</ol>
<p>此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p>
<ol start="2">
<li><strong>示例说明</strong></li>
</ol>
<ul>
<li>规则：fd1/_<br>说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</li>
<li>规则：/fd1/_<br>说明：忽略根目录下的 /fd1/ 目录的全部内容；</li>
<li>规则：<br>/*<br>!.gitignore<br>!/fw/bin/<br>!/fw/sf/<br>说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；</li>
</ul>
<p>下面是线上使用过的一个 gerrit 里项目代码的.gitignore 的配置（在项目中添加.gitignore 过滤文件，在 git push 到 gerrit 里即可）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">#Built application files</span><br><span class="line">*.apk</span><br><span class="line">*.ap_</span><br><span class="line"> </span><br><span class="line"># Files for the Dalvik VM</span><br><span class="line">*.dex</span><br><span class="line"> </span><br><span class="line"># Java class files</span><br><span class="line">*.class</span><br><span class="line"> </span><br><span class="line"># Generated files</span><br><span class="line">*/bin/</span><br><span class="line">*/gen/</span><br><span class="line">*/out/</span><br><span class="line"> </span><br><span class="line"># Gradle files</span><br><span class="line">.gradle/</span><br><span class="line">build/</span><br><span class="line">*/build/</span><br><span class="line">gradlew</span><br><span class="line">gradlew.bat</span><br><span class="line"> </span><br><span class="line"># Local configuration file (sdk path, etc)</span><br><span class="line">local.properties</span><br><span class="line"> </span><br><span class="line"># Proguard folder generated by Eclipse</span><br><span class="line">proguard/</span><br><span class="line"> </span><br><span class="line"># Log Files</span><br><span class="line">*.log</span><br><span class="line"> </span><br><span class="line"># Android Studio Navigation editor temp files</span><br><span class="line">.navigation/</span><br><span class="line"> </span><br><span class="line"># Android Studio captures folder</span><br><span class="line">captures/</span><br><span class="line"> </span><br><span class="line"># Intellij</span><br><span class="line">*.iml</span><br><span class="line">*/*.iml</span><br><span class="line"> </span><br><span class="line"># Keystore files</span><br><span class="line">#*.jks</span><br><span class="line">#gradle wrapper</span><br><span class="line">gradle/</span><br><span class="line"> </span><br><span class="line">#some local files</span><br><span class="line">*/.settings/</span><br><span class="line">*/.DS_Store</span><br><span class="line">.DS_Store</span><br><span class="line">*/.idea/</span><br><span class="line">.idea/</span><br><span class="line">gradlew</span><br><span class="line">gradlew.bat</span><br><span class="line">unused.txt</span><br></pre></td></tr></table></figure>
<p>在看一个例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line"># Lines that start with &apos;#&apos; are comments.</span><br><span class="line"># IntelliJ IDEA Project files</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line">*.iws</span><br><span class="line">out</span><br><span class="line"> </span><br><span class="line"># Eclipse Project files</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings/</span><br><span class="line"> </span><br><span class="line">bin/</span><br><span class="line">gen/</span><br><span class="line">local.properties</span><br><span class="line"> </span><br><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line"> </span><br><span class="line">*.bak</span><br><span class="line">*.tem</span><br><span class="line">*.temp</span><br><span class="line">#.swp</span><br><span class="line">*.*~</span><br><span class="line">~*.*</span><br></pre></td></tr></table></figure></p>
<p>其实，需要清除的一点是：<br>有三种方法可以实现过滤掉 Git 里不想上传的文件，这三种方法都能达到目的，只不过适用情景不一样。</p>
<h3 id="1-第一种方法"><a href="#1-第一种方法" class="headerlink" title="1. 第一种方法"></a>1. 第一种方法</h3><p>针对单一工程排除文件，这种方式会让这个工程的所有修改者在克隆代码的同时，也能克隆到过滤规则，而不用自己再写一份，这就能保证所有修改者应用的都是同一份规则，而不是张三自己有一套过滤规则，李四又使用另一套过滤规则，个人比较喜欢这个。配置步骤如下：</p>
<p>在工程根目录下建立.gitignore 文件，将要排除的文件或目录 写到.gitignore 这个文件中，其中有两种写入方法。<br>a)使用命令行增加排除文件<br>排除以.class 结尾的文件 echo “*.class” &gt;.gitignore (&gt;&gt; 是在文件尾增加,&gt; 是删除已经存在的内容再增加)，之后会在当前目录下生成一个.gitignore 的文件。<br>排除 bin 目录下的文件 echo “bin/” &gt;.gitignore<br>b)最方便的办法是，用记事本打开，增加需要排除的文件或目录，一行增加一个，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_.class</span><br><span class="line">_.apk</span><br><span class="line">bin/</span><br><span class="line">gen/</span><br><span class="line">.settings/</span><br><span class="line">proguard/</span><br></pre></td></tr></table></figure></p>
<h3 id="2-第二种方法"><a href="#2-第二种方法" class="headerlink" title="2. 第二种方法"></a>2. 第二种方法</h3><p>全局设置排除文件，这会在全局起作用，只要是 Git 管理的工程，在提交时都会自动排除不在控制范围内的文件或目录。这种方法对开发者来说，比较省事，只要一次全局配置，不用每次建立工程都要配置一遍过滤规则。但是这不保证其他的开发者在克隆你的代码后，他们那边的规则跟你的是一样的，这就带来了代码提交过程中的各种冲突问题。<br>配置步骤如下：<br>a）像方法（1）一样，也需要建立一个.gitignore 文件，把要排除的文件写进去。<br>b）但在这里，我们不规定一定要把.gitnore 文件放到某个工程下面，而是任何地方，比如我们这里放到了 Git 默认的 Home 路径下，比如：/home/wangshibo/hqsb_ios<br>c）使用命令方式可以配置全局排除文件 git config –global core.excludesfile ~/.gitignore，你会发现在~/.gitconfig 文件中会出现 excludesfile = /home/wangshibo/hqsb_ios/.gitignore。<br>说明 Git 把文件过滤规则应用到了 Global 的规则中。</p>
<h3 id="3-第三种方法"><a href="#3-第三种方法" class="headerlink" title="3. 第三种方法"></a>3. 第三种方法</h3><p>单个工程设置排除文件，在工程目录下找到.git/info/exclude，把要排除的文件写进去：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_.class</span><br><span class="line">_.apk</span><br><span class="line">bin/</span><br><span class="line">gen/</span><br><span class="line">.settings/</span><br><span class="line">proguard/</span><br></pre></td></tr></table></figure></p>
<p>这种方法就不提倡了，只能针对单一工程配置，而且还不能将过滤规则同步到其他开发者，跟方法（1）（2）比较起来没有一点优势。</p>
<h2 id="Git-忽略规则及-gitignore-规则不生效的解决办法"><a href="#Git-忽略规则及-gitignore-规则不生效的解决办法" class="headerlink" title="Git 忽略规则及.gitignore 规则不生效的解决办法"></a>Git 忽略规则及.gitignore 规则不生效的解决办法</h2><p>在 git 中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"></span><br><span class="line">_.a # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a # 但 lib.a 除外</span><br><span class="line">/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/ # 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/_.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交：</span><br><span class="line"></span><br><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;update .gitignore&apos;</span><br></pre></td></tr></table></figure></p>
<p>注意：<br>不要误解了 .gitignore 文件的用途，该文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件）。<br>如果文件曾经被 Git 记录过，那么.gitignore 就对它们完全无效。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>发布一个npm包你需要知道的npm命令详解</title>
    <url>/2020/10/16/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84npm%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在前端工作中，npm是大家在熟悉不过的了。大家多多少少都会用到npm包来加快我们的业务开发。对于一个有梦想的咸鱼来说，有时候也想自己发布一个包。这里就分享下发布一个包需要使用到的npm命令和发布流程<a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先需要去<a href="https://www.npmjs.com/" rel="external nofollow noopener noreferrer" target="_blank">npm官网</a>注册自己的账号，这里需要用到用户名、邮箱、密码。这里的用户名就是你发布的包所属的作用域，邮箱是给你发通知用的。这些都搞定后，我们就可以开发准备发布的包了</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><blockquote>
<p>npm官方建议规范的包<strong>至少</strong>包含：</p>
<ul>
<li><p>package.json（包的基本信息）</p>
</li>
<li><p>README.md（文档）</p>
</li>
<li><p>index.js （入口文件）</p>
</li>
</ul>
</blockquote>
<h3 id="发布一个不在自己用户名作用域下的包"><a href="#发布一个不在自己用户名作用域下的包" class="headerlink" title="发布一个不在自己用户名作用域下的包"></a>发布一个不在自己用户名作用域下的包</h3><h5 id="发布create-wy-umi包"><a href="#发布create-wy-umi包" class="headerlink" title="发布create-wy-umi包"></a>发布<a href="https://www.npmjs.com/package/create-wy-umi" rel="external nofollow noopener noreferrer" target="_blank">create-wy-umi</a>包</h5><h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><ol>
<li>创建文件夹</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir create-wy-umi</span><br><span class="line">cd create-wy-umi</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>初始化项目</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init/npm init -y</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建包的入口文件，假设是index.js，则package.json文件如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;wy-create-umi&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;my first npm package&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;npm&quot;,</span><br><span class="line">    &quot;packge&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;wy&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>创建README.md</p>
</li>
<li><p>创建index.js</p>
</li>
<li>最基本的目录结构如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">└── wy-create-umi</span><br><span class="line">    ├── README.md</span><br><span class="line">    ├── index.js</span><br><span class="line">    └── package.json</span><br></pre></td></tr></table></figure>
<h5 id="开始发布的步骤和使用的npm命令"><a href="#开始发布的步骤和使用的npm命令" class="headerlink" title="开始发布的步骤和使用的npm命令"></a>开始发布的步骤和使用的npm命令</h5><ol>
<li><p>切换npm源为官网源，可以使用nrm进行管理</p>
</li>
<li><p>登录</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 输入用户名和密码</span><br><span class="line">npm login</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//在本地先测试我们的包</span><br><span class="line">npm link</span><br></pre></td></tr></table></figure>
<p>这样在我们项目里就可以使用我们本地开发的包了，测试没有问题之后就可以进行发布</p>
<ol start="4">
<li>卸载掉测试包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 卸载掉本地测试包</span><br><span class="line">npm unlink</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>发布</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如果包的名字是唯一的，那么这一步基本已经发布成功一个npm包了</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure>
<h3 id="发布一个在自己用户名作用域下的包"><a href="#发布一个在自己用户名作用域下的包" class="headerlink" title="发布一个在自己用户名作用域下的包"></a>发布一个在自己用户名作用域下的包</h3><p>基本的发布步骤差不多，主要区别是npm命令的不同。</p>
<ol>
<li>在初始化和发布的时候命令改成如下命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 初始化项目的时候</span><br><span class="line">npm init --scope=@wy -y</span><br><span class="line">// 发布项目的时候</span><br><span class="line">npm publish --access public</span><br></pre></td></tr></table></figure>
<p>如果这样的话，那么发布的指定作用域下的包就完成了，发布组织下的包，也是使用这样的方法，比如<a href="https://www.npmjs.com/package/@waterpack/wx-cli" rel="external nofollow noopener noreferrer" target="_blank">@waterpack/wx-cli</a>，这个是我发布的生成小程序页面或者组件的脚手架工具。</p>
<p>至此我们已经能成功发布一个包了，接下来就是对我们发的包的迭代更新</p>
<h3 id="迭代和更新"><a href="#迭代和更新" class="headerlink" title="迭代和更新"></a>迭代和更新</h3><p>当我们需要优化我们的包代码的时候，就需要对已经发布的包进行更新，这里就说下更新包的步骤和npm命令</p>
<ol>
<li>更新我们的代码比如<code>index.js</code>中的类容</li>
<li>更新我们的包版本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 更新版本的命令为</span><br><span class="line">npm version &lt;major | minor | patch&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>包</th>
<th>版本号意义</th>
<th>规则</th>
<th style="text-align:left">版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>首次发布</td>
<td>首发</td>
<td>1.0.0开始</td>
<td style="text-align:left">1.0.0</td>
</tr>
<tr>
<td>bug修复，向后兼容</td>
<td>补丁版本号</td>
<td>变更第三位数字</td>
<td style="text-align:left">1.0.1</td>
</tr>
<tr>
<td>新功能，向后兼容</td>
<td>此版本号</td>
<td>变更第二位数字，且第三位数字改为0</td>
<td style="text-align:left">1.1.0</td>
</tr>
<tr>
<td>重大变更，不向后兼容</td>
<td>主版本号</td>
<td>变更第一位数字，且第二第三位数字改为0</td>
<td style="text-align:left">2.0.0</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>关于<code>npm version</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  npm version --help</span><br><span class="line">npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease [--preid=&lt;prerelease-id&gt;] | from-git]</span><br><span class="line">(run in package dir)</span><br><span class="line">&apos;npm -v&apos; or &apos;npm --version&apos; to print npm version (6.14.7)</span><br><span class="line">&apos;npm view &lt;pkg&gt; version&apos; to view a package&apos;s published version</span><br><span class="line">&apos;npm ls&apos; to inspect current package/dependency versions</span><br></pre></td></tr></table></figure>
<p>可以看到命令的所有参数，这里解释下各个参数的意义和作用</p>
<ul>
<li><h5 id="prerelease"><a href="#prerelease" class="headerlink" title="prerelease"></a>prerelease</h5></li>
</ul>
<ol>
<li><code>npm version prerelease</code><br>package.json 中的版本号<code>1.0.0</code>变为 <code>1.0.1-0</code></li>
<li>再次执行 <code>npm version prerelease</code><br>package.json 中的版本号<code>1.0.1-0</code>变为 <code>1.0.1-1</code></li>
</ol>
<blockquote>
<p>操作说明 当执行<code>npm version prerelease</code>时，如果没有预发布号，则增加补丁版本号，同时预发布号设为0；<br>如果有prerelease， 则prerelease 增加1。</p>
</blockquote>
<ul>
<li><h5 id="prepatch"><a href="#prepatch" class="headerlink" title="prepatch"></a>prepatch</h5></li>
</ul>
<ol>
<li><code>npm version prepatch</code><br>package.json 中的版本号<code>1.0.1-1</code>变为 <code>1.0.2-0</code></li>
</ol>
<blockquote>
<p>prepatch - 直接升级补丁号，增加预发布号为0。</p>
</blockquote>
<ul>
<li><h5 id="preminor"><a href="#preminor" class="headerlink" title="preminor"></a>preminor</h5></li>
</ul>
<ol>
<li><code>npm version preminor</code><br>package.json 中的版本号<code>1.0.2-0</code>变为 <code>1.1.0-0</code></li>
</ol>
<blockquote>
<p>preminor - 直接升级次版本号，补丁版本号置为0，增加预发布号为0。</p>
</blockquote>
<ul>
<li><h5 id="premajor"><a href="#premajor" class="headerlink" title="premajor"></a>premajor</h5></li>
</ul>
<ol>
<li><code>npm version premajor</code><br>package.json 中的版本号<code>1.1.0-0</code>变为 <code>2.0.0-0</code></li>
</ol>
<blockquote>
<p>premajor - 直接升级主版本号，次版本号、补丁版本号置为0，增加预发布号为0。</p>
</blockquote>
<ul>
<li><h5 id="patch-主要目的升级补丁版本号"><a href="#patch-主要目的升级补丁版本号" class="headerlink" title="patch: 主要目的升级补丁版本号"></a>patch: 主要目的升级补丁版本号</h5></li>
</ul>
<ol>
<li><code>npm version patch</code><br>package.json 中的版本号<code>2.0.0-0</code>变为 <code>2.0.0</code>;</li>
<li>再次执行<code>npm version patch</code><br>package.json 中的版本号<code>2.0.0</code>变为 <code>2.0.1</code>;</li>
</ol>
<blockquote>
<p>操作说明，patch：如果有预发版本号 ，则去掉 ，其他保持不变；<br>如果没有预发版本号 ，则升级补丁版本号.</p>
</blockquote>
<ul>
<li><h5 id="minor：-主要目的升级次要版本"><a href="#minor：-主要目的升级次要版本" class="headerlink" title="minor： 主要目的升级次要版本"></a>minor： 主要目的升级次要版本</h5></li>
</ul>
<ol>
<li><code>npm version minor</code><br>package.json 中的版本号<code>2.0.1</code>变为 <code>2.1.0</code>;</li>
</ol>
<blockquote>
<p>如果没有预发版本，直接升级次要版本， 同时补丁版本设置为0；</p>
</blockquote>
<ol start="2">
<li><p><code>npm version premajor</code> <code>2.1.0</code>–&gt; <code>3.0.0-0</code>;</p>
</li>
<li><p><code>npm version minor</code> <code>3.0.0-0</code>–&gt; <code>3.0.0</code>;</p>
</li>
<li><p><code>npm version prepatch</code> <code>3.0.0</code>–&gt;<code>3.0.1-0</code>;</p>
</li>
<li><p><code>npm version minor</code> <code>3.0.1-0</code>–&gt;<code>3.1.0</code>;</p>
</li>
</ol>
<blockquote>
<p>如果有预发版本号， 首先需要去掉；如果补丁版本号为0，则不升级次要版本：如<code>3</code>；<br>如果补丁版本号不为0， 则升级次要版本号，同时补丁版本号设为0，如<code>5</code>。</p>
</blockquote>
<ul>
<li><h5 id="major-：主要目的升级主版本"><a href="#major-：主要目的升级主版本" class="headerlink" title="major ：主要目的升级主版本"></a>major ：主要目的升级主版本</h5></li>
</ul>
<ol>
<li><code>npm version major</code> : <code>3.1.0</code> –&gt;<code>4.0.0</code></li>
</ol>
<blockquote>
<p>如果没有预发版本号，则直接升级主版本号，其他位都置为0；</p>
</blockquote>
<ol start="2">
<li><p><code>npm version premajor</code>: <code>4.0.0</code> –&gt; <code>5.0.0-0</code>;</p>
</li>
<li><p><code>npm version premajor</code>: <code>5.0.0-0</code> –&gt; <code>5.0.0</code>;</p>
</li>
</ol>
<blockquote>
<p>如果有预发布号： 次版本号和补丁版本都为0，则不升级主版本，只将预发版本号去掉。</p>
</blockquote>
<ol start="4">
<li><p><code>npm version preminor</code> : <code>5.0.0-0</code>–&gt; <code>5.1.0-0</code></p>
</li>
<li><p><code>npm version major</code> : <code>5.1.0-0</code> –&gt;<code>6.0.0</code></p>
</li>
</ol>
<blockquote>
<p>如果有预发布号：且次版本号和补丁版本号有任意一个不是0，则升级主版本号，其他位都置为0，并去掉预发版本。</p>
</blockquote>
<h5 id="更新迭代发布"><a href="#更新迭代发布" class="headerlink" title="更新迭代发布"></a>更新迭代发布</h5><p>版本更改完毕后，直接执行发布命令，这时发布应该就成功了如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  wx-cli git:(master) npm publish      </span><br><span class="line">npm notice </span><br><span class="line">npm notice 📦  @waterpack/wx-cli@1.0.7</span><br><span class="line">npm notice === Tarball Contents === </span><br><span class="line">npm notice 8.4kB bin/index.js            </span><br><span class="line">npm notice 215B  template/comp/index.js  </span><br><span class="line">npm notice 850B  template/page/index.js  </span><br><span class="line">npm notice 48B   template/comp/index.json</span><br><span class="line">npm notice 27B   template/page/index.json</span><br><span class="line">npm notice 776B  package.json            </span><br><span class="line">npm notice 2.1kB README.md               </span><br><span class="line">npm notice 68B   template/comp/index.wxml</span><br><span class="line">npm notice 80B   template/page/index.wxml</span><br><span class="line">npm notice 29B   template/comp/index.wxss</span><br><span class="line">npm notice 35B   template/page/index.wxss</span><br><span class="line">npm notice === Tarball Details === </span><br><span class="line">npm notice name:          @waterpack/wx-cli                       </span><br><span class="line">npm notice version:       1.0.7                                   </span><br><span class="line">npm notice package size:  3.8 kB                                  </span><br><span class="line">npm notice unpacked size: 12.6 kB                                 </span><br><span class="line">npm notice shasum:        6e2389721598375d068ae12852694b1ce8</span><br><span class="line">npm notice integrity:     sha512-agsPUF0J1fU8s[...]DdB8Gb3QVpWxg==</span><br><span class="line">npm notice total files:   11                                      </span><br><span class="line">npm notice </span><br><span class="line">+ @waterpack/wx-cli@1.0.7</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此，发布一个包的讲解结束。觉得的有帮助的小伙伴欢迎给个赞！！！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>手写node事件发布订阅</title>
    <url>/2020/09/27/%E6%89%8B%E5%86%99node%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>node中的事件是必然要用到的，这也就让了解node事件机制变得很有必要，了解下原来总是好的。简单贴下代码，方便查阅学习。<a id="more"></a></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._events = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">eventName,callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>._events)&#123;</span><br><span class="line">        <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  当前绑定的事件 不是newListener事件就触发newListener事件</span></span><br><span class="line">    <span class="keyword">if</span>(eventName !== <span class="string">'newListener'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'newListener'</span>,eventName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._events[eventName])&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName].push(callback)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName] = [callback]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">eventName,...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>._events) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._events[eventName])&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName].forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn(...args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定一次</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">eventName,callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> once = <span class="function">(<span class="params">...args</span>) =&gt;</span>&#123;</span><br><span class="line">        callback(...args);  </span><br><span class="line">        <span class="comment">// 当绑定后将自己移除掉</span></span><br><span class="line">        <span class="keyword">this</span>.off(eventName,once);</span><br><span class="line">    &#125;</span><br><span class="line">    once.l = callback; <span class="comment">// 用来标识这个once是谁的</span></span><br><span class="line">    <span class="keyword">this</span>.on(eventName,once)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">EventEmitter.prototype.off = <span class="function"><span class="keyword">function</span> (<span class="params">eventName,callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>._events) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>._events[eventName] = <span class="keyword">this</span>._events[eventName].filter(<span class="function"><span class="params">fn</span>=&gt;</span>((fn !== callback) &amp;&amp; (fn.l!=callback)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = EventEmitter</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>利用sentry构建前端监控方案</title>
    <url>/2020/09/25/%E5%88%A9%E7%94%A8sentry%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>作为程序员，每次开发完自测充分的时候，但还是会有线上异常情况。如何快速发现 或者提前监控到这些异常的出现呢，是不是需要一个错误监控系统呢吧？<a id="more"></a></p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>一个错误监控系统应该做下面这些事情</p>
<p> <strong>监控错误 -&gt; 搜集错误 -&gt; 存储错误 -&gt; 分析错误 -&gt; 错误报警-&gt; 定位错误 -&gt; 解决错误</strong></p>
<p>当错误发生的时候我们更需要一些辅助信息来帮我们更快的定位错误，比如 <em>JS错误类型、 JS错误信息、JS错误堆栈、JS错误发生的位置以及相关位置的代码；JS错误发生的几率、浏览器的类型，版本号，设备机型等等辅助信息</em></p>
<h2 id="sentry概述"><a href="#sentry概述" class="headerlink" title="sentry概述"></a>sentry概述</h2><p>Sentry是程序的哨兵，它可以监控我们在生产环境中项目的运行状态，一旦某段代码运行报错或者异常，会第一时间把报错的路由异常文件，请求方式 等一些非常详细的信息以消息或者邮件给我们，让我们第一时间知道：程序出错了，然后我们可以从 Sentry 给我们的详细的错误信息中瞬间找到我们需要处理的代码，及时解决异常！</p>
<p>官方地址：</p>
<p><a href="https://github.com/getsentry/onpremise" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/getsentry/onpremise</a>   //安装部署</p>
<p><a href="https://sentry.io/" rel="external nofollow noopener noreferrer" target="_blank">https://sentry.io</a></p>
<p><a href="https://github.com/getsentry/sentry" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/getsentry/sentry</a></p>
<p><a href="https://github.com/docker-library/docs/tree/master/sentry" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/docker-library/docs/tree/master/sentry</a>   //dockerhub官方镜像 v9.1.2</p>
<p><strong>Requirements</strong></p>
<ul>
<li><p>Docker 17.05.0+</p>
</li>
<li><p>Compose 1.17.0+</p>
</li>
</ul>
<p><strong>Minimum Hardware Requirements:</strong></p>
<ul>
<li><p>You need at least 3GB RAM</p>
<p><strong>env:</strong></p>
</li>
<li><p>centos7.x</p>
</li>
</ul>
<h2 id="sentry架构"><a href="#sentry架构" class="headerlink" title="sentry架构"></a>sentry架构</h2><p>注意：当前分析v9.1.2</p>
<p>　　Sentry到底是如何实现实时日志监控报警的呢？首先，Sentry是一个C/S架构，我们需要在自己应用中集成Sentry的SDK(支持前后端语言)才能在应用发生错误是将错误信息发送给Sentry服务端。根据语言和框架的不同，我们可以选择自动或自定义设置特殊的错误类型报告给Sentry服务端。<br>　　Sentry的服务端分为web、cron、worker这几个部分，应用（客户端）发生错误后将错误信息上报给web，web处理后放入消息队列或Redis内存队列，worker从队列中消费数据进行处理，postgresql对数据持久化。</p>
<p>my-sentry：sentry的web服务<br>sentry-cron：sentry的定时任务，活性检测<br>sentry-worker：业务处理，数据持久化，报警</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/790307-20200328013405726-1523196842.png" alt="img"></p>
<h2 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a>安装与部署</h2><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><ol>
<li><strong>远程仓库直接安装</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/getsentry/onpremise</span><br><span class="line">cd onpremise</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p><strong>中间会有一次让你配置管理员账号密码的过程</strong> 下载完毕以后执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-comose up -d</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>docker安装</strong></li>
</ol>
<h3 id="先安装"><a href="#先安装" class="headerlink" title="先安装"></a>先安装</h3><ul>
<li><p>docker-ce</p>
</li>
<li><p>docker-compose</p>
</li>
</ul>
<h3 id="部署sentry"><a href="#部署sentry" class="headerlink" title="部署sentry"></a>部署sentry</h3><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull sentry       </span><br><span class="line"></span><br><span class="line">docker pull redis</span><br><span class="line"></span><br><span class="line">docker pull postgres</span><br></pre></td></tr></table></figure>
<h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name sentry-redis --restart=always redis   ###保证了，异常自动拉起</span><br><span class="line">docker run -d --name sentry-postgres -e POSTGRES_PASSWORD=secret -e POSTGRES_USER=sentry --restart=always postgres</span><br></pre></td></tr></table></figure>
<h5 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm sentry config generate-secret-key</span><br><span class="line"></span><br><span class="line">n8ntkj(u3z5(o18tm*wprg^sqp2)z%980f@upd7(e86v67g*ut  ###打印出secret-keys</span><br></pre></td></tr></table></figure>
<h5 id="数据库及账户初始化"><a href="#数据库及账户初始化" class="headerlink" title="数据库及账户初始化"></a>数据库及账户初始化</h5><p>注意：过程中需要你创建用户和密码<br>During the upgrade, you will be prompted to create the initial user which will act as the superuser.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --rm -e SENTRY_SECRET_KEY=&apos;n8ntkj(u3z5(o18tm*wprg^sqp2)z%980f@upd7(e86v67g*ut&apos; --link sentry-postgres:postgres --link sentry-redis:redis sentry upgrade</span><br></pre></td></tr></table></figure>
<h5 id="启动sentry的web服务"><a href="#启动sentry的web服务" class="headerlink" title="启动sentry的web服务"></a>启动sentry的web服务</h5><p>The web interface needs to expose port 9000 into the container. This can just be done with –publish 9000:9000:<br>You should now be able to test the web service by visiting <a href="http://localhost:9000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:9000/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --name my-sentry -e SENTRY_SECRET_KEY=&apos;n8ntkj(u3z5(o18tm*wprg^sqp2)z%980f@upd7(e86v67g*ut&apos; --link sentry-redis:redis --link sentry-postgres:postgres --restart=always sentry</span><br></pre></td></tr></table></figure>
<h5 id="启动sentry-cron-work服务"><a href="#启动sentry-cron-work服务" class="headerlink" title="启动sentry-cron/work服务"></a>启动sentry-cron/work服务</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name sentry-cron -e SENTRY_SECRET_KEY=&apos;n8ntkj(u3z5(o18tm*wprg^sqp2)z%980f@upd7(e86v67g*ut&apos; --link sentry-postgres:postgres --link sentry-redis:redis sentry run cron</span><br><span class="line"></span><br><span class="line">docker run -d --name sentry-worker-1 -e SENTRY_SECRET_KEY=&apos;n8ntkj(u3z5(o18tm*wprg^sqp2)z%980f@upd7(e86v67g*ut&apos; --link sentry-postgres:postgres --link sentry-redis:redis sentry run worker</span><br></pre></td></tr></table></figure>
<h5 id="登录测试效果"><a href="#登录测试效果" class="headerlink" title="登录测试效果"></a>登录测试效果</h5><p>账号密码是刚才创建的管理员的密码</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20200927111801382.png" alt="image-20200927111801382"></p>
<p>监控的错误详情</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20200927112011576.png" alt="image-20200927112011576"></p>
<h2 id="项目接入监控"><a href="#项目接入监控" class="headerlink" title="项目接入监控"></a>项目接入监控</h2><p><strong>创建项目</strong></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20200927112855400.png" alt="image-20200927112855400"></p>
<p>这里我们选 <strong>javascript</strong> 项目名叫 <strong>myapp</strong></p>
<p>然后sentry后台多了个项目, 然后在我们的前端项目里面像下面这样引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 脚本引入</span><br><span class="line">&lt;script</span><br><span class="line">  src=&quot;https://browser.sentry-cdn.com/5.22.3/bundle.tracing.min.js&quot;</span><br><span class="line">  integrity=&quot;sha384-HfEJlGrJtFM0B01Wt4sGzTbxWqLMcMeGAXCbyQyB+iK9BhnDmNAtIGovhekIQOa2&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;</span><br><span class="line">&gt;&lt;/script&gt;</span><br><span class="line">// npm </span><br><span class="line">import * as Sentry from &apos;@sentry/browser&apos;;</span><br><span class="line">import &#123; Integrations &#125; from &apos;@sentry/tracing&apos;;</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  dsn: &apos;xxxx&apos;,</span><br><span class="line">  integrations: [</span><br><span class="line">    new Integrations.BrowserTracing(),</span><br><span class="line">  ],</span><br><span class="line">  tracesSampleRate: 1.0,</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这样整个流程就通了，可以用起来了</p>
<h2 id="Sourcemap-上传"><a href="#Sourcemap-上传" class="headerlink" title="Sourcemap 上传"></a>Sourcemap 上传</h2><p>众所周知，我们的线上代码都是被压缩混淆过的。所以就算拿到了错误信息，只能靠猜了，所以要配合 souremap 精准定位错误信息</p>
<p><strong>准备</strong></p>
<ol>
<li>sentry 后台配置 authToken 用于上传sourcemap 使用，如下图注意勾选</li>
</ol>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20200927112142155.png" alt="image-20200927112142155"></p>
<ol>
<li>下载 webpack 插件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i @sentry/webpack-plugin -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>然后在根目录下新建 <strong>.sentryclirc</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[defaults]</span><br><span class="line">### 你的域名</span><br><span class="line">defaults.url=&apos;http://localhost:9000&apos;</span><br><span class="line">### 组织团队名默认是 sentry</span><br><span class="line">org=sentry</span><br><span class="line">### 项目名称</span><br><span class="line">project=myapp</span><br><span class="line">### 步骤1创建的</span><br><span class="line">[auth]</span><br><span class="line">token=1234</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>配置插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const SentryWebpackPlugin = require(&apos;@sentry/webpack-plugin&apos;);</span><br><span class="line">if (process.env.NODE_ENV !== &apos;development&apos;) &#123; // 注意只在生成环境开启，不然npm run dev也会上传</span><br><span class="line">    new SentryWebpackPlugin(&#123;</span><br><span class="line">      release: Date.now(), // 唯一标识，可以用其他的比如 hash</span><br><span class="line">      include: &apos;./build&apos;, // 要上传的文件夹 有的叫 dist</span><br><span class="line">      ignoreFile: &apos;.sentrycliignore&apos;, // 可不要</span><br><span class="line">      ignore: [&apos;node_modules&apos;, &apos;config-overrides.js&apos;], </span><br><span class="line">      configFile: &apos;.sentryclirc&apos; // 默认同级，如果不一样需要用node path模块处理一下</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>然后运行 npm run build</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating an optimized production build...</span><br><span class="line">&gt; Found 10 release files</span><br><span class="line">&gt; Analyzing 10 sources</span><br><span class="line">&gt; Rewriting sources</span><br><span class="line">&gt; Adding source map references</span><br><span class="line">&gt; Bundled 10 files for upload</span><br><span class="line">&gt; Uploaded release files to Sentry</span><br><span class="line">&gt; File upload complete</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>恭喜你配置成功了</p>
<h3 id="其他常用api"><a href="#其他常用api" class="headerlink" title="其他常用api"></a>其他常用api</h3><p><strong>主动上报</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sentry.captureMessage(&apos;Hello, world!&apos;); // 上报信息</span><br><span class="line">Sentry.captureException(new Error(&apos;Good bye&apos;)); // 上报异常</span><br><span class="line">Sentry.captureEvent(&#123; // 上报事件</span><br><span class="line">  message: &apos;Manual&apos;,</span><br><span class="line">  stacktrace: [</span><br><span class="line">    // ...</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>配置用户信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sentry.configureScope((scope) =&gt; &#123;</span><br><span class="line">        scope.setUser(&#123;</span><br><span class="line">          ...data.userInfo,</span><br><span class="line">          time: new Date().toLocaleString()</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>邮件</li>
<li>钉钉机器 可以去自己下载一些插件配置</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>看了其他大佬的自研方案发现可以扩展成埋点+性能监控，sentry 还是有一定的局限性，不过对于一般公司来说够用了</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>你需要知道的jest测试</title>
    <url>/2020/09/23/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84jest%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>引入 jest 官网的一段话：</p>
<blockquote>
<p>Jest 是一个令人愉快的 JavaScript 测试框架，专注于简洁明快。他适用但不局限于使用以下技术的项目：<a href="https://babeljs.io/" rel="external nofollow noopener noreferrer" target="_blank">Babel</a>, <a href="https://www.typescriptlang.org/" rel="external nofollow noopener noreferrer" target="_blank">TypeScript</a>, <a href="https://nodejs.org/en/" rel="external nofollow noopener noreferrer" target="_blank">Node</a>, <a href="https://reactjs.org/" rel="external nofollow noopener noreferrer" target="_blank">React</a>, <a href="https://angular.io/" rel="external nofollow noopener noreferrer" target="_blank">Angular</a>, <a href="https://vuejs.org/" rel="external nofollow noopener noreferrer" target="_blank">Vue</a></p>
</blockquote>
<p>如官网所说，jest 是一个易于使用的测试框架，很多框架的单元测试也都选择使用 jest。所以 jest 也是我们的一大利器，学习一下总是好的<a id="more"></a></p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以使用 npm 或者 yarn 来进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install jest --save-dev</span><br><span class="line">// or</span><br><span class="line">yarn add jest --dev</span><br></pre></td></tr></table></figure>
<h3 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h3><ul>
<li>先编写一个需要测试的函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = sum</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个 sum.test.js 文件，并写入我们的测试用例</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">'./sum'</span>)</span><br><span class="line">test(<span class="string">'adds 1 + 2 to equal 3'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 精确匹配等于3</span></span><br><span class="line">  expect(sum(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>Package.json 中配置脚本命令</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn test</span><br><span class="line">// or</span><br><span class="line">npm run test</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PASS  ./sum.test.js</span><br><span class="line">✓ adds 1 + 2 to equal 3 (5ms)</span><br></pre></td></tr></table></figure>
<p>当结果出现 pass 说明测试通过且 jest 测试框架安装成功！</p>
<h2 id="常用测试-api"><a href="#常用测试-api" class="headerlink" title="常用测试 api"></a>常用测试 api</h2><h5 id="普通匹配器"><a href="#普通匹配器" class="headerlink" title="普通匹配器"></a>普通匹配器</h5><ul>
<li>toBeNull</li>
</ul>
<p>判断是否匹配 null</p>
<ul>
<li>toBeUndefined</li>
</ul>
<p>判断是否匹配 undefined</p>
<ul>
<li>toBeDefined</li>
</ul>
<p>与 toBeUndefined 相反，匹配非 undefined</p>
<ul>
<li>toBeTruthy</li>
</ul>
<p>判断布尔值为 true</p>
<ul>
<li>toBeFalsy</li>
</ul>
<p>判断布尔值为 false</p>
<ul>
<li>not</li>
</ul>
<p>取反</p>
<ul>
<li>toEqual 和 toBe</li>
</ul>
<p><code>toBe</code> 使用 <code>Object.is</code> 来测试精确相等。 如果您想要检查对象的值，请使用 <code>toEqual</code> 代替</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'null'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line">  expect(a).toBeNull()</span><br><span class="line">  expect(a).toBeDefined()</span><br><span class="line">  expect(a).not.toBeUndefined()</span><br><span class="line">  expect(a).not.toBeTruthy()</span><br><span class="line">  expect(a).toBeFalsy()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'zero'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">0</span></span><br><span class="line">  expect(b).not.toBeNull()</span><br><span class="line">  expect(b).toBeDefined()</span><br><span class="line">  expect(b).not.toBeUndefined()</span><br><span class="line">  expect(b).not.toBeTruthy()</span><br><span class="line">  expect(b).toBeFalsy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="数字匹配器"><a href="#数字匹配器" class="headerlink" title="数字匹配器"></a>数字匹配器</h5><ul>
<li>toBeGreaterThan</li>
</ul>
<p>判断返回值大于期望值</p>
<ul>
<li>toBeGreaterThanOrEqual</li>
</ul>
<p>判断返回值大于或者等于期望值</p>
<ul>
<li>toBeLessThan</li>
</ul>
<p>判断返回值小于期望值</p>
<ul>
<li>toBeLessThanOrEqual</li>
</ul>
<p>判断返回值小于或等于期望值</p>
<ul>
<li>toBe</li>
</ul>
<p>判断返回值全等于期望值</p>
<ul>
<li>toEqual</li>
</ul>
<p>判断对象等值等于期望值</p>
<ul>
<li>toBeCloseTo</li>
</ul>
<p>判断浮点数在允许的误差范围相等</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'two plus two'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">  expect(value).toBeGreaterThan(<span class="number">3</span>)</span><br><span class="line">  expect(value).toBeGreaterThanOrEqual(<span class="number">3.5</span>)</span><br><span class="line">  expect(value).toBeLessThan(<span class="number">5</span>)</span><br><span class="line">  expect(value).toBeLessThanOrEqual(<span class="number">4.5</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// toBe and toEqual are equivalent for numbers</span></span><br><span class="line">  expect(value).toBe(<span class="number">4</span>)</span><br><span class="line">  expect(value).toEqual(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'两个浮点数字相加'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line">  <span class="comment">//expect(value).toBe(0.3);  这句会报错，因为浮点数有舍入误差</span></span><br><span class="line">  expect(value).toBeCloseTo(<span class="number">0.3</span>) <span class="comment">// 这句可以运行</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="字符串匹配器"><a href="#字符串匹配器" class="headerlink" title="字符串匹配器"></a>字符串匹配器</h5><ul>
<li>toMatch</li>
</ul>
<p>判断是否含有期望字符</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'there is no I in team'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="string">'team'</span>).not.toMatch(<span class="regexp">/I/</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'but there is a "stop" in Christoph'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="string">'Christoph'</span>).toMatch(<span class="regexp">/stop/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="数组匹配器"><a href="#数组匹配器" class="headerlink" title="数组匹配器"></a>数组匹配器</h5><ul>
<li>toContain</li>
</ul>
<p>判断数组是否包含某个值</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shoppingList = [<span class="string">'diapers'</span>, <span class="string">'kleenex'</span>, <span class="string">'trash bags'</span>, <span class="string">'paper towels'</span>, <span class="string">'beer'</span>]</span><br><span class="line"></span><br><span class="line">test(<span class="string">'the shopping list has beer on it'</span>, () =&gt; &#123;</span><br><span class="line">  expect(shoppingList).toContain(<span class="string">'beer'</span>)</span><br><span class="line">  expect(<span class="keyword">new</span> <span class="built_in">Set</span>(shoppingList)).toContain(<span class="string">'beer'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="Throw-error-匹配器"><a href="#Throw-error-匹配器" class="headerlink" title="Throw error 匹配器"></a>Throw error 匹配器</h5><p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileAndroidCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'you are using the wrong JDK'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'compiling android goes as expected'</span>, () =&gt; &#123;</span><br><span class="line">  expect(compileAndroidCode).toThrow()</span><br><span class="line">  expect(compileAndroidCode).toThrow(<span class="built_in">Error</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You can also use the exact error message or a regexp</span></span><br><span class="line">  expect(compileAndroidCode).toThrow(<span class="string">'you are using the wrong JDK'</span>)</span><br><span class="line">  expect(compileAndroidCode).toThrow(<span class="regexp">/JDK/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="多次测试前后准备的钩子函数"><a href="#多次测试前后准备的钩子函数" class="headerlink" title="多次测试前后准备的钩子函数"></a>多次测试前后准备的钩子函数</h2><p>如果你有一些要为多次测试重复设置的工作，你可以使用 <code>beforeEach</code> 和 <code>afterEach</code>。例如，我们考虑一些与城市信息数据库进行交互的测试。 你必须在每个测试之前调用方法 <code>initializeCityDatabase()</code> ，同时必须在每个测试后，调用方法 <code>clearCityDatabase()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  initializeCityDatabase()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  clearCityDatabase()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'city database has Vienna'</span>, () =&gt; &#123;</span><br><span class="line">  expect(isCity(<span class="string">'Vienna'</span>)).toBeTruthy()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'city database has San Juan'</span>, () =&gt; &#123;</span><br><span class="line">  expect(isCity(<span class="string">'San Juan'</span>)).toBeTruthy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在某些情况下，你只需要在文件的开头做一次设置，缓存数据方便后面的操作。Jest 提供 <code>beforeAll</code> 和 <code>afterAll</code> 处理这种情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> initializeCityDatabase()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> clearCityDatabase()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'city database has Vienna'</span>, () =&gt; &#123;</span><br><span class="line">  expect(isCity(<span class="string">'Vienna'</span>)).toBeTruthy()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'city database has San Juan'</span>, () =&gt; &#123;</span><br><span class="line">  expect(isCity(<span class="string">'San Juan'</span>)).toBeTruthy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="关于分组块-describe"><a href="#关于分组块-describe" class="headerlink" title="关于分组块 describe"></a>关于分组块 describe</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> initializeCityDatabase()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> clearCityDatabase()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'city database has Vienna'</span>, () =&gt; &#123;</span><br><span class="line">  expect(isCity(<span class="string">'Vienna'</span>)).toBeTruthy()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'city database has San Juan'</span>, () =&gt; &#123;</span><br><span class="line">  expect(isCity(<span class="string">'San Juan'</span>)).toBeTruthy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>分组和命名空间差不多,就是把我们的测试分块整理下，这样测试就比较有条理。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是关于 jest 测试的一些简单使用的总结和记录。欢迎大家查阅指正，觉得有帮助的给个赞，谢谢啦！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>手写promise</title>
    <url>/2020/09/15/%E6%89%8B%E5%86%99promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>promise是解决异步问题的大杀器，我们在使用的过程中有没有想过大概是怎么实现的呢？简单放上实现的源码供参考<a id="more"></a></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> STATUS = &#123; <span class="attr">PENDING</span>: <span class="string">'PENDING'</span>, <span class="attr">FUFILLED</span>: <span class="string">'FUFILLED'</span>, <span class="attr">REJECTED</span>: <span class="string">'REJECTED'</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的promise 按照规范来写 就可以和别人的promise公用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">x, promise2, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// If promise and x refer to the same object, reject promise with a TypeError as the reason.</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 == x) &#123; <span class="comment">// 防止自己等待自己完成</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'类型错了'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看x 是普通值还是promise 如果是promise要采用他的状态</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// x可以是一个对象 或者是函数</span></span><br><span class="line">        <span class="keyword">let</span> called;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> then = x.then; <span class="comment">// 就看一下这个对象是否有then方法</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then == <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="comment">// then是函数 我就认为这个x是一个promise</span></span><br><span class="line">                <span class="comment">// 如果x是promise 那么就采用他的状态</span></span><br><span class="line">                then.call(x, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123; <span class="comment">// 调用返回的promise 用他的结果 作为下一次then的结果</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 递归解析成功后的值 直到他是一个普通值为止</span></span><br><span class="line">                    resolvePromise(y, promise2, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x); <span class="comment">// 此时x 就是一个普通对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e); <span class="comment">// 取then时抛出错误了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x); <span class="comment">// x是一个原始数据类型 不能是promise</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是proimise 直接就调用resolve</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.PENDING;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = []; <span class="comment">// 存放成功的回调的 </span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = []; <span class="comment">// 存放失败的回调的</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(val <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123; <span class="comment">// 是promise 就继续递归解析</span></span><br><span class="line">                <span class="keyword">return</span> val.then(resolve,reject)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status == STATUS.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = STATUS.FUFILLED;</span><br><span class="line">                <span class="keyword">this</span>.value = val;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status == STATUS.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = STATUS.REJECTED;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="comment">// 腹部</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 出错走失败逻辑</span></span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123; <span class="comment">// swtich  作用域</span></span><br><span class="line">        <span class="comment">// 可选参数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">x</span> =&gt;</span> x</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span>? onRejected: <span class="function"><span class="params">err</span>=&gt;</span> &#123;<span class="keyword">throw</span> err&#125;</span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.FUFILLED) &#123;</span><br><span class="line">                <span class="comment">// to....</span></span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                        resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.REJECTED) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                        resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">                <span class="comment">// 装饰模式 切片编程</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// todo..</span></span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                            resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// todo..</span></span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                            resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(err)&#123; <span class="comment">// 默认没有成功 只有失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason)&#123; <span class="comment">// 失败的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试时会调用此方法  Promise.finally  resolve reject catch all</span></span><br><span class="line"><span class="built_in">Promise</span>.defer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// npm install promises-aplus-tests -g</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>图解正则——字符匹配</title>
    <url>/2020/09/10/%E5%9B%BE%E8%A7%A3%E6%AD%A3%E5%88%99%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正则表达式是绕不开的，正则的强大是众所周知的，学会它对我们的编程也是有大大的帮助<a id="more"></a></p>
<h2 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h2><p>正则表达式之所以强大，就要归功于它的模糊匹配，不能可以匹配不同数量的字符串，还可以匹配不同内容的字符串。如果正常只能精确匹配字符串，那正则的效果就没有啥用了比如：/a/就匹配一个a字符。</p>
<h3 id="用于匹配字符串长度的横行匹配"><a href="#用于匹配字符串长度的横行匹配" class="headerlink" title="用于匹配字符串长度的横行匹配"></a>用于匹配字符串长度的横行匹配</h3><p>匹配的字符串长度是不固定的，如图所示：</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20200910170307203.png" alt="image-20200910170307203"></p>
<h3 id="用于匹配字符串多种情况内容的纵向匹配"><a href="#用于匹配字符串多种情况内容的纵向匹配" class="headerlink" title="用于匹配字符串多种情况内容的纵向匹配"></a>用于匹配字符串多种情况内容的纵向匹配</h3><p>匹配的字符串的内容是几种情况中的一种，如图所示：</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20200910170403956.png" alt="image-20200910170403956"></p>
<h2 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h2><p>我们在写正则匹配的时候，在一个位置上，比如一个字符串的某个索引上可能的值有很多个,假设就是abc其中一个字母。那么我们就需要用到字符组，大概的意思就是一组字符中的其中一个。</p>
<ul>
<li>表示一个位置可能出现的多种情况，正则表示<code>/[abc]/</code>,图解如下：</li>
</ul>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20200910170841308.png" alt="image-20200910170841308"></p>
<ul>
<li>表示一个范围取值，也是多种情况取其一，正则表示<code>[1-6a-f]</code>，图解如下：</li>
</ul>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20200910171154129.png" alt="image-20200910171154129"></p>
<p>在表示范围这里需要注意下，有时我们需要匹配的就只是表示范围的三个值比如：<code>a</code> <code>-</code> <code>f</code> 那我们的正则就不能<code>[a-f]</code> 这样写了，需要像这样写：</p>
<p><strong>[-af]</strong></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img1.png" alt="img"></p>
<p><strong>[-fa]</strong></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img2.png" alt="img"></p>
<p><strong>[a-f]</strong></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/20200910171745.png" alt></p>
<ul>
<li>排除部分值，也就是说把不要的值写出来，正则<code>[^abc]</code>表示排除abc其中之一，图解如下：</li>
</ul>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/image-20200910172039436.png" alt="image-20200910172039436"></p>
<ul>
<li><strong>常见的几种简写方式</strong></li>
</ul>
<ol>
<li>\d  =  [0-9]</li>
</ol>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img3.png" alt="img"></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img4.png" alt="img"></p>
<ol start="2">
<li>\D = [^0-9]</li>
</ol>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img5.png" alt="img"></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img6.png" alt="img"></p>
<ol start="3">
<li>\w = [0-9a-zA-Z_]</li>
</ol>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img7.png" alt="img"></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img8.png" alt="img"></p>
<ol start="4">
<li>\W = [^0-9a-zA-Z]</li>
</ol>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img9.png" alt="img"></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img10.png" alt="img"></p>
<ol start="5">
<li>\s = [\t\v\n\r\f]</li>
</ol>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img11.png" alt="img"></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img12.png" alt="img"></p>
<ol start="6">
<li>\S = [^\t\v\n\r\f]</li>
</ol>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img13.png" alt="img" style="zoom:67%;"></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img14.png" alt="img"></p>
<ol start="7">
<li>. = [^\n\r\u2028\u2029]</li>
</ol>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img15.png" alt="img" style="zoom:67%;"></p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img16.png" alt="img" style="zoom:67%;"></p>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><h3 id="简写形式"><a href="#简写形式" class="headerlink" title="简写形式"></a>简写形式</h3><ul>
<li>{m,}至少出现m次，m是一个数量。比如a{9,}表示a至少出现9次，如图</li>
</ul>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img17.png" alt="img"></p>
<ul>
<li>{m} = {m,m} = 出现m次。比如a{9}表示a出现9次，如图：</li>
</ul>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img18.png" alt="img"></p>
<ul>
<li>? = {0,1} = 不出现或出现一次。比如a?表示a不出现或者出现1次，如图：</li>
</ul>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img19.png" alt="img"></p>
<ul>
<li>+ = {1,} = 至少出现1次。比如a+表示a至少出现1次，如图：</li>
</ul>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img20.png" alt="img"></p>
<ul>
<li>* = {0,}= 出现任意多次。比如a*表示a出现任意多次，可能很多，也可能一次没出现，如图：</li>
</ul>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img21.png" alt="img"></p>
<h2 id="多条分支"><a href="#多条分支" class="headerlink" title="多条分支"></a>多条分支</h2><p>也是表示多种情况中的一种用<code>｜</code>来表示，比如：a|b|c，表示abc其中之一，如图：</p>
<p><img src="https://gitee.com/wangyuan0108/image/raw/master/img22.png" alt="img"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是学习正则的初步理解和图示，用图来表示正则非常好理解，欢迎大家查阅，有问题请指出，觉得不错，可以给个赞，谢谢！！！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>umi@3.0+ts+antd@4.0从零搭建后台项目工程</title>
    <url>/2020/09/03/umi-3-0-ts-antd-4-0%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>umi 和 antd 升级有一段时间了，一直准备用这个插件式开发套件新建一个项目，用来体验下这个框架的优点。因为这个 umi 升级完成之后，文档写的略微对新手不太友好（比如我这样的菜鸡）。在新建一个基础架构的过程中也遇到了不少问题，把解决过程记录下，像大家分享下！<a id="more"></a></p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先 umi 的<a href="https://umijs.org/zh-CN/docs/getting-started" rel="external nofollow noopener noreferrer" target="_blank">文档</a>在此，可以参照这个快速上手进行搭建，我也是参照这个进行搭建的，简单说下步骤。</p>
<ul>
<li>首先得有 node，并确保 node 版本是 10.13 或以上。（mac 下推荐使用 nvm 来管理 node 版本）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v10.13.0</span><br></pre></td></tr></table></figure>
<ul>
<li>用脚手架搭建一个初始项目目录<br>找个位置新建一个文件夹用来放置代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir test_umi &amp;&amp; cd test_umi</span><br></pre></td></tr></table></figure>
<p>然后执行命令<code>yarn create @umijs/umi-app</code>通过官方工具创建项目,成功会得到如下项目目录代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yarn create @umijs/umi-app</span><br><span class="line"># 或 npx @umijs/create-umi-app</span><br><span class="line">Copy:  .editorconfig</span><br><span class="line">Write: .gitignore</span><br><span class="line">Copy:  .prettierignore</span><br><span class="line">Copy:  .prettierrc</span><br><span class="line">Write: .umirc.ts</span><br><span class="line">Copy:  mock/.gitkeep</span><br><span class="line">Write: package.json</span><br><span class="line">Copy:  README.md</span><br><span class="line">Copy:  src/pages/index.less</span><br><span class="line">Copy:  src/pages/index.tsx</span><br><span class="line">Copy:  tsconfig.json</span><br><span class="line">Copy:  typings.d.ts</span><br></pre></td></tr></table></figure>
<ul>
<li>安装 npm 依赖包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn</span><br><span class="line">yarn install v1.21.1</span><br><span class="line">[1/4] 🔍  Resolving packages...</span><br><span class="line">success Already up-to-date.</span><br><span class="line">✨  Done <span class="keyword">in</span> 0.71s.</span><br></pre></td></tr></table></figure>
<ul>
<li>启动项目</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn start</span><br><span class="line">Starting the development server...</span><br><span class="line">✔ Webpack</span><br><span class="line">  Compiled successfully <span class="keyword">in</span> 17.84s</span><br><span class="line"> DONE  Compiled successfully <span class="keyword">in</span> 17842ms                                       8:06:31 PM</span><br><span class="line">  App running at:</span><br><span class="line">  - Local:   http://localhost:8000 (copied to clipboard)</span><br><span class="line">  - Network: http://192.168.12.34:8000</span><br></pre></td></tr></table></figure>
<p>在浏览器里打开 <a href="http://localhost:8000/，不出意外的话就能看到界面了" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8000/，不出意外的话就能看到界面了</a><br><img src="https://img.alicdn.com/tfs/TB1JpeLwxD1gK0jSZFsXXbldVXa-1540-950.png" alt="img"></p>
<h2 id="修改配置添加需要的插件"><a href="#修改配置添加需要的插件" class="headerlink" title="修改配置添加需要的插件"></a>修改配置添加需要的插件</h2><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>默认的脚手架内置了 @umijs/preset-react，包含布局、权限、国际化、dva、简易数据流等常用功能。比如想要 ant-design-pro 的布局，编辑 .umirc.ts 配置 layout: {}，<strong>并且需要安装 @ant-design/pro-layout</strong>。这里尤其注意这个依赖包的安装，如果没有这个包，antd-pro 的布局是不能正确显示的。之前官方文档没有这个提示，后期踩坑才发现，给加到文档上了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'umi'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="comment">// 配置开启布局插件</span></span><br><span class="line">+ layout: &#123;&#125;,</span><br><span class="line">  routes: [&#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'@/pages/index'</span> &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>layout 配置请参考<a href="https://umijs.org/zh-CN/plugins/plugin-layout#%E9%85%8D%E7%BD%AE" rel="external nofollow noopener noreferrer" target="_blank">文档</a>这里主要说下我踩的坑：</p>
<ol>
<li>在使用这个布局的时候，我需要显示右上方的用户名和头像，但是文档没有提及如何修改默认的头像。这里官网说过，要使用登录按钮和用户名需要进行运行时配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/app.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> layout = &#123;</span><br><span class="line">  logout: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, <span class="comment">// do something</span></span><br><span class="line">  rightRender: <span class="function"><span class="params">initInfo</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hahah'</span></span><br><span class="line">  &#125;, <span class="comment">// return string || ReactNode;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果配置了 <code>rightRender</code>，那么用户名和退出的逻辑都需要自定义了。这里我不需要自定义交互只是想修改下名称和头像，所以修改这个 rightRender 方法是不合适的，因为默认在顶部右侧并不会显示退出按钮，需要在运行配置中配合<code>@umijs/plugin-intial-state</code> 的 <code>getInitialState</code> 返回一个对象，才可以显示。所以需要安装插件<code>@umijs/plugin-intial-state</code></p>
<h3 id="全局初始化数据"><a href="#全局初始化数据" class="headerlink" title="全局初始化数据"></a>全局初始化数据</h3><ul>
<li>概念<br>在全局定义一个初始化数据的地方，以供全局任何地方使用。安装插件<code>@umijs/plugin-intial-state</code></li>
<li>启用<br>在 <code>src/app.ts</code> 并且导出 <code>getInitialState</code> 方法时启用。需要运行时配置</li>
<li>依赖<br>不可直接使用，必须搭配 <code>@umijs/plugin-model</code> 一起使用。</li>
<li>配置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/app.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getInitialState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    userId: <span class="string">'1'</span>,</span><br><span class="line">    role: <span class="string">'admin'</span>,</span><br><span class="line">    name: <span class="string">'清风'</span>, <span class="comment">// 这个就是配置布局中默认用户名的地方</span></span><br><span class="line">    avatar: <span class="string">'http://dinping.wangyuanweb.top/18-4-12/31903640.jpg'</span>, <span class="comment">// 这个就是配置布局中默认用户头像的地方</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置右上方退出登录的逻辑函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> layout = &#123;</span><br><span class="line">  logout: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1234'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取全局共享数据需要插件<code>@umijs/plugin-model</code><br>这个插件获取的是存在全局共享的数据，不是存在 dva 数据流中的数据。此处需要特别注意下，简单使用方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; initialState, loading, error, refresh, setInitialState &#125; = useModel(<span class="string">'@@initialState'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="接口请求"><a href="#接口请求" class="headerlink" title="接口请求"></a>接口请求</h3><p>插件<code>@umijs/plugin-request</code>默认是启用的。</p>
<p>使用的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">'umi'</span></span><br><span class="line">request(url, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">  requestType: <span class="string">'form'</span>,</span><br><span class="line">  data,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>更多使用方式请参考<a href="https://umijs.org/zh-CN/plugins/plugin-request#userequest" rel="external nofollow noopener noreferrer" target="_blank">文档</a></p>
<h3 id="接入antd-4-0"><a href="#接入antd-4-0" class="headerlink" title="接入antd@4.0"></a>接入<a href="mailto:antd@4.0" rel="external nofollow noopener noreferrer" target="_blank">antd@4.0</a></h3><p>启用方式是配置开启</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'umi'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="comment">// 配置开启布局插件</span></span><br><span class="line">+ layout: &#123;&#125;,</span><br><span class="line">+ antd: &#123;&#125;,</span><br><span class="line">  routes: [&#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'@/pages/index'</span> &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>有个注意的地方就是<a href="mailto:antd@4.0" rel="external nofollow noopener noreferrer" target="_blank">antd@4.0</a>的图标库单独分出去了，使用的时候要单独安装</strong><br>具体详见<a href="https://ant.design/components/icon-cn/" rel="external nofollow noopener noreferrer" target="_blank">文档</a></p>
<h3 id="使用-dva-数据流"><a href="#使用-dva-数据流" class="headerlink" title="使用 dva 数据流"></a>使用 dva 数据流</h3><p>插件是<code>@umijs/plugin-dva</code>,启用方式是配置开启</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'umi'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="comment">// 配置开启布局插件</span></span><br><span class="line">+ layout: &#123;&#125;,</span><br><span class="line">+ antd: &#123;&#125;,</span><br><span class="line">+ dva: &#123;</span><br><span class="line">    immer: <span class="literal">true</span>,</span><br><span class="line">    hmr: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  routes: [&#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'@/pages/index'</span> &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>详细配置请参考<a href="https://umijs.org/zh-CN/plugins/plugin-dva#extramodels" rel="external nofollow noopener noreferrer" target="_blank">文档</a></p>
<h3 id="使用代理跨域请求"><a href="#使用代理跨域请求" class="headerlink" title="使用代理跨域请求"></a>使用代理跨域请求</h3><p>添加配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'umi'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="comment">// 配置开启布局插件</span></span><br><span class="line">+ layout: &#123;&#125;,</span><br><span class="line">+ antd: &#123;&#125;,</span><br><span class="line">+ dva: &#123;</span><br><span class="line">    immer: <span class="literal">true</span>,</span><br><span class="line">    hmr: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">+ proxy: &#123;</span><br><span class="line">    <span class="string">'/api'</span>: &#123;</span><br><span class="line">      target: <span class="string">'https://a.b.com/'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123; <span class="string">'^/api'</span>: <span class="string">''</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  routes: [&#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'@/pages/index'</span> &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="开启微前端"><a href="#开启微前端" class="headerlink" title="开启微前端"></a>开启微前端</h3><p>微前端插件<code>@umijs/plugin-qiankun</code>使用方式是配置开发,需要安装此插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @umijs/plugin-qiankun -D</span><br></pre></td></tr></table></figure>
<p>配置开启</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'umi'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="comment">// 配置开启布局插件</span></span><br><span class="line">+ layout: &#123;&#125;,</span><br><span class="line">+ antd: &#123;&#125;,</span><br><span class="line">+ dva: &#123;</span><br><span class="line">    immer: <span class="literal">true</span>,</span><br><span class="line">    hmr: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">+ proxy: &#123;</span><br><span class="line">    <span class="string">'/api'</span>: &#123;</span><br><span class="line">      target: <span class="string">'https://a.b.com/'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123; <span class="string">'^/api'</span>: <span class="string">''</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">+ qiankun:&#123;</span><br><span class="line">    master: &#123;</span><br><span class="line">      <span class="comment">// 注册子应用信息</span></span><br><span class="line">      apps: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">'app1'</span>, <span class="comment">// 唯一 id</span></span><br><span class="line">          entry: <span class="string">'http://localhost:8001'</span>, <span class="comment">// html entry</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  routes: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'@/pages/index'</span> &#125;,</span><br><span class="line">    + &#123; <span class="attr">path</span>: <span class="string">'/dashboard/analysis'</span>, <span class="attr">microApp</span>: <span class="string">'app1'</span> &#125; <span class="comment">// 微前端的子页面路由</span></span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://gw.alipayobjects.com/mdn/rms_655822/afts/img/A*TroZSp_cH0MAAAAAAAAAAAAAARQnAQ" alt="例子"><br>更多使用配置请看<a href="https://umijs.org/zh-CN/plugins/plugin-qiankun#%E5%90%AF%E7%94%A8%E6%96%B9%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">文档</a></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>umi</tag>
        <tag>ts</tag>
        <tag>antd</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序实现详情页滚动渐变导航条</title>
    <url>/2020/08/27/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%BA%AC%E4%B8%9C%E8%AF%A6%E6%83%85%E9%A1%B5%E5%AE%9E%E7%8E%B0%E6%BB%9A%E5%8A%A8%E6%B8%90%E5%8F%98%E5%AF%BC%E8%88%AA%E6%9D%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于项目需要，需要在我们的详情页做一个类似京东详情页的滚动渐进增强的自定义导航条。接下来就简单记录下开发时的实现思路，以及自己实现中的问题，方便以后查阅。<a id="more"></a></p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>由于微信的限制，我们要实现单一页面的自定义导航条需要对这个页面进行配置才允许自定义。如果是所有页面都要自定义导航条，那就需要在 app.json 中全局配置了。具体配置如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"navigationStyle": "custom",</span><br></pre></td></tr></table></figure>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>首先我们要实现自定义导航条，那么我们就需要获得导航条的宽高和边距大小。用一个普通的盒子来模拟这导航条的样子，然后盒子的内部就可以放一些我们想放的元素和切换展示的 icon。</p>
<h3 id="获取导航条的属性"><a href="#获取导航条的属性" class="headerlink" title="获取导航条的属性"></a>获取导航条的属性</h3><p>获取导航条的宽高需要借助微信的两个 api：<code>wx.getSystemInfo()</code> 和 <code>wx.getMenuButtonBoundingClientRect()</code>，具体 api 描述请看<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/system/system-info/wx.getSystemInfo.html" rel="external nofollow noopener noreferrer" target="_blank">微信官方文档</a>。因为自定义导航条可能会在多个页面使用这个数据变量。故把获取数据的计算过程放在 app.js 中。计算的结果数据也存储到 app.js 的全局变量中，方便以后其它页面的取用。具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置导航的高度</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  setNavBarHeight () &#123;</span><br><span class="line">    <span class="comment">// 默认高度</span></span><br><span class="line">    <span class="keyword">this</span>.globalData.navHeight = <span class="number">88</span></span><br><span class="line">    <span class="comment">// 默认距离上方的距离</span></span><br><span class="line">    <span class="keyword">this</span>.globalData.navTop = <span class="number">50</span></span><br><span class="line">    <span class="comment">// 默认状态栏的高度</span></span><br><span class="line">    <span class="keyword">this</span>.globalData.statusBarHeight = <span class="number">44</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取菜单按钮（右上角胶囊按钮）的布局位置信息。坐标信息以屏幕左上角为原点。</span></span><br><span class="line">      <span class="keyword">const</span> menuButtonObject = wx.getMenuButtonBoundingClientRect()</span><br><span class="line">      <span class="comment">// 获取系统信息</span></span><br><span class="line">      wx.getSystemInfo(&#123;</span><br><span class="line">        success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 解构出所需要的计算数据</span></span><br><span class="line">          <span class="keyword">const</span> &#123; top = <span class="number">50</span>, height = <span class="number">32</span> &#125; = menuButtonObject || &#123;<span class="attr">top</span>: <span class="number">50</span>, <span class="attr">height</span>: <span class="number">32</span>&#125;</span><br><span class="line">          <span class="keyword">const</span> &#123; statusBarHeight = <span class="number">44</span>, system,safeArea &#125; = res</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 通过右上角的胶囊按钮计算出导航条的高度</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          **/</span></span><br><span class="line">          <span class="keyword">const</span> navHeight = statusBarHeight + height + (top - statusBarHeight) * <span class="number">2</span></span><br><span class="line">          <span class="keyword">this</span>.globalData.navHeight = navHeight <span class="comment">// 导航高度</span></span><br><span class="line">          <span class="keyword">this</span>.globalData.navTop = top <span class="comment">// 胶囊按钮与顶部的距离</span></span><br><span class="line">          <span class="keyword">this</span>.globalData.statusBarHeight = statusBarHeight <span class="comment">// 状态栏高度</span></span><br><span class="line">          <span class="keyword">this</span>.globalData.system = system</span><br><span class="line">          <span class="keyword">this</span>.globalData.safeAreaTop = safeArea.top</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.globalData.navHeight = <span class="number">88</span></span><br><span class="line">          <span class="keyword">this</span>.globalData.navTop = <span class="number">50</span></span><br><span class="line">          <span class="keyword">this</span>.globalData.statusBarHeight = <span class="number">44</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.globalData.navHeight = <span class="number">88</span></span><br><span class="line">      <span class="keyword">this</span>.globalData.navTop = <span class="number">50</span></span><br><span class="line">      <span class="keyword">this</span>.globalData.statusBarHeight = <span class="number">44</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过以上代码实现，已经获取到了导航条的高度、状态栏的高度等信息，以供后面使用</p>
<h2 id="封装自定义导航条组件"><a href="#封装自定义导航条组件" class="headerlink" title="封装自定义导航条组件"></a>封装自定义导航条组件</h2><p>对于封装成单独的一个组件，很显然是为了更大的复用。以后如果在哪个页面再需要自定义导航条的话，直接修改下导航条的配置和引入使用下组件就好了，详细组件封装如下：</p>
<ul>
<li>navbar/index.wxml</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;view <span class="class"><span class="keyword">class</span></span>=<span class="string">'navbar'</span> style=<span class="string">'height:&#123;&#123;navH&#125;&#125;px;background-color:rgba(51,51,51,&#123;&#123;bgOpacityValue&#125;&#125;);'</span>&gt;</span><br><span class="line">  &lt;view</span><br><span class="line">    wx:<span class="keyword">if</span>=<span class="string">'&#123;&#123;showNavIcon&#125;&#125;'</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span></span>=<span class="string">"navbar-action-wrap navbar-action-group &#123;&#123;!showBgColor&amp;&amp;'navbar-navback-bg'&#125;&#125;"</span></span><br><span class="line">    style=<span class="string">'top:&#123;&#123;navTop&#125;&#125;px;'</span></span><br><span class="line">    bind:tap=<span class="string">"&#123;&#123;showBackHome?'toIndex':'navBack'&#125;&#125;"</span>&gt;</span><br><span class="line">    <span class="comment">// 是否显示返回主页的小房子图标</span></span><br><span class="line">    &lt;view wx:<span class="keyword">if</span>=<span class="string">'&#123;&#123;showBackHome&#125;&#125;'</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"iconfont icon-nav_back_home icon-me &#123;&#123;!showBgColor&amp;&amp;'icon-hidden'&#125;&#125;"</span> /&gt;</span><br><span class="line">    &lt;view wx:<span class="keyword">if</span>=<span class="string">'&#123;&#123;!showBackHome&#125;&#125;'</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"iconfont icon-nav_back icon-me &#123;&#123;!showBgColor&amp;&amp;'icon-hidden'&#125;&#125;"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 导航条中的两个tab按钮切换显示内容</span></span><br><span class="line"><span class="regexp">  &lt;view wx:if='&#123;&#123;bgOpacityValue&#125;&#125;' class='navbar-title &#123;&#123;!showBgColor&amp;&amp;"navbar-title-hidden"&#125;&#125;' style='top:&#123;&#123;navTop&#125;&#125;px'&gt;</span></span><br><span class="line"><span class="regexp">    &lt;text class="navbar-play-other &#123;&#123;currentIndex===0&amp;&amp;'navbar-tab-active'&#125;&#125;" data-value='&#123;&#123;0&#125;&#125;' bind:tap='selectTitle'&gt;</span></span><br><span class="line"><span class="regexp">      商品</span></span><br><span class="line"><span class="regexp">    &lt;/</span>text&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">if</span>=<span class="string">'&#123;&#123;showPlayTab&#125;&#125;'</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"navbar-play-other &#123;&#123;currentIndex===1&amp;&amp;'navbar-tab-active'&#125;&#125;"</span> data-value=<span class="string">'&#123;&#123;1&#125;&#125;'</span> bind:tap=<span class="string">'selectTitle'</span>&gt;</span><br><span class="line">      评价</span><br><span class="line">    &lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>view&gt;</span><br><span class="line">&lt;<span class="regexp">/view&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>navbar/index.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = getApp()</span><br><span class="line"></span><br><span class="line">Component(&#123;</span><br><span class="line">  options: &#123;</span><br><span class="line">    addGlobalClass: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 组件的属性列表</span></span><br><span class="line">  properties: &#123;</span><br><span class="line">    <span class="comment">// 返回icon的颜色</span></span><br><span class="line">    showIconBgColor: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      value: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 是否显示导航条icon</span></span><br><span class="line">    showNavIcon: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      value: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 渐进色值（控制头部滚动变色）</span></span><br><span class="line">    bgOpacityValue: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      value: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当前的tab值</span></span><br><span class="line">    currentIndex: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      value: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 是否显示返回首页按钮判断值</span></span><br><span class="line">    showBackHome: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      value: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 是否显示tab判断值</span></span><br><span class="line">    showPlayTab: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      value: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 标题一字段</span></span><br><span class="line">    playTitle: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      value: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 标题2字段</span></span><br><span class="line">    goodsTitle: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      value: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件的初始数据</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    titleIndex: <span class="number">0</span>, <span class="comment">// 默认高量的tile（比如商品）</span></span><br><span class="line">    navH: App.globalData.navHeight || <span class="number">88</span>, <span class="comment">// 导航条高度</span></span><br><span class="line">    navTop: App.globalData.navTop || <span class="number">50</span>, <span class="comment">// 距离顶部高度</span></span><br><span class="line">    statusBarHeight: App.globalData.statusBarHeight || <span class="number">44</span>, <span class="comment">// 状态栏高度</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件的方法列表</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 回退</span></span><br><span class="line">    navBack() &#123;</span><br><span class="line">      wx.navigateBack()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 回主页</span></span><br><span class="line">    toIndex() &#123;</span><br><span class="line">      wx.reLaunch(<span class="string">'home'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 返回数据判断是商品还是评价</span></span><br><span class="line">    selectTitle(e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        titleIndex: e.currentTarget.dataset.value,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.triggerEvent(<span class="string">'selectTitle'</span>, e.currentTarget.dataset.value)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>navbar/index.wxss<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">z-index</span>: <span class="number">999999</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar-title</span> &#123;</span><br><span class="line">	<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">	<span class="attribute">padding-left</span>: <span class="number">119</span>rpx;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">32px</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">32px</span>;</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">	<span class="attribute">font-weight</span>: bold;</span><br><span class="line">	<span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">	<span class="attribute">white-space</span>: nowrap;</span><br><span class="line">	<span class="attribute">display</span>: table-cell;</span><br><span class="line">	<span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar-title-hidden</span> &#123;</span><br><span class="line">	<span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar-play-other</span> &#123;</span><br><span class="line">	<span class="attribute">margin-left</span>: <span class="number">40</span>rpx;</span><br><span class="line">	<span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar-tab-active</span> &#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">34</span>rpx;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fdd100</span>;</span><br><span class="line">	<span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar-action-wrap</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">align-items</span>: center;</span><br><span class="line">	<span class="attribute">justify-content</span>: center;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">z-index</span>: <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar-navback-bg</span> &#123;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.56</span>);</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.08</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar-action-group</span> &#123;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">64</span>rpx;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">64</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar-action_item</span> &#123;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">3px</span> <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar-action-group</span> <span class="selector-class">.navbar-action_item</span> &#123;</span><br><span class="line">	<span class="attribute">border-right</span>: <span class="number">1px</span> solid <span class="number">#f0f0f0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">3px</span> <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar-action-group</span> <span class="selector-class">.last</span> &#123;</span><br><span class="line">	<span class="attribute">border-right</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.icon-me</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.icon-hidden</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>至此一个自定义导航条就封装完成了，接下来就是在目标页面使用此组件就好了。</p>
<h2 id="使用导航条组件"><a href="#使用导航条组件" class="headerlink" title="使用导航条组件"></a>使用导航条组件</h2><p>先在使用页面的配置文件中引入组件<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"usingComponents": &#123;</span><br><span class="line">		"navbar": "/components/navBar/index",</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure></p>
<p>在.wxml文件中进行使用</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;navbar bind:selectTitle=<span class="string">"selectTitle"</span> goodsTitle=<span class="string">"&#123;&#123;goodsDetail&#125;&#125;"</span> playTitle=<span class="string">"&#123;&#123;playTitle&#125;&#125;"</span> currentIndex=<span class="string">"&#123;&#123;current&#125;&#125;"</span> showBgColor=<span class="string">"&#123;&#123;current===1||isBackShow||showNavTitle&#125;&#125;"</span> bgOpacityValue=<span class="string">"&#123;&#123;(current===1&amp;&amp;1)||opacityValue&#125;&#125;"</span> showBackHome=<span class="string">"&#123;&#123;showBackHome&#125;&#125;"</span> showPlayTab=<span class="string">"&#123;&#123; isShowPlayTab &#125;&#125;"</span>&gt;&lt;<span class="regexp">/navbar&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在js中写相应的逻辑。以上是组件的封装，然后就是对用户往下滚动的时候导航条的颜色渐变加深，往上滚动的时候颜色渐变消失。主要的实现思路是通过透明度实现的。具体如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动实现渐变色</span></span><br><span class="line">  handleScroll (e) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; scrollTop &#125; = e.detail</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.versionCompare(wx.getSystemInfoSync().SDKVersion, <span class="string">'2.5.2'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.data.current === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scrollTop &gt; <span class="number">6</span> &amp;&amp; scrollTop &lt; <span class="number">100</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            isBackShow: <span class="literal">true</span>,</span><br><span class="line">            opacityValue: scrollTop / <span class="number">100</span></span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">if</span> (scrollTop &gt; <span class="number">60</span>) &#123;</span><br><span class="line">            wx.setNavigationBarColor(&#123;</span><br><span class="line">              frontColor: <span class="string">'#ffffff'</span>,</span><br><span class="line">              backgroundColor: <span class="string">''</span>,</span><br><span class="line">              animation: &#123;</span><br><span class="line">                duration: <span class="number">400</span>,</span><br><span class="line">                timingFunc: <span class="string">'easeIn'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wx.setNavigationBarColor(&#123;</span><br><span class="line">              frontColor: <span class="string">'#000000'</span>,</span><br><span class="line">              backgroundColor: <span class="string">''</span>,</span><br><span class="line">              animation: &#123;</span><br><span class="line">                duration: <span class="number">400</span>,</span><br><span class="line">                timingFunc: <span class="string">'easeIn'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scrollTop &gt; <span class="number">100</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            isBackShow: <span class="literal">true</span>,</span><br><span class="line">            opacityValue: <span class="number">1</span></span><br><span class="line">          &#125;)</span><br><span class="line">          wx.setNavigationBarColor(&#123;</span><br><span class="line">            frontColor: <span class="string">'#ffffff'</span>,</span><br><span class="line">            backgroundColor: <span class="string">''</span>,</span><br><span class="line">            animation: &#123;</span><br><span class="line">              duration: <span class="number">400</span>,</span><br><span class="line">              timingFunc: <span class="string">'easeIn'</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            isBackShow: <span class="literal">false</span>,</span><br><span class="line">            opacityValue: <span class="number">0</span></span><br><span class="line">          &#125;)</span><br><span class="line">          wx.setNavigationBarColor(&#123;</span><br><span class="line">            frontColor: <span class="string">'#000000'</span>,</span><br><span class="line">            backgroundColor: <span class="string">''</span>,</span><br><span class="line"></span><br><span class="line">            animation: &#123;</span><br><span class="line">              duration: <span class="number">400</span>,</span><br><span class="line">              timingFunc: <span class="string">'easeIn'</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (scrollTop &gt; <span class="number">6</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            isBackShow: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            isBackShow: <span class="literal">false</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wx.setNavigationBarColor(&#123;</span><br><span class="line">        frontColor: <span class="string">'#ffffff'</span>,</span><br><span class="line">        backgroundColor: <span class="string">'#333333'</span>,</span><br><span class="line">        animation: &#123;</span><br><span class="line">          duration: <span class="number">400</span>,</span><br><span class="line">          timingFunc: <span class="string">'easeIn'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>各位看官，一次自定义导航踩坑已经结束，对于自己来说也是一次成长。如果对于你也有帮助的还请给个赞，谢谢大家。写的不好，如有问题请指正。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>自定义导航条</tag>
        <tag>滚动渐变</tag>
      </tags>
  </entry>
  <entry>
    <title>使用脚本上传tag</title>
    <url>/2020/08/24/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E4%B8%8A%E4%BC%A0tag/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="使用脚本上传创建-tag"><a href="#使用脚本上传创建-tag" class="headerlink" title="使用脚本上传创建 tag"></a>使用脚本上传创建 tag</h2><p>我们在创建 tag 时有两种方式，一种是在 gitlab 上进行创建提交，还有一种是在命令行通过 git 命令来进行提交。但是在实际开发中，发现操作的步骤比较繁琐和重复，故而思考使用 script 脚本来生成 tag，方便操作和提升效率。<a id="more"></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 拉取分支上现有的tags</span></span><br><span class="line"></span><br><span class="line">git fetch --tags</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"所有tag列表"</span></span><br><span class="line">git tag -l -n</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;tagList&#125;</span>"</span></span><br><span class="line"><span class="comment">#获取最新版本tag</span></span><br><span class="line">LatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"最新版本tag......"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$LatestTag</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"请输入要新增的版本号...... 如 v1.0.1"</span></span><br><span class="line"><span class="comment">#输入tag名称</span></span><br><span class="line"><span class="built_in">read</span> tagName</span><br><span class="line"></span><br><span class="line">git tag <span class="variable">$&#123;tagName&#125;</span></span><br><span class="line"><span class="comment">#推到分支上</span></span><br><span class="line">git push origin <span class="variable">$&#123;tagName&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后使用命令行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh ./tag.sh</span><br></pre></td></tr></table></figure>
<p>配置成 script 命令简化操作</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "tag": "sh ./tag.sh"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>执行命令按提示生成 tag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run tag</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>在小程序中实现多环境切换</title>
    <url>/2020/08/24/%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在前端开发中，我们的工程化体系中都是有多套服务环境的。比如本地开发、测试、生产（线上）这几种环境，这对应的是不同的服务地址。也许在以前我们会手动更改我们的服务地址，比如接口域名的更改。但是这样的人工操作不仅麻烦，而且还极容易出现错误。所以 web 项目中都有 script 脚本来更改环境配置，这里就让小程序也拥有配置多环境的能力。<a id="more"></a></p>
<h2 id="配置文件目录结构"><a href="#配置文件目录结构" class="headerlink" title="配置文件目录结构"></a>配置文件目录结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── config.js // 项目配置文件</span><br><span class="line">├── configs // 环境配置文件夹</span><br><span class="line">│   ├── common.config.js // 公共基础配置</span><br><span class="line">│   ├── dev.config.js // 开发环境配置</span><br><span class="line">│   ├── prd.config.js // 生产环境配置</span><br><span class="line">│   ├── script.js // 切换环境配置脚本文件</span><br><span class="line">│   └── test.config.js // 测试环境配置</span><br><span class="line">└── wxs // wxs配置文件夹</span><br><span class="line">    └── config.wxs // wxs配置文件</span><br></pre></td></tr></table></figure>
<h2 id="切换环境原理"><a href="#切换环境原理" class="headerlink" title="切换环境原理"></a>切换环境原理</h2><p>首先要使用脚本切换配置，就需要安装 node 环境。这点做过前端的开发就不用多说了。这里也是通过 script 脚本进行不同环境和文件配置的切换。在执行<code>node ./script</code>脚本的时候，通过改写项目的配置文件<code>config.js</code>来达到切换的效果。因为项目中使用的配置都是从<code>config.js</code>和<code>wxs/config.wxs</code>文件中导入的。</p>
<h2 id="文件基本配置代码展示"><a href="#文件基本配置代码展示" class="headerlink" title="文件基本配置代码展示"></a>文件基本配置代码展示</h2><ul>
<li>config.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*eslint-disable*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>项目配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口base路径</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> API_URL = <span class="string">'https://www.baidu.com'</span></span><br><span class="line"><span class="comment">// 运行环境</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> RUN_ENV = <span class="string">'test-release'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态图片地址</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IMAGE_URL = <span class="string">'https://www.baidu.com/static'</span></span><br><span class="line"><span class="comment">// 高德定位接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LOCATION_API = <span class="string">'https://www.amap.com/'</span></span><br><span class="line"><span class="comment">// 高德sdk秘钥</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AMAP_KEY = <span class="string">'12324324jjdjfojoejgj2e232323'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前版本（预发版本）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> APP_VERSION = <span class="string">'TEST'</span></span><br></pre></td></tr></table></figure>
<p>这个文件是项目的配置文件，提供对整体项目的配置。配置一些我们小程序需要使用的公共部分，我们在切换环境的时候也是切换这个配置文件。我们在使用的过程中可以根据自己的项目进行添加更改以达到自己项目的需求。</p>
<ul>
<li>configs/script.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入命令行颜色包</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'colors'</span>)</span><br><span class="line"><span class="comment">// node文件处理模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="comment">// node读取文件</span></span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">'readline'</span>)</span><br><span class="line"><span class="comment">// node环境获取</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">// 各环境配置文件的获取</span></span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./common.config'</span>)</span><br><span class="line"><span class="keyword">const</span> dev = <span class="built_in">require</span>(<span class="string">'./dev.config'</span>)</span><br><span class="line"><span class="keyword">const</span> prd = <span class="built_in">require</span>(<span class="string">'./prd.config'</span>)</span><br><span class="line"><span class="keyword">const</span> pre = <span class="built_in">require</span>(<span class="string">'./test.config'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rl = readline.createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 项目配置config.js文件路径</span></span><br><span class="line"><span class="keyword">const</span> OUTPUT = path.resolve(__dirname, <span class="string">'../config.js'</span>)</span><br><span class="line"><span class="comment">// 使用的wxs文件的配置路径</span></span><br><span class="line"><span class="keyword">const</span> OUTPUT_WXS = path.resolve(__dirname, <span class="string">'../wxs/config.wxs'</span>)</span><br><span class="line"><span class="comment">// 用require方式生成导出文件</span></span><br><span class="line"><span class="keyword">const</span> writeRequire = <span class="function">(<span class="params">path, obj</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.writeFileSync(path, <span class="string">'/*eslint-disable*/\n/**\n * @desc 项目配置文件 \n */ \n'</span>)</span><br><span class="line">  fs.appendFileSync(path, <span class="string">`\nmodule.exports = &#123;\n`</span>)</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> conf = obj[item]</span><br><span class="line">    fs.appendFileSync(path, <span class="string">`  // <span class="subst">$&#123;conf.title&#125;</span>\n`</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> conf.value === <span class="string">'string'</span>) &#123;</span><br><span class="line">      fs.appendFileSync(path, <span class="string">`  <span class="subst">$&#123;item&#125;</span>: '<span class="subst">$&#123;conf.value&#125;</span>',\n`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> conf.value === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (conf.value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        fs.appendFileSync(path, <span class="string">`  <span class="subst">$&#123;item&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(conf.value)&#125;</span>,\n`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fs.appendFileSync(path, <span class="string">`  <span class="subst">$&#123;item&#125;</span>: &#123;\n`</span>)</span><br><span class="line">        <span class="built_in">Object</span>.keys(conf.value).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">          fs.appendFileSync(path, <span class="string">`    '<span class="subst">$&#123;key&#125;</span>': '<span class="subst">$&#123;conf.value[key]&#125;</span>',\n`</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        fs.appendFileSync(path, <span class="string">`  &#125;,\n`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fs.appendFileSync(path, <span class="string">`  <span class="subst">$&#123;item&#125;</span>: <span class="subst">$&#123;conf.value&#125;</span>,\n`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  fs.appendFileSync(path, <span class="string">`&#125;\n`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用es6的模块进行导出文件  @isOverflow是否覆盖原文件</span></span><br><span class="line"><span class="keyword">const</span> writeExport = <span class="function">(<span class="params">path, obj, isOverflow = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  isOverflow &amp;&amp; fs.writeFileSync(path, <span class="string">'/*eslint-disable*/\n/**\n * @desc 项目配置文件 \n */ \n'</span>)</span><br><span class="line">  fs.appendFileSync(path, <span class="string">`\n`</span>)</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> conf = obj[item]</span><br><span class="line">    fs.appendFileSync(path, <span class="string">`// <span class="subst">$&#123;conf.title&#125;</span>\n`</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> conf.value === <span class="string">'string'</span>) &#123;</span><br><span class="line">      fs.appendFileSync(path, <span class="string">`export const <span class="subst">$&#123;item&#125;</span> = '<span class="subst">$&#123;conf.value&#125;</span>'\n`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> conf.value === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (conf.value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        fs.appendFileSync(path, <span class="string">`export const <span class="subst">$&#123;item&#125;</span> = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(conf.value)&#125;</span>\n`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fs.appendFileSync(path, <span class="string">`export const <span class="subst">$&#123;item&#125;</span> = &#123;\n`</span>)</span><br><span class="line">        <span class="built_in">Object</span>.keys(conf.value).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">          fs.appendFileSync(path, <span class="string">`  '<span class="subst">$&#123;key&#125;</span>': '<span class="subst">$&#123;conf.value[key]&#125;</span>',\n`</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        fs.appendFileSync(path, <span class="string">`&#125;\n`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fs.appendFileSync(path, <span class="string">`export const <span class="subst">$&#123;item&#125;</span> = <span class="subst">$&#123;conf.value&#125;</span>\n`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入配置文件到项目文件夹</span></span><br><span class="line"><span class="keyword">const</span> write = <span class="function">(<span class="params">obj, isOverflow = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  writeExport(OUTPUT, obj, isOverflow)</span><br><span class="line">  writeRequire(OUTPUT_WXS, obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染一个命令行文本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heredoc</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    fn</span><br><span class="line">      .toString()</span><br><span class="line">      .split(<span class="string">'\n'</span>)</span><br><span class="line">      .slice(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">      .join(<span class="string">'\n'</span>) + <span class="string">'\n'</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tmpl = heredoc(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ███████╗██╗    ██╗██╗████████╗ ██████╗██╗  ██╗     ██████╗ ██████╗ ███╗   ██╗███████╗██╗ ██████╗ ███████╗</span></span><br><span class="line"><span class="comment">  ██╔════╝██║    ██║██║╚══██╔══╝██╔════╝██║  ██║    ██╔════╝██╔═══██╗████╗  ██║██╔════╝██║██╔════╝ ██╔════╝</span></span><br><span class="line"><span class="comment">  ███████╗██║ █╗ ██║██║   ██║   ██║     ███████║    ██║     ██║   ██║██╔██╗ ██║█████╗  ██║██║  ███╗███████╗</span></span><br><span class="line"><span class="comment">  ╚════██║██║███╗██║██║   ██║   ██║     ██╔══██║    ██║     ██║   ██║██║╚██╗██║██╔══╝  ██║██║   ██║╚════██║</span></span><br><span class="line"><span class="comment">  ███████║╚███╔███╔╝██║   ██║   ╚██████╗██║  ██║    ╚██████╗╚██████╔╝██║ ╚████║██║     ██║╚██████╔╝███████║</span></span><br><span class="line"><span class="comment">  ╚══════╝ ╚══╝╚══╝ ╚═╝   ╚═╝    ╚═════╝╚═╝  ╚═╝     ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝     ╚═╝ ╚═════╝ ╚══════╝</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                      +----------------------------------------------------+</span></span><br><span class="line"><span class="comment">                      |                                                    |</span></span><br><span class="line"><span class="comment">                      |    切 换 环 境                                     |</span></span><br><span class="line"><span class="comment">                      |                                                    |</span></span><br><span class="line"><span class="comment">                      |    小 心 驶 得 万 年 船                            |</span></span><br><span class="line"><span class="comment">                      |                                                    |</span></span><br><span class="line"><span class="comment">                      |    马 虎 一 时 爽    生 死 两 茫 茫     (╥╯^╰╥)    |</span></span><br><span class="line"><span class="comment">                      |                                                    |</span></span><br><span class="line"><span class="comment">                      +----------------------------------------------------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// const setLanguage = (path) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   fs.appendFileSync(path, '\n\n// 语言设置 目前支持：zh_CN (简体中文)、en_US（英文版）')</span></span><br><span class="line"><span class="comment">//   fs.appendFileSync(path, '\nconst systemLanguage = wx.getSystemInfoSync().language || "zh_CN"')</span></span><br><span class="line"><span class="comment">//   fs.appendFileSync(path, '\nexport const APP_LANGUAGE = systemLanguage.indexOf("zh") !== -1 ? "zh_CN" : "en_US"')</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回不同环境的命令行颜色</span></span><br><span class="line"><span class="keyword">const</span> titleInfo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> data = fs.readFileSync(OUTPUT, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="keyword">var</span> index = data.indexOf(<span class="string">'export const RUN_ENV'</span>)</span><br><span class="line">  <span class="keyword">var</span> enviroment = data.slice(index + <span class="number">24</span>, data.indexOf(<span class="string">'\n'</span>, index) - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">var</span> info = heredoc(tmpl) + <span class="string">'                                    当前开发环境为:'</span> + enviroment + <span class="string">'\n\n\n\n\n'</span></span><br><span class="line">  <span class="keyword">if</span> (enviroment === <span class="string">'release'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> info.blue</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enviroment === <span class="string">'test-release'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> info.green</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enviroment === <span class="string">'develop'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> info.yellow</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行让用户自行选择环境</span></span><br><span class="line">rl.question(</span><br><span class="line">  titleInfo() +</span><br><span class="line">    <span class="string">'请输入需要切换的开发环境~  \n\n'</span> +</span><br><span class="line">    <span class="string">'-------------------------------------------------------------------------------------------- \n|'</span> +</span><br><span class="line">    <span class="string">' prd'</span>.blue +</span><br><span class="line">    <span class="string">' 生产 | '</span> +</span><br><span class="line">    <span class="string">'dev'</span>.yellow +</span><br><span class="line">    <span class="string">' 开发 | '</span> +</span><br><span class="line">    <span class="string">'test'</span>.green +</span><br><span class="line">    <span class="string">' 测试 |\n '</span> +</span><br><span class="line">    <span class="string">'-------------------------------------------------------------------------------------------- \n\nEnter: '</span>,</span><br><span class="line">  answer =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (answer) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'prd'</span>:</span><br><span class="line">        rl.question(<span class="string">'\n请输入要发布的版本号，格式类似于'</span> + <span class="string">'x.x.x'</span>.green + <span class="string">':\n\n'</span>, version =&gt; &#123;</span><br><span class="line">          <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'[1-9]+.[0-9]+.[0-9]*[0-9]$'</span>)</span><br><span class="line">          <span class="keyword">if</span> (reg.test(version)) &#123;</span><br><span class="line">            write(prd, <span class="literal">true</span>)</span><br><span class="line">            write(common, <span class="literal">false</span>)</span><br><span class="line">            fs.appendFileSync(OUTPUT, <span class="string">'\n// 当前版本'</span>)</span><br><span class="line">            fs.appendFileSync(OUTPUT, <span class="string">`\nexport const APP_VERSION = "<span class="subst">$&#123;version&#125;</span>"`</span>)</span><br><span class="line">            <span class="comment">// setLanguage(OUTPUT)</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'\n ~&gt; 🙂 '</span> + <span class="string">'生产环境 '</span>.green + <span class="string">'配置完成 '</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'\n ~&gt; 😈 '</span> + <span class="string">`切换失败，版本号(<span class="subst">$&#123;version&#125;</span>)输入有误`</span>.red)</span><br><span class="line">          &#125;</span><br><span class="line">          rl.close()</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'dev'</span>:</span><br><span class="line">        write(dev, <span class="literal">true</span>)</span><br><span class="line">        write(common, <span class="literal">false</span>)</span><br><span class="line">        fs.appendFileSync(OUTPUT, <span class="string">'\n// 当前版本（开发版本）'</span>)</span><br><span class="line">        fs.appendFileSync(OUTPUT, <span class="string">`\nexport const APP_VERSION = "DEV"`</span>)</span><br><span class="line">        <span class="comment">// setLanguage(OUTPUT)</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'\n ~&gt; 🙂 '</span> + <span class="string">'开发环境 '</span>.green + <span class="string">'配置完成（真机演示请打开调试）'</span>)</span><br><span class="line">        rl.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'test'</span>:</span><br><span class="line">        write(pre, <span class="literal">true</span>)</span><br><span class="line">        write(common, <span class="literal">false</span>)</span><br><span class="line">        fs.appendFileSync(OUTPUT, <span class="string">'\n// 当前版本（预发版本）'</span>)</span><br><span class="line">        fs.appendFileSync(OUTPUT, <span class="string">`\nexport const APP_VERSION = "TEST"`</span>)</span><br><span class="line">        <span class="comment">// setLanguage(OUTPUT)</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'\n ~&gt; 🙂 '</span> + <span class="string">'测试环境 '</span>.green + <span class="string">'配置完成 '</span>)</span><br><span class="line">        rl.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'\n ~&gt; 🙄 '</span> + <span class="string">'输入错误'</span>.red)</span><br><span class="line">        rl.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个脚本文件就是对配置文件根据用户的命令行输入条件进行输入对应的配置。</p>
<ul>
<li>configs/common.config.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  IMAGE_URL: &#123;</span><br><span class="line">    title: <span class="string">'静态图片地址'</span>,</span><br><span class="line">    value: <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  LOCATION_API: &#123;</span><br><span class="line">    title: <span class="string">'高德定位接口'</span>,</span><br><span class="line">    value: <span class="string">'https://www.amap.com'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  AMAP_KEY: &#123;</span><br><span class="line">    title: <span class="string">'高德sdk秘钥'</span>,</span><br><span class="line">    value: <span class="string">'12324324jjdjfojoejgj2e232323'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>configs/common.config.js</code>文件是多环境中的公共配置，就是多环境用的都是一样的东西就放在了这个文件中</p>
<ul>
<li>configs/dev.config.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  API_URL: &#123;</span><br><span class="line">    title: <span class="string">'接口base路径'</span>,</span><br><span class="line">    value: <span class="string">'http://dev.baidu.com'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  RUN_ENV: &#123;</span><br><span class="line">    title: <span class="string">'运行环境'</span>,</span><br><span class="line">    value: <span class="string">'develop'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>configs/dev.config.js</code>文件是开发环境下不一样的部分，比如接口的服务器域名</p>
<ul>
<li>configs/test.config.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  API_URL: &#123;</span><br><span class="line">    title: <span class="string">'接口base路径'</span>,</span><br><span class="line">    value: <span class="string">'http://test.baidu.com'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  RUN_ENV: &#123;</span><br><span class="line">    title: <span class="string">'运行环境'</span>,</span><br><span class="line">    value: <span class="string">'test-release'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>configs/test.config.js</code>文件是测试环境下不一样的部分，比如接口的服务器域名</p>
<ul>
<li>configs/prd.config.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  API_URL: &#123;</span><br><span class="line">    title: <span class="string">'接口base路径'</span>,</span><br><span class="line">    value: <span class="string">'http://prod.baidu.com'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  RUN_ENV: &#123;</span><br><span class="line">    title: <span class="string">'运行环境'</span>,</span><br><span class="line">    value: <span class="string">'release'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>configs/prd.config.js</code>文件是正式环境下不一样的部分，比如接口的服务器域名</p>
<ul>
<li>wxs/config.wxs</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*eslint-disable*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>项目配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 静态图片地址</span></span><br><span class="line">  IMAGE_URL: <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">  <span class="comment">// 高德定位接口</span></span><br><span class="line">  LOCATION_API: <span class="string">'https://www.amap.com'</span>,</span><br><span class="line">  <span class="comment">// 高德sdk秘钥</span></span><br><span class="line">  AMAP_KEY: <span class="string">'12324324jjdjfojoejgj2e232323'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wxs/config.wxs</code>文件是<code>wxs</code>的配置，主要是用于在<code>wxml</code>中使用<code>wxs</code>中的基础配置，比如在<code>wxml</code>中直接获取图片</p>
<h2 id="使用脚本命令快速执行脚本"><a href="#使用脚本命令快速执行脚本" class="headerlink" title="使用脚本命令快速执行脚本"></a>使用脚本命令快速执行脚本</h2><p>在项目包管理文件<code>package.json</code>中配置 script 脚本命令简化操作</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "config": "node ./configs/script.js",</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用如下命令进行运行环境的选择</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run config</span><br><span class="line"></span><br><span class="line">&gt; node ./configs/script.js</span><br><span class="line"></span><br><span class="line">  ███████╗██╗    ██╗██╗████████╗ ██████╗██╗  ██╗     ██████╗ ██████╗ ███╗   ██╗███████╗██╗ ██████╗ ███████╗</span><br><span class="line">  ██╔════╝██║    ██║██║╚══██╔══╝██╔════╝██║  ██║    ██╔════╝██╔═══██╗████╗  ██║██╔════╝██║██╔════╝ ██╔════╝</span><br><span class="line">  ███████╗██║ █╗ ██║██║   ██║   ██║     ███████║    ██║     ██║   ██║██╔██╗ ██║█████╗  ██║██║  ███╗███████╗</span><br><span class="line">  ╚════██║██║███╗██║██║   ██║   ██║     ██╔══██║    ██║     ██║   ██║██║╚██╗██║██╔══╝  ██║██║   ██║╚════██║</span><br><span class="line">  ███████║╚███╔███╔╝██║   ██║   ╚██████╗██║  ██║    ╚██████╗╚██████╔╝██║ ╚████║██║     ██║╚██████╔╝███████║</span><br><span class="line">  ╚══════╝ ╚══╝╚══╝ ╚═╝   ╚═╝    ╚═════╝╚═╝  ╚═╝     ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝     ╚═╝ ╚═════╝ ╚══════╝</span><br><span class="line"></span><br><span class="line">                      +----------------------------------------------------+</span><br><span class="line">                      |                                                    |</span><br><span class="line">                      |    切 换 环 境                                       |</span><br><span class="line">                      |                                                    |</span><br><span class="line">                      |    小 心 驶 得 万 年 船                              |</span><br><span class="line">                      |                                                    |</span><br><span class="line">                      |    马 虎 一 时 爽    生 死 两 茫 茫     (╥╯^╰╥)       |</span><br><span class="line">                      |                                                    |</span><br><span class="line">                      +----------------------------------------------------+</span><br><span class="line"></span><br><span class="line">                                    当前开发环境为:release</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">请输入需要切换的开发环境~</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">| prd 生产 | dev 开发 | <span class="built_in">test</span> 测试</span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">Enter: <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"> ~&gt; 🙂 测试环境 配置完成</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是多环境切换的简单使用，使用脚本化配置，最简单的好处就是不会忘记如何配置，直接执行命令就配置完成了。简化了手动操作，减少出错的几率，增加了开发效率。</p>
]]></content>
      <categories>
        <category>WEB 前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的六种继承</title>
    <url>/2020/08/11/JavaScript%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'water'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// water</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>缺点：</p>
<ul>
<li>引用类型的属性被所有实例共享</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [<span class="string">'water'</span>, <span class="string">'ice'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'fire'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names) <span class="comment">// ['water', 'ice', 'fire']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names) <span class="comment">// ['water', 'ice', 'fire']</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在创建 Child 的实例时，不能向 Parent 传参</li>
</ul>
<h2 id="借用构造函数-经典继承"><a href="#借用构造函数-经典继承" class="headerlink" title="借用构造函数(经典继承)"></a>借用构造函数(经典继承)</h2><p>复制父类构造函数内的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [<span class="string">'water'</span>, <span class="string">'ice'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line">child1.names.push(<span class="string">'fire'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1.names) <span class="comment">// ['water', 'ice', 'fire']</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.names) <span class="comment">// ['water', 'ice']</span></span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>避免了引用类型的属性被所有实例共享</li>
<li>可以在 Child 中向 Parent 传参</li>
</ul>
<p>缺点：</p>
<ul>
<li>只是子类的实例，不是父类的实例</li>
<li>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'water'</span>)</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'ice'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1.name) <span class="comment">// water</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.name) <span class="comment">// ice</span></span><br><span class="line"><span class="built_in">console</span>.log(child1 <span class="keyword">instanceof</span> Parent) <span class="comment">// false   不能识别是Parent的实例</span></span><br></pre></td></tr></table></figure>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>原型链继承和经典继承双剑合璧：组合原型链继承和借用构造函数继承<br>背后的思路是：使用原型链实现对原型方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name) <span class="comment">// 第二次调用 Parent</span></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent() <span class="comment">// 第一次调用Parent</span></span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'water'</span>, <span class="string">'20'</span>)</span><br><span class="line">child1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name) <span class="comment">// water</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors) <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'ice'</span>, <span class="string">'26'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name) <span class="comment">// ice</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age) <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors) <span class="comment">// ["red", "blue", "green"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1 <span class="keyword">instanceof</span> Child) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(child1 <span class="keyword">instanceof</span> Parent) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。<br>缺点：调用了两次父类构造函数（组合继承最大的问题是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部）</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="built_in">console</span>.log(o.__proto__ === <span class="built_in">Object</span>.prototype)</span><br><span class="line">  <span class="built_in">console</span>.log(F.prototype.constructor === <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'water'</span>,</span><br><span class="line">  friend: [<span class="string">'ice'</span>, <span class="string">'fire'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = CreateObj(person)</span><br><span class="line"><span class="keyword">var</span> person2 = CreateObj(person)</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'person1'</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name) <span class="comment">// xiaopao</span></span><br><span class="line">person1.friend.push(<span class="string">'joke'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person2.friend) <span class="comment">// ['ice', 'fire', 'joke']</span></span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123;name: "water", friend: Array(3)&#125;</span></span><br><span class="line">person1.friend = [<span class="string">'Tom'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(person1.friend) <span class="comment">// ['Tom']</span></span><br><span class="line"><span class="built_in">console</span>.log(person.friend) <span class="comment">//  ['ice', 'fire', 'joke']</span></span><br><span class="line"><span class="comment">// 注意： 这里修改了person1.name的值，person2.name的值并未改变，并不是因为person1和person2有独立的name值，而是person1.name='person1'是给person1添加了name值，并非修改了原型上的name值</span></span><br><span class="line"><span class="comment">// 因为我们找对象上的属性时，总是先找实例上对象，没有找到的话再去原型对象上的属性。实例对象和原型对象上如果有同名属性，总是先取实例对象上的值</span></span><br></pre></td></tr></table></figure>
<p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p>
<p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。<br>注意： 这里修改了 person1.name 的值，person2.name 的值并未改变，并不是因为 person1 和 person2 有独立的 name 值，而是 person1.name=’person1’是给 person1 添加了 name 值，并非修改了原型上的 name 值。<br>因为我们找对象上的属性时，总是先找实例上对象，没有找到的话再去原型对象上的属性。实例对象和原型对象上如果有同名属性，总是先取实例对象上的值</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。可以理解为在原型式继承的基础上新增一些函数或属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寄生式继承  可以理解为在原型式继承的基础上增加一些函数或属性</span></span><br><span class="line"><span class="keyword">var</span> ob = &#123;</span><br><span class="line">  name: <span class="string">'water'</span>,</span><br><span class="line">  friends: [<span class="string">'ice'</span>, <span class="string">'fire'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 创建一个构造函数F</span></span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面CreateObj函数 在ECMAScript5 有了一新的规范写法，Object.create(ob) 效果是一样的 , 看下面代码</span></span><br><span class="line"><span class="keyword">var</span> ob1 = CreateObj(ob)</span><br><span class="line"><span class="keyword">var</span> ob2 = <span class="built_in">Object</span>.create(ob)</span><br><span class="line"><span class="built_in">console</span>.log(ob1.name) <span class="comment">// water</span></span><br><span class="line"><span class="built_in">console</span>.log(ob2.name) <span class="comment">// water</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateOb</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newob = CreateObj(o) <span class="comment">// 创建对象 或者用 var newob = Object.create(ob)</span></span><br><span class="line">  newob.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 增强对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newob <span class="comment">// 指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = CreateOb(ob)</span><br><span class="line">p1.sayName() <span class="comment">// water</span></span><br></pre></td></tr></table></figure>
<p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>子类构造函数复制父类的自身属性和方法，子类原型只接收父类的原型属性和方法</p>
<blockquote>
<p>所谓寄生组合继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型的原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给予类型的原型。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'water'</span>, <span class="string">'20'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure>
<p>组合继承最大的缺点是会调用两次父构造函数。</p>
<ul>
<li>设置子类型实例的原型的时候：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br></pre></td></tr></table></figure>
<ul>
<li>在创建子类型实例的时候：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'water'</span>, <span class="string">'20'</span>)</span><br></pre></td></tr></table></figure>
<p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Parent.call(<span class="keyword">this</span>, name)</span><br></pre></td></tr></table></figure>
<p>在这里，我们又会调用了一次 Parent 构造函数。所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为 colors，属性值为[‘red’, ‘blue’, ‘green’]。那么我们该如何精益求精，避免这一次重复调用呢？如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？看看如何实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="comment">// var F = function() &#123;&#125;</span></span><br><span class="line"><span class="comment">// F.prototype = Parent.prototype</span></span><br><span class="line"><span class="comment">// Child.prototype = new F()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.prototype = new Parent(); // 这里换成下面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = CreateObj(parent.prototype)</span><br><span class="line">  prototype.constructor = child</span><br><span class="line">  child.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line">prototype(Child, Parent)</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'water'</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构——链表</title>
    <url>/2020/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>链表也是线性表的一种，相比于数组，链表是一种稍微复杂点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，我们常常将会放到一块儿来比较。所以我们先来看，这两者有什么区别。<a id="more"></a></p>
<ul>
<li>从内存的存储结构来看<ul>
<li>数组在存储的时候，需要在内存中开辟一块连续的内存空间。比如一个数组需要 10M 的内存空间，如果一个计算机恰好就剩下 10M 且是连续的空间，那这个数组数据刚好可以存进去。但是如果不是连续的 10M 那就会存储失败。</li>
<li>链表在存储的时候，对是否是连续的存储空间并没有要求，因为链表是通过指针或者引用将不连续的内存空间链接起来。所以只要是空间足够就总能存储成功。</li>
</ul>
</li>
</ul>
<p>我们了解了链表的基本结构之后，简单介绍下比较常用的链表：单链表、双向链表、循环链表。</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作后继指针 next。</p>
<p>在但链表中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中头结点用来记录链表的基地址。有了它我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。与数组一样，链表也支持数据的查找、插入和删除操作。</p>
<p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 $O(n)$ 。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以在链表中插入和删除一个数据是非常快速的。<br>针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是$O(1)$。</p>
<p>但是，有利就有弊。链表要想随机访问第 i 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p>
<p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 i 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以链表随机访问的性能没有数组好，需要$O(n)$的时间复杂度。</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表是一种特殊的单链表。它跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。它像一个环一样首尾相连，所以叫作“循环”链表。</p>
<p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>单链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表支持两个方向，每个结点不仅有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？</p>
<ul>
<li>从结构上来看，双向链表可以支持 O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</li>
</ul>
<ul>
<li><p>删除操作。在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p>
<ol>
<li><p>删除结点中“值等于某个给定值”的结点；</p>
</li>
<li><p>删除给定指针指向的结点。</p>
</li>
</ol>
</li>
</ul>
<p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过指针操作将其删除。尽管单纯的删除操作时间复杂度是$O(1)$ ，但遍历查找的时间是主要的耗时点，对应的时间复杂度为$O(n)$。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为$O(n)$。</p>
<p>对于第二种情况，已经找到了要删除的结点，但是删除某个结点 b 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 a-&gt;next=b ，说明 a 是 b 的前驱结点。但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以针对第二种情况，单链表删除操作需要$O(n)$的时间复杂度，而双向链表只需要在$O(1)$的时间复杂度内就搞定了。同理如果在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在$O(1)$时间复杂度搞定，而单向链表需要$O(n)$的时间复杂度。除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为可以记录上次查找的位置 a，每次查询时，根据要查找的值与 a 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛。实际上这里有一个更加重要的知识点，那就是用空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p>
<h2 id="数组和链表的性能分析"><a href="#数组和链表的性能分析" class="headerlink" title="数组和链表的性能分析"></a>数组和链表的性能分析</h2><ul>
<li>复杂度</li>
</ul>
<ol>
<li>数组的插入是 O(n)时间复杂度，随机访问是 O(1)复杂度</li>
<li>链表的插入是 O(1)时间复杂度，随机访问是 O(n)复杂度</li>
</ol>
<p>数组和链表的对比，并不能局限于时间复杂度。而且在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（ out of memory ）” 。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-数组</title>
    <url>/2020/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起数组，大家肯定都是在熟悉不过了。我们在开发过程中，不管是使用的什么语言，肯定都使用过数组。平常我们都知道数组是一种数据类型，其实数组也是一种基本的数据结构。当数组作为数据结构来理解的时候，可能不太熟悉了。这里作为自己学习的笔记记录下数组这个数据结构的基本概念和应用。<a id="more"></a></p>
<h2 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h2><p>数组可能我们都知道是什么，比如 js 中的[1,2,3]就是一个数组，但是这是一个数据类型，这里说下数组数据结构的定义：数组是一种线性表数据结构，它用一组连续的内存空间来存储一组具有相同类型的数据。</p>
<h2 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表"></a>什么是线性表</h2><p>线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。当然除了数组是线性表结构，与数组线性表相同结构的还有栈、队列、链表。除了有线性表结构，还有非线性表结构。比如：树、堆、图，之所以是非线性的，是因为数据不是前后线性连接的关系。</p>
<h2 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h2><ol>
<li>首先数组是一个连续的内存空间和相同类型的数据，因为有这两个特点，所以数组支持随机访问，效率非常高。但是因为有这两个特点，也就导致了数组数据结构数据的插入、删除变得非常的低效。因为有连续性的要求，有很多数据的移动操作影响性能。</li>
<li>数组是可以根据下标随机访问数据的，这个是什么原理呢？大概的原因就是：当定义一个数组时，计算机会在内存中分配一个空间用来存储数据。然后在这个分配的空间中进而切割更小的内存单元，用来存储数组中的每一个数据。每个存储单元对应一个内存地址，当需要随机访问某一个元素的时候，就通过这个地址来进行查询。</li>
<li>数组和链表的区别：</li>
</ol>
<ul>
<li>数组支持随机访问，并且根据下标访问的时间复杂度是$O(1)$，不适合插入和删除。</li>
<li>链表适合插入和删除，时间复杂度是$O(1)$，不适合查找。</li>
</ul>
<h2 id="为什么数组的插入和删除比较低效"><a href="#为什么数组的插入和删除比较低效" class="headerlink" title="为什么数组的插入和删除比较低效"></a>为什么数组的插入和删除比较低效</h2><p>前面我们提到，数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。现在我们就来详细说一下，究竟为什么会导致低效？</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>假设数组的长度为 n ，现在如果我们需要将一个数据插入到数组中的第 i 个位置。为了把第 i 个位置腾出来，给新来的数据，我们需要将第 i ～ n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 $O(1)$ 。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是$O(n)$。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 $(1+2+…n)/n=O(n)$ 。 如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 i 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 i 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将 第 i 位的数据搬移到数组元素的最后，把新的元素直接放入第 i 个位置。利用这种处理技巧，在特定场景下，在第 i 个位置插入一个元素的时间复杂度就会降为$O(1)$。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>跟插入数据类似，如果我们要删除第 i 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 $O(1)$ ；如果删除开头的数据，则最坏情况时间复杂度为 $O(n)$ ；平均情况时间复杂度也为 $O(n)$ 实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率会提高很多</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法初探-复杂度分析</title>
    <url>/2020/07/29/%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>相信有很多小伙伴都知道数据结构和算法，也都看过学过数据结构和算法。当然我也不例外，准备入坑了，感受下程序的奥妙。在我们学习编写数据结构和算法之前，我们应该先学会如何去分析和总结一个算法的优缺点。这时我们会用到数据结构和算法的复杂度分析（时间复杂度、空间复杂度），通过这个复杂度的分析来初略的估计一个算法的好坏。<a id="more"></a></p>
<h2 id="什么是复杂度"><a href="#什么是复杂度" class="headerlink" title="什么是复杂度"></a>什么是复杂度</h2><ol>
<li>复杂度分为时间复杂度和空间复杂度，是评估数据结构与算法性能的两个维度（时间和空间）。</li>
<li>复杂度是用来描述算法的运行时间或者是占用的空间与数据规模之家的一种增长关系的趋势。</li>
<li>数据结构和算法是让代码更好的利用计算的空间和运行起来更快，提高代码的运行效率。</li>
</ol>
<h2 id="为什么要用复杂度分析来估算一个算法的好坏"><a href="#为什么要用复杂度分析来估算一个算法的好坏" class="headerlink" title="为什么要用复杂度分析来估算一个算法的好坏"></a>为什么要用复杂度分析来估算一个算法的好坏</h2><p>在开发中，我们也许做过有时想知道一段代码的执行时间，比如一个接口的请求时间。我们通常会用记录开始和结束的两个时间点来进行计算得到代码的运行时间，这样我们也达到了估算一段代码运行效率的效果。有时也会通过统计监控机制去得到算法的运行时间和占用内存的大小。那可能就有人问了我们为什么要这个复杂度的分析？其实主要有以下原因：</p>
<ol>
<li>一段代码在不同的机器上运行，所需要的时间不一样，受限于硬件的影响</li>
<li>一段代码的运行还受到数据多少的影响，就拿循环来说，数据越多需要的时间越多</li>
</ol>
<p>所以，我们要估算一个算法的好坏应该去除这些影响因素，大 O 复杂度表示法就登场了，就是用来粗略表示数据结构和算法好坏的一种方式。</p>
<h2 id="什么是大-O-表示法"><a href="#什么是大-O-表示法" class="headerlink" title="什么是大 O 表示法"></a>什么是大 O 表示法</h2><p>其实就是一个复杂度表示的方法，或者可以说是一种增长关系。因为运行每一行代码都需要一定的时间，我们可以粗略的给定一个固定值，可以知道算法执行的时间和每行代码执行的时间成正比用公式可以简单表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(n) = O(f(n))</span><br></pre></td></tr></table></figure>
<p>其中 T(n)表示算法的总运行时间，f(n)表示每行代码执行的时间，所以总的时间受到 n 的影响。由于复杂度表示的是一种增长变化的趋势所以对于常量、低阶以及系数等不产生决定性影响的可以忽略，所以在做复杂度分析的时候可以忽略掉一部分数据。</p>
<h2 id="时间复杂度分析和常见的种类"><a href="#时间复杂度分析和常见的种类" class="headerlink" title="时间复杂度分析和常见的种类"></a>时间复杂度分析和常见的种类</h2><h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><ol>
<li>只关注运行次数最多的一段代码。比如一个循环假设为 n，那么这行代码就执行了 n 次那么就可以粗略算做时间复杂度为 O(n)</li>
<li>如果有多段代码耗时，可以以最大的耗时作为时间复杂度，因为最耗时的代码都执行完了，那耗时少的肯定也执行完了。比如一段代码循环 n 次，另一段代码嵌套循环 n 次，那两段代码的时间复杂度就是 O(n)和$O(n^2)$,所以总体的时间复杂度就是$O(n^2)$</li>
<li>如果有嵌套的代码，那时间复杂度可以以乘积来表示，比如嵌套的循环都为 n 次，那总体的复杂度就是$O(n^2)$</li>
</ol>
<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><ol>
<li>常量阶（O(1)）</li>
<li>对数阶（O(logn)）</li>
<li>线性阶（O(n)）</li>
<li>线性对数阶（O(long)）</li>
<li>平方阶（$O(n^2)$）</li>
<li>立方阶（$O(n^3)$）</li>
<li>n 次方阶（$O(n^n)$）</li>
<li>指数阶（$O(2^n)$）</li>
<li>阶乘阶（O(!n)）</li>
</ol>
<h4 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h4><p>这个表示的是常量阶，并不是一行代码执行的时间复杂度，如果有 3 行代码执行，那么它的时间复杂度还是 O(1)而不是 O(3)。时间复杂度的一种表示方法,总体来说就是如果代码运行的时间不受数据大小 n 的影响那时间复杂度就是 O(1)。</p>
<h4 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h4><p>如果一个循环 n 次，每次是 i*2。那么 i 的值就是 2 的次方幂，只要算出 2 的次方数，那就是这个循环的复杂度，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以粗略算出$k=log_2n$,所以就是 O(logn)的时间复杂度。O(nlogn)的复杂度就是复杂度为 O(logn)的代码执行了 n 遍，就得到了这个 O(nlogn)复杂度。</p>
<h4 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h4><p>如果有两段代码分别执行，我们能判断出哪个耗时长那就直接取最长的时间为复杂度，但是有时两段代码我们不能确定谁耗时长，所以就不能简单以长的为准那就可以用 O(m+n)来表示其复杂度。如果为嵌套执行的话时间复杂度还是 O(m*n)</p>
<h3 id="常见的空间复杂度"><a href="#常见的空间复杂度" class="headerlink" title="常见的空间复杂度"></a>常见的空间复杂度</h3><p>空间复杂度是表示占用计算机内存空间的表示，如果定义一个常量，那就是 O(1)的空间复杂度。常见的有：</p>
<ol>
<li>O(1)</li>
<li>O(n)</li>
<li>$O(n^2)$</li>
</ol>
<p>像 O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总体而言基本可以用以上方法进行简单的分析，得到我们代码的复杂度。复杂度从低到高：从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、$O(n^2)$,我们只有掌握了复杂度的分析才能大概判断一个算法的优劣，有助于我们优化代码的性能</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序中前端生成海报图片</title>
    <url>/2020/07/27/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90%E6%B5%B7%E6%8A%A5%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>一般在促销活动中，都会有一个活动海报进行宣传。有时候的海报是针对产品的，那么分享出去的海报是实时更新的。这里就以前端拿到相应的数据然后进行图片的绘制然后在进行分享，简单记录下代码的实现。<a id="more"></a></p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul>
<li><p>在 wxml 中放一个 canvas 的承载标签 imgCanvas</p>
</li>
<li><p>在海报的分享中，改变的部分大多数是产品信息和二维码，这里我们可以吧绘制图片写成一个方法函数然后需要的数据以参数的方式传递进来。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setCanvasImage</span>(<span class="params">productInfo, qrCode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 具体的业务实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>更具需求获取到海报的元信息，比如：背景图、商品图、logo 图、市场价、活动价等，然后对海报的样式进行绘制</li>
<li>首先我们先从参数中获取到我们的元信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; productName, url, price, marketPrice, logo &#125; = productInfo</span><br></pre></td></tr></table></figure>
<ul>
<li><p>图片获取的是一个 url，我们在绘制海报的时候，需要把图片下载下来，然后才能进行绘制，因为图片获取的接口是个异步行为，我们用 promise 进行封装，获取图片完成之后才能进行绘制。</p>
</li>
<li><p>封装了一个单位转换函数,因为样式是基于px的</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">rpxToPx</span>(<span class="params">data = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return (data / 750 * wx.getSystemInfoSync().windowWidth)</span></span><br><span class="line">  <span class="keyword">return</span> (data * wx.getSystemInfoSync().windowWidth) / <span class="number">750</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取背景图片</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bgImgPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  wx.downloadFile(&#123;</span><br><span class="line">    url: <span class="string">'https://xxxx.com/a.jpg'</span>,</span><br><span class="line">    success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(res.tempFilePath)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>获取产品图片</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prdImgPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  wx.getImageInfo(&#123;</span><br><span class="line">    src: url,</span><br><span class="line">    success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>获取品牌 logo 图</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logoImgPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  wx.downloadFile(&#123;</span><br><span class="line">    url: logo,</span><br><span class="line">    success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(res.tempFilePath)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>获取二维码信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于数据是base64所以是一下方法如果是url可以使用上面获取图片的方式拿到图片</span></span><br><span class="line"><span class="keyword">const</span> qrImgPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [, format, bodyData] = <span class="regexp">/data:image\/(\w+);base64,(.*)/</span>.exec(qrCode) || []</span><br><span class="line">  <span class="keyword">if</span> (format) &#123;</span><br><span class="line">    <span class="keyword">const</span> filePath = <span class="string">`<span class="subst">$&#123;wx.env.USER_DATA_PATH&#125;</span>/<span class="subst">$&#123;productInfo.productId&#125;</span>.png`</span></span><br><span class="line">    <span class="keyword">const</span> fileManager = wx.getFileSystemManager()</span><br><span class="line">    fileManager.writeFile(&#123;</span><br><span class="line">      filePath,</span><br><span class="line">      data: bodyData,</span><br><span class="line">      encoding: <span class="string">'base64'</span>,</span><br><span class="line">      success: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(filePath)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'xxxxxxxxx'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来就是在画布上对获取的元素进行拼图和美化操作了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  Promise.all([bgImgPromise, prdImgPromise, logoImgPromise, qrImgPromise])</span><br><span class="line">    .then(results =&gt; &#123;</span><br><span class="line">      const context = wx.createCanvasContext(&apos;imgCanvas&apos;)</span><br><span class="line">      // 背景图片</span><br><span class="line">      context.drawImage(results[0], 0, 0, rpxToPx(750), rpxToPx(1334))</span><br><span class="line"></span><br><span class="line">      // 产品图片 做了兼容处理，修改样式api可以查看官方文档</span><br><span class="line">      const &#123; width, height, path &#125; = results[1]</span><br><span class="line">      if (width === height) &#123;</span><br><span class="line">        // 产品图片：宽度等于高度</span><br><span class="line">        context.drawImage(path, rpxToPx(80), rpxToPx(100), rpxToPx(590), rpxToPx(590))</span><br><span class="line">      &#125; else if (width &gt; height) &#123;</span><br><span class="line">        // 产品图片：宽度大于高度</span><br><span class="line">        const hwScale = height / width // 高宽比</span><br><span class="line">        context.drawImage(path, rpxToPx(80), rpxToPx(100 + (590 * (1 - hwScale)) / 2), rpxToPx(590), rpxToPx(590 * hwScale))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 产品图片：宽度小于高度</span><br><span class="line">        const whScale = width / height // 高宽比</span><br><span class="line">        context.drawImage(path, rpxToPx(80 + (590 * (1 - whScale)) / 2), rpxToPx(100), rpxToPx(590 * whScale), rpxToPx(590))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 产品名称</span><br><span class="line">      context.setFontSize(rpxToPx(30))</span><br><span class="line">      context.setTextBaseline(&apos;top&apos;)</span><br><span class="line">      context.setFillStyle(&apos;rgba(0, 0, 0, 0.9)&apos;)</span><br><span class="line">      let productNameDrawY = rpxToPx(730) // 绘制文本的y坐标</span><br><span class="line">      const productNameMaxWidth = rpxToPx(570) // 绘制文本最大宽度</span><br><span class="line">      const productNameLineHeight = rpxToPx(40) // 产品名称单行高度</span><br><span class="line">      let productNameDrawTxt = &apos;&apos; // 当前绘制的内容</span><br><span class="line">      let productNameDrawIndex = 0 // 当前绘制内容的索引</span><br><span class="line">      let productNameLineNum = 1 // 产品名称展示行数</span><br><span class="line">      if (context.measureText(productName).width &lt;= productNameMaxWidth) &#123;</span><br><span class="line">        // 单行绘制</span><br><span class="line">        context.fillText(productName, rpxToPx(80), productNameDrawY)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 多行绘制</span><br><span class="line">        for (var i = 0; i &lt; productName.length; i++) &#123;</span><br><span class="line">          productNameDrawTxt += productName[i]</span><br><span class="line">          if (context.measureText(productNameDrawTxt).width &gt;= productNameMaxWidth) &#123;</span><br><span class="line">            context.fillText(productName.substring(productNameDrawIndex, i + 1), rpxToPx(80), productNameDrawY)</span><br><span class="line">            productNameDrawIndex = i + 1</span><br><span class="line">            productNameDrawY += productNameLineHeight</span><br><span class="line">            productNameDrawTxt = &apos;&apos;</span><br><span class="line">            productNameLineNum += 1</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            if (i === productName.length - 1) &#123;</span><br><span class="line">              // 剩下不足 maxWidth 内容的绘制</span><br><span class="line">              context.fillText(productName.substring(productNameDrawIndex), rpxToPx(80), productNameDrawY)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 拼团价整数部分</span><br><span class="line">      const showPriceInt = `￥$&#123;Math.floor(price / 100)&#125;`</span><br><span class="line">      context.setFontSize(rpxToPx(50))</span><br><span class="line">      context.setFillStyle(&apos;#f5770a&apos;)</span><br><span class="line">      context.setTextBaseline(&apos;normal&apos;)</span><br><span class="line">      context.fillText(showPriceInt, rpxToPx(70), rpxToPx(795 - 0.5) + productNameLineHeight * productNameLineNum)</span><br><span class="line">      context.fillText(showPriceInt, rpxToPx(70 - 0.5), rpxToPx(795) + productNameLineHeight * productNameLineNum)</span><br><span class="line">      context.fillText(showPriceInt, rpxToPx(70), rpxToPx(795) + productNameLineHeight * productNameLineNum)</span><br><span class="line"></span><br><span class="line">      // 拼团价小数部分</span><br><span class="line">      const showPriceIntWidth = context.measureText(showPriceInt).width</span><br><span class="line">      const decimal = price % 100</span><br><span class="line">      const showPriceDecimal = decimal &gt; 9 ? `.$&#123;decimal&#125;` : `.0$&#123;decimal&#125;`</span><br><span class="line">      context.setFontSize(rpxToPx(40))</span><br><span class="line">      context.setFillStyle(&apos;#f5770a&apos;)</span><br><span class="line">      context.setTextBaseline(&apos;normal&apos;)</span><br><span class="line">      context.fillText(showPriceDecimal, rpxToPx(70) + showPriceIntWidth, rpxToPx(795 - 0.5) + productNameLineHeight * productNameLineNum)</span><br><span class="line">      context.fillText(showPriceDecimal, rpxToPx(70 - 0.5) + showPriceIntWidth, rpxToPx(795) + productNameLineHeight * productNameLineNum)</span><br><span class="line">      context.fillText(showPriceDecimal, rpxToPx(70) + showPriceIntWidth, rpxToPx(795) + productNameLineHeight * productNameLineNum)</span><br><span class="line"></span><br><span class="line">      // 拼团价标识背景</span><br><span class="line">      const showPriceDecimalWidth = context.measureText(showPriceDecimal).width</span><br><span class="line">      context.setFillStyle(&apos;#f5770a&apos;)</span><br><span class="line">      context.fillRect(</span><br><span class="line">        rpxToPx(80) + showPriceIntWidth + showPriceDecimalWidth,</span><br><span class="line">        rpxToPx(765) + productNameLineHeight * productNameLineNum,</span><br><span class="line">        rpxToPx(88),</span><br><span class="line">        rpxToPx(30)</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      // 拼团价标识</span><br><span class="line">      context.setFontSize(rpxToPx(22))</span><br><span class="line">      context.setTextBaseline(&apos;top&apos;)</span><br><span class="line">      context.setFillStyle(&apos;rgba(255, 255, 255, 0.9)&apos;)</span><br><span class="line">      context.fillText(&apos;拼团价&apos;, rpxToPx(91) + showPriceIntWidth + showPriceDecimalWidth, rpxToPx(766) + productNameLineHeight * productNameLineNum)</span><br><span class="line"></span><br><span class="line">      // 市场价</span><br><span class="line">      const showMarketPrice = `￥$&#123;Number(marketPrice / 100).toFixed(2)&#125;`</span><br><span class="line">      context.setFontSize(rpxToPx(26))</span><br><span class="line">      context.setTextBaseline(&apos;top&apos;)</span><br><span class="line">      context.setFillStyle(&apos;rgba(0, 0, 0, 0.6)&apos;)</span><br><span class="line">      context.fillText(showMarketPrice, rpxToPx(80), rpxToPx(816) + productNameLineHeight * productNameLineNum)</span><br><span class="line"></span><br><span class="line">      // 市场价删除线</span><br><span class="line">      const showMarketPriceWidth = context.measureText(showMarketPrice).width</span><br><span class="line">      context.beginPath()</span><br><span class="line">      context.moveTo(rpxToPx(80), rpxToPx(830) + productNameLineHeight * productNameLineNum)</span><br><span class="line">      context.lineTo(rpxToPx(80) + showMarketPriceWidth, rpxToPx(830) + productNameLineHeight * productNameLineNum)</span><br><span class="line">      context.setStrokeStyle(&apos;rgba(0, 0, 0, 0.6)&apos;)</span><br><span class="line">      context.stroke()</span><br><span class="line"></span><br><span class="line">      // 扫描/长按识别</span><br><span class="line">      context.setFontSize(rpxToPx(40))</span><br><span class="line">      context.setTextBaseline(&apos;top&apos;)</span><br><span class="line">      context.setFillStyle(&apos;rgba(0, 0, 0, 0.9)&apos;)</span><br><span class="line">      // 由于api没有加粗效果的，故用叠加达到加粗效果</span><br><span class="line">      context.fillText(&apos;扫描/长按识别&apos;, rpxToPx(60), rpxToPx(1137 - 0.5))</span><br><span class="line">      context.fillText(&apos;扫描/长按识别&apos;, rpxToPx(60 - 0.5), rpxToPx(1137))</span><br><span class="line">      context.fillText(&apos;扫描/长按识别&apos;, rpxToPx(60), rpxToPx(1137))</span><br><span class="line"></span><br><span class="line">      // 即刻参与拼团</span><br><span class="line">      context.setFontSize(rpxToPx(26))</span><br><span class="line">      context.setTextBaseline(&apos;top&apos;)</span><br><span class="line">      context.setFillStyle(&apos;rgba(0, 0, 0, 0.6)&apos;)</span><br><span class="line">      context.fillText(&apos;即刻参与拼团&apos;, rpxToPx(60), rpxToPx(1195))</span><br><span class="line"></span><br><span class="line">      // 品牌log和二维码</span><br><span class="line">      context.drawImage(results[2], rpxToPx(380), rpxToPx(1129), rpxToPx(100), rpxToPx(100))</span><br><span class="line">      context.drawImage(results[3], rpxToPx(515), rpxToPx(1099), rpxToPx(160), rpxToPx(160))</span><br><span class="line"></span><br><span class="line">      context.draw(true, res =&gt; &#123;</span><br><span class="line">        if (res.errMsg === &apos;drawCanvas:ok&apos;) &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            wx.canvasToTempFilePath(&#123;</span><br><span class="line">              canvasId: &apos;imgCanvas&apos;,</span><br><span class="line">              success: result =&gt; &#123;</span><br><span class="line">                // 图片生成成功，删除本地二维码文件</span><br><span class="line">                const filePath = `$&#123;wx.env.USER_DATA_PATH&#125;/$&#123;productInfo.productId&#125;.png`</span><br><span class="line">                const fileManager = wx.getFileSystemManager()</span><br><span class="line">                fileManager.unlinkSync(filePath)</span><br><span class="line">                // 返回图片临时路径</span><br><span class="line">                resolve(result.tempFilePath)</span><br><span class="line">              &#125;,</span><br><span class="line">              fail: err =&gt; &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;, 100)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          reject(res.errMsg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>整体实现一个分享海报的图片就上面这几步，可能根据具体的业务有相应的修改，但大体的步骤没有变化，代码有注释，不清楚的可以看下注释因该就懂了，贴上完整代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 拼团海报</span><br><span class="line"> * @param &#123;产品信息&#125; productInfo</span><br><span class="line"> * @param &#123;二维码&#125; qrCode</span><br><span class="line"> */</span><br><span class="line">export function setCanvasImage(productInfo, qrCode) &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    productName, // 产品名称</span><br><span class="line">    url, // 产品图片</span><br><span class="line">    price, //</span><br><span class="line">    marketPrice,</span><br><span class="line">    logo,</span><br><span class="line">  &#125; = productInfo</span><br><span class="line">  // 背景图片</span><br><span class="line">  const bgImgPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    wx.downloadFile(&#123;</span><br><span class="line">      url: &apos;https://g.wopuwulian.com/zpk/assets/static/img_assemble_share_b.jpg&apos;,</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        resolve(res.tempFilePath)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: err =&gt; &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  // 产品图片</span><br><span class="line">  const prdImgPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    wx.getImageInfo(&#123;</span><br><span class="line">      src: url,</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: err =&gt; &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  // 品牌logo图片</span><br><span class="line">  const logoImgPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    wx.downloadFile(&#123;</span><br><span class="line">      url: logo,</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        resolve(res.tempFilePath)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: err =&gt; &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  // 二维码图片</span><br><span class="line">  const qrImgPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const [, format, bodyData] = /data:image\/(\w+);base64,(.*)/.exec(qrCode) || []</span><br><span class="line">    if (format) &#123;</span><br><span class="line">      const filePath = `$&#123;wx.env.USER_DATA_PATH&#125;/$&#123;productInfo.productId&#125;.png`</span><br><span class="line">      const fileManager = wx.getFileSystemManager()</span><br><span class="line">      fileManager.writeFile(&#123;</span><br><span class="line">        filePath,</span><br><span class="line">        data: bodyData,</span><br><span class="line">        encoding: &apos;base64&apos;,</span><br><span class="line">        success: () =&gt; &#123;</span><br><span class="line">          resolve(filePath)</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: err =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return new Error(&apos;xxxxxxxxx&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    Promise.all([bgImgPromise, prdImgPromise, logoImgPromise, qrImgPromise])</span><br><span class="line">      .then(results =&gt; &#123;</span><br><span class="line">        const context = wx.createCanvasContext(&apos;imgCanvas&apos;)</span><br><span class="line">        // 背景图片</span><br><span class="line">        context.drawImage(results[0], 0, 0, rpxToPx(750), rpxToPx(1334))</span><br><span class="line"></span><br><span class="line">        // 产品图片</span><br><span class="line">        const &#123; width, height, path &#125; = results[1]</span><br><span class="line">        if (width === height) &#123;</span><br><span class="line">          // 产品图片：宽度等于高度</span><br><span class="line">          context.drawImage(path, rpxToPx(80), rpxToPx(100), rpxToPx(590), rpxToPx(590))</span><br><span class="line">        &#125; else if (width &gt; height) &#123;</span><br><span class="line">          // 产品图片：宽度大于高度</span><br><span class="line">          const hwScale = height / width // 高宽比</span><br><span class="line">          context.drawImage(path, rpxToPx(80), rpxToPx(100 + (590 * (1 - hwScale)) / 2), rpxToPx(590), rpxToPx(590 * hwScale))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 产品图片：宽度小于高度</span><br><span class="line">          const whScale = width / height // 高宽比</span><br><span class="line">          context.drawImage(path, rpxToPx(80 + (590 * (1 - whScale)) / 2), rpxToPx(100), rpxToPx(590 * whScale), rpxToPx(590))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 产品名称</span><br><span class="line">        context.setFontSize(rpxToPx(30))</span><br><span class="line">        context.setTextBaseline(&apos;top&apos;)</span><br><span class="line">        context.setFillStyle(&apos;rgba(0, 0, 0, 0.9)&apos;)</span><br><span class="line">        let productNameDrawY = rpxToPx(730) // 绘制文本的y坐标</span><br><span class="line">        const productNameMaxWidth = rpxToPx(570) // 绘制文本最大宽度</span><br><span class="line">        const productNameLineHeight = rpxToPx(40) // 产品名称单行高度</span><br><span class="line">        let productNameDrawTxt = &apos;&apos; // 当前绘制的内容</span><br><span class="line">        let productNameDrawIndex = 0 // 当前绘制内容的索引</span><br><span class="line">        let productNameLineNum = 1 // 产品名称展示行数</span><br><span class="line">        if (context.measureText(productName).width &lt;= productNameMaxWidth) &#123;</span><br><span class="line">          // 单行绘制</span><br><span class="line">          context.fillText(productName, rpxToPx(80), productNameDrawY)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 多行绘制</span><br><span class="line">          for (var i = 0; i &lt; productName.length; i++) &#123;</span><br><span class="line">            productNameDrawTxt += productName[i]</span><br><span class="line">            if (context.measureText(productNameDrawTxt).width &gt;= productNameMaxWidth) &#123;</span><br><span class="line">              context.fillText(productName.substring(productNameDrawIndex, i + 1), rpxToPx(80), productNameDrawY)</span><br><span class="line">              productNameDrawIndex = i + 1</span><br><span class="line">              productNameDrawY += productNameLineHeight</span><br><span class="line">              productNameDrawTxt = &apos;&apos;</span><br><span class="line">              productNameLineNum += 1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              if (i === productName.length - 1) &#123;</span><br><span class="line">                // 剩下不足 maxWidth 内容的绘制</span><br><span class="line">                context.fillText(productName.substring(productNameDrawIndex), rpxToPx(80), productNameDrawY)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 拼团价整数部分</span><br><span class="line">        const showPriceInt = `￥$&#123;Math.floor(price / 100)&#125;`</span><br><span class="line">        context.setFontSize(rpxToPx(50))</span><br><span class="line">        context.setFillStyle(&apos;#f5770a&apos;)</span><br><span class="line">        context.setTextBaseline(&apos;normal&apos;)</span><br><span class="line">        context.fillText(showPriceInt, rpxToPx(70), rpxToPx(795 - 0.5) + productNameLineHeight * productNameLineNum)</span><br><span class="line">        context.fillText(showPriceInt, rpxToPx(70 - 0.5), rpxToPx(795) + productNameLineHeight * productNameLineNum)</span><br><span class="line">        context.fillText(showPriceInt, rpxToPx(70), rpxToPx(795) + productNameLineHeight * productNameLineNum)</span><br><span class="line"></span><br><span class="line">        // 拼团价小数部分</span><br><span class="line">        const showPriceIntWidth = context.measureText(showPriceInt).width</span><br><span class="line">        const decimal = price % 100</span><br><span class="line">        const showPriceDecimal = decimal &gt; 9 ? `.$&#123;decimal&#125;` : `.0$&#123;decimal&#125;`</span><br><span class="line">        context.setFontSize(rpxToPx(40))</span><br><span class="line">        context.setFillStyle(&apos;#f5770a&apos;)</span><br><span class="line">        context.setTextBaseline(&apos;normal&apos;)</span><br><span class="line">        context.fillText(showPriceDecimal, rpxToPx(70) + showPriceIntWidth, rpxToPx(795 - 0.5) + productNameLineHeight * productNameLineNum)</span><br><span class="line">        context.fillText(showPriceDecimal, rpxToPx(70 - 0.5) + showPriceIntWidth, rpxToPx(795) + productNameLineHeight * productNameLineNum)</span><br><span class="line">        context.fillText(showPriceDecimal, rpxToPx(70) + showPriceIntWidth, rpxToPx(795) + productNameLineHeight * productNameLineNum)</span><br><span class="line"></span><br><span class="line">        // 拼团价标识背景</span><br><span class="line">        const showPriceDecimalWidth = context.measureText(showPriceDecimal).width</span><br><span class="line">        context.setFillStyle(&apos;#f5770a&apos;)</span><br><span class="line">        context.fillRect(</span><br><span class="line">          rpxToPx(80) + showPriceIntWidth + showPriceDecimalWidth,</span><br><span class="line">          rpxToPx(765) + productNameLineHeight * productNameLineNum,</span><br><span class="line">          rpxToPx(88),</span><br><span class="line">          rpxToPx(30)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // 拼团价标识</span><br><span class="line">        context.setFontSize(rpxToPx(22))</span><br><span class="line">        context.setTextBaseline(&apos;top&apos;)</span><br><span class="line">        context.setFillStyle(&apos;rgba(255, 255, 255, 0.9)&apos;)</span><br><span class="line">        context.fillText(&apos;拼团价&apos;, rpxToPx(91) + showPriceIntWidth + showPriceDecimalWidth, rpxToPx(766) + productNameLineHeight * productNameLineNum)</span><br><span class="line"></span><br><span class="line">        // 市场价</span><br><span class="line">        const showMarketPrice = `￥$&#123;Number(marketPrice / 100).toFixed(2)&#125;`</span><br><span class="line">        context.setFontSize(rpxToPx(26))</span><br><span class="line">        context.setTextBaseline(&apos;top&apos;)</span><br><span class="line">        context.setFillStyle(&apos;rgba(0, 0, 0, 0.6)&apos;)</span><br><span class="line">        context.fillText(showMarketPrice, rpxToPx(80), rpxToPx(816) + productNameLineHeight * productNameLineNum)</span><br><span class="line"></span><br><span class="line">        // 市场价删除线</span><br><span class="line">        const showMarketPriceWidth = context.measureText(showMarketPrice).width</span><br><span class="line">        context.beginPath()</span><br><span class="line">        context.moveTo(rpxToPx(80), rpxToPx(830) + productNameLineHeight * productNameLineNum)</span><br><span class="line">        context.lineTo(rpxToPx(80) + showMarketPriceWidth, rpxToPx(830) + productNameLineHeight * productNameLineNum)</span><br><span class="line">        context.setStrokeStyle(&apos;rgba(0, 0, 0, 0.6)&apos;)</span><br><span class="line">        context.stroke()</span><br><span class="line"></span><br><span class="line">        // 扫描/长按识别</span><br><span class="line">        context.setFontSize(rpxToPx(40))</span><br><span class="line">        context.setTextBaseline(&apos;top&apos;)</span><br><span class="line">        context.setFillStyle(&apos;rgba(0, 0, 0, 0.9)&apos;)</span><br><span class="line">        // 由于api没有加粗效果的，故用叠加达到加粗效果</span><br><span class="line">        context.fillText(&apos;扫描/长按识别&apos;, rpxToPx(60), rpxToPx(1137 - 0.5))</span><br><span class="line">        context.fillText(&apos;扫描/长按识别&apos;, rpxToPx(60 - 0.5), rpxToPx(1137))</span><br><span class="line">        context.fillText(&apos;扫描/长按识别&apos;, rpxToPx(60), rpxToPx(1137))</span><br><span class="line"></span><br><span class="line">        // 即刻参与拼团</span><br><span class="line">        context.setFontSize(rpxToPx(26))</span><br><span class="line">        context.setTextBaseline(&apos;top&apos;)</span><br><span class="line">        context.setFillStyle(&apos;rgba(0, 0, 0, 0.6)&apos;)</span><br><span class="line">        context.fillText(&apos;即刻参与拼团&apos;, rpxToPx(60), rpxToPx(1195))</span><br><span class="line"></span><br><span class="line">        // 品牌logo和二维码</span><br><span class="line">        context.drawImage(results[2], rpxToPx(380), rpxToPx(1129), rpxToPx(100), rpxToPx(100))</span><br><span class="line">        context.drawImage(results[3], rpxToPx(515), rpxToPx(1099), rpxToPx(160), rpxToPx(160))</span><br><span class="line"></span><br><span class="line">        context.draw(true, res =&gt; &#123;</span><br><span class="line">          if (res.errMsg === &apos;drawCanvas:ok&apos;) &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              wx.canvasToTempFilePath(&#123;</span><br><span class="line">                canvasId: &apos;imgCanvas&apos;,</span><br><span class="line">                success: result =&gt; &#123;</span><br><span class="line">                  // 图片生成成功，删除本地二维码文件</span><br><span class="line">                  const filePath = `$&#123;wx.env.USER_DATA_PATH&#125;/$&#123;productInfo.productId&#125;.png`</span><br><span class="line">                  const fileManager = wx.getFileSystemManager()</span><br><span class="line">                  fileManager.unlinkSync(filePath)</span><br><span class="line">                  // 返回图片临时路径</span><br><span class="line">                  resolve(result.tempFilePath)</span><br><span class="line">                &#125;,</span><br><span class="line">                fail: err =&gt; &#123;</span><br><span class="line">                  reject(err)</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;, 100)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            reject(res.errMsg)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(err =&gt; &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>你需要知道的javascript中的编码与解码</title>
    <url>/2020/06/18/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84javascript%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 web 开发中，我们经常会和我网站 url 打交道。当我们跳转到一个其他网站的时候，也是通过 url 来进行跳转的。有时我们需要对 url 进行处理，例如拼接参数等。在一次开发中，我直接拿后台返回的 url 进行拼接参数，然后居然出错了。最后查到是因为 url 经过了转译编码，然后前端没有显示的进行解码操作，所以 url 地址是不正确的，由此用到了编码和解码，记录下自己踩过的坑。<a id="more"></a></p>
<h2 id="编码：encodeURIComponent-和解码：decodeURIComponent"><a href="#编码：encodeURIComponent-和解码：decodeURIComponent" class="headerlink" title="编码：encodeURIComponent()和解码：decodeURIComponent()"></a>编码：encodeURIComponent()和解码：decodeURIComponent()</h2><ol>
<li>encodeURIComponent()<br>encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。<br>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。<br>其他字符（比如 ：;/?:@&amp;=+\$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。<br>简单点就是能转的都给转了，例子如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">'http://www.baidu.com?name=Tom&amp;age=12&amp;city=杭州'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri))</span><br><span class="line"><span class="comment">//输出 'http%3A%2F%2Fwww.baidu.com%3Fname%3DTom%26age%3D12%26city%3D%E6%9D%AD%E5%B7%9E'</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>decodeURIComponent()是对 encodeURIComponent()编码的解码操作，把转译成正常的 url 链接</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urlCode = <span class="string">'http%3A%2F%2Fwww.baidu.com%3Fname%3DTom%26age%3D12%26city%3D%E6%9D%AD%E5%B7%9E'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(urlCode))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 'http://www.baidu.com?name=Tom&amp;age=12&amp;city=杭州'</span></span><br></pre></td></tr></table></figure>
<h2 id="编码：encodeURI-和解码：decodeURI"><a href="#编码：encodeURI-和解码：decodeURI" class="headerlink" title="编码：encodeURI()和解码：decodeURI()"></a>编码：encodeURI()和解码：decodeURI()</h2><ol>
<li>encodeURI()<br>encodeURI() 函数可把字符串作为 URI 进行编码。<br>对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的： , / ? : @ &amp; = + \$ # (可以使用 encodeURIComponent() 方法分别对特殊含义的 ASCII 标点符号进行编码。).</li>
</ol>
<p>简单点就是对 url 进行部分转译，例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://www.baidu.com?name=Tom&amp;age=12&amp;city=杭州'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(url))</span><br><span class="line"><span class="comment">//输出 'http://www.baidu.com?name=Tom&amp;age=12&amp;city=%E6%9D%AD%E5%B7%9E'</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>decodeURI 是 encodeURI 编码的 URI 进行解码</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urlCode = <span class="string">'http://www.baidu.com?name=Tom&amp;age=12&amp;city=%E6%9D%AD%E5%B7%9E'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(urlCode))</span><br><span class="line"><span class="comment">//输出 'http://www.baidu.com?name=Tom&amp;age=12&amp;city=杭州'</span></span><br></pre></td></tr></table></figure>
<h2 id="编码：escape-和解码：unescape"><a href="#编码：escape-和解码：unescape" class="headerlink" title="编码：escape()和解码：unescape()"></a>编码：escape()和解码：unescape()</h2><ol>
<li><p>escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . / 。其他所有的字符都会被转义序列替换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.baidu.com?name=Tom&amp;age=12&amp;city=杭州"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">escape</span>(str))</span><br><span class="line"><span class="comment">//输出 'http%3A//www.baidu.com%3Fname%3DTom%26age%3D12%26city%3D%u676D%u5DDE'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"爱我中华"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">escape</span>(str))</span><br><span class="line"><span class="comment">//输出 '%u7231%u6211%u4E2D%u534E'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>unescape()函数是对escape()编码的进行解码（备注：ECMAScript v3 已从标准中删除了 unescape() 函数，并反对使用它，因此应该用 decodeURI() 和 decodeURIComponent() 取而代之）</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"http%3A//www.baidu.com%3Fname%3DTom%26age%3D12%26city%3D%u676D%u5DDE"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">unescape</span>(str))</span><br><span class="line"><span class="comment">//输出 'http://www.baidu.com?name=Tom&amp;age=12&amp;city=杭州'</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"%u7231%u6211%u4E2D%u534E"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">unescape</span>(str))</span><br><span class="line"><span class="comment">//输出 '爱我中华'</span></span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果是对url整个进行编码解码就使用：encodeURIComponent()、decodeURIComponent()</p>
<p>如果是对url的参数进行编码解码就使用：encodeURI()、decodeURI()</p>
<p>如果是对字符串进行编码解码就使用：unescape()函数是对escape()，unescape()已被废弃请使用最新api</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>全局方法</tag>
      </tags>
  </entry>
  <entry>
    <title>taro接入友盟埋点统计</title>
    <url>/2020/06/16/taro%E6%8E%A5%E5%85%A5%E5%8F%8B%E7%9B%9F%E5%9F%8B%E7%82%B9%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们在做软件程序的时候，有时需要知道一些功能有多少人用。就拿微信小程序来举例子，我们关注的就是小程序的使用人数、小程序打开人数、小程序的每个页面的访问量等，我就需要对小程序进行埋点操作。这里我使用的是第三方的埋点服务<a href="https://www.umeng.com/" rel="external nofollow noopener noreferrer" target="_blank">友盟</a>，这里就记录下 taro 集成友盟的方式。<a id="more"></a></p>
<h3 id="注册友盟账号"><a href="#注册友盟账号" class="headerlink" title="注册友盟账号"></a>注册友盟账号</h3><p>去友盟的官网注册个账号，用这个账号登录到管理控制台</p>
<h3 id="创建服务应用进行-Appkey-申请"><a href="#创建服务应用进行-Appkey-申请" class="headerlink" title="创建服务应用进行 Appkey 申请"></a>创建服务应用进行 Appkey 申请</h3><p>选择创建小程序应用，填写需要埋点的小程序需要的信息进行申请</p>
<h3 id="配置域名白名单"><a href="#配置域名白名单" class="headerlink" title="配置域名白名单"></a>配置域名白名单</h3><p>把友盟的域名添加到小程序的开发服务域名中<code>umini.shujupie.com</code></p>
<h3 id="安装-sdk"><a href="#安装-sdk" class="headerlink" title="安装 sdk"></a>安装 sdk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 支付宝小程序sdk</span><br><span class="line">npm install umtrack-alipay --save</span><br><span class="line">// 微信小程序sdk</span><br><span class="line">npm install umtrack-wx --save</span><br></pre></td></tr></table></figure>
<h3 id="集成-sdk"><a href="#集成-sdk" class="headerlink" title="集成 sdk"></a>集成 sdk</h3><ol>
<li>但文件利用环境变量进行区分集成 <code>sdk</code><br>在 <code>src/app.jsx</code> 中进行集成</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uma = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'weapp'</span>) &#123;</span><br><span class="line">  uma = <span class="built_in">require</span>(<span class="string">'umtrack-wx'</span>)</span><br><span class="line">  uma.init(&#123;</span><br><span class="line">    appKey: <span class="string">'YOUR_APP_KEY'</span>,</span><br><span class="line">    useOpenid: <span class="literal">false</span>,</span><br><span class="line">    autoGetOpenid: <span class="literal">false</span>,</span><br><span class="line">    debug: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'alipay'</span>) &#123;</span><br><span class="line">  uma = <span class="built_in">require</span>(<span class="string">'umtrack-alipay'</span>)</span><br><span class="line">  uma.init(&#123;</span><br><span class="line">    appKey: <span class="string">'YOUR_APP_KEY'</span>,</span><br><span class="line">    debug: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把uma 添加到Taro，后续通过Taro.uma调用uma方法 ,es6模块导入的是模块引用，</span></span><br><span class="line"><span class="comment">//因此放心注入，后面页面导入Taro模块是可以获取uma的</span></span><br><span class="line"><span class="keyword">import</span> Taro, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line">Taro.uma = uma</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>利用跨平台文件进行集成<br><code>src/uma/index.weapp.js</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uma <span class="keyword">from</span> <span class="string">'umtrack-wx'</span></span><br><span class="line"></span><br><span class="line">uma.init(&#123;</span><br><span class="line">  appKey: <span class="string">'YOUR_APP_KEY'</span>,</span><br><span class="line">  useOpenid: <span class="literal">false</span>,</span><br><span class="line">  autoGetOpenid: <span class="literal">false</span>,</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> uma</span><br></pre></td></tr></table></figure>
<p><code>src/uma/index.alipay.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uma <span class="keyword">from</span> <span class="string">'umtrack-alipay'</span></span><br><span class="line"></span><br><span class="line">uma.init(&#123;</span><br><span class="line">  appKey: <span class="string">'YOUR_APP_KEY'</span>,</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> uma</span><br></pre></td></tr></table></figure>
<p>两种方法调用 uma 模块: 1.在其他页面中直接 <code>import uma from &#39;path/to/uma&#39;</code> 2.或者同单文件集成，在 <code>app.jsx</code>中注入 <code>uma</code> 到 <code>Taro</code><br><code>app.jsx</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uma <span class="keyword">from</span> <span class="string">'./uma'</span></span><br><span class="line"><span class="keyword">import</span> Taro, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line">Taro.uma = uma</span><br></pre></td></tr></table></figure>
<h3 id="自定义事件点"><a href="#自定义事件点" class="headerlink" title="自定义事件点"></a>自定义事件点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidShow () &#123;</span><br><span class="line">    Taro.uma.trackEvent(<span class="string">'eventID'</span>, &#123;</span><br><span class="line">      name: <span class="string">'taro'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>无论哪种集成方式，在 <code>app.jsx</code> 文件中 <code>uma</code> 模块的导入一定要在 <code>Taro</code> 的导入之前，如 <code>eslint</code> 出现提示，建议关掉 <code>app.jsx</code> 文件的相关 <code>eslint</code> 检查，一般是关于 <code>import</code> 前置 或 绝对路径模块要先于相对模块的 <code>eslint</code> 提示。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>大前端</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>uni-app接入友盟埋点统计</title>
    <url>/2020/06/16/uni-app%E6%8E%A5%E5%85%A5%E5%8F%8B%E7%9B%9F%E5%9F%8B%E7%82%B9%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们在做软件程序的时候，有时需要知道一些功能有多少人用。就拿微信小程序来举例子，我们关注的就是小程序的使用人数、小程序打开人数、小程序的每个页面的访问量等，我就需要对小程序进行埋点操作。这里我使用的是第三方的埋点服务<a href="https://www.umeng.com/" rel="external nofollow noopener noreferrer" target="_blank">友盟</a>，这里就记录下 uni-app 集成友盟的方式。<a id="more"></a></p>
<h3 id="注册友盟账号"><a href="#注册友盟账号" class="headerlink" title="注册友盟账号"></a>注册友盟账号</h3><p>去友盟的官网注册个账号，用这个账号登录到管理控制台</p>
<h3 id="创建服务应用进行-Appkey-申请"><a href="#创建服务应用进行-Appkey-申请" class="headerlink" title="创建服务应用进行 Appkey 申请"></a>创建服务应用进行 Appkey 申请</h3><p>选择创建小程序应用，填写需要埋点的小程序需要的信息进行申请</p>
<h3 id="配置域名白名单"><a href="#配置域名白名单" class="headerlink" title="配置域名白名单"></a>配置域名白名单</h3><p>把友盟的域名添加到小程序的开发服务域名中<code>umini.shujupie.com</code></p>
<h3 id="安装-sdk"><a href="#安装-sdk" class="headerlink" title="安装 sdk"></a>安装 sdk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 支付宝小程序sdk</span><br><span class="line">npm install umtrack-alipay --save</span><br><span class="line">// 微信小程序sdk</span><br><span class="line">npm install umtrack-wx --save</span><br></pre></td></tr></table></figure>
<h3 id="利用条件编译集成-sdk"><a href="#利用条件编译集成-sdk" class="headerlink" title="利用条件编译集成 sdk"></a>利用条件编译集成 sdk</h3><p>在 main.js 中进行集成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #ifdef MP-WEIXIN</span></span><br><span class="line"><span class="keyword">import</span> uma <span class="keyword">from</span> <span class="string">'umtrack-wx'</span></span><br><span class="line">uma.init(&#123;</span><br><span class="line">  appKey: <span class="string">'xxxx'</span>,</span><br><span class="line">  useOpenid: <span class="literal">false</span>,</span><br><span class="line">  autoGetOpenid: <span class="literal">false</span>,</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"><span class="comment">// #ifdef MP-ALIPAY</span></span><br><span class="line"><span class="keyword">import</span> uma <span class="keyword">from</span> <span class="string">'umtrack-alipay'</span></span><br><span class="line">uma.init(&#123;</span><br><span class="line">  appKey: <span class="string">'xxxx'</span>,</span><br><span class="line">  debug: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.uma = uma || &#123;&#125; <span class="comment">// 此处用来挂载入uma到组件实例上，方便组件内使用this.uma</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">App.mpType = <span class="string">'app'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...App,</span><br><span class="line">&#125;)</span><br><span class="line">app.$mount()</span><br></pre></td></tr></table></figure>
<h3 id="自定义事件点"><a href="#自定义事件点" class="headerlink" title="自定义事件点"></a>自定义事件点</h3><p><code>/pages/index/index/vue</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onLoad()&#123;</span><br><span class="line">  <span class="keyword">this</span>.uma.trackEvent(<span class="string">'eventID'</span>,&#123;<span class="attr">title</span>:<span class="string">'uni-app'</span>&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="sdk-集成位置尽量靠前"><a href="#sdk-集成位置尽量靠前" class="headerlink" title="sdk 集成位置尽量靠前"></a>sdk 集成位置尽量靠前</h3>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>前端</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>react + typeScriprt使用技巧</title>
    <url>/2020/06/16/react-typeScriprt%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h3><h4 id="1-文件顶部的注释，包括描述、作者、日期"><a href="#1-文件顶部的注释，包括描述、作者、日期" class="headerlink" title="(1) 文件顶部的注释，包括描述、作者、日期"></a>(1) 文件顶部的注释，包括描述、作者、日期</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description xxxxxx</span><br><span class="line"> * @author chengfeng</span><br><span class="line"> * @since 19/05/21</span><br><span class="line"> */</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2-模块的注释"><a href="#2-模块的注释" class="headerlink" title="(2) 模块的注释"></a>(2) 模块的注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 拷贝数据</span><br><span class="line"> * @param  &#123;*&#125;  data   要拷贝的源数据</span><br><span class="line"> * @param  &#123;boolean&#125; [isDeep=false] 是否深拷贝，默认浅拷贝</span><br><span class="line"> * @return &#123;*&#125;         返回拷贝后的数据</span><br><span class="line"> */</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="3-业务代码注释"><a href="#3-业务代码注释" class="headerlink" title="(3) 业务代码注释"></a>(3) 业务代码注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*业务代码注释*/</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="4-变量注释"><a href="#4-变量注释" class="headerlink" title="(4) 变量注释"></a>(4) 变量注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  // 名字</span><br><span class="line">  name: string;</span><br><span class="line">  // 电话</span><br><span class="line">  phone: number;</span><br><span class="line">  // 地址</span><br><span class="line">  address: string;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="2-引用组件顺序"><a href="#2-引用组件顺序" class="headerlink" title="2. 引用组件顺序"></a>2. 引用组件顺序</h3><ul>
<li>先引用外部组件库,,再引用当前组件块级组件, 然后是 common 里的公共函数库最后是 css 样式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import &#123; Dropdown, Menu, Icon &#125; from &apos;antd&apos;;</span><br><span class="line">import Header from &apos;./Header&apos;;</span><br><span class="line">import toast from &apos;common/toast&apos;;</span><br><span class="line">import &apos;./index.less&apos;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="3-引号"><a href="#3-引号" class="headerlink" title="3. 引号"></a>3. 引号</h3><ul>
<li>使用单引号,或者 es6 的反引号</li>
</ul>
<h3 id="4-缩进"><a href="#4-缩进" class="headerlink" title="4. 缩进"></a>4. 缩进</h3><ul>
<li>使用两个空格</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const handleCheck = () =&gt; &#123;</span><br><span class="line">  onCancel &amp;&amp; onCancel();</span><br><span class="line">  onClose &amp;&amp; onClose();</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="5-分号"><a href="#5-分号" class="headerlink" title="5. 分号"></a>5. 分号</h3><ul>
<li>除了代码块的以外的每个表达式后必须加分号。</li>
</ul>
<h3 id="6-括号"><a href="#6-括号" class="headerlink" title="6. 括号"></a>6. 括号</h3><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// not good</span><br><span class="line">if (condition) doSomething();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (condition) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="7-空格"><a href="#7-空格" class="headerlink" title="7. 空格"></a>7. 空格</h3><ul>
<li>二元和三元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">++ x;</span><br><span class="line">y ++;</span><br><span class="line">z = x?1:2;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">++x;</span><br><span class="line">y++;</span><br><span class="line">z = x ? 1 : 2;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>用作代码块起始的左花括号 { 前必须有一个空格。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (condition)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (condition)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function funcName()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function funcName() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if(condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(function() &#123;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">&#125;)();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a : 1,</span><br><span class="line">    b:2,</span><br><span class="line">    c :3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="8-换行"><a href="#8-换行" class="headerlink" title="8. 换行"></a>8. 换行</h3><ul>
<li>每个独立语句结束后必须换行。</li>
<li>在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 1</span><br><span class="line">    , b: 2</span><br><span class="line">    , c: 3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function test()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">for (const key in object)</span><br><span class="line"> &#123;</span><br><span class="line">  if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">    const element = object[key];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (const key in object) &#123;</span><br><span class="line">  if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">    const element = object[key];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>下列关键字后：else, catch, finally 不需要换行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (condition) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">catch (e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (condition) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="9-数组、对象"><a href="#9-数组、对象" class="headerlink" title="9. 数组、对象"></a>9. 数组、对象</h3><ul>
<li>对象属性名不需要加引号；</li>
<li>对象以缩进的形式书写，不要写在一行；</li>
<li>数组最后不要有逗号。</li>
<li>对象最后要有逗号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const a = &#123;</span><br><span class="line">    &apos;b&apos;: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const a = &#123;b: 1&#125;;</span><br><span class="line"></span><br><span class="line">const a = &#123;</span><br><span class="line">    b: 1,</span><br><span class="line">    c: 2</span><br><span class="line">&#125;;</span><br><span class="line">const arr = [1, 2, 3, 4,];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const a = &#123;</span><br><span class="line">    b: 1,</span><br><span class="line">    c: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const arr = [1, 2, 3, 4];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="10-命名"><a href="#10-命名" class="headerlink" title="10. 命名"></a>10. 命名</h3><ul>
<li>类名: 大驼峰式风格，字母和数字，例如：AbcTest。禁止汉字、特殊符号，禁止非大驼峰式风格。</li>
<li>函数名: 小驼峰式风格，字母和数字，例如：abcTest。禁止汉字、特殊符号，禁止非小驼峰式风格，例如snake_case等。</li>
<li>变量名: 同函数名。</li>
<li>常量: 全大写风格，大写字母、数字和下划线，单词之间以下划线分隔，例如：ABC_TEST。禁止汉字、特殊符号、小写字母。</li>
<li>使用 onXxx 形式作为 props 中用于回调的属性名称。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  onClose?: () =&gt; void;</span><br><span class="line">  onOk?: (item: Record&lt;string, any&gt;) =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>组件内的事件函数使用 handle 开头尾,handleCheckBtn。</li>
<li>使用 withXxx 形式的词作为高阶组件的名称。</li>
<li>接口命名前面带上 I 表示 interface</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IProps &#123;&#125;</span><br><span class="line">interface IState &#123;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="11-类型断言"><a href="#11-类型断言" class="headerlink" title="11. 类型断言"></a>11. 类型断言</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,22): error TS2339: Property &apos;length&apos; does not exist on type &apos;string | number&apos;.</span><br><span class="line">//   Property &apos;length&apos; does not exist on type &apos;number&apos;.</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123;</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">  if (typeof something === &apos;string&apos;) &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return something.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="12-interface声明顺序"><a href="#12-interface声明顺序" class="headerlink" title="12. interface声明顺序"></a>12. interface声明顺序</h3><p>日常用到比较多的是四种，只读参数放第一位，必选参数第二位，可选参数次之，不确定参数放最后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface iProps &#123;</span><br><span class="line">  readonly x: number;</span><br><span class="line">  readonly y: number;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  height?: number;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="13-ts好用的相关工具泛型"><a href="#13-ts好用的相关工具泛型" class="headerlink" title="13. ts好用的相关工具泛型"></a>13. ts好用的相关工具泛型</h3><ul>
<li>Record&lt;string,any&gt; 用这个来声明对象结构的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用于定义一个javascript的对象，key是字符串，value是任意类型</span><br><span class="line">const people:Record&lt;string,any&gt; = &#123;</span><br><span class="line">    name: &apos;chengfeng&apos;,</span><br><span class="line">    age: 10</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>Partial 作用是将传入的属性变为可选项.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface iPeople &#123;</span><br><span class="line">    title: string;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const people: Partial&lt;iPeople&gt; = &#123;</span><br><span class="line">    title: &apos;Delete inactive users&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">定义的结构可以是接口iPeople的任意key</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>Readonly 作用是将传入的属性变为变成只读</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface iPeople &#123;</span><br><span class="line">    title: string;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const people: Readonly&lt;Todo&gt; = &#123;</span><br><span class="line">    title: &apos;todo list&apos;,</span><br><span class="line">    name: chenfeng;</span><br><span class="line">&#125;;</span><br><span class="line">title name属性就是只读的了</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>Required 的作用是将传入的属性变为必选项</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface iPeople &#123;</span><br><span class="line">    title?: string;</span><br><span class="line">    name?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const people1: Props = &#123; title: &apos;ts&apos; &#125;; // OK</span><br><span class="line"></span><br><span class="line">const people22: Required&lt;iPeople&gt; = &#123; title: &apos;ts&apos; &#125;; // Error: property &apos;name&apos; missing</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Microsoft/TypeScript-Handbook/diffs/0?base_sha=22b37a2d8c9a1dd378795444baf954c2e7ecccf5&amp;commentable=true&amp;head_user=csantos42&amp;pull_number=801&amp;sha1=22b37a2d8c9a1dd378795444baf954c2e7ecccf5&amp;sha2=9d4c56f5d414dbe23780719885baa3df40222412&amp;short_path=0b2da51&amp;unchanged=expanded&amp;utf8=✓#requiredt" rel="external nofollow noopener noreferrer" target="_blank">查看更多</a></p>
<h3 id="14-ts一些好用的小tips"><a href="#14-ts一些好用的小tips" class="headerlink" title="14. ts一些好用的小tips"></a>14. ts一些好用的小tips</h3><ul>
<li>keyof</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface iPeople &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type T = keyof iPeople // -&gt; &quot;name&quot; | &quot;age&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>in</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Keys = &quot;a&quot; | &quot;b&quot;</span><br><span class="line">type Obj =  &#123;</span><br><span class="line">  [p in Keys]: any</span><br><span class="line">&#125; // -&gt; &#123; a: any, b: any &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="15-规范其他"><a href="#15-规范其他" class="headerlink" title="15. 规范其他"></a>15. 规范其他</h3><ul>
<li>不要使用 var 声明变量</li>
<li>不会被修改的变量使用 const 声明</li>
<li>去除声明但未被引用的代码</li>
<li>禁止在代码里使用 debug</li>
<li>不允许有空的代码块</li>
</ul>
<h3 id="16-仅当初始-state-需要从-props-计算得到的时候，才将-state-的声明放在构造函数中，其它情况下使用静态属性声明-state-并且一般情况下不要将-prop-传给-state，"><a href="#16-仅当初始-state-需要从-props-计算得到的时候，才将-state-的声明放在构造函数中，其它情况下使用静态属性声明-state-并且一般情况下不要将-prop-传给-state，" class="headerlink" title="16. 仅当初始 state 需要从 props 计算得到的时候，才将 state 的声明放在构造函数中，其它情况下使用静态属性声明 state,并且一般情况下不要将 prop 传给 state，"></a>16. 仅当初始 state 需要从 props 计算得到的时候，才将 state 的声明放在构造函数中，其它情况下使用静态属性声明 state,并且一般情况下不要将 prop 传给 state，</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">constructor ()&#123;</span><br><span class="line">  this.setState(&#123; people: this.props.people &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">state: IState = &#123;</span><br><span class="line">  people: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="17-渲染默认值"><a href="#17-渲染默认值" class="headerlink" title="17. 渲染默认值"></a>17. 渲染默认值</h3><ul>
<li>添加非空判断可以提高代码的稳健性,例如后端返回的一些值,可能会出现不存在的情况，应该要给默认值.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">render()&#123;</span><br><span class="line">  &#123;name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">render()&#123;</span><br><span class="line">  &#123;!!name || &apos;--&apos;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>还有一种情况，就是本来后端应该返回一个数组给你，但是数据库取不到数据，可能后端给你返回了null,然后前端null.length。这样就gg了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const &#123; list, totalCount &#125; = await getPeopleList(keyword, page, pageSize);</span><br><span class="line">list 可能是null或者undefined</span><br><span class="line">list.length将直接导致前端报错</span><br><span class="line"></span><br><span class="line">this.setState(&#123;</span><br><span class="line">  status: STATUS.READY,</span><br><span class="line">  apps: list,</span><br><span class="line">  total: totalCount,</span><br><span class="line">  page: page,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">const &#123; list, totalCount &#125; = await getPeopleList(keyword, page, pageSize);</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  status: STATUS.READY,</span><br><span class="line">  apps: list || [],</span><br><span class="line">  total: totalCount || 0,</span><br><span class="line">  page: page,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="18-不确定的属性，最后却疯狂的用…访问不存在的属性"><a href="#18-不确定的属性，最后却疯狂的用…访问不存在的属性" class="headerlink" title="18. 不确定的属性，最后却疯狂的用…访问不存在的属性"></a>18. 不确定的属性，最后却疯狂的用…访问不存在的属性</h3><p>例如一些地方，不确定这个变量里面到底有什么，但自己觉得有，就疯狂的…,最明显的就是后端返回了一个对象给你，前端拿到之后判断都不判断直接data.dataList.forEach()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const data = await getPeopleList(keyword, page, pageSize);</span><br><span class="line">data.dataList.forEach() // 直接挂了</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const data = await getPeopleList(keyword, page, pageSize);</span><br><span class="line">if (data &amp;&amp; data.dataList &amp;&amp; Array.isArray(data.dataList) &#123;</span><br><span class="line">    data.dataList.forEach() </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="19-数据格式转换"><a href="#19-数据格式转换" class="headerlink" title="19. 数据格式转换"></a>19. 数据格式转换</h3><ol>
<li>把字符串转整型可以使用+号</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let maxPrice = +form.maxPrice.value;</span><br><span class="line">let maxPrice = Number(form.maxPrice.value);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ol>
<li>转成 boolean 值用!!</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let mobile = !!ua.match(/iPhone|iPad|Android|iPod|Windows Phone/);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="20-判断条件真假"><a href="#20-判断条件真假" class="headerlink" title="20. 判断条件真假"></a>20. 判断条件真假</h3><p>js 中以下为假,其他情况为真</p>
<ul>
<li>false</li>
<li>null</li>
<li>undefined</li>
<li>0</li>
<li>‘’ (空字符串)</li>
<li>NaN</li>
</ul>
<h3 id="21-简单组件可以使用函数代替"><a href="#21-简单组件可以使用函数代替" class="headerlink" title="21. 简单组件可以使用函数代替"></a>21. 简单组件可以使用函数代替</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">class Listing extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;&#123;this.props.hello&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function Listing(&#123; hello &#125;) &#123;</span><br><span class="line">  return &lt;div&gt;&#123;hello&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="22-对于常用的属性进行缓存"><a href="#22-对于常用的属性进行缓存" class="headerlink" title="22. 对于常用的属性进行缓存"></a>22. 对于常用的属性进行缓存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">this.props.app.openid;</span><br><span class="line">this.state.time</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const &#123; app &#125; = this.props;</span><br><span class="line">const &#123; time &#125; = this.state;</span><br><span class="line">console.log(app.openid)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="23-input-输入框使用-trim"><a href="#23-input-输入框使用-trim" class="headerlink" title="23. input 输入框使用 trim()"></a>23. input 输入框使用 trim()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">let searchContent = form.search.value;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">let searchContent = form.search.value.trim();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="24-使用-location-跳转前需要先转义"><a href="#24-使用-location-跳转前需要先转义" class="headerlink" title="24. 使用 location 跳转前需要先转义"></a>24. 使用 location 跳转前需要先转义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">window.location.href = redirectUrl + &apos;?a=10&amp;b=20&apos;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">window.location.href = redirectUrl + encodeURIComponent(&apos;?a=10&amp;b=20&apos;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="25-使用-react-router"><a href="#25-使用-react-router" class="headerlink" title="25. 使用 react-router"></a>25. 使用 react-router</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">import &#123; withRouter, RouteComponentProps &#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">export interface IProps extends RouteComponentProps&lt;any&gt; &#123;&#125;</span><br><span class="line">class App extends React.Component&lt;IProps, AppStates&gt; &#123;&#125;</span><br><span class="line">export default withRouter(App);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import &#123; withRouter, RouteComponentProps &#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component&lt;IProps &amp; RouteComponentProps&lt;&#123;&#125;&gt;, AppStates&gt; &#123;&#125;</span><br><span class="line">export default withRouter(App);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="26-同时开发，数据请求-api-目录-git-冲突目录方案"><a href="#26-同时开发，数据请求-api-目录-git-冲突目录方案" class="headerlink" title="26. 同时开发，数据请求 api 目录 git 冲突目录方案"></a>26. 同时开发，数据请求 api 目录 git 冲突目录方案</h3><ul>
<li>在 api 目录下新建一个目录，目录对应一级 tab,这个目录内放置一个 index.js ，最后把二级 tab 组件所使用的 api 请求都在这个 index.js 内引入。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 目前</span><br><span class="line"></span><br><span class="line">|- api</span><br><span class="line">  |- pageA.ts</span><br><span class="line">  |- pageB.ts</span><br><span class="line"></span><br><span class="line">// 建议</span><br><span class="line"></span><br><span class="line">|- api</span><br><span class="line">  |- pageA</span><br><span class="line">    |- index.js</span><br><span class="line">    |- aaa.js</span><br><span class="line">    |- bbb.js</span><br><span class="line">  |- pageB</span><br><span class="line">    |- index.js</span><br><span class="line">    |- aaa.js</span><br><span class="line">    |- bbb.js</span><br><span class="line">    |- ccc.js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="27-组件嵌套过深"><a href="#27-组件嵌套过深" class="headerlink" title="27. 组件嵌套过深"></a>27. 组件嵌套过深</h3><ul>
<li>组件一般不要超过三层,最多四层,层级过深可能会导致数据传递过深，在做一些颗粒度比较细的操作的时候，处理起来较为繁琐，可以使用 redux 等状态管理工具替代。</li>
</ul>
<h3 id="28-代码过滤掉你没考虑到的情况"><a href="#28-代码过滤掉你没考虑到的情况" class="headerlink" title="28. 代码过滤掉你没考虑到的情况"></a>28. 代码过滤掉你没考虑到的情况</h3><ul>
<li>例如一个函数，你只想操作字符串，那你必须在函数开头就只允许参数是字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parse (str:string)&#123;</span><br><span class="line">  if (typeof(str) === &apos;string&apos; ) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="29-业务代码里面的异步请求需要-try-catch"><a href="#29-业务代码里面的异步请求需要-try-catch" class="headerlink" title="29. 业务代码里面的异步请求需要 try catch"></a>29. 业务代码里面的异步请求需要 try catch</h3><ul>
<li>ajax 请求，使用 try catch，错误提示后端返回,并且做一些失败后的状态操作例如进入列表页，我们需要一个 loading 状态，然后去请求数据,可是失败之后，也需要把 loading 状态去掉,把 loading 隐藏的代码就写在 finally 里面。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getStudentList = async () =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      loading: true,</span><br><span class="line">      isEmpty: false</span><br><span class="line">    &#125;);</span><br><span class="line">    await getStudentList(&#123;&#125;);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // TODO</span><br><span class="line">    console.log(e)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    //  失败之后的一些兜底操作</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      loading: false,</span><br><span class="line">      isEmpty: true</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="30-setState有三种用法"><a href="#30-setState有三种用法" class="headerlink" title="30. setState有三种用法"></a>30. setState有三种用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 对象</span><br><span class="line">this.setState(&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 函数，一般是用于在setState之前做一些操作</span><br><span class="line">this.setState(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    // TODO</span><br><span class="line">    console.log(&apos;&apos;)</span><br><span class="line">    return &#123;</span><br><span class="line">      a:300</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 第二个参数，一般是用于在setState之后做一些操作</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  a:300</span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">  // TODO</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="31-setState可能是同步的"><a href="#31-setState可能是同步的" class="headerlink" title="31. setState可能是同步的"></a>31. setState可能是同步的</h3><ul>
<li>setState 在react里的合成事件和钩子函数中是“异步”的。</li>
<li>setState 在原生事件和 setTimeout 中是同步的。</li>
</ul>
<h3 id="32-不要在-setState-前面加-await"><a href="#32-不要在-setState-前面加-await" class="headerlink" title="32. 不要在 setState 前面加 await"></a>32. 不要在 setState 前面加 await</h3><ul>
<li>setState 前面也是可以带 await 的，会变成同步设置状态,但这是一种巧合，不确定未来哪个版本就不支持了，为了遵循 react 框架的设计原则，我们使用回掉函数的形式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">func = async (name, value, status) =&gt; &#123;</span><br><span class="line">  await this.setState(&#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;);</span><br><span class="line">  // TODO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">func = (name, value, status) =&gt; &#123;</span><br><span class="line">  this.setState(</span><br><span class="line">    &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      // TODO</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="33-阻止事件默认行为"><a href="#33-阻止事件默认行为" class="headerlink" title="33. 阻止事件默认行为"></a>33. 阻止事件默认行为</h3><ul>
<li>在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault 。</li>
</ul>
<h3 id="34-在-componentWillUnmount-里面去除副作用的函数"><a href="#34-在-componentWillUnmount-里面去除副作用的函数" class="headerlink" title="34. 在 componentWillUnmount 里面去除副作用的函数"></a>34. 在 componentWillUnmount 里面去除副作用的函数</h3><ul>
<li>清除 EventListener</li>
<li>中止数据请求</li>
<li>清除定时器</li>
</ul>
<h3 id="35-key"><a href="#35-key" class="headerlink" title="35. key"></a>35. key</h3><ul>
<li>对于组件中的 key 优化，起到最大化重用 dom</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//bad</span><br><span class="line">this.state.dataAry.map((item, index) =&gt; &#123;</span><br><span class="line">  return &lt;span key=&#123;index&#125; /&gt;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//good</span><br><span class="line">this.state.dataAry.map(item =&gt; &lt;span key=&#123;item.id&#125; /&gt;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="36-for-in-中一定要有-hasOwnProperty-的判断（即禁止直接读取原型对象的属性）"><a href="#36-for-in-中一定要有-hasOwnProperty-的判断（即禁止直接读取原型对象的属性）" class="headerlink" title="36. for-in 中一定要有 hasOwnProperty 的判断（即禁止直接读取原型对象的属性）"></a>36. for-in 中一定要有 hasOwnProperty 的判断（即禁止直接读取原型对象的属性）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//bad</span><br><span class="line">const arr = [];</span><br><span class="line">const key = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">for (key in obj) &#123;</span><br><span class="line">  arr.push(obj[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//good</span><br><span class="line">const arr = [];</span><br><span class="line">const key = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">for (key in obj) &#123;</span><br><span class="line">  if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">    arr.push(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="37-第三方库函数的使用"><a href="#37-第三方库函数的使用" class="headerlink" title="37. 第三方库函数的使用"></a>37. 第三方库函数的使用</h3><ul>
<li>用 try catch 包裹，防止第三方库的出现错误，导致整个程序崩溃</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Echart 用于代绘制图表，但当其自身发生错误时，可能影响到业务代码的执行</span><br><span class="line"> */</span><br><span class="line">// bad</span><br><span class="line">const iniDom = document.getElementById(&apos;init-container&apos;);</span><br><span class="line">const echartObj = echarts.init(iniDom);</span><br><span class="line">this.setState(</span><br><span class="line">  &#123;</span><br><span class="line">    echartObj</span><br><span class="line">  &#125;,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    const &#123; echartObj &#125; = this.state;</span><br><span class="line">    // 更新图表</span><br><span class="line">    echartObj.setOption(CHART_CONFIG, true);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">try &#123;</span><br><span class="line">  const iniDom = document.getElementById(&apos;init-container&apos;);</span><br><span class="line">  const echartObj = echarts.init(iniDom);</span><br><span class="line">  this.setState(</span><br><span class="line">    &#123;</span><br><span class="line">      echartObj</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      const &#123; echartObj &#125; = this.state;</span><br><span class="line">      // 更新图表</span><br><span class="line">      echartObj.setOption(CHART_CONFIG, true);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  // TODO</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="38-防止-xss-攻击"><a href="#38-防止-xss-攻击" class="headerlink" title="38. 防止 xss 攻击"></a>38. 防止 xss 攻击</h3><ul>
<li>input，textarea 等标签，不要直接把 html 文本直接渲染在页面上,使用 xssb 等过滤之后再输出到标签上;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; html2text &#125; from &apos;xss&apos;;</span><br><span class="line">render()&#123;</span><br><span class="line">  &lt;div</span><br><span class="line">  dangerouslySetInnerHTML=&#123;&#123;</span><br><span class="line">    __html: html2text(htmlContent)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="39-在组件中获取真实-dom"><a href="#39-在组件中获取真实-dom" class="headerlink" title="39. 在组件中获取真实 dom"></a>39. 在组件中获取真实 dom</h3><ul>
<li>使用 16 版本后的 createRef()函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyComponent extends React.Component&lt;iProps, iState&gt; &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.inputRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;input type=&quot;text&quot; ref=&#123;this.inputRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.inputRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="40-减少魔法数字"><a href="#40-减少魔法数字" class="headerlink" title="40. 减少魔法数字"></a>40. 减少魔法数字</h3><ul>
<li>写代码的时候尽量减少一些未知含义的数字，尽量用英文单词。例如type === 0的时候做了一些操作，让人不知所以然。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (type !== 0) &#123;</span><br><span class="line">  // TODO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const STATUS: Record&lt;string, any&gt; = &#123;</span><br><span class="line">  READY: 0,</span><br><span class="line">  FETCHING: 1,</span><br><span class="line">  FAILED: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">if (type === STATUS.READY) &#123;</span><br><span class="line">  // TODO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">enum STATUS &#123;</span><br><span class="line">  // 就绪</span><br><span class="line">  READY = 0,</span><br><span class="line">  // 请求中</span><br><span class="line">  FETCHING = 1,</span><br><span class="line">  // 请求失败</span><br><span class="line">  FAILED = 2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="41-如果需要优化-react-性能（一般用不到）"><a href="#41-如果需要优化-react-性能（一般用不到）" class="headerlink" title="41. 如果需要优化 react 性能（一般用不到）"></a>41. 如果需要优化 react 性能（一般用不到）</h3><ul>
<li>如果组件的 state 和 props 都是简单类型，可以继承 PureComponent 而不是 Component</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Component, PureComponent &#125; from &apos;react&apos;;</span><br><span class="line">// bad</span><br><span class="line">class Message extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;span&gt;&#123;this.state.message&#125;&lt;/span&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">class Message extends PureComponent &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;span&gt;&#123;this.state.message&#125;&lt;/span&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>重写 shouldComponentUpdate 方法,在 shouldComponentUpdate 里面根据 state,props 是否有改变来判断是否需要重新渲染.如果组件继承了 PureComponent 就没必要再重写 shouldComponentUpdate 方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; isReactPropsEqual, isReactStateEqual &#125; from &apos;@fe/common/lib/equal&apos;;</span><br><span class="line">shouldComponentUpdate(nextProps:IProps, nextState:IState) &#123;</span><br><span class="line">    if (isReactStateEqual(nextState,this.state) &amp;&amp; isReactPropsEqual(nextProps,this.props)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="42-Event-事件对象类型"><a href="#42-Event-事件对象类型" class="headerlink" title="42. Event 事件对象类型"></a>42. Event 事件对象类型</h3><p>很多小伙伴用了很久的ts,都不知道常用 Event 事件对象类型：</p>
<p>ClipboardEvent<t = element> 剪贴板事件对象</t></p>
<p>DragEvent<t = element> 拖拽事件对象</t></p>
<p>ChangeEvent<t = element> Change 事件对象</t></p>
<p>KeyboardEvent<t = element> 键盘事件对象</t></p>
<p>MouseEvent<t = element> 鼠标事件对象</t></p>
<p>TouchEvent<t = element> 触摸事件对象</t></p>
<p>WheelEvent<t = element> 滚轮事件对象</t></p>
<p>AnimationEvent<t = element> 动画事件对象</t></p>
<p>TransitionEvent<t = element> 过渡事件对象</t></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; MouseEvent &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  onClick(event: MouseEvent&lt;HTMLDivElement&gt;): void;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="43-使用私有属性取代state状态"><a href="#43-使用私有属性取代state状态" class="headerlink" title="43. 使用私有属性取代state状态"></a>43. 使用私有属性取代state状态</h3><p>对于一些不需要控制ui的状态属性，我们可以直接绑到this上， 即私有属性，没有必要弄到this.state上，不然会触发渲染机制，造成性能浪费 例如请求翻页数据的时候,我们都会有个变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">state: IState = &#123;</span><br><span class="line">  pageNo:1,</span><br><span class="line">  pageSize:10</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">queryParams:Record&lt;string,any&gt; = &#123;</span><br><span class="line">  pageNo:1,</span><br><span class="line">  pageSize:10</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="44-代码细粒度的思考"><a href="#44-代码细粒度的思考" class="headerlink" title="44. 代码细粒度的思考"></a>44. 代码细粒度的思考</h3><p>总结四句话。我们在写组件或者函数的的时候，工具函数和业务逻辑抽离，表单校验和业务抽离、事件函数和业务抽离，ajax和业务抽离。 例如有些页面是通过location.href跳转的，我们有些业务逻辑等都是放到didmountMount,但是后期改需求，可能要用react-router进行跳转，可能要改的逻辑就会很多了，所以函数抽离出来，需求更新就少改一点代码。 如果还不确定如何划分函数的细粒度，我有个建议。使用过两次以上的代码，要抽离组件或者函数，两次的可以不用</p>
<h3 id="45-if-else-等判断太多了，后期难以维护。"><a href="#45-if-else-等判断太多了，后期难以维护。" class="headerlink" title="45. if else 等判断太多了，后期难以维护。"></a>45. if else 等判断太多了，后期难以维护。</h3><p>个人觉得if else 嵌套深看起来也不会太难受，难受的是，项目迭代久之后，自己都忘记曾经写过这些代码，而且类型多或者不确定有什么类型，是否后期还会加的情况下，改起来就非常复杂了，而且很容易踩坑和背锅。 用配置取代if嵌套，大概就是抽离一个config.ts出来，里面放一些配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如你的业务代码里面，会根据不同url参数，代码会执行不同的逻辑.</span><br><span class="line">/info?type=wechat&amp;uid=123456&amp;</span><br><span class="line">const qsObj = qs(window.location.url)</span><br><span class="line">const urlType = qsObj.type</span><br><span class="line">// bad </span><br><span class="line">if (urlType === &apos;wechat&apos;) &#123;</span><br><span class="line">    doSomeThing()</span><br><span class="line">&#125; else if () &#123;</span><br><span class="line">    doSomeThing()</span><br><span class="line">&#125; else if () &#123;</span><br><span class="line">    doSomeThing()</span><br><span class="line">&#125; else if () &#123;</span><br><span class="line">    doSomeThing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">config.t</span><br><span class="line">const urlTypeConfig: Record&lt;string, typeItem&gt; = &#123;</span><br><span class="line">  &apos;wechat&apos;: &#123; // key 就是对应的type</span><br><span class="line">    name: &apos;wechat&apos;, </span><br><span class="line">    show: [&apos;header&apos;, &apos;footer&apos;, &apos;wechat&apos;] // 展示什么，可能是异步的</span><br><span class="line">    pession: [&apos;admin&apos;], // 权限是什么，可能是异步的</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;zhifubao&apos;: &#123; // key 就是对应的type</span><br><span class="line">    name: &apos;zhifubao&apos;, </span><br><span class="line">    show: [&apos;header&apos;, &apos;footer&apos;, &apos;zhifubao&apos;] // 展示什么，可能是异步的</span><br><span class="line">    pession: [&apos;admin&apos;], // 权限是什么，可能是异步的</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 业务逻辑</span><br><span class="line">const qsObj = qs(window.location.url)</span><br><span class="line">const urlType = qsObj.type</span><br><span class="line">Object.keys(urlTypeConfig).forEach(item =&gt; &#123;</span><br><span class="line">  if(urlType === item.type) &#123;</span><br><span class="line">    doSomeThing(item.show)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="46-不要使用renderXXX-要使用函数式组件"><a href="#46-不要使用renderXXX-要使用函数式组件" class="headerlink" title="46. 不要使用renderXXX,要使用函数式组件"></a>46. 不要使用renderXXX,要使用函数式组件</h3><p>发现团队一些小伙伴为了减少render函数里面的代码量，会把一些元素拆分到函数里面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">  renderHeader = () =&gt; &#123;</span><br><span class="line">    return (&lt;div /&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">  renderBody = () =&gt; &#123;</span><br><span class="line">    return (&lt;div /&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">  renderFooter = () =&gt; &#123;</span><br><span class="line">    return (&lt;div /&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        renderHeader()</span><br><span class="line">        renderBody()</span><br><span class="line">        renderFooter()</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>更好的办法，是用函数式组件取代在当前组件里面写方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// good</span><br><span class="line"> function RenderHeader(props) =  &#123;</span><br><span class="line">    return (&lt;div /&gt;)</span><br><span class="line">  &#125;</span><br><span class="line"> function RenderBody(props) =  &#123;</span><br><span class="line">    return (&lt;div /&gt;)</span><br><span class="line">  &#125;</span><br><span class="line"> function RenderFooter(props) =  &#123;</span><br><span class="line">    return (&lt;div /&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">class Component extends React.Component&lt;iProps, iState&gt;&#123;  </span><br><span class="line">  render () &#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;RenderHeader /&gt;</span><br><span class="line">        &lt;RenderBody /&gt;</span><br><span class="line">        &lt;RenderFooter /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="47-a标签安全问题"><a href="#47-a标签安全问题" class="headerlink" title="47. a标签安全问题"></a>47. a标签安全问题</h3><p>使用a标签打开一个新窗口过程中的安全问题。新页面中可以使用window.opener来控制原始页面。如果新老页面同域，那么在新页面中可以任意操作原始页面。如果是不同域，新页面中依然可以通过window.opener.location，访问到原始页面的location对象</p>
<p>在带有target=”_blank”的a标签中，加上rel=”noopener”属性。如果使用window.open的方式打开页面，将opener对象置为空。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var newWindow = window.open();</span><br><span class="line">newWindow.opener = null;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="48-void-0-替代undefined"><a href="#48-void-0-替代undefined" class="headerlink" title="48. void 0 替代undefined"></a>48. void 0 替代undefined</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clearSessioin = () =&gt; &#123;</span><br><span class="line">	</span><br><span class="line">  req.session.userName = undefined;</span><br><span class="line">  </span><br><span class="line">  req.session.userName = void 0</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="49-前端不要操作cookie"><a href="#49-前端不要操作cookie" class="headerlink" title="49. 前端不要操作cookie"></a>49. 前端不要操作cookie</h3><p>在做一些前后端鉴权的时候，后端应该开启domain,secure,httponly严格模式，禁止前端操作cookie，防止csrf攻击。</p>
<h3 id="50-代码检查插件"><a href="#50-代码检查插件" class="headerlink" title="50. 代码检查插件"></a>50. 代码检查插件</h3><p>我们可以使用构建工具继承 husky eslint tslint lint-stage prettier来规范代码。</p>
<ul>
<li><a href="https://www.npmjs.com/package/eslint-config-prettier" rel="external nofollow noopener noreferrer" target="_blank">eslint-config-prettier</a></li>
<li><a href="https://www.npmjs.com/package/eslint-plugin-prettier" rel="external nofollow noopener noreferrer" target="_blank">eslint-plugin-prettier</a></li>
<li><a href="https://www.npmjs.com/package/eslint-plugin-react" rel="external nofollow noopener noreferrer" target="_blank">eslint-plugin-react</a></li>
<li><a href="https://www.npmjs.com/package/tslint-react" rel="external nofollow noopener noreferrer" target="_blank">tslint-react</a></li>
<li><a href="https://www.npmjs.com/package/tslint-plugin-prettier" rel="external nofollow noopener noreferrer" target="_blank">tslint-plugin-prettier</a></li>
<li><a href="https://www.npmjs.com/package/tslint-config-prettier" rel="external nofollow noopener noreferrer" target="_blank">tslint-config-prettier</a></li>
</ul>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>typeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>git删除不需要的本地和远程tag</title>
    <url>/2020/06/10/git%E5%88%A0%E9%99%A4%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8Btag/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们在用git做代码管理的时候，当一个需求结束需要做个节点记录。我们一般都会打一个tag作为一个节点记录，但是在打tag的过程中难免会出问题，有时我们需要删除掉不需要的tag。<a id="more"></a></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>以tag 1.0.0为例，这个tag已经同步到远程，但是现在发现了一个问题，需要撤回该tag，git命令如下：</p>
<p>删除本地tag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d 1.0.0</span><br></pre></td></tr></table></figure>
<p>删除远程tag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/1.0.0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序使用echarts图表</title>
    <url>/2020/06/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8echarts%E5%9B%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数据统计是我们经常使用的功能，我们一般在 pc 端使用的比较多，大多数用在管理系统中统计数据的分析，最近在做微信小程序的时候也遇到了相同的需求，把数据统计在小程序端以图表的形式展示，这里记录下自己的配置使用过程。<a id="more"></a></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先百度的 echarts 没有提供小程序版本，这里找了个封装过可以用在微信端的仓库<a href="https://github.com/ecomfe/echarts-for-weixin" rel="external nofollow noopener noreferrer" target="_blank">小程序版 echarts</a>,通过这个链接下载最新的包。解压之后有个<code>ec-canvas</code>文件夹就是封装的组件，放到小程序的组件文件夹目录下，以供使<br>用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">├── ec-canvas</span><br><span class="line">│   ├── ec-canvas.js</span><br><span class="line">│   ├── ec-canvas.json</span><br><span class="line">│   ├── ec-canvas.wxml</span><br><span class="line">│   ├── ec-canvas.wxss</span><br><span class="line">│   ├── echarts.min.js</span><br><span class="line">│   └── wx-canvas.js</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>在需要使用的页面配置文件中引入该图表组件</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"usingComponents": &#123;</span><br><span class="line">    "ec-canvas": "../../ec-canvas/ec-canvas"</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>index.wxml 中，我们创建了一个 <ec-canvas> 组件：</ec-canvas></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;ec-canvas id=&quot;mychart-dom-bar&quot; canvas-id=&quot;mychart-bar&quot; ec=&quot;&#123;&#123; ec &#125;&#125;&quot;&gt;&lt;/ec-canvas&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>其中 ec 是一个我们在 index.js 中定义的对象，它使得图表能够在页面加载后被初始化并设置。index.js 的结构如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    ec: &#123;</span><br><span class="line">      onInit: initChart</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad()&#123;</span><br><span class="line">      <span class="comment">// 在需要的地方获取dom</span></span><br><span class="line">      <span class="keyword">this</span>.echartsComponnet1 = <span class="keyword">this</span>.selectComponent(<span class="string">'#mychart-dom-bar1'</span>)</span><br><span class="line">      <span class="keyword">this</span>.init_echarts1(&#123; <span class="attr">value</span>: res.data.rotateSpeed || <span class="number">0</span>, <span class="attr">name</span>: <span class="string">'x1000'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">    init_echarts1 (data) &#123;</span><br><span class="line">      <span class="keyword">this</span>.echartsComponnet1.init(<span class="function">(<span class="params">canvas, width, height</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化图表</span></span><br><span class="line">        <span class="keyword">const</span> chart = echarts.init(canvas, <span class="literal">null</span>, &#123;</span><br><span class="line">          width: width,</span><br><span class="line">          height: height</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.chart = chart</span><br><span class="line">        <span class="comment">// setGaugeChartOption1获取到基础配置</span></span><br><span class="line">        chart.setOption(setGaugeChartOption1(data))</span><br><span class="line">        <span class="comment">// 注意这里一定要返回 chart 实例，否则会影响事件处理等</span></span><br><span class="line">        <span class="keyword">return</span> chart</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>微信</tag>
        <tag>echarts图表</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript实现数据结构--队列</title>
    <url>/2020/05/08/javaScript%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学习数据结构和算法的笔记，方便下次复习巩固<a id="more"></a></p>
<h3 id="js-实现队列"><a href="#js-实现队列" class="headerlink" title="js 实现队列"></a>js 实现队列</h3><h4 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ele = ele</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>,</span><br><span class="line">    front, <span class="comment">//队首指针</span></span><br><span class="line">    rear <span class="comment">//队尾指针</span></span><br><span class="line">  <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> Node(ele),</span><br><span class="line">      temp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">      front = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      temp = rear</span><br><span class="line">      temp.next = node</span><br><span class="line">    &#125;</span><br><span class="line">    rear = node</span><br><span class="line">    length++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = front</span><br><span class="line">    front = front.next</span><br><span class="line">    length--</span><br><span class="line">    temp.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.getFront = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> front</span><br><span class="line">    <span class="comment">// 有没有什么思路只获取队列的头结点,而不是获取整个队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.getRear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rear</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">''</span>,</span><br><span class="line">      temp = front</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">      string += temp.ele + <span class="string">' '</span></span><br><span class="line">      temp = temp.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    front = <span class="literal">null</span></span><br><span class="line">    rear = <span class="literal">null</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myQueue = <span class="keyword">new</span> LinkedQueue()</span><br><span class="line"></span><br><span class="line">myQueue.push(<span class="number">1</span>)</span><br><span class="line">myQueue.push(<span class="number">2</span>)</span><br><span class="line">myQueue.push(<span class="number">3</span>)</span><br><span class="line">myQueue.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myQueue.toString()) <span class="comment">// 1 2 3 4</span></span><br><span class="line"><span class="built_in">console</span>.log(myQueue.pop()) <span class="comment">// Node &#123; ele: 1, next: null &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(myQueue.toString()) <span class="comment">// 2 3 4</span></span><br></pre></td></tr></table></figure>
<h4 id="js-线性表内置数据实现"><a href="#js-线性表内置数据实现" class="headerlink" title="js 线性表内置数据实现"></a>js 线性表内置数据实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="comment">//入队操作</span></span><br><span class="line">  <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    arr.push(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//出队操作</span></span><br><span class="line">  <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取队首</span></span><br><span class="line">  <span class="keyword">this</span>.getFront = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取队尾</span></span><br><span class="line">  <span class="keyword">this</span>.getRear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[arr.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//清空队列</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    arr = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取队长</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript实现栈数据结构</title>
    <url>/2020/05/08/javaScript%E5%AE%9E%E7%8E%B0%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于编程基础，算法和数据结构是必不可少的知识，这里简单用 javaScript 语言来实现基本的数据结构。<a id="more"></a></p>
<h3 id="用-javaScript-中的线性表数组来模拟实现"><a href="#用-javaScript-中的线性表数组来模拟实现" class="headerlink" title="用 javaScript 中的线性表数组来模拟实现"></a>用 javaScript 中的线性表数组来模拟实现</h3><h4 id="使用函数的方式"><a href="#使用函数的方式" class="headerlink" title="使用函数的方式"></a>使用函数的方式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> stack = []</span><br><span class="line">  <span class="keyword">this</span>.push = <span class="function"><span class="params">element</span> =&gt;</span> stack.push(element)</span><br><span class="line">  <span class="keyword">this</span>.pop = <span class="function"><span class="params">()</span> =&gt;</span> stack.pop()</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="function"><span class="params">()</span> =&gt;</span> stack.length</span><br><span class="line">  <span class="keyword">this</span>.top = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> stack[stack.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'stack empty'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    stack.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.length) &#123;</span><br><span class="line">      stack.reverse()</span><br><span class="line">      <span class="keyword">return</span> stack.join(<span class="string">' '</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'stack empty'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-class-类的方式"><a href="#使用-class-类的方式" class="headerlink" title="使用 class 类的方式"></a>使用 class 类的方式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line">  &#125;</span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(element)</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">this</span>.items.length</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span><br><span class="line">  &#125;</span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.items.toString())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用链表来模拟实现"><a href="#使用链表来模拟实现" class="headerlink" title="使用链表来模拟实现"></a>使用链表来模拟实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedStack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> top</span><br><span class="line">  <span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">    <span class="keyword">if</span> (top) &#123;</span><br><span class="line">      node.next = top</span><br><span class="line">      top = node</span><br><span class="line">      length++</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      top = node</span><br><span class="line">      length++</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top) &#123;</span><br><span class="line">      <span class="keyword">var</span> current</span><br><span class="line">      current = top</span><br><span class="line">      top = top.next</span><br><span class="line">      current.next = <span class="literal">null</span></span><br><span class="line">      length--</span><br><span class="line">      <span class="keyword">return</span> current</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'stack empty'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.top = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> string = <span class="string">''</span></span><br><span class="line">    <span class="keyword">var</span> current = top</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      string += current.element</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    top = <span class="literal">null</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>css实现内凹圆角</title>
    <url>/2020/04/09/css%E5%AE%9E%E7%8E%B0%E5%86%85%E5%87%B9%E5%9C%86%E8%A7%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最近在做项目中，遇到一个项目需求，在 ui 上显示一个优惠券的卡片。这个卡片和大家一般看到的类似，中间会有两个内凹的半圆。实现这个背景卡片的方式最简单的就是用背景图这里我就不说了。还有一个方式就是用 css 样式来写一个这样的效果。<a id="more"></a></p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="用四个-div-遮盖的方式"><a href="#用四个-div-遮盖的方式" class="headerlink" title="用四个 div 遮盖的方式"></a>用四个 div 遮盖的方式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>内凹圆角<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">      .cro &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        border: 1px solid #58c4e6;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .cro_left_top,</span><br><span class="line">      .cro_right_top,</span><br><span class="line">      .cro_left_bottom,</span><br><span class="line">      .cro_right_bottom &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 20px;</span><br><span class="line">        height: 20px;</span><br><span class="line">        border: 1px solid #fff;</span><br><span class="line">        z-index: 1;</span><br><span class="line">        background: #fff;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .cro_left_top &#123;</span><br><span class="line">        top: -1px;</span><br><span class="line">        left: -1px;</span><br><span class="line">        border-radius: 0 0 20px 0;</span><br><span class="line">        border-bottom: 1px solid #58c4e6;</span><br><span class="line">        border-right: 1px solid #58c4e6;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .cro_right_top &#123;</span><br><span class="line">        top: -1px;</span><br><span class="line">        right: -1px;</span><br><span class="line">        border-radius: 0 0 0 20px;</span><br><span class="line">        border-bottom: 1px solid #58c4e6;</span><br><span class="line">        border-left: 1px solid #58c4e6;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .cro_left_bottom &#123;</span><br><span class="line">        left: -1px;</span><br><span class="line">        bottom: -1px;</span><br><span class="line">        border-radius: 0 20px 0 0;</span><br><span class="line">        border-top: 1px solid #58c4e6;</span><br><span class="line">        border-right: 1px solid #58c4e6;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .cro_right_bottom &#123;</span><br><span class="line">        right: -1px;</span><br><span class="line">        bottom: -1px;</span><br><span class="line">        border-radius: 20px 0 0 0;</span><br><span class="line">        border-top: 1px solid #58c4e6;</span><br><span class="line">        border-left: 1px solid #58c4e6;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cro"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cro_left_top"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cro_right_top"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cro_left_bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cro_right_bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="用背景的渐变来实现"><a href="#用背景的渐变来实现" class="headerlink" title="用背景的渐变来实现"></a>用背景的渐变来实现</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      p &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      .top-box &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background: red;</span><br><span class="line">        position: relative;</span><br><span class="line">        margin-bottom: 20px;</span><br><span class="line">        border-radius: 4px 4px 0 0;</span><br><span class="line">      &#125;</span><br><span class="line">      .bottom-box &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: #000;</span><br><span class="line">        position: relative;</span><br><span class="line">        border-radius: 0 0 4px 4px;</span><br><span class="line">      &#125;</span><br><span class="line">      .top-box p,</span><br><span class="line">      .bottom-box p &#123;</span><br><span class="line">        width: calc(100% - 20px);</span><br><span class="line">        height: 10px;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 10px;</span><br><span class="line">      &#125;</span><br><span class="line">      .top-box p &#123;</span><br><span class="line">        background: red;</span><br><span class="line">        bottom: -10px;</span><br><span class="line">      &#125;</span><br><span class="line">      .bottom-box p &#123;</span><br><span class="line">        background: #000;</span><br><span class="line">        top: -10px;</span><br><span class="line">      &#125;</span><br><span class="line">      .top-box p::before,</span><br><span class="line">      .bottom-box p::before &#123;</span><br><span class="line">        content: '';</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 10px;</span><br><span class="line">        height: 10px;</span><br><span class="line">        left: -10px;</span><br><span class="line">      &#125;</span><br><span class="line">      .top-box p::after,</span><br><span class="line">      .bottom-box p::after &#123;</span><br><span class="line">        content: '';</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 10px;</span><br><span class="line">        height: 10px;</span><br><span class="line">        right: -10px;</span><br><span class="line">      &#125;</span><br><span class="line">      .top-box p::before &#123;</span><br><span class="line">        background-image: radial-gradient(circle 10px at 0 100%, transparent 50px, red 50%);</span><br><span class="line">      &#125;</span><br><span class="line">      .top-box p::after &#123;</span><br><span class="line">        background-image: radial-gradient(circle 10px at 100% 100%, transparent 50px, red 50%);</span><br><span class="line">      &#125;</span><br><span class="line">      .bottom-box p::before &#123;</span><br><span class="line">        background-image: radial-gradient(circle 10px at 0 0, transparent 50px, #000 50%);</span><br><span class="line">      &#125;</span><br><span class="line">      .bottom-box p::after &#123;</span><br><span class="line">        background-image: radial-gradient(circle 10px at 100% 0, transparent 50px, #000 50%);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"modal"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mask"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top-box"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom-box"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="各自的特点"><a href="#各自的特点" class="headerlink" title="各自的特点"></a>各自的特点</h3><p>第一种方式相对来说简单点，但是这样的实现不能够透出下边背景的内容，如果有需要透出背景中的文字就需要使用第二种方式。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目中使用微信sdk</title>
    <url>/2020/04/08/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BE%AE%E4%BF%A1sdk/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们在做微信公众号开发的时候，在编写 H5 页面的时候难免要用到微信的功能。比如：微信的分享功能。H5 中使用微信客户端的能力是通过调用微信 sdk 来实现的。<a id="more"></a>一般移动端 H5 比较简洁，大部分使用 vue 进行开发，这里简单记录下 vue 中使用微信 sdk 的方法。</p>
<h3 id="使用-js-链接的方式进行调用"><a href="#使用-js-链接的方式进行调用" class="headerlink" title="使用 js 链接的方式进行调用"></a>使用 js 链接的方式进行调用</h3><p>首现我使用的是 vue-cli 创建的项目，在文件目录中有一个模版 html 文件，我们去微信官方文档获取到当前的 sdk 的最新版本链接，然后放到我们的 html 文件中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=0, viewport-fit=cover;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%= BASE_URL %&gt;favicon.ico"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://res.wx.qq.com/open/js/jweixin-1.6.0.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 微信的sdk线上版本</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后当 html 加载了这个 js 后，会把 wx 对象放到 window 全局变量上，通过 window.wx 可以调用相应的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.wx.config(&#123;</span><br><span class="line">  debug: <span class="literal">true</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">  appId: <span class="string">''</span>, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">  timestamp: <span class="string">''</span>, <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">  nonceStr: <span class="string">''</span>, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">  signature: <span class="string">''</span>, <span class="comment">// 必填，签名</span></span><br><span class="line">  jsApiList: [], <span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后我们就可以在 vue 的钩子函数中处理业务逻辑来调用 wx 的 api 了</p>
<h3 id="使用-npm-包的方式进行使用"><a href="#使用-npm-包的方式进行使用" class="headerlink" title="使用 npm 包的方式进行使用"></a>使用 npm 包的方式进行使用</h3><ul>
<li>首现去 npm 上安装微信 sdk 的包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install weixin-js-sdk</span><br></pre></td></tr></table></figure>
<ul>
<li>然后在需要使用的地方引入文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wx <span class="keyword">from</span> <span class="string">'weixin-js-sdk'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>微信方法的使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">  debug: <span class="literal">true</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">  appId: <span class="string">''</span>, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">  timestamp: <span class="string">''</span>, <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">  nonceStr: <span class="string">''</span>, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">  signature: <span class="string">''</span>, <span class="comment">// 必填，签名</span></span><br><span class="line">  jsApiList: [], <span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>git flow工作流的使用说明</title>
    <url>/2020/03/23/git-flow%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在代码开发过程中，代码的版本管理是必不可少的。现在大部分使用的都是 git 版本管理工具，关于 git 的优点和安装使用方式我就不一一叙述了，需要的可以自行百度。这里我主要记录下当前比较流行的 git-flow 工作流的安装和使用。<a id="more"></a></p>
<h3 id="git-flow-工作流简介"><a href="#git-flow-工作流简介" class="headerlink" title="git flow 工作流简介"></a>git flow 工作流简介</h3><p>git flow 是 git 分支和发行版管理工作流程，可帮助开发人员跟踪大型软件项目中的功能，修补程序和发行版。这个工作流程有很多命令可以输入和记住，因此还有 git 子命令的 git-flow 库，可以帮助自动化流程的某些部分，从而使流程更容易使用。</p>
<h3 id="git-fow-安装"><a href="#git-fow-安装" class="headerlink" title="git fow 安装"></a>git fow 安装</h3><p>以 mac 电脑为例，列举几种安装方式</p>
<ul>
<li>通过 Homebrew 进行安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install git-flow-avh</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 wget 进行安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -q -O - https://github.com/petervanderdoes/gitflow-avh/raw/develop/contrib/gitflow-installer.sh install stable| sudo bash</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 curl 进行安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sL https://github.com/petervanderdoes/gitflow-avh/raw/develop/contrib/gitflow-installer.sh | sudo bash -s install stable</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 github 仓库手动安装</li>
</ul>
<ol>
<li>首现 clone 下官方的仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/petervanderdoes/gitflow.git</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入到项目文件夹执行命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="git-flow-默认分支介绍"><a href="#git-flow-默认分支介绍" class="headerlink" title="git flow 默认分支介绍"></a>git flow 默认分支介绍</h3><ol>
<li><p>master 分支存放所有正式发布的版本，可以作为项目历史版本记录分支，不直接提交代码。仅用于保持一个对应线上运行代码的 code base。</p>
</li>
<li><p>develop 分支为主开发分支，一般不直接提交代码</p>
</li>
<li><p>feature 分支为新功能分支，feature 分支都是基于 develop 创建的，开发完成后会合并到 develop 分支上。同时存在多个</p>
</li>
<li><p>release 分支基于最新 develop 分支创建，当新功能足够发布一个新版本(或者接近新版本发布的截止日期)，从 develop 分支创建一个 release 分支作为新版本的起点，用于测试，所有的测试 bug 在这个分支改。测试完成后合并到 master 并打上版本号，同时也合并到 develop，更新最新开发分支。(一旦打了 release 分支之后不要从 develop 分支上合并新的改动到 release 分支)，同一时间只有 1 个，生命周期很短，只是为了发布。</p>
</li>
<li><p>hotfix 分支基于 master 分支创建，对线上版本的 bug 进行修复，完成后直接合并到 master 分支和 develop 分支，如果当前还有新功能 release 分支，也同步到 release 分支上。同一时间只有 1 个，生命周期较短</p>
</li>
</ol>
<h3 id="git-flow-常用命令"><a href="#git-flow-常用命令" class="headerlink" title="git flow 常用命令"></a>git flow 常用命令</h3><ul>
<li><p>git flow init：初始化一个现有的 git 库,将会设置一些初始的参数，如分支前缀名等，建议用默认值。</p>
</li>
<li><p>git flow feature start [featureBranchName]: 创建一个基于’develop’的 feature 分支，并切换到这个分支之下。</p>
</li>
<li><p>git flow feature finish [featureBranchName]: 完成开发新特性, 合并 MYFEATURE 分支到 ‘develop’, 删除这个新特性分支, 切换回 ‘develop’ 分支。</p>
</li>
<li><p>git flow feature publish [featureBranchName]：发布新特性分支到远程服务器，也可以使用 git 的 push 命令</p>
</li>
<li><p>git flow feature pull origin [featureBranchName]：取得其它用户发布的新特性分支，并签出远程的变更。也可以使用 git 的 pull 命令</p>
</li>
<li><p>git flow feature track [featureBranchName]：跟踪在 origin 上的 feature 分支。</p>
</li>
<li><p>git flow release start [releaseBranchName]：开始准备 release 版本，从 ‘develop’ 分支开始创建一个 release 分支。</p>
</li>
<li><p>git flow release publish [releaseBranchName]：创建 release 分支之后立即发布允许其它用户向这个 release 分支提交内容。</p>
</li>
<li><p>git flow release track [releaseBranchName]：签出 release 版本的远程变更。</p>
</li>
<li><p>git flow release finish [releaseBranchName]：归并 release 分支到 ‘master’ 分支，用 release 分支名打 Tag，归并 release 分支到 ‘develop’，移除 release 分支。</p>
</li>
<li><p>git flow hotfix start [hotfixBranchName]：开始 git flow 紧急修复，从 master 上建立 hotfix 分支。</p>
</li>
<li><p>git flow hotfix finish [hotfixBranchName]：结束 git flow 紧急修复，代码归并回 develop 和 master 分支。相应地，master 分支打上修正版本的 TAG。</p>
</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul>
<li>使用基本分支结构初始化新的存储库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 初始化项目仓库</span><br><span class="line">git flow init [-d]</span><br></pre></td></tr></table></figure>
<p>-d 参数是接受默认配置</p>
<ul>
<li>新需求开发新建新的功能分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 列出所有功能分支</span><br><span class="line">git flow feature</span><br><span class="line">// 开始新建一个新的功能分支</span><br><span class="line">git flow feature start &lt;name&gt; [&lt;base&gt;]</span><br><span class="line">// 完成一个新的功能分支</span><br><span class="line">git flow feature finish &lt;name&gt;</span><br><span class="line">// 删除当前分支</span><br><span class="line">git flow feature delete &lt;name&gt;</span><br><span class="line">// 开放当前分支可以让其他人提交</span><br><span class="line">git flow feature publish &lt;name&gt;</span><br><span class="line">// 签出当前分支版本的远程变更</span><br><span class="line">git flow feature track &lt;name&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理测试待发布分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 列出待发布分支</span><br><span class="line">git flow release</span><br><span class="line">// 开始创建一个待发布分支</span><br><span class="line">git flow release start &lt;release&gt; [&lt;base&gt;]</span><br><span class="line">// 完成一个待发布分支</span><br><span class="line">git flow release finish &lt;release&gt;</span><br><span class="line">// 删除一个待发布分支</span><br><span class="line">git flow release delete &lt;release&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>线上问题修复分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 列出修复分支</span><br><span class="line">git flow hotfix</span><br><span class="line">// 创建开始一个修改分支</span><br><span class="line">git flow hotfix start &lt;release&gt; [&lt;base&gt;]</span><br><span class="line">// 结束一个修改分支</span><br><span class="line">git flow hotfix finish &lt;release&gt;</span><br><span class="line">// 删除一个修改分支</span><br><span class="line">git flow hotfix delete &lt;release&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>支持分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 列出支持分支</span><br><span class="line">git flow support</span><br><span class="line">// 开始一个支持分支</span><br><span class="line">git flow support start &lt;release&gt; &lt;base&gt;</span><br></pre></td></tr></table></figure>
<p>就简单写下自己知道的，为了防止以后忘记。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>react高阶组件的实现和运用</title>
    <url>/2020/01/09/react%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在项目中，有很多大致相同的页面。又不想每次都写相同的页面布局，所以封装一个公共的页面，然后通过继承多态来实现每个自己的页面实例。其中用到高阶组件的知识，这里巩固学习一下高阶组件的实现方法和使用场景。<a id="more"></a></p>
<h2 id="高阶组件实现的方式"><a href="#高阶组件实现的方式" class="headerlink" title="高阶组件实现的方式"></a>高阶组件实现的方式</h2><h3 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h3><p>函数返回一个我们自己定义的组件，然后在render中返回要包裹的组件，这样我们就可以代理所有传入的props，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数visible就是一个HOC属性代理的实现方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比原生组件增强的项：</p>
<ul>
<li>可操作所有传入的props</li>
<li>可操作组件的生命周期</li>
<li>可操作组件的static方法</li>
<li>获取refs</li>
</ul>
<h3 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h3><p>返回一个组件，继承原组件，在render中调用原组件的render。由于继承了原组件，能通过this访问到原组件的生命周期、props、state、render等，相比属性代理它能操作更多的属性。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对比原生组件增强的项：</p>
<ul>
<li>可操作所有传入的props</li>
<li>可操作组件的生命周期</li>
<li>可操作组件的static方法</li>
<li>获取refs</li>
<li>可操作state</li>
<li>可以渲染劫持</li>
</ul>
<h2 id="高阶组件可实现的功能"><a href="#高阶组件可实现的功能" class="headerlink" title="高阶组件可实现的功能"></a>高阶组件可实现的功能</h2><h3 id="组合渲染"><a href="#组合渲染" class="headerlink" title="组合渲染"></a>组合渲染</h3><p>可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果。</p>
<blockquote>
<p>通过属性代理实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stylHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"title"</span>&gt;</span>&#123;this.props.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>通过反向继承实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">styleHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"title"</span>&gt;</span>&#123;this.props.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;super.render()&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>根据特定的属性决定原组件是否渲染</p>
<blockquote>
<p>通过属性代理实现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function visibleHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      if (this.props.visible === false) return null;</span><br><span class="line">      return &lt;WrappedComponent &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>通过反向继承实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibleHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.visible === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="操作props"><a href="#操作props" class="headerlink" title="操作props"></a>操作props</h3><p>可以对传入组件的props进行增加、修改、删除或者根据特定的props进行特殊的操作。</p>
<blockquote>
<p>通过属性代理实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        ...this.props,</span><br><span class="line">        user: <span class="string">'ConardLi'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="获取refs"><a href="#获取refs" class="headerlink" title="获取refs"></a>获取refs</h3><p>高阶组件中可获取原组件的ref，通过ref获取组件实力，如下面的代码，当程序初始化完成后调用原组件的log方法。</p>
<blockquote>
<p>通过属性代理实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.wapperRef.log()</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">ref</span>=<span class="string">&#123;ref</span> =&gt;</span> &#123; this.wapperRef = ref &#125;&#125; /&gt;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这里注意：调用高阶组件的时候并不能获取到原组件的真实ref，需要手动进行传递</p>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>将原组件的状态提取到HOC中进行管理，如下面的代码，我们将Input的value提取到HOC中进行管理，使它变成受控组件，同时不影响它使用onChange方法进行一些其他操作。基于这种方式，我们可以实现一个简单的双向绑定，具体请看双向绑定。</p>
<blockquote>
<p>通过属性代理实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: <span class="string">''</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onChange &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value: event.target.value,</span><br><span class="line">      &#125;, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onChange ===<span class="string">'function'</span>)&#123;</span><br><span class="line">          onChange(event);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        value: <span class="keyword">this</span>.state.value,</span><br><span class="line">        onChange: <span class="keyword">this</span>.onChange,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> proxyHoc(HOC);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="操作state"><a href="#操作state" class="headerlink" title="操作state"></a>操作state</h3><p>上面的例子通过属性代理利用HOC的state对原组件进行了一定的增强，但并不能直接控制原组件的state，而通过反向继承，我们可以直接操作原组件的state。但是并不推荐直接修改或添加原组件的state，因为这样有可能和组件内部的操作构成冲突。</p>
<blockquote>
<p>通过反向继承实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debugHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'props'</span>, <span class="keyword">this</span>.props);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'state'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"debuging"</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">super</span>.render()&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>复制代码上面的HOC在render中将props和state打印出来，可以用作调试阶段，当然你可以在里面写更多的调试代码。想象一下，只需要在我们想要调试的组件上加上@debug就可以对该组件进行调试，而不需要在每次调试的时候写很多冗余代码。</p>
<h3 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h3><p>高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出。只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。<br>实际上，上面的组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可直接增强由原组件render函数产生的React元素。</p>
<blockquote>
<p>通过反向继承实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hijackHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> tree = <span class="keyword">super</span>.render();</span><br><span class="line">      <span class="keyword">let</span> newProps = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (tree &amp;&amp; tree.type === <span class="string">'input'</span>) &#123;</span><br><span class="line">        newProps = &#123; <span class="attr">value</span>: <span class="string">'渲染被劫持了'</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, tree.props, newProps);</span><br><span class="line">      <span class="keyword">const</span> newTree = React.cloneElement(tree, props, tree.props.children);</span><br><span class="line">      <span class="keyword">return</span> newTree;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义create-umi脚手架</title>
    <url>/2019/12/30/%E8%87%AA%E5%AE%9A%E4%B9%89create-umi%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在开发 react 项目中，使用的是阿里开源的框架 umi。这个架构非常好用，可以集成我们需要的 dva、antd、antd pro、typescript 等。对我们开发新项目的架构初始化非常友好。但是官方的 umi 虽然好用，但是文件结构是通用的，不符合我们各自的项目需求。<a id="more"></a>比如：我们的项目需要一个 api 文件夹，这时我们就需要基于新建的项目添加文件夹。这样改一点的还好，万一我们改的多了，每次新建项目都需要复制修改，比较麻烦，这里我就想自定义脚手架，每次执行 shell 命令就生成我们定义好的架构目录，踩坑走起！</p>
<h2 id="踩坑自定义脚手架步骤"><a href="#踩坑自定义脚手架步骤" class="headerlink" title="踩坑自定义脚手架步骤"></a>踩坑自定义脚手架步骤</h2><h3 id="fork-官方的-create-umi-脚手架仓库到自己的-github-中"><a href="#fork-官方的-create-umi-脚手架仓库到自己的-github-中" class="headerlink" title="fork 官方的 create-umi 脚手架仓库到自己的 github 中"></a>fork 官方的 create-umi 脚手架仓库到自己的 github 中</h3><h3 id="git-clone-我们-fork-完的远程仓库"><a href="#git-clone-我们-fork-完的远程仓库" class="headerlink" title="git clone 我们 fork 完的远程仓库"></a>git clone 我们 fork 完的远程仓库</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/wangyuan0108/create-umi.git</span><br></pre></td></tr></table></figure>
<h3 id="卸载之前全局装的官方的脚手架"><a href="#卸载之前全局装的官方的脚手架" class="headerlink" title="卸载之前全局装的官方的脚手架"></a>卸载之前全局装的官方的脚手架</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn remove global umi create-umi</span><br></pre></td></tr></table></figure>
<h3 id="进入-clone-的-create-umi-项目并安装依赖包"><a href="#进入-clone-的-create-umi-项目并安装依赖包" class="headerlink" title="进入 clone 的 create-umi 项目并安装依赖包"></a>进入 clone 的 create-umi 项目并安装依赖包</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> create-umi</span><br><span class="line">yarn</span><br></pre></td></tr></table></figure>
<h3 id="找到你想修改的地方"><a href="#找到你想修改的地方" class="headerlink" title="找到你想修改的地方"></a>找到你想修改的地方</h3><p>比如我想在 app 类型下面新加一个 api 的文件夹，就找到对应的位置进行修改就好了。模版所在的位置是</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./lib/generators/ant-design-pro</span><br><span class="line">./lib/generators/app</span><br><span class="line">./lib/generators/block</span><br><span class="line">./lib/generators/library</span><br><span class="line">./lib/generators/plugin</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>要删除全局安装的官方脚手架</li>
<li>如果修改 package.json 中的 bin 字段命令，那么 name 字段也要改成相应的字段<br>3.</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn create umi appname</span><br><span class="line">// 等于以下两步</span><br><span class="line">yarn global add create-umi（bin中指定的字段)</span><br><span class="line">create-umi appname</span><br></pre></td></tr></table></figure>
<p>至此就可以愉快的修改自己的脚手架了</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>解决node-sass的安装问题</title>
    <url>/2019/12/27/%E8%A7%A3%E5%86%B3node-sass%E7%9A%84%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在我们想使用 scss 来写样式的时候，避免不了的需要安装 node-sass 包，但是只要是安装的过这个包的都知道，这个包的安装是非常的困难。所以这里提供一个新的解决方法，解决这个包安装慢的问题。</p>
<a id="more"></a>
<h2 id="踩坑过程"><a href="#踩坑过程" class="headerlink" title="踩坑过程"></a>踩坑过程</h2><p>在初学 scss 的时候安装 node-sass 当然是最普通的 npm 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install node-sass --save-dev</span><br></pre></td></tr></table></figure>
<p>结果很显然，当然是安装不上。然后换 npm 的源，我用的是 nrm 来管理的 npm 源。也需要用 nrm 的可以安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure>
<p>然后查看我的 npm 源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm ls</span><br><span class="line"></span><br><span class="line">  npm -------- https://registry.npmjs.org/</span><br><span class="line">  yarn ------- https://registry.yarnpkg.com/</span><br><span class="line">  cnpm ------- http://r.cnpmjs.org/</span><br><span class="line">* taobao ----- https://registry.npm.taobao.org/</span><br><span class="line">  nj --------- https://registry.nodejitsu.com/</span><br><span class="line">  npmMirror -- https://skimdb.npmjs.com/registry/</span><br><span class="line">  edunpm ----- http://registry.enpmjs.org/</span><br></pre></td></tr></table></figure>
<p>*号代表当前使用的源，切换源的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nrm use npm</span><br></pre></td></tr></table></figure>
<p>这样就切换到了 npm 的源。我使用淘宝源，下载 node-sass，这个就是佛系了，有时网络好就下载下来了，不好就下载不了，现在大部分有时下不下来（yarn 也是一样的问题）。然后我就用 cpm 来下载。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install node-sass --save-dev</span><br></pre></td></tr></table></figure>
<p>结果是 cnpm 能够很快的下载下来，但是总有文章说使用 cnpm 有时会出现莫名的问题，这让我也很尴尬，所以也就寻找其他方法，然后找到了，对 node-sass 的包单独换源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> sass_binary_site https://npm.taobao.org/mirrors/node-sass/</span><br></pre></td></tr></table></figure>
<p>然后在用 npm 就可以下载了，结果很奈斯</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过程是曲折的，但是结果是美好的，遇到问题慢慢找办法，这就是成长。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>在react函数式组件中用hook使用debounce和throttle工具函数</title>
    <url>/2019/12/05/%E5%9C%A8-react-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%ADhook-%E4%BD%BF%E7%94%A8-debounce-%E5%92%8C-throttle-%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>之前在 react 的类组件中就使用过 lodash 的防抖和节流的工具函数，具体可查看文章。但是当 hook 盛行的时候，我也尝试用这种方式来从新使用一次，但是在使用的过程中出现了挖坑填坑，特此记录下，方便自己查看。<a id="more"></a></p>
<h3 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个滚动的事件函数</span></span><br><span class="line"><span class="keyword">const</span> onOwnScroll = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.persist()</span><br><span class="line">  <span class="keyword">if</span> (e.target) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; target &#125; = e</span><br><span class="line">    <span class="keyword">if</span> (target.scrollTop + target.offsetHeight === target.scrollHeight &amp;&amp; data.length &lt; total) &#123;</span><br><span class="line">      onPopupScroll() <span class="comment">// 父组件方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个防抖使用函数</span></span><br><span class="line"><span class="keyword">const</span> debounceFnSearch = useCallback(debounce(onSearch, <span class="number">1000</span>), [loading])</span><br></pre></td></tr></table></figure>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>这里遇到的坑就是，我之前是这样写的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debounceFnSearch = useCallback(debounce(onSearch, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<p>我想在事件结束后更新 loading 的状态，但是 loading 的状态没有更新,最后知道防抖原来有数据缓存，需要传入需要更新的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debounceFnSearch = useCallback(debounce(onSearch, <span class="number">1000</span>), [loading])</span><br></pre></td></tr></table></figure>
<p>以上就是踩的小坑，记录下</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>初次尝试配置nginx服务器</title>
    <url>/2019/12/03/%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95%E9%85%8D%E7%BD%AEnginx%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>一般服务器是 linux 系统，所以我也是在这个系统下安装使用 nginx 的，简单记录下使用过程</p>
<ol>
<li>在 linux 系统上安装 nginx 有很多方式，我这里选择一个比较简单的方式 yum 来进行安装。一般买的服务器都默认装好了以下工具，如果没有就安装一下：<a id="more"></a>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf pcre-devel make automake</span><br><span class="line">yum -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看服务器是否有 nginx 的 yum 源，有的话就可以直接安装，如果没有就先配置 yum 源：</li>
</ol>
<ul>
<li>查看源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不存在，或者不是你需要的版本，那我们可以自行配置 yum 源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>
<ul>
<li>把配置写入到以下配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure>
<ul>
<li>赋值完成后，你需要修改一下对应的操作系统和版本号，因为我的是 centos 和 7 的版本，所以改为这样。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baseurl=http://nginx.org/packages/centos/7/$basearch/</span><br></pre></td></tr></table></figure>
<ul>
<li>yum 安装 nginx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>验证安装是否成功并查看版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure>
<p>如果出现版本号的详细信息就说明成功了</p>
<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><ol>
<li>查看安装 nginx 的文件夹</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ql nginx</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>找到 nginx 的配置文件并打开</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /etc/nginx</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看基本的配置信息</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行用户，默认即是nginx，可以不进行设置</span></span><br><span class="line">user  nginx;</span><br><span class="line"><span class="comment">#Nginx进程，一般设置为和CPU核数一样</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"><span class="comment">#错误日志存放目录</span></span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line"><span class="comment">#进程pid存放位置</span></span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024; <span class="comment"># 单个后台进程的最大并发数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;   <span class="comment">#文件扩展名与类型映射表</span></span><br><span class="line">    default_type  application/octet-stream;  <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="comment">#设置日志模式</span></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;   <span class="comment">#nginx访问日志存放位置</span></span><br><span class="line"></span><br><span class="line">    sendfile        on;   <span class="comment">#开启高效传输模式</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;    #减少网络报文段的数量</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;  <span class="comment">#保持连接的时间，也叫超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;  #开启gzip压缩</span></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf; <span class="comment">#包含的子配置项位置和文件</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看引入的默认配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /conf.d</span><br><span class="line">vim default.conf</span><br></pre></td></tr></table></figure>
<p>然后看配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;   <span class="comment">#配置监听端口</span></span><br><span class="line">    server_name  localhost;  //配置域名</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;     <span class="comment">#服务默认启动目录</span></span><br><span class="line">        index  index.html index.htm;    <span class="comment">#默认访问文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;   # 配置404页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;   <span class="comment">#错误状态码的显示页面，配置后需要重启</span></span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx's one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>看了以上配置可以找到我们的静态页面存放的位置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/share/nginx/html</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>到此我们的 nginx 基本配置使用完成，可以打开浏览器输入服务器地址验证下。如果没有出现 nginx 的欢迎页，还需要去服务器配置开放 80 端口。</p>
<h3 id="Nginx-服务启动、停止、重启"><a href="#Nginx-服务启动、停止、重启" class="headerlink" title="Nginx 服务启动、停止、重启"></a>Nginx 服务启动、停止、重启</h3><ol>
<li>启动</li>
</ol>
<ul>
<li>nginx 直接启动</li>
</ul>
<p>在 CentOS7.4 版本里（低版本是不行的），是可以直接直接使用 nginx 启动服务的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 systemctl 命令启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure>
<ul>
<li>输入命令后，没有任何提示,可以输入以下命令查询下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>停止 Nginx 服务</li>
</ol>
<ul>
<li>立即停止服务，直接停止进程。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx  -s stop</span><br></pre></td></tr></table></figure>
<ul>
<li>从容停止服务，需要进程完成当前工作后再停止。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure>
<ul>
<li>killall 方法杀死进程，直接杀死</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">killall nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>systemctl 停止</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop nginx.service</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>重启 Nginx 服务</li>
</ol>
<ul>
<li>重新启动服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure>
<ul>
<li>重新载入配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>查看端口占用情况</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -tlnp</span><br></pre></td></tr></table></figure>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ul>
<li>最简单的反向代理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name water.wangyuanweb.top;</span><br><span class="line">        location / &#123;</span><br><span class="line">               proxy_pass http://www.baidu.com;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>react必知必会</title>
    <url>/2019/05/09/react%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="React-面试题-amp-回答"><a href="#React-面试题-amp-回答" class="headerlink" title="React 面试题 &amp; 回答"></a>React 面试题 &amp; 回答</h1><blockquote>
<p>本项目的面试题来源于 <a href="https://github.com/sudheerj/reactjs-interview-questions" rel="external nofollow noopener noreferrer" target="_blank">sudheerj/reactjs-interview-questions</a> 这个项目。<br>中文版<a href="https://github.com/semlinker/reactjs-interview-questions" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/semlinker/reactjs-interview-questions</a><br><a id="more"></a></p>
</blockquote>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>取数组最大值的几种方法</title>
    <url>/2019/05/09/%E5%8F%96%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="取数组最大值的几种方法"><a href="#取数组最大值的几种方法" class="headerlink" title="取数组最大值的几种方法"></a>取数组最大值的几种方法</h3><p>var arr = [7,2,0,-3,5];</p>
<h4 id="apply-应用某一对象的一个方法，用另一个对象替换当前对象"><a href="#apply-应用某一对象的一个方法，用另一个对象替换当前对象" class="headerlink" title="apply()应用某一对象的一个方法，用另一个对象替换当前对象"></a>apply()应用某一对象的一个方法，用另一个对象替换当前对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var max = Math.max.apply(null,arr);</span><br><span class="line">console.log(max)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>由于 max()里面参数不能为数组，所以借助 apply(funtion,args)方法调用 Math.max()，function 为要调用的方法，args 是数组对象，当 function 为 null 时，默认为上文,即相当于 apply(Math.max,arr)</p>
<h4 id="call-调用一个对象的一个方法，以另一个对象替换当前对象"><a href="#call-调用一个对象的一个方法，以另一个对象替换当前对象" class="headerlink" title="call()调用一个对象的一个方法，以另一个对象替换当前对象"></a>call()调用一个对象的一个方法，以另一个对象替换当前对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var max1 = Math.max.call(null,7,2,0,-3,5)</span><br><span class="line">console.log(max1)</span><br></pre></td></tr></table></figure>
<p>call()与 apply()类似，区别是传入参数的方式不同，apply()参数是一个对象和一个数组类型的对象，call()参数是一个对象和参数列表</p>
<h4 id="sort-reverse"><a href="#sort-reverse" class="headerlink" title="sort()+reverse()"></a>sort()+reverse()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//sort()排序默认为升序，reverse()将数组掉个</span><br><span class="line">var max3 = arr.sort().reverse()[0];</span><br><span class="line">console.log(max3)</span><br></pre></td></tr></table></figure>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//b-a 从大到小，a-b 从小到大</span><br><span class="line">var max2 = arr.sort(function(a,b)&#123;</span><br><span class="line">return b-a;</span><br><span class="line">&#125;)[0];</span><br><span class="line">console.log(max2)</span><br></pre></td></tr></table></figure>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var max3 = arr.sort().pop();</span><br><span class="line">console.log(max3)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>堆栈内存及闭包详解</title>
    <url>/2019/03/13/%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%E5%8F%8A%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过自己的总结和学习，记录的一点笔记</p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><ol>
<li>先声明一个变量 <code>a</code>，没有赋值</li>
<li>在当前作用域开辟一个位置存储 <code>12</code></li>
<li>让变量 <code>a</code>和 <code>12</code> 关联在一起(定义：赋值)</li>
<li>基础值类型就是直接操作值，和变量没有关系</li>
<li>引用类型是按照引用的空间地址进行操作，地址都是一个。<a id="more"></a></li>
<li>函数也是引用类型</li>
<li><ul>
<li>栈内存:作用域（代码都是在栈中执行的） 1. 提供一个提供 js 代码自上而下执行的环境 2. 由于基本数据类型值比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存储进去的 3. 栈内存被销毁，存储的基本值也销毁</li>
<li>堆内存:引用值对应的空间 1. 存储引用类型值的（对象：键值对 函数：代码字符串） 2. 当前堆内存销毁，那么引用消失 3. 堆内存没有被任何变量或者其他东西占用，就会被浏览器在空闲的时候，自主的进行内存回收，把所有不被占用的堆内存销毁 4. 销毁堆：XX=null</li>
</ul>
</li>
</ol>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><ol>
<li><p>当栈内存（作用域）形成，js 代码自上而下执行之前，浏览器首先会把所有带<code>var</code>和<code>function</code>关键词的进行提前的“声明”或者“定义”，这种预先处理机制称之为“变量提升”</p>
<ul>
<li>声明（declare）：<code>var a/function sum</code> (默认值 undefined)</li>
<li>定义（defined）：<code>a=12</code> (定义其实就是赋值)</li>
<li>变量提升阶段：带<code>var</code>的只声明未定义，带<code>funtion</code>的声明和赋值都完成了</li>
</ul>
</li>
<li><p>变量提升只发生在当前作用域（例如：开始加载页面的时候只对全局作用域下的进行提升，因为 此时函数中存储的都是字符串而已）</p>
</li>
<li>在全局作用域下声明的函数或者变量是“全局变量”，同理，在私有作用域下声明的变量是“私有变 量”（带<code>var/function</code>的才是声明）</li>
<li>浏览器很懒，做过的事情不会重复执行第二遍，也就是，当代码执行遇到创建函数这部分代码后，直接的跳过即可（因为在提升阶段就已经完成函数的赋值操作了）</li>
<li>私有作用域形成后，也不是立即执行代码，而是先进行变量提升（变量提升钱，先形参赋值）</li>
<li>在<code>es3/es5</code>语法规范中，只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存</li>
</ol>
<h3 id="带-var-和不带-var-的区别"><a href="#带-var-和不带-var-的区别" class="headerlink" title="带 var 和不带 var 的区别"></a>带 var 和不带 var 的区别</h3><ol>
<li>在全局作用域下声明一个变量，也相当于给 <code>window</code> 全局对象设置了一个属性，变量的值就是属性值（私用作用域中声明的私有变量和 <code>window</code>没啥关系）</li>
<li>在变量提升阶段，在全局作用域中声明了一个变量<code>a</code>，此时就已经把<code>a</code>当做属性赋值给 <code>window</code> 了，只不过此时还没有给 <code>a</code> 赋值，默认 <code>undefined</code></li>
<li><code>in</code>操作符可以检测某个属性是否属于这个对象</li>
<li>全局变量和 <code>window</code> 中的属性存在“映射机制”</li>
<li><code>a=12=&gt;window.a=12</code> 不加 <code>var</code> 的本质是 <code>window</code> 的属性。<code>var a=b=12</code> 这样写 <code>b</code> 是不带 <code>var</code> 的</li>
<li>私有作用域中带 var 和不带也有区别<ol>
<li>带 <code>var</code> 的在私有作用域变量提升阶段，都声明为私有变量，和外界没有任何的关系</li>
<li>不带 <code>var</code> 不是私有变量，会向它的上级作用域查找，一直找到 <code>window</code> 为止（我们把这种查找机制叫做：‘作用域链’），也就是我们在私有作用域中操作的这个非私有变量，是一直操作别人的。</li>
</ol>
</li>
</ol>
<p>###　作用域链的扩展</p>
<ol>
<li>在作用域链查找的过程中，如果找到 <code>window</code> 也没有这个变量，相当于给 <code>window</code> 设置一个属性</li>
</ol>
<h3 id="变量提升的一些细节问题（关于条件判断下的处理）"><a href="#变量提升的一些细节问题（关于条件判断下的处理）" class="headerlink" title="变量提升的一些细节问题（关于条件判断下的处理）"></a>变量提升的一些细节问题（关于条件判断下的处理）</h3><ol>
<li>匿名函数之函数表达式<code>var fn = function () {}</code></li>
<li><code>var fn</code>只对左边进行变量提升</li>
<li>（条件判断下）在当前作用域下，不管条件是否成立都要进行变量提升，带 <code>var</code> 的还是只声明，带 <code>function</code> 的在老版本浏览器渲染机制之下，声明加定义都处理了，但是为了迎合 <code>es6</code> 中的块级作用域， 新版浏览器对于函数（在条件判断中的函数），不管条件是否成立，都只是先声明，没有定义，类似 <code>var</code><br>4.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 没有变量提升</span><br><span class="line">f=function()&#123;return true&#125;;</span><br><span class="line">g=function()&#123;return false&#125;;</span><br><span class="line">~function()&#123;</span><br><span class="line">    // 变量提升：funtion g; g是私有变量</span><br><span class="line">    if(g()&amp;&amp;[]==![])&#123;</span><br><span class="line">        // 新浏览器Uncaught TypeError: g is not a function (此时的g是undefined)</span><br><span class="line">        // 老浏览器不会</span><br><span class="line">        // []==![]是true</span><br><span class="line">        f=function()&#123;return false&#125; // 把全局中的f进行修改 false</span><br><span class="line">        function g()&#123;return true&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 老版本浏览器</span><br><span class="line">console.log(f()); // false</span><br><span class="line">console.log(g()); // false</span><br></pre></td></tr></table></figure>
<h3 id="条件判断下的变量提升到底有多坑"><a href="#条件判断下的变量提升到底有多坑" class="headerlink" title="条件判断下的变量提升到底有多坑"></a>条件判断下的变量提升到底有多坑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 变量提升：function fn;</span><br><span class="line">console.log(fn); =&gt;undefined</span><br><span class="line">if (1===1)&#123;</span><br><span class="line">    console.log(fn);=&gt;函数本身：当条件成立，进入到判断体中（在es6中它是一个块级作用域）第一件事并不是代码执行，而是类似于变量提升一样，先把fn声明和定义了，也就是判断体中代码执行之前，fn就已经赋值了</span><br><span class="line">    function fn() &#123;</span><br><span class="line">        console.log(&apos;ok&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(fn);=&gt;输出函数本身</span><br></pre></td></tr></table></figure>
<h3 id="变量提升机制下重名的处理"><a href="#变量提升机制下重名的处理" class="headerlink" title="变量提升机制下重名的处理"></a>变量提升机制下重名的处理</h3><ol>
<li>带 <code>var</code> 和 <code>function</code> 关键字声明相同的名字，这种也算是重名了（其实是一个变量，只是存储值的类型不一样）</li>
<li>关于重名的处理：如果名字重复了，不会重新的声明，但是会重新的定义（重新赋值）&lt;不管是变量的提升还是代码执行阶段皆是如此&gt;</li>
<li>代码有报错，下面的代码不在执行</li>
</ol>
<h3 id="ES6-中的-let-不存在变量提升"><a href="#ES6-中的-let-不存在变量提升" class="headerlink" title="ES6 中的 let 不存在变量提升"></a>ES6 中的 let 不存在变量提升</h3><ol>
<li>在 <code>es6</code> 中基于 <code>let/const</code> 等方式创建变量或者函数，不存在变量提升机制，切断了全局变量和 <code>window</code> 属性的映射机制</li>
<li>在相同的作用域中，基于 <code>let</code> 不能声明相同名字的变量（不管用什么方式在当前作用域下声明了变量，再次使用 let 创建都会报错）</li>
<li>虽然没有变量提升机制，但是在当前作用域代码自上而下执行之前，浏览器会做一个重复性检测（语法检测）：自上而下查找当前作用域下所有变量，一旦发现有重复的，直接抛出异常，代码也不会再执行了（虽然没有把变量提前升声明定义，但是浏览器已经记住了，当前作用域下有哪些变量）</li>
</ol>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><ol>
<li>基于 <code>let</code> 创建变量，会把大部分{}当做一个私有的块级作用域（类似于函数的私有作用域），在这里也是重新检测语法规范，看一下是否基于新语法规范创建的变量，如果是则按照新语法规范来解析</li>
<li>在原有浏览器渲染机制下，基于 typeof 等逻辑运算符检测一个未被声明过的变量，不会报错，返回 <code>undefined</code></li>
<li>如果当前变量是基于 <code>es6</code> 语法处理，在没有声明这个变量的时候，使用 <code>typeof</code> 检测会直接报错，不会 <code>undefined</code> 解决了原有的 <code>js</code> 的暂时性死区</li>
</ol>
<h3 id="区分私有变量和全局变量"><a href="#区分私有变量和全局变量" class="headerlink" title="区分私有变量和全局变量"></a>区分私有变量和全局变量</h3><ol>
<li>在私有作用域中，只有以下两种情况是私有变量：A.声明过的变量（带 var/function）B.形参也是私有变量； 剩下的都不是自己私有的变量，都需要基于作用域链的机制向上查找</li>
</ol>
<h3 id="上级作用域的查找"><a href="#上级作用域的查找" class="headerlink" title="上级作用域的查找"></a>上级作用域的查找</h3><ol>
<li>当前函数执行，形成一个私有作用域 A，A 的上级作用域是谁，和他在哪执行的没有关系，和他在哪创建（定义）的有关系，在哪创建的，他的上级作用域就是谁</li>
<li><code>arguments</code> 是函数实参集合，<code>arguments.callee</code> 是函数本身，<code>arguments.callee.caller</code> 是当前函数在哪执行的，<code>caller</code> 就是谁（记录的是他执行的宿主环境），在全局下执行 <code>caller</code> 的结果是 <code>null</code></li>
</ol>
<h3 id="闭包及堆栈内存释放"><a href="#闭包及堆栈内存释放" class="headerlink" title="闭包及堆栈内存释放"></a>闭包及堆栈内存释放</h3><ol>
<li><p><code>js</code> 中的内存分为堆内存和栈内存<br>堆内存：存储引用数据类型值（对象：键值对 函数：代码字符串）<br>栈内存：提供 <code>js</code> 代码执行的环境和存储基本类型值</p>
</li>
<li><p>堆内存释放：让所有引用堆内存空间地址的变量赋值为 <code>null</code> 即可（没有变量占用这个堆内存了，浏览器会在空闲的时候把它释放掉）<br>栈内存释放： 一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉（在栈内存中存储的值也会释放掉），但是也有特殊不销毁的情况：</p>
<ul>
<li>函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放（一旦释放外面找不到原有的内容了）</li>
<li>全局栈内只有在页面关闭的时候才会被释放掉，如果当时栈内存没有被释放，那么之前在栈内存中存储的基本值也不会被释放，能够一直保存下来。</li>
</ul>
</li>
<li><p><code>var f = fn(2)</code> =&gt;先把 <code>fn</code> 执行（传递实参 2），把 <code>fn</code> 执行的返回结果（return 后面的值）赋值给 <code>f</code>,<code>f()</code>=&gt;把返回的结果执行。<code>fn(2)()</code>=&gt;和上面两步骤类似，都是先把 <code>fn</code> 执行，在 <code>fn</code> 执行的返回结果再次执行</p>
</li>
<li><p><code>i++</code> 自身累加 <code>1</code>: 先运算在累加<br><code>++i</code> 自身累加 <code>1</code>: 先累加在运算</p>
</li>
</ol>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ol>
<li>闭包：</li>
</ol>
<ul>
<li>函数执行形成一个私有的作用域，保护里面的私有变量不受外界的干扰，这种保护机制称之为闭包</li>
<li>市面上的开发者认为的闭包：形成一个不销毁的私有作用域（私有栈内存）才是闭包</li>
<li>闭包：柯理化函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    return function ()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = fn</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">-   闭包：惰性函数</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">var utils = (function () &#123;</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>闭包项目实战应用</li>
</ol>
<ul>
<li><p>真实项目中为了保证 js 的性能（堆栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的）</p>
</li>
<li><p>闭包具有保护作用：保护私有变量不受外界的干扰 jq</p>
<ul>
<li><p>在真实项目中，尤其是团队协作开发的时候，应当尽可能的减少全局变量的使用，以防止相互之间的冲突（‘全局变量污染’），那么此时我们完全可以把自己这一部分内容封装到一个闭包中，让全局变量转换为私有变量(function(){<br>var n =12<br>function fn(){</p>
<p>}<br>})()</p>
</li>
<li><p>不仅如此，我们封装类库插件的时候，也会把自己的程序都存放到闭包中保护起来，防止和用户的程序冲突，但是我们又需要暴露一些方法给客户使用，这样我们如何出理？</p>
</li>
<li>jq 这种方式：把需要暴露的方法抛到全局</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    function jQuery() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    把需要提供外面使用的方法，通过给win设置属性的方式暴露出去</span><br><span class="line">    window.jQuery = window.$ = jQuery;</span><br><span class="line">&#125;)()</span><br><span class="line">jQuery();</span><br><span class="line">$()</span><br></pre></td></tr></table></figure>
<ul>
<li>Zepto 这种方式：基于 return 把需要供外面使用的方法暴露出去</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Zepto = (function()&#123;</span><br><span class="line">    ...</span><br><span class="line">    return &#123;</span><br><span class="line">        xxx: function()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">Zepto.xxx()</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包具有保存作用：形成不销毁的栈内存，把一些值保存下来，方便后面的调取使用</p>
</li>
</ul>
<ol start="3">
<li>闭包作用之保存</li>
</ol>
<ul>
<li>循环和判断都不会形成私有作用域（栈内存），<code>for</code> 循环执行，形成一个私有的栈内存，遇到变量 <code>i</code>，<code>i</code> 不是私有变量，向上一级作用域查找（上级作用域是 win）</li>
</ul>
<ul>
<li>所有的事件绑定都是异步编程（同步编程：一件事一件事的做，当前这件事没有完成，下一个任务不能处理/异步编程：当前这件事件没有彻底完成，不再等待，继续执行下面的任务），绑定事件后，不需要等待执行，继续执行下一个循环任务，所以当我们点击执行方法的时候，循环早已结束（让全局的等于循环最后的结果）</li>
<li><p>解决方案：</p>
<ul>
<li>自定义属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i = 0,i&lt;tabList.length;i++)&#123;</span><br><span class="line">    tabList[i].myIndex = i;</span><br><span class="line">    tabList[i].onclick = function()&#123;</span><br><span class="line">        changeTab(this.myIndex)</span><br><span class="line">    &#125;</span><br><span class="line">    // this:给当前元素的某个时间绑定方法，当事件触发，方法执行的时候，方法中的this是当前操作的元素对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包解决</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i = 0,i&lt;tabList.length;i++)&#123;</span><br><span class="line">    tabList[i].onclick = (function(n)&#123;</span><br><span class="line">        // 让自执行函数执行，把执行的返回值（return）赋值给此处on-click（on-click绑定的是返回的小函数，点击的时候执行的是小函数），自执行函数在给事件赋值的时候就已经执行了</span><br><span class="line">        var i=n;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            changeTab(i); // 上级作用域：自执行函数形成的作用域</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 总结：循环几次，形成几个不销毁的私有作用域（自执行函数执行），而每一个不销毁的栈内存中都存储了一个私有变量，而这个值分别是每一次执行传递进来的全局i的值，当点击的时候，执行返回的小函数，遇到变量i，向它自己的上级作用域查找，找到i的值</span><br></pre></td></tr></table></figure>
<ul>
<li>基于 ES6 解决</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let i = 0,i&lt;tabList.length;i++)&#123;</span><br><span class="line">    // 循环体也是块级作用域，初始值设置的变量是当前本次块级作用域中的变量（形成了i个块级作用域，每个块级作用域中都有一个私有变量i，变量值就是每一次循环的i）</span><br><span class="line">        tabList[i].onclick = function()&#123;</span><br><span class="line">            changeTab(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 基于es6中的let来创建变量，是存在块级作用域的（类似于私有作用域）</span><br><span class="line">    // 作用域（栈内存）1. 全局作用域 2.私有作用域 3.块级作用域（一般用大括号包起来的都是块级作用域，前提是es6语法规范）</span><br><span class="line">    // 对象的&#123;&#125;不是块级作用域</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>数组去重方法</title>
    <url>/2018/12/12/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="双重循环"><a href="#双重循环" class="headerlink" title="双重循环"></a>双重循环</h3><p>1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const newArray = [];</span><br><span class="line">  let isRepeat;</span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    isRepeat = false;</span><br><span class="line">    for (let j = 0; j &lt; newArray.length; j++) &#123;</span><br><span class="line">      if (this[i] === newArray[j]) &#123;</span><br><span class="line">        isRepeat = true;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isRepeat) &#123;</span><br><span class="line">      newArray.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const newArray = [];</span><br><span class="line">  let isRepeat;</span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    isRepeat = false;</span><br><span class="line">    for (let j = i + 1; j &lt; this.length; j++) &#123;</span><br><span class="line">      if (this[i] === this[j]) &#123;</span><br><span class="line">        isRepeat = true;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isRepeat) &#123;</span><br><span class="line">      newArray.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const newArray = [];</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    for (let j = i + 1; j &lt; this.length; j++) &#123;</span><br><span class="line">      if (this[i] === this[j]) &#123;</span><br><span class="line">        j = ++i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newArray.push(this[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-indexOf"><a href="#Array-prototype-indexOf" class="headerlink" title="Array.prototype.indexOf()"></a>Array.prototype.indexOf()</h3><p>1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  return this.filter((item, index) =&gt; &#123;</span><br><span class="line">    return this.indexOf(item) === index;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 3, 22, 233, 22, 2, 233, &apos;a&apos;, 3, &apos;b&apos;, &apos;a&apos;];</span><br><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const newArray = [];</span><br><span class="line">  this.forEach(item =&gt; &#123;</span><br><span class="line">    if (newArray.indexOf(item) === -1) &#123;</span><br><span class="line">      newArray.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a>Array.prototype.sort()</h3><p>1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const newArray = [];</span><br><span class="line">  this.sort();</span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    if (this[i] !== this[i + 1]) &#123;</span><br><span class="line">      newArray.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const newArray = [];</span><br><span class="line">  this.sort();</span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    if (this[i] !== newArray[newArray.length - 1]) &#123;</span><br><span class="line">      newArray.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###　 Array.prototype.includes()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const newArray = [];</span><br><span class="line">  this.forEach(item =&gt; &#123;</span><br><span class="line">    if (!newArray.includes(item)) &#123;</span><br><span class="line">      newArray.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  return this.sort().reduce((init, current) =&gt; &#123;</span><br><span class="line">    if(init.length === 0 || init[init.length - 1] !== current)&#123;</span><br><span class="line">      init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    return init;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象键值对"><a href="#对象键值对" class="headerlink" title="对象键值对"></a>对象键值对</h3><p>1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const newArray = [];</span><br><span class="line">  const tmp = &#123;&#125;;</span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    if (!tmp[typeof this[i] + this[i]]) &#123;</span><br><span class="line">      tmp[typeof this[i] + this[i]] = 1;</span><br><span class="line">      newArray.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const newArray = [];</span><br><span class="line">  const tmp = &#123;&#125;;</span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    // 使用JSON.stringify()进行序列化</span><br><span class="line">    if (!tmp[typeof this[i] + JSON.stringify(this[i])]) &#123;</span><br><span class="line">      // 将对象序列化之后作为key来使用</span><br><span class="line">      tmp[typeof this[i] + JSON.stringify(this[i])] = 1;</span><br><span class="line">      newArray.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const newArray = [];</span><br><span class="line">  const tmp = new Map();</span><br><span class="line">  for(let i = 0; i &lt; this.length; i++)&#123;</span><br><span class="line">        if(!tmp.get(this[i]))&#123;</span><br><span class="line">            tmp.set(this[i], 1);</span><br><span class="line">            newArray.push(this[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const tmp = new Map();</span><br><span class="line">  return this.filter(item =&gt; &#123;</span><br><span class="line">    return !tmp.has(item) &amp;&amp; tmp.set(item, 1);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  const set = new Set(this);</span><br><span class="line">  return Array.from(set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">  return [...new Set(this)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原生-js-实例封装"><a href="#原生-js-实例封装" class="headerlink" title="原生 js 实例封装"></a>原生 js 实例封装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.myUnique = function () &#123;</span><br><span class="line">            var obj = &#123;&#125;;</span><br><span class="line">            for(var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">                var cur = this[i];</span><br><span class="line">                if(obj[cur] === cur)&#123;</span><br><span class="line">                    this[i] = this[this.length-1];</span><br><span class="line">                    this.length--;</span><br><span class="line">                    i--;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                obj[cur] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">                obj = null;</span><br><span class="line">                return this;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>css布局自省</title>
    <url>/2018/11/01/css%E5%B8%83%E5%B1%80%E8%87%AA%E7%9C%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>布局是我们前端开发中不可避免的，简单回忆一下 css 的布局方案，供大家参考以及自己参阅。</p>
<h3 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h3><p>这里的居中布局是不定宽度为前提，固定宽度情况也包含其中。</p>
<h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><ol>
<li><code>inline-block + text-align</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.child &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这个方案的兼容性比较好，可兼容到 IE8，对于 IE567 不支持<code>inline-block</code>,需要使用 css hack 进行兼容。</p>
<ol start="2">
<li><code>table + margin</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">    display: table;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方案兼容到 IE8，可以使用<table>代替 css 写法，兼容性更好。</table></p>
<ol start="3">
<li><code>absolute + transform</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position:relative;</span><br><span class="line">    height:1.5em;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    left:50%;</span><br><span class="line">    transform:translateX(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方案兼容到 IE9，因为<code>transform</code>兼容性导致，如果<code>.child</code>为定宽元素，可以使用以下写法，提高兼容性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    height:1.5em;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width:100px;</span><br><span class="line">    left:50%;</span><br><span class="line">    margin-left:-50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>flex + justify-content</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    justify-content;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex 布局很强大，但是受到兼容的限制。不考虑兼容可以大胆使用。</p>
<h4 id="垂直居中布局"><a href="#垂直居中布局" class="headerlink" title="垂直居中布局"></a>垂直居中布局</h4><ol>
<li><code>table-cell + vertial-align</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方案可以用<table>替换，提高兼容性。</table></p>
<ol start="2">
<li><code>absolute + transform</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translateY(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>css3 新属性兼容性不是很好。</p>
<ol start="3">
<li><code>flex + align-items</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>兼容性不是很好,不考虑低版本浏览器。</p>
<h4 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h4><ol>
<li><code>inline-block + table-cell + text-align + vertical-align</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	text-align: center;</span><br><span class="line">	display: table-cell;</span><br><span class="line">	vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">	display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>兼容到 IE8.</p>
<ol start="2">
<li><code>absolute + transform</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	left: 50%;</span><br><span class="line">	top: 50%;</span><br><span class="line">	transform: translate(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>兼容性差，兼容 IE10 以上</p>
<ol start="3">
<li><code>flex</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	display: flex;</span><br><span class="line">	justify-content: center;</span><br><span class="line">	align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>兼容差</p>
<h3 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h3><h4 id="一列定宽，一列自适应"><a href="#一列定宽，一列自适应" class="headerlink" title="一列定宽，一列自适应"></a>一列定宽，一列自适应</h4><ol>
<li><code>float + margin</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.left&#123;</span><br><span class="line">	float: left;</span><br><span class="line">	width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	margin-left: 120px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方案对于定宽布局比较好，不定宽布局推荐下面方法 2.</p>
<ol start="2">
<li><code>float + overflow</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.left&#123;</span><br><span class="line">	float: left;</span><br><span class="line">	width: 100px;</span><br><span class="line">	margin-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方案不管是多列定宽或是不定宽，都可以完美实现，同时可以实现等高布局。</p>
<ol start="3">
<li><code>table</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	display: table; width: 100%;</span><br><span class="line">	table-layout: fixed;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">	display: table-cell;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">	padding-right: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>flex</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">	padding-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多列定宽，一列自适应"><a href="#多列定宽，一列自适应" class="headerlink" title="多列定宽，一列自适应"></a>多列定宽，一列自适应</h4><ol>
<li><code>float + overflow</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.left,.center&#123;</span><br><span class="line">	float: left;</span><br><span class="line">	width: 100px;</span><br><span class="line">	margin-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>table</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	display: table; width: 100%;</span><br><span class="line">	table-layout: fixed;</span><br><span class="line">&#125;</span><br><span class="line">.left,.center,.right&#123;</span><br><span class="line">	display: table-cell;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">	padding-right: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>flex</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left,.center&#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">	padding-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一列不定宽，一列自适应"><a href="#一列不定宽，一列自适应" class="headerlink" title="一列不定宽，一列自适应"></a>一列不定宽，一列自适应</h4><ol>
<li><code>float + overflow</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.left&#123;</span><br><span class="line">	float: left;</span><br><span class="line">	margin-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.left p&#123;width: 200px;&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>table</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	display: table; width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">	display: table-cell;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">	width: 0.1%;</span><br><span class="line">	padding-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.left p&#123;width:200px;&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>flex</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">	margin-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">.left p&#123;width: 200px;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多列不定宽，一列自适应"><a href="#多列不定宽，一列自适应" class="headerlink" title="多列不定宽，一列自适应"></a>多列不定宽，一列自适应</h4><ol>
<li><code>float + overflow</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.left,.center&#123;</span><br><span class="line">	float: left;</span><br><span class="line">	margin-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.left p,.center p&#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等分"><a href="#等分" class="headerlink" title="等分"></a>等分</h4><ol>
<li><code>float + margin</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	margin-left: -20px;</span><br><span class="line">&#125;</span><br><span class="line">.column&#123;</span><br><span class="line">	float: left;</span><br><span class="line">	width: 25%;</span><br><span class="line">	padding-left: 20px;</span><br><span class="line">	box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>table + margin</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent-fix&#123;</span><br><span class="line">	margin-left: -20px;</span><br><span class="line">&#125;</span><br><span class="line">.parent&#123;</span><br><span class="line">	display: table;</span><br><span class="line">	width:100%;</span><br><span class="line">	table-layout: fixed;</span><br><span class="line">&#125;</span><br><span class="line">.column&#123;</span><br><span class="line">	display: table-cell;</span><br><span class="line">	padding-left: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>flex</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.column&#123;</span><br><span class="line">	flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">.column+.column&#123;</span><br><span class="line">	margin-left:20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等高"><a href="#等高" class="headerlink" title="等高"></a>等高</h4><ol>
<li><code>float + overflow</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">	padding-bottom: 9999px;</span><br><span class="line">	margin-bottom: -9999px;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">	float: left; width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>table</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	display: table;</span><br><span class="line">	width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">	display:table-cell;</span><br><span class="line">	width: 100px;</span><br><span class="line">	margin-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	display:table-cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>flex</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	display:flex;</span><br><span class="line">	width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">	flex:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并排等分，单排对齐靠左布局"><a href="#并排等分，单排对齐靠左布局" class="headerlink" title="并排等分，单排对齐靠左布局"></a>并排等分，单排对齐靠左布局</h3><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-flow: row wrap;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">.empty&#123;</span><br><span class="line">    height: 0;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="圣杯布局-amp-双飞翼布局"><a href="#圣杯布局-amp-双飞翼布局" class="headerlink" title="圣杯布局&amp;双飞翼布局"></a>圣杯布局&amp;双飞翼布局</h3><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;wrapper clearfix&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;main col&quot;&gt;main&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;left col&quot;&gt;left&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right col&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.container &#123;width: 500px; margin: 50px auto;&#125;</span><br><span class="line">.wrapper &#123;padding: 0 100px 0 100px;&#125;</span><br><span class="line">.col &#123;position: relative; float: left;&#125;</span><br><span class="line">.header,.footer &#123;height: 50px;&#125;</span><br><span class="line">.main &#123;width: 100%;height: 200px;&#125;</span><br><span class="line">.left &#123;width: 100px; height: 200px; margin-left: -100%;left: -100px;&#125;</span><br><span class="line">.right &#123;width: 100px; height: 200px; margin-left: -100px; right: -100px;&#125;</span><br><span class="line">.clearfix::after &#123;content: &quot;&quot;; display: block; clear: both; visibility: hidden; height: 0; overflow: hidden;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;wrapper clearfix&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;main col&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;main-wrap&quot;&gt;main&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;left col&quot;&gt;left&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right col&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.col &#123;float: left;&#125;</span><br><span class="line">.header &#123;height: 50px;&#125;</span><br><span class="line">.main &#123;width: 100%;&#125;</span><br><span class="line">.main-wrap &#123;margin: 0 100px 0 100px;height: 200px;&#125;</span><br><span class="line">.left &#123;width: 100px; height: 200px; margin-left: -100%;&#125;</span><br><span class="line">.right &#123;width: 100px; height: 200px; margin-left: -100px;&#125;</span><br><span class="line">.footer &#123;height: 50px;&#125;</span><br><span class="line">.clearfix::after &#123;content: &quot;&quot;; display: block; clear: both; visibility: hidden; height: 0; overflow: hidden;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定位布局"><a href="#定位布局" class="headerlink" title="定位布局"></a>定位布局</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main col&quot;&gt;</span><br><span class="line">        main</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;left col&quot;&gt;</span><br><span class="line">        left</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right col&quot;&gt;</span><br><span class="line">        right</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.wrapper &#123; position: relative; &#125;</span><br><span class="line">.main &#123; margin:0 100px;&#125;</span><br><span class="line">.left &#123; position: absolute; left: 0; top: 0;&#125;</span><br><span class="line">.right &#123; position: absolute; right: 0; top: 0;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>文字样式超出显示省略号</title>
    <url>/2018/09/04/%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>接到开发需求，然后简单看了下，找到一个文本超出两行显示省略号。虽然知道大概的思路，但是还是忘记了详细的 css 样式写法，特此记录下。<a id="more"></a></p>
<h3 id="文本单行超出显示省略号"><a href="#文本单行超出显示省略号" class="headerlink" title="文本单行超出显示省略号"></a>文本单行超出显示省略号</h3><p>如果实现单行文本的溢出显示省略号同学们应该都知道用 text-overflow:ellipsis 属性来，当然还需要加宽度 width 属来兼容部分浏览。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// css样式</span><br><span class="line"></span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure>
<h3 id="文本多行超出显示省略号（举列为-2-行）"><a href="#文本多行超出显示省略号（举列为-2-行）" class="headerlink" title="文本多行超出显示省略号（举列为 2 行）"></a>文本多行超出显示省略号（举列为 2 行）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// css 样式</span><br><span class="line"></span><br><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: 2;</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>因使用了 WebKit 的 CSS 扩展属性，该方法适用于 WebKit 浏览器及移动端；</li>
<li>将 height 设置为 line-height 的整数倍，防止超出的文字露出。</li>
<li>给 p::after 添加渐变背景可避免文字只显示一半。</li>
<li>由于 ie6-7 不显示 content 内容，所以要添加标签兼容 ie6-7（如：<span>…<span>）；兼容 ie8 需要将::after 替换成:after。</span></span></li>
</ol>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>本地新建文件夹怎么关联到远程仓库</title>
    <url>/2018/08/20/%E6%9C%AC%E5%9C%B0%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E6%80%8E%E4%B9%88%E5%85%B3%E8%81%94%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>有时我们在使用 git 的时候，会在本地生成文件夹然后关联到 github 上面的远程仓库。所以这里简单说下 git 的命令和关联步骤。<a id="more"></a></p>
<ol>
<li>本地生成文件夹</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir test</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入和 git 初始化本地仓库文件夹</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd test</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>git 添加所有文夹</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>git 提交所有文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;这里是log日志&quot; -a</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>github 上建立一个远程仓库</p>
</li>
<li><p>复制远程仓库的地址</p>
</li>
<li><p>连接到远程仓库</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/wangyuan0108/***.git</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>把本地项目推送到远程仓库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>create-react-app配置css moudles 和 scss 并防止和antd样式冲突</title>
    <url>/2018/07/30/create-react-app%E9%85%8D%E7%BD%AEcss-moudles-%E5%92%8C-scss-%E5%B9%B6%E9%98%B2%E6%AD%A2%E5%92%8Cantd%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们在使用 react 来开发的时候，用的是它的组件化开发的思想，在封装组件的时候，样式的书写方式和引入也是我们在开发中需要考虑的问题。这里简单记录下自己使用 css moudles 和解决与 antd 的样式发生冲突的过程<a id="more"></a></p>
<h3 id="配置-css-modules-和-sass-并且解决样式冲突"><a href="#配置-css-modules-和-sass-并且解决样式冲突" class="headerlink" title="配置 css modules 和 sass 并且解决样式冲突"></a>配置 css modules 和 sass 并且解决样式冲突</h3><p>因为 create-react-app 内置支持 css modules，所以只需开启下就好，先配置下 sass：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add sass-loader node-sass --dev</span><br></pre></td></tr></table></figure>
<p>我们需要给 webpack 配置上 css-modules 和 sass-loader。但是使用 css-modules 会使 node_modules 库里的 css 样式找不到，比如后面要使用到的 antd，这个时候我们需要 inclube 来排除影响 node_modules，使得 css-modules 不会影响到 node_modules。</p>
<p>修改项目中 config 目录下的 webpack.config.dev.js 和 webpack.config.prod.js，说明下这两个文件，前一个是开发环境 npm start 使用，后一个是 npm run build 打包后使用。</p>
<ul>
<li>修改 webpack.config.dev.js 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            //这里增加SCSS的支持,两种方式用一种就可以</span><br><span class="line">            // test: /.(css|scss)$/</span><br><span class="line">            test: [/\.css$/, /\.scss$/],</span><br><span class="line">            exclude: [/node_modules/],// 这里去排除node_modules，防止css modules影响到node_modules</span><br><span class="line">            use: [</span><br><span class="line">              require.resolve(&apos;style-loader&apos;),</span><br><span class="line">              &#123;</span><br><span class="line">                loader: require.resolve(&apos;css-loader&apos;),</span><br><span class="line">                options: &#123;</span><br><span class="line">                  importLoaders: 1,</span><br><span class="line">                  modules: true, // 这里增加对css modules的支持</span><br><span class="line">                  localIdentName: &apos;[name]__[local]__[hash:base64:5]&apos; //这里增加对css modules的支持</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                loader: require.resolve(&apos;sass-loader&apos;), // 这里增加sass的支持</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                loader: require.resolve(&apos;postcss-loader&apos;),</span><br><span class="line">                options: &#123;</span><br><span class="line">                  // Necessary for external CSS imports to work</span><br><span class="line">                  // https://github.com/facebookincubator/create-react-app/issues/2677</span><br><span class="line">                  ident: &apos;postcss&apos;,</span><br><span class="line">                  plugins: () =&gt; [</span><br><span class="line">                    require(&apos;postcss-flexbugs-fixes&apos;),</span><br><span class="line">                    autoprefixer(&#123;</span><br><span class="line">                      browsers: [</span><br><span class="line">                        &apos;&gt;1%&apos;,</span><br><span class="line">                        &apos;last 4 versions&apos;,</span><br><span class="line">                        &apos;Firefox ESR&apos;,</span><br><span class="line">                        &apos;not ie &lt; 9&apos;, // React doesn&apos;t support IE8 anyway</span><br><span class="line">                      ],</span><br><span class="line">                      flexbox: &apos;no-2009&apos;,</span><br><span class="line">                    &#125;),</span><br><span class="line">                  ],</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">          // 因为上面排除了css_modules所以这里一定要再添加个排除src来识别css_modules</span><br><span class="line">          // 其实就是复制之前没修改前的所有，再增加一个exclude: [/src/]</span><br><span class="line">          &#123;</span><br><span class="line">            test: /\.css$/,</span><br><span class="line">            exclude: [/src/], // 这里添加排除src，</span><br><span class="line">            use: [</span><br><span class="line">              require.resolve(&apos;style-loader&apos;),</span><br><span class="line">              &#123;</span><br><span class="line">                loader: require.resolve(&apos;css-loader&apos;),</span><br><span class="line">                options: &#123;</span><br><span class="line">                  importLoaders: 1,</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                loader: require.resolve(&apos;postcss-loader&apos;),</span><br><span class="line">                options: &#123;</span><br><span class="line">                  // Necessary for external CSS imports to work</span><br><span class="line">                  // https://github.com/facebookincubator/create-react-app/issues/2677</span><br><span class="line">                  ident: &apos;postcss&apos;,</span><br><span class="line">                  plugins: () =&gt; [</span><br><span class="line">                    require(&apos;postcss-flexbugs-fixes&apos;),</span><br><span class="line">                    autoprefixer(&#123;</span><br><span class="line">                      browsers: [</span><br><span class="line">                        &apos;&gt;1%&apos;,</span><br><span class="line">                        &apos;last 4 versions&apos;,</span><br><span class="line">                        &apos;Firefox ESR&apos;,</span><br><span class="line">                        &apos;not ie &lt; 9&apos;, // React doesn&apos;t support IE8 anyway</span><br><span class="line">                      ],</span><br><span class="line">                      flexbox: &apos;no-2009&apos;,</span><br><span class="line">                    &#125;),</span><br><span class="line">                  ],</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>webpack.config.prod.js 文件修改方式与 webpack.config.dev.js 方式类似</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">           //这里增加SCSS的支持,两种方式用一种就可以</span><br><span class="line">           // test: /.(css|scss)$/</span><br><span class="line">           test: [/\.css$/, /\.scss$/],</span><br><span class="line">           exclude: [/node_modules/], // 这里去排除node_modules</span><br><span class="line">           loader: ExtractTextPlugin.extract(</span><br><span class="line">             Object.assign(</span><br><span class="line">               &#123;</span><br><span class="line">                 fallback: &#123;</span><br><span class="line">                   loader: require.resolve(&apos;style-loader&apos;),</span><br><span class="line">                   options: &#123;</span><br><span class="line">                     hmr: false,</span><br><span class="line">                   &#125;,</span><br><span class="line">                 &#125;,</span><br><span class="line">                 use: [</span><br><span class="line">                   &#123;</span><br><span class="line">                     loader: require.resolve(&apos;css-loader&apos;),</span><br><span class="line">                     options: &#123;</span><br><span class="line">                       importLoaders: 1,</span><br><span class="line">                       minimize: true,</span><br><span class="line">                       sourceMap: true,</span><br><span class="line">                       modules: true, // 这里添加css modules支持</span><br><span class="line">                     &#125;,</span><br><span class="line">                   &#125;,</span><br><span class="line">                   &#123;</span><br><span class="line">                     loader: require.resolve(&apos;postcss-loader&apos;),</span><br><span class="line">                     options: &#123;</span><br><span class="line">                       // Necessary for external CSS imports to work</span><br><span class="line">                       // https://github.com/facebookincubator/create-react-app/issues/2677</span><br><span class="line">                       ident: &apos;postcss&apos;,</span><br><span class="line">                       plugins: () =&gt; [</span><br><span class="line">                         require(&apos;postcss-flexbugs-fixes&apos;),</span><br><span class="line">                         autoprefixer(&#123;</span><br><span class="line">                           browsers: [</span><br><span class="line">                             &apos;&gt;1%&apos;,</span><br><span class="line">                             &apos;last 4 versions&apos;,</span><br><span class="line">                             &apos;Firefox ESR&apos;,</span><br><span class="line">                             &apos;not ie &lt; 9&apos;, // React doesn&apos;t support IE8 anyway</span><br><span class="line">                           ],</span><br><span class="line">                           flexbox: &apos;no-2009&apos;,</span><br><span class="line">                         &#125;),</span><br><span class="line">                       ],</span><br><span class="line">                     &#125;,</span><br><span class="line">                   &#125;,</span><br><span class="line">                   &#123;</span><br><span class="line">                     loader: require.resolve(&apos;sass-loader&apos;), // 这里添加sass支持</span><br><span class="line">                   &#125;</span><br><span class="line">                 ],</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               extractTextPluginOptions</span><br><span class="line">             )</span><br><span class="line">           ),</span><br><span class="line">           // Note: this won&apos;t work without `new ExtractTextPlugin()` in `plugins`.</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           test: /\.css$/,</span><br><span class="line">           exclude: [/src/], // 排除src</span><br><span class="line">           loader: ExtractTextPlugin.extract(</span><br><span class="line">             Object.assign(</span><br><span class="line">               &#123;</span><br><span class="line">                 fallback: &#123;</span><br><span class="line">                   loader: require.resolve(&apos;style-loader&apos;),</span><br><span class="line">                   options: &#123;</span><br><span class="line">                     hmr: false,</span><br><span class="line">                   &#125;,</span><br><span class="line">                 &#125;,</span><br><span class="line">                 use: [</span><br><span class="line">                   &#123;</span><br><span class="line">                     loader: require.resolve(&apos;css-loader&apos;),</span><br><span class="line">                     options: &#123;</span><br><span class="line">                       importLoaders: 1,</span><br><span class="line">                       minimize: true,</span><br><span class="line">                       sourceMap: true,</span><br><span class="line">                     &#125;,</span><br><span class="line">                   &#125;,</span><br><span class="line">                   &#123;</span><br><span class="line">                     loader: require.resolve(&apos;postcss-loader&apos;),</span><br><span class="line">                     options: &#123;</span><br><span class="line">                       // Necessary for external CSS imports to work</span><br><span class="line">                       // https://github.com/facebookincubator/create-react-app/issues/2677</span><br><span class="line">                       ident: &apos;postcss&apos;,</span><br><span class="line">                       plugins: () =&gt; [</span><br><span class="line">                         require(&apos;postcss-flexbugs-fixes&apos;),</span><br><span class="line">                         autoprefixer(&#123;</span><br><span class="line">                           browsers: [</span><br><span class="line">                             &apos;&gt;1%&apos;,</span><br><span class="line">                             &apos;last 4 versions&apos;,</span><br><span class="line">                             &apos;Firefox ESR&apos;,</span><br><span class="line">                             &apos;not ie &lt; 9&apos;, // React doesn&apos;t support IE8 anyway</span><br><span class="line">                           ],</span><br><span class="line">                           flexbox: &apos;no-2009&apos;,</span><br><span class="line">                         &#125;),</span><br><span class="line">                       ],</span><br><span class="line">                     &#125;,</span><br><span class="line">                   &#125;</span><br><span class="line">                 ],</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               extractTextPluginOptions</span><br><span class="line">             )</span><br><span class="line">           ),</span><br><span class="line">           // Note: this won&apos;t work without `new ExtractTextPlugin()` in `plugins`.</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>antd</tag>
        <tag>create-react-app</tag>
      </tags>
  </entry>
  <entry>
    <title>create-react-app 配置scss第二种方法</title>
    <url>/2018/07/23/create-react-app-%E9%85%8D%E7%BD%AEscss%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在编写css的时候我们会用到预编译器scss，之前在用的时候找到了一种配置方法，但是现在又找到一种配置方法<a id="more"></a></p>
<h3 id="不使用yarn-eject命令的配置方式"><a href="#不使用yarn-eject命令的配置方式" class="headerlink" title="不使用yarn eject命令的配置方式"></a>不使用yarn eject命令的配置方式</h3><p>首先安装使用scss需要的包<code>sass-loader</code>,<code>node-sass</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add sass-loader node-sass --dev</span><br></pre></td></tr></table></figure>
<p>用create-react-app创建好项目之后，依次查找目录找到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node_modules =&gt; react-scripts =&gt; config =&gt; webpack.config.dev.js</span><br><span class="line"></span><br><span class="line">node_modules =&gt; react-scripts =&gt; config =&gt; webpack.config.prod.js</span><br></pre></td></tr></table></figure>
<p>然后找到文件中的以下位置并修改：</p>
<p><img src="http://dinping.wangyuanweb.top/18-7-23/63661560.jpg" alt="图片"></p>
<p>重新执行<code>yarn start</code></p>
<h3 id="使用yarn-eject命令的配置方式"><a href="#使用yarn-eject命令的配置方式" class="headerlink" title="使用yarn eject命令的配置方式"></a>使用yarn eject命令的配置方式</h3><p>首先执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn eject</span><br></pre></td></tr></table></figure>
<p>然后找到项目目录下的<code>config</code>文件夹找到配置文件<code>webpack.config.dev.js</code>和<code>webpack.config.prod.js</code>，然后配置同上图所示</p>
<p>然后执行<code>yarn start</code></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>少年请规范你的git commit message</title>
    <url>/2018/07/12/%E5%B0%91%E5%B9%B4%E8%AF%B7%E8%A7%84%E8%8C%83%E4%BD%A0%E7%9A%84git-commit-message/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们在开发代码的时候，都会用到代码版本控制工具（这里主要讲 git）。我们在用 git 的时候，不管是单人开发还是多人合作，我们都需要提交 commit 日志<code>git commit</code>。如果我们的提交日志写的很随意的话，不仅没有语义，而且以后查起来也难，还影响合作的开发效率，这里就简单说下提交日志的规范，仅供参考。<a id="more"></a></p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>社区有多种 commit message 的写法规范，但是用的较多的是 angular 规范。也是比较合理和系统化的，还有配套的使用工具。</p>
<h3 id="commit-message-的格式化"><a href="#commit-message-的格式化" class="headerlink" title="commit message 的格式化"></a>commit message 的格式化</h3><p>每次提交的 commit message 都包括三个部分：header, body 和 footer。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;):&lt;subject&gt;</span><br><span class="line">//空行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">//空行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<p>其中 header 是必须的但是其 scope 是可选的，body 和 footer 可以省略。<br>注意：commit message 的任何行不能超过 100 个字符，方便阅读。</p>
<h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>header 部分只有一行：type、scope 和 subject。</p>
<ol>
<li>type</li>
</ol>
<p>type 用于说明 commit 的类别，只允许下面 7 个标识。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* feat：新功能（feature）</span><br><span class="line">* fix：修补bug</span><br><span class="line">* docs：文档（documentation）</span><br><span class="line">* style： 格式（不影响代码运行的变动）</span><br><span class="line">* refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">* test：增加测试</span><br><span class="line">* perf：代码更改，提高了性能</span><br><span class="line">* build：影响构建系统或外部依赖的改变</span><br><span class="line">* ci：改变ci配置文件和脚本</span><br><span class="line">* chore：构建过程或辅助工具的变动</span><br><span class="line">* revert：恢复以前的提交</span><br></pre></td></tr></table></figure>
<p>如果 type 为 feat 和 fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。</p>
<ol start="2">
<li>scope</li>
</ol>
<p>scope 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<ol start="3">
<li>subject</li>
</ol>
<p>subject 是 commit 目的的简短描述，不超过 50 个字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 以动词开头，使用第一人称现在时，比如change，而不是changed或changes</span><br><span class="line">* 第一个字母小写</span><br><span class="line">* 结尾不加句号（.）</span><br></pre></td></tr></table></figure>
<h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4><p>Body 部分是对本次 commit 的详细描述，可以分成多行。<br>注意：</p>
<p>使用第一人称现在时，比如使用 change 而不是 changed 或 changes。<br>应该说明代码变动的动机，以及与以前行为的对比。</p>
<h4 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h4><p>footer 分两种情况：</p>
<ul>
<li>不兼容变动：如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</li>
<li>关闭 Issue：如果当前 commit 针对某个 issue，那么可以在 Footer 部分关闭这个 issue 。</li>
</ul>
<h4 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h4><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以 revert:开头，后面跟着被撤销 Commit 的 Header。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">revert: feat(pencil): add &apos;graphiteWidth&apos; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure>
<p>body 部分的格式是固定的，必须写成 This reverts commit <hash>.，其中的 hash 是被撤销 commit 的 SHA 标识符。</hash></p>
<h3 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a>commitizen</h3><p>commitizen 是一个格式化 commit message 的工具。</p>
<h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br></pre></td></tr></table></figure>
<p>然后，在项目目录下，运行下面的命令，使其支持 angular 的 commit message 格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>
<h4 id="项目根目录安装"><a href="#项目根目录安装" class="headerlink" title="项目根目录安装"></a>项目根目录安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -D commitizen cz-conventional-changelog</span><br></pre></td></tr></table></figure>
<p>package.json 中配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;script&quot;: &#123;</span><br><span class="line">    ...,</span><br><span class="line">    &quot;commit&quot;: &quot;git-cz&quot;,</span><br><span class="line">&#125;,</span><br><span class="line"> &quot;config&quot;: &#123;</span><br><span class="line">    &quot;commitizen&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;node_modules/cz-conventional-changelog&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>以后，凡是用到 git commit 命令，一律改为使用 git cz</p>
<h3 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h3><h4 id="commitlint-检验-commit-message-格式"><a href="#commitlint-检验-commit-message-格式" class="headerlink" title="commitlint 检验 commit message 格式"></a>commitlint 检验 commit message 格式</h4><p>commitlint: 可以帮助我们 lint commit messages, 如果我们提交的不符合指向的规范, 直接拒绝提交.同样的, 它也需要一份校验的配置, 这里推荐 @commitlint/config-conventional (符合 Angular 团队规范).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 安装</span><br><span class="line"></span><br><span class="line">npm i -D @commitlint/config-conventional @commitlint/cli</span><br></pre></td></tr></table></figure>
<p>同时需要在项目目录下创建配置文件.commitlintrc.js,如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  extends: [</span><br><span class="line">    &apos;@commitlint/config-conventional&apos;</span><br><span class="line">  ],</span><br><span class="line">  rules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="结合-husky-使用"><a href="#结合-husky-使用" class="headerlink" title="结合 husky 使用"></a>结合 husky 使用</h4><p>校验 commit message 的最佳方式是结合 git hook, 所以需要配合 Husky.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 安装</span><br><span class="line"></span><br><span class="line">npm i husky@next</span><br></pre></td></tr></table></figure>
<p>然后在 package.json 中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">    &quot;hooks&quot;: &#123;</span><br><span class="line">      &quot;commit-msg&quot;: &quot;commitlint -e&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成-change-log"><a href="#生成-change-log" class="headerlink" title="生成 change log"></a>生成 change log</h3><p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。</p>
<p>生成的文档包括以下三个部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* New features</span><br><span class="line">* Bug fixes</span><br><span class="line">* Breaking changes.</span><br></pre></td></tr></table></figure>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>
<h4 id="conventional-changelog-就是生成-Change-log-的工具。"><a href="#conventional-changelog-就是生成-Change-log-的工具。" class="headerlink" title="conventional-changelog 就是生成 Change log 的工具。"></a>conventional-changelog 就是生成 Change log 的工具。</h4><p>运行如下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br><span class="line">$ cd my-project</span><br><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure>
<p>上面命令不会覆盖以前的 Change log，只会在 CHANGELOG.md 的头部加上自从上次发布以来的变动。</p>
<p>如果你想生成所有发布的 Change log，要改为运行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conventional-changelog -p angular -i CHANGELOG.md -s -r 0</span><br></pre></td></tr></table></figure>
<p>为了方便使用，可以将其写入 package.json 的 scripts 字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后直接执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run changelog</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>vue合作开发不完全指南</title>
    <url>/2018/07/06/vue%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们在任何一家公司工作，合作是必不可少的。在前端工作上也是会有很多同事一起进行业务逻辑的开发。那么在合作开发的过程中，一些注意的事项和规则统一起来的话，合作得效率就会提高很多。<a id="more"></a>这里我简单总结下 vue 开发中的能提高合作效率的要点，仅供参考。</p>
<ol>
<li>组件的命名尽可能的语义化，包括.vue 文件，有多个单词合成。根组件 App 除外</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    name: &apos;TodoItem&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>组件的 data 必须是一个函数，并且在组件中，必须要用 return 返回一个对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            flag: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>prop 的定义要尽量详细点，需要指定类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    status: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        require: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>v-for 循环的时候设置 key,并且 key 是唯一的值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;item of items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">        &#123;&#123;item.title&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>尽量不要把 v-if 和 v-for 这另个指令放在同一个元素标签上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul v-if=&quot;flag&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;item of items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">        &#123;&#123;item.title&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>在为组件设置样式的时候，需要定义一个最外层的 class，来进行样式的隔绝，只作用于局部，这样的好处不会造成全局的污染，并且也容易进行样式的覆盖（不使用 scoped 的原因）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;panel&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>在写组件的时候，使用.vue 文件的方式。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">    User.vue</span><br><span class="line">    IndexHeader.vue</span><br></pre></td></tr></table></figure>
<ol start="8">
<li><p>组件文件的命名使用大驼峰或者小驼峰的书写方式</p>
</li>
<li><p>基础组件加个特定的前缀作为区分（Base）</p>
</li>
<li><p>如果组件之间有关系，加上关系层的父组件前缀</p>
</li>
</ol>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>规范</tag>
        <tag>合作</tag>
      </tags>
  </entry>
  <entry>
    <title>快被遗忘的组件传值方法——EventBus</title>
    <url>/2018/06/25/%E5%BF%AB%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94EventBus/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们在使用 vue 的时候都知道，组件化开发是 vue 的一个重要的特性。所以我们在开发业务的过程中会经常进行组件的封装，进而实现组件的复用，来提高开发效率。然而在我们使用组件化开发的时候，难免会有组件间的数据通信。<a id="more"></a>父子级组件数据传递到还是很好解决，但是兄弟组件和多级嵌套的组件就显得不是那么友好了，单纯的 props 和事件传值已经有点吃力了，所以这里有两种解决的办法：EventBus 和 vuex。这里就主要说下 EventBus 实现的方法。</p>
<h3 id="EventBus-实现原理介绍"><a href="#EventBus-实现原理介绍" class="headerlink" title="EventBus 实现原理介绍"></a>EventBus 实现原理介绍</h3><ul>
<li><p>父组件发送数据给子组件，可以通过子组件的 props 来进行数据的传递。</p>
</li>
<li><p>EventBus 其实就是通过实例化一个 Vue 实例，然后通过该实例的$emit 方法发送数据消息和$on 方法接收数据消息。它适用在子组件发送消息给父组件或兄弟组件之间发送消息。</p>
</li>
</ul>
<h3 id="EventBus-实现小事例"><a href="#EventBus-实现小事例" class="headerlink" title="EventBus 实现小事例"></a>EventBus 实现小事例</h3><p>首先，我们需要实例化一个 Vue 来充当 EventBus 来进行数据的通信。这里定义一个 EventBus.js.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &apos;Vue&apos;</span><br><span class="line">export default new Vue()</span><br></pre></td></tr></table></figure>
<p>然后定义一个父组件和一个子组件以及一个兄弟组件。命名文件：parent.js child.js subItem.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// parent.js 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child&gt;&lt;/child&gt;</span><br><span class="line">    &lt;sub-item&gt;&lt;/sub-item&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;data&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &apos;./child&apos;;</span><br><span class="line">import subItem from &apos;./subItem&apos;;</span><br><span class="line">import EventBus from &apos;./EventBus&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            data:&apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 在mounted接受数据消息，$on接受两个参数。</span><br><span class="line">        * 第一个参数是消息事件名，应该与发送数据消息的第一个参数相同，否则接收不到数据消息</span><br><span class="line">        * 第二个参数是一个函数，对数据消息事件做处理；该函数带一个参数，则是数据。</span><br><span class="line">        */</span><br><span class="line">        EventBus.$on(&apos;search&apos;,(val)=&gt;&#123;</span><br><span class="line">        this.data=val;</span><br><span class="line">        //示例：如果数据传递的是对象形式</span><br><span class="line">        // this.data=val.data;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">    child,</span><br><span class="line">    subItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// child.js 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input placeholder=&quot;搜索内容&quot; @input=&quot;sendHandleEvent&quot; v-model=&quot;searchContent&quot;/&gt;   //增加了@input=“sendHandleEvent”，去监听onInput事件，并回调sendHandleEvent方法</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">  import EventBus from &apos;./EventBus&apos;     //导入EventBus</span><br><span class="line">  export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        searchContent:&quot;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      sendHandleEvent:function()&#123;      //定义sendHandleEvent方法，在input中监听onInput，并回调该方法</span><br><span class="line">        /**</span><br><span class="line">         * 通过导入的EventBus调用$emit方法去发送数据消息。</span><br><span class="line">         * 第一个参数为事件名，到时候我们要通过该事件名去接收数</span><br><span class="line">         * 第二个参数为数据值，如果只有一个参数，我们可以直接传递该参数</span><br><span class="line">         * 如果有两个及以上的参数，我们可以通过对象的形式去传递。</span><br><span class="line">         */</span><br><span class="line">        EventBus.$emit(&quot;search&quot;,this.searchContent)</span><br><span class="line">        //多个参数传递的示例：</span><br><span class="line">        //EventBus.$emit(&quot;search&quot;,&#123;&quot;content&quot;:this.searchContent,&quot;flag</span><br><span class="line">        &quot;:&quot;flag&quot;&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// subItem.js 子组件的兄弟组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">      &#123;&#123;data&#125;&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import EventBus from &apos;./EventBus&apos;  //导入EventBus</span><br><span class="line">  export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        data:&apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 在mounted接受数据消息，$on接受两个参数。</span><br><span class="line">     * 第一个参数是消息事件名，应该与发送数据消息的第一个参数相同，否则接收不到数据消息</span><br><span class="line">     * 第二个参数是一个函数，对数据消息事件做处理；该函数带一个参数，则是数据。</span><br><span class="line">     */</span><br><span class="line">      EventBus.$on(&apos;search&apos;,(val)=&gt;&#123;</span><br><span class="line">        this.data=val;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的示例我们主要做了以下事情：<br>1、在父组件和兄弟组件通过在组件 mounted 生命周期中调用 EventBus.on()方法去接收子组件和兄弟组件的数据消息，并对 data 进行修改值.</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、父组件给子组件进行数据传递可以通过 props 进行传递。</p>
<p>2、子组件给父组件进行消息传递或子组件给兄弟组件进行消息传递可以通过 EventBus 去实例化一个 Vue，并通过该实例的$emit 和$on 方法去传递和接收数据消息。</p>
<p>3、数据消息一旦发送，所有注册了接收该数据消息的地方都会接收到该数据消息。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件传值</tag>
      </tags>
  </entry>
  <entry>
    <title>React中的this绑定的实现方法</title>
    <url>/2018/06/14/React%E4%B8%AD%E7%9A%84this%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>this 在 js 中使用频率非常高。就算是在框架中也依然很高，比如：vue react 等这些框架。所以就需要研究下 this 的各种使用场景和指向问题。特别是和箭头函数使用时的区别。这里主要说下在 react 中 this 的使用绑定问题。<a id="more"></a></p>
<h3 id="1-使用-React-createClass-创建组件"><a href="#1-使用-React-createClass-创建组件" class="headerlink" title="1.使用 React.createClass 创建组件"></a>1.使用 React.createClass 创建组件</h3><p>如果你使用的是 React 15 及以下的版本，你可能使用过 React.createClass 函数来创建一个组件。你在里面创建的所有函数的 this 将会自动绑定到组件上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Comp = React.createClass(&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&apos;this is &apos;, this); // this 指向Comp组件本身</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick=&#123;this.handleClick&#125;&gt;test&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是需要注意随着 React 16 版本的发布官方已经将改方法从 React 中移除。</p>
<h3 id="2-render-方法中使用-bind"><a href="#2-render-方法中使用-bind" class="headerlink" title="2.render 方法中使用 bind"></a>2.render 方法中使用 bind</h3><p>如果你使用 React.Component 创建一个组件，在其中给某个组件/元素一个 onClick 属性，它现在并会自定绑定其 this 到当前组件，解决这个问题的方法是在事件函数后使用.bind(this)将 this 绑定到当前组件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Comp extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&apos;this is &apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;test&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法很简单，可能是大多数初学开发者在遇到问题后采用的一种方式。然后由于组件每次执行 render 将会重新分配函数这将会影响性能。特别是在你做了一些性能优化之后，它会破坏 PureComponent 性能。不推荐使用</p>
<h3 id="3-render-方法中使用箭头函数"><a href="#3-render-方法中使用箭头函数" class="headerlink" title="3.render 方法中使用箭头函数"></a>3.render 方法中使用箭头函数</h3><p>这种方法使用了 ES6 的上下文绑定来让 this 指向当前组件，但是它同第 2 种存在着相同的性能问题，不推荐使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Comp extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&apos;this is &apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick=&#123;e =&gt; this.handleClick(e)&#125;&gt;test&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-构造函数中-bind"><a href="#4-构造函数中-bind" class="headerlink" title="4.构造函数中 bind"></a>4.构造函数中 bind</h3><p>为了避免在 render 中绑定 this 引发可能的性能问题，我们可以在 constructor 中预先进行绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Comp extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&apos;this is &apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick=&#123;this.handleClick&#125;&gt;test&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这种方法很明显在可读性和维护性上没有第 2 种和第 3 种有优势，但是第 2 种和第 3 种由于存在潜在的性能问题不推荐使用，那么现在推荐 ECMA stage-2 所提供的箭头函数绑定。</p>
<h3 id="5-在定义阶段使用箭头函数绑定"><a href="#5-在定义阶段使用箭头函数绑定" class="headerlink" title="5.在定义阶段使用箭头函数绑定"></a>5.在定义阶段使用箭头函数绑定</h3><p>要使用这个功能，需要在.babelrc 种开启 stage-2 功能，绑定方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Comp extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(&apos;this is &apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick=&#123;this.handleClick&#125;&gt;test&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法有很多优化：</p>
<ul>
<li><p>箭头函数会自动绑定到当前组件的作用域种，不会被 call 改变</p>
</li>
<li><p>它避免了第 2 种和第 3 种的可能潜在的性能问题</p>
</li>
<li><p>它避免了第 4 种绑定时大量重复的代码</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综合以上方法使用 react16 的话最好的绑定方法是在定义阶段使用箭头函数绑定。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>实力踩坑--linux服务器安装mongodb数据库</title>
    <url>/2018/06/08/%E5%AE%9E%E5%8A%9B%E8%B8%A9%E5%9D%91-linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85mongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>在使用 node 做为服务端的时候，我配合使用的是 mongodb 数据库。因为 mongodb 数据库是 json 格式的，对前端入门数据库相对比较友好。所以果断选择，但是在服务器上安装确实出现了很多问题。好在最后得到解决，这里记录下自己的实践过程。<a id="more"></a></p>
<h3 id="使用-yum-安装-mongodb"><a href="#使用-yum-安装-mongodb" class="headerlink" title="使用 yum 安装 mongodb"></a>使用 yum 安装 mongodb</h3><p>我这里使用的是 yum 安装，虽然还有其他安装方法。比如：源码安装。但是我觉得这个方法比较简单、简便。并且对新手比较友好。</p>
<ul>
<li>首先查看下 linux 服务器上是否存在 mongodb 的 yum 源。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 切换到目录</span><br><span class="line">cd /etc/yum.repos.d</span><br><span class="line"></span><br><span class="line">// 使用ls命令查看文件</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有则添加 yum 源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建文件</span><br><span class="line">touch mongodb-3.6.repo</span><br><span class="line"></span><br><span class="line">// 编辑该文件</span><br><span class="line">vim mongodb-3.6.repo</span><br><span class="line"></span><br><span class="line">// 编辑内容</span><br><span class="line">[mongodb-org-3.6]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.6/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc</span><br></pre></td></tr></table></figure>
<p>简单说明一下，这里的 3.6 是版本号，大家可以安装自己喜欢的版本，直接修改这个版本号就行了，其他不变。</p>
<ul>
<li>使用 yum 命令安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y mongodb-org</span><br></pre></td></tr></table></figure>
<p>这里注意一下，如果没有权限，那么就执行以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure>
<p>安装完毕后，修改下配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 修改配置文件的 bind_ip, 默认是 127.0.0.1 只限于本机连接。所以安装完成后必须把这个修改为 0.0.0.0 ,否则通过别的机器是没法连接的!</span><br><span class="line">vim /etc/mongod.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>启动、停止、重新启动 mongodb</li>
</ul>
<p>MongoDB 默认将数据文件存储在/var/lib/mongo 目录，默认日志文件在/var/log/mongodb 中。如果要修改,可以在 /etc/mongod.conf 配置中指定备用日志和数据文件目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 启动</span><br><span class="line">service mongod start</span><br><span class="line"></span><br><span class="line">// 停止</span><br><span class="line">service mongod stop</span><br><span class="line"></span><br><span class="line">// 重启</span><br><span class="line">service mongod restart</span><br></pre></td></tr></table></figure>
<p>查看 mongoDB 是否启动成功,可以通过查看日志文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /var/log/mongodb/mongod.log</span><br></pre></td></tr></table></figure>
<p>如果日志文件出现如下一句说明则成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[initandlisten] waiting for connections on port &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;port&gt;</code>是 mongodb 的运行端口</p>
<p>也可以用以下命令来检查是否成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig mongod on</span><br></pre></td></tr></table></figure>
<ul>
<li>mongo shell</li>
</ul>
<p>然后就可以像本地一样命令行操作了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[rootxxx*** ~]# mongo</span><br><span class="line"></span><br><span class="line">## 查看数据库</span><br><span class="line">&gt; show dbs;</span><br><span class="line"></span><br><span class="line">## 查看数据库版本</span><br><span class="line">&gt; db.version();</span><br><span class="line"></span><br><span class="line">## 常用命令帮助</span><br><span class="line">&gt; db.help();</span><br></pre></td></tr></table></figure>
<ul>
<li>卸载移除 mongo</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum erase $(rpm -qa | grep mongodb-org)</span><br></pre></td></tr></table></figure>
<ul>
<li>移除数据库文件和日志文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -r /var/log/mongodb</span><br><span class="line">rm -r /var/lib/mongo</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>mongodb</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>node部署vue项目</title>
    <url>/2018/05/29/node%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们在用 vue 框架来做开发的时候，虽然在打包之前的文件有点和传统的前端代码不一样。但是我们线上部署的时候，所使用的代码还是和传统的代码是一样的，在这过程中，项目需要经过打包，<a id="more"></a>上线的时候就是用打包之后的代码，也就是我们要部署到服务器上的代码。这里简单说下用 node 来部署 vue 项目。</p>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>首先 vue-cli 中已经配置好了打包的命令，命令行执行下便是能够打包好等待上线的代码文件夹 dist</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<h3 id="node-服务器代码"><a href="#node-服务器代码" class="headerlink" title="node 服务器代码"></a>node 服务器代码</h3><p>首先 vue 是 spa 项目，这里只有一个入口页的 html，用 node 写一个 app.js 脚本输出到客户端:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(path.resolve(__dirname, &apos;./dist&apos;)));</span><br><span class="line"></span><br><span class="line">app.get(&apos;*&apos;, function(req, res) &#123;</span><br><span class="line">    const html = fs.readFileSync(path.resolve(__dirname, &apos;./dist/index.html&apos;), &apos;utf-8&apos;);</span><br><span class="line">    res.send(html);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(80);</span><br></pre></td></tr></table></figure>
<p>这个脚本中使用了express框架，我们需要安装一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure>
<h3 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h3><p>把app.js、package.json和dist文件夹上传到服务器，例如www文件夹下。然后用pm2启动app.js服务。然后就能正常访问到你的线上项目了</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>自己造轮子——封装vue插件</title>
    <url>/2018/05/22/%E8%87%AA%E5%B7%B1%E9%80%A0%E8%BD%AE%E5%AD%90%EF%BC%8C%E5%B0%81%E8%A3%85vue%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>当我们在开发一个项目时，有一个使用次数很多的组件。例如：<code>loading</code>动画、<code>toast</code>弹出框。如果每个使用的地方，我们都需要引用一次，那么很显然代码不优美。并且会添加很多无用的代码。于是 <code>vue</code> 插件的封装就上场了。<a id="more"></a></p>
<h3 id="不同形式的封装和调用"><a href="#不同形式的封装和调用" class="headerlink" title="不同形式的封装和调用"></a>不同形式的封装和调用</h3><p>首先定义两个文件夹：分别是<code>loading</code>、<code>toast</code>.各自文件夹下面定义一个<code>index.js</code>和<code>.vue</code>模板。</p>
<p>这两个插件的区别是：<code>loading</code>插件作为组件引入使用，而<code>toast</code>是直接挂载使用，通过方法改变状态使用。所以就有了不同的封装方法。</p>
<h3 id="封装-toast-插件"><a href="#封装-toast-插件" class="headerlink" title="封装 toast 插件"></a>封装 toast 插件</h3><p><code>toast</code> 文件夹下有两个文件，后缀为 <code>vue</code> 的文件就是这个插件的模板，<code>js</code> 文件一个是将这个模板放入 <code>Vue</code> 全局中，并写明操作逻辑。</p>
<p><code>toast.vue</code>的文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;toast&quot; v-show=&quot;show&quot;&gt;</span><br><span class="line">            &#123;&#123;message&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      show: false,</span><br><span class="line">      message: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.toast &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 40%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  margin-left: -15vw;</span><br><span class="line">  padding: 2vw;</span><br><span class="line">  width: 30vw;</span><br><span class="line">  font-size: 4vw;</span><br><span class="line">  color: #fff;</span><br><span class="line">  text-align: center;</span><br><span class="line">  background-color: rgba(0, 0, 0, 0.8);</span><br><span class="line">  border-radius: 5vw;</span><br><span class="line">  z-index: 999;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fade-enter-active,</span><br><span class="line">.fade-leave-active &#123;</span><br><span class="line">  transition: 0.3s ease-out;</span><br><span class="line">&#125;</span><br><span class="line">.fade-enter &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transform: scale(1.2);</span><br><span class="line">&#125;</span><br><span class="line">.fade-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transform: scale(0.8);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>这里的主要内容就是决定是否显示的<code>show</code>值和显示的内容<code>message</code>.</p>
<p><code>index.js</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ToastComponent from &apos;./toast.vue&apos;</span><br><span class="line">const Toast = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 注册Toast</span><br><span class="line">Toast.install = function (Vue) &#123;</span><br><span class="line"></span><br><span class="line">    // 生成一个Vue的子类</span><br><span class="line">    // 同时这个子类也就是组件</span><br><span class="line">    const ToastConstructor = Vue.extend(ToastComponent)</span><br><span class="line"></span><br><span class="line">    // 生成一个该子类的实例</span><br><span class="line">    const instance = new ToastConstructor();</span><br><span class="line"></span><br><span class="line">    // 将这个实例挂载在我创建的div上</span><br><span class="line">    // 并将此div加入全局挂载点内部</span><br><span class="line">    instance.$mount(document.createElement(&apos;div&apos;))</span><br><span class="line">    document.body.appendChild(instance.$el)</span><br><span class="line"></span><br><span class="line">    // 通过Vue的原型注册一个方法</span><br><span class="line">    // 让所有实例共享这个方法</span><br><span class="line">    Vue.prototype.$toast = (msg, duration = 2000) =&gt; &#123;</span><br><span class="line">        instance.message = msg;</span><br><span class="line">        instance.show = true;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            instance.show = false;</span><br><span class="line">        &#125;, duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Toast</span><br></pre></td></tr></table></figure>
<p>这里主要是经过以下几步:</p>
<ol>
<li><p>创建一个空对象，这个对象就是日后要使用到的插件的名字。此外，这个对象中要有一个 <code>install</code> 的函数。</p>
</li>
<li><p>使用 <code>vue</code> 的 <code>extend</code> 方法创建一个插件的构造函数（可以看做创建了一个 <code>vue</code> 的子类），实例化该子类，之后的所有操作都可以通过这个子类完成。</p>
</li>
<li><p>之后再 <code>Vue</code> 的原型上添加一个共用的方法。</p>
</li>
</ol>
<p>###　 toast 插件的调用</p>
<p>首先在修改<code>main.js</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 添加toast插件</span><br><span class="line">import Toast from &apos;./components/toast&apos;;</span><br><span class="line">Vue.use(Toast);</span><br></pre></td></tr></table></figure>
<p>然后在<code>.vue</code>文件中使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;toast&quot;&gt;显示toast弹出框&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    toast() &#123;</span><br><span class="line">      this.$toast(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="封装-loading-插件"><a href="#封装-loading-插件" class="headerlink" title="封装 loading 插件"></a>封装 loading 插件</h3><p><code>loading.vue</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&apos;wrapper&apos; v-if=&quot;show&quot;&gt;</span><br><span class="line">        &lt;div class=&apos;loading&apos;&gt;</span><br><span class="line">            &lt;img src=&quot;./loading.gif&quot; alt=&quot;&quot; width=&quot;40&quot; height=&quot;40&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;Loading&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    duration: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;1s&quot; //默认1s</span><br><span class="line">    &#125;,</span><br><span class="line">    show: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: function() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p><code>index.js</code>文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import LoadingComponent from &apos;./loading.vue&apos;</span><br><span class="line"></span><br><span class="line">let Loading = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Loading.install = (Vue) =&gt; &#123;</span><br><span class="line">Vue.component(LoadingComponent.name, LoadingComponent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Loading;</span><br></pre></td></tr></table></figure>
<h3 id="loading-插件的调用"><a href="#loading-插件的调用" class="headerlink" title="loading 插件的调用"></a>loading 插件的调用</h3><p>首先，修改<code>main.js</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 添加插件</span><br><span class="line">import Loading from &apos;./components/loading&apos;;</span><br><span class="line">Vue.use(Loading);</span><br></pre></td></tr></table></figure>
<p>需要使用插件的<code>.vue</code>的文件调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;loading duration=&apos;2s&apos; :show=&apos;show&apos;&gt;&lt;/loading&gt;</span><br><span class="line">    &lt;button @click=&quot;show = !show&quot;&gt;显示/隐藏loading&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      show: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>以上就是<code>vue</code>插件的封装方法。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这些封装的插件我们是在我们自己的项目中使用。其实我们可以把封装好的插件发布成<code>npm</code>包，这样想使用的人就都可以使用了。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>基于vue-cli的webpack多环境打包配置</title>
    <url>/2018/05/14/%E5%9F%BA%E4%BA%8Evue-cli%E7%9A%84webpack%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在实际项目中，在开发过程会根据开发、测试、生产环境的不同来采用不用的配置，最常用的便是 api 接口调用的不同。因此，我们需要根据不同的环境设置不同的 api 地址。所以我们需要对 webpack 的不同配置来完成这个需求。<a id="more"></a></p>
<p>项目中，我使用的是 vue-cli 来初始化构建项目的。文件夹目录中会有 build 和 config 两个文件夹。</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><h4 id="config-index-js"><a href="#config-index-js" class="headerlink" title="./config/index.js"></a>./config/index.js</h4><p>在此配置文件中添加需要增加的环境配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build: &#123;</span><br><span class="line">        sitEnv: require(&apos;./sit.env&apos;), // 添加测试环境</span><br><span class="line">        preProdEnv: require(&apos;./preProd.env&apos;), // 添加沙箱测试环境</span><br><span class="line">        prodEnv: require(&apos;./prod.env&apos;),  // 添加生产环境</span><br><span class="line"></span><br><span class="line">        // Template for index.html</span><br><span class="line">        index: path.resolve(__dirname, `../dist/$&#123;process.env.ENV_CONFIG&#125;/index.html`),</span><br><span class="line"></span><br><span class="line">        // Paths</span><br><span class="line">        assetsRoot: path.resolve(__dirname, `../dist/$&#123;process.env.ENV_CONFIG&#125;`),</span><br><span class="line">        assetsSubDirectory: &apos;&apos;,</span><br><span class="line">        assetsPublicPath: &apos;./&apos;,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Source Maps</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        productionSourceMap: false,</span><br><span class="line">        // https://webpack.js.org/configuration/devtool/#production</span><br><span class="line">        devtool: &apos;#source-map&apos;,</span><br><span class="line"></span><br><span class="line">        // Gzip off by default as many popular static hosts such as</span><br><span class="line">        // Surge or Netlify already gzip all static assets for you.</span><br><span class="line">        // Before setting to `true`, make sure to:</span><br><span class="line">        // npm install --save-dev compression-webpack-plugin</span><br><span class="line">        productionGzip: false,</span><br><span class="line">        productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;],</span><br><span class="line"></span><br><span class="line">        // Run the build command with an extra argument to</span><br><span class="line">        // View the bundle analyzer report after build finishes:</span><br><span class="line">        // `npm run build --report`</span><br><span class="line">        // Set to `true` or `false` to always turn it on or off</span><br><span class="line">        bundleAnalyzerReport: process.env.npm_config_report</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="webpack-prod-conf-js"><a href="#webpack-prod-conf-js" class="headerlink" title="webpack.prod.conf.js"></a>webpack.prod.conf.js</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const env = config.build[process.env.ENV_CONFIG+&apos;Env&apos;]</span><br></pre></td></tr></table></figure>
<h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build:sit&quot;: &quot;cross-env NODE_ENV=production ENV_CONFIG=sit  node build/build.js&quot;,</span><br><span class="line">    &quot;build:preProd&quot;: &quot;cross-env NODE_ENV=production  ENV_CONFIG=preProd  node build/build.js&quot;,</span><br><span class="line">    &quot;build:prod&quot;: &quot;cross-env NODE_ENV=production  ENV_CONFIG=prod node build/build.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>这里有几点需要注意：</p>
<ol>
<li>cross-env 是为了兼容各个系统之间差别，需要安装这个包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install cross-env --save-dev</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>NODE_ENV 和 ENV_CONFIG 与环境配置文件中的大小写一定要一致，不然在 linux 系统服务器下面会出现问题，已踩坑。</li>
</ol>
<h3 id="添加相应的环境文件"><a href="#添加相应的环境文件" class="headerlink" title="添加相应的环境文件"></a>添加相应的环境文件</h3><h4 id="sit-env-js-等"><a href="#sit-env-js-等" class="headerlink" title="sit.env.js 等"></a>sit.env.js 等</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    NODE_ENV: &apos;&quot;production&quot;&apos;,</span><br><span class="line">    ENV_CONFIG: &apos;&quot;sit&quot;&apos;,</span><br><span class="line">    BASE_URL: &apos;&quot;http://xxx.xxx.com/buy-api/&quot;&apos;,</span><br><span class="line">    CONFIG_TEXT: &apos;&quot;SIT测试环境&quot;&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果需要配置的环境比较多，就按照这个来进行改写添加相应的环境配置文件。</p>
<h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#开发调试</span><br><span class="line">npm run dev</span><br><span class="line">#测试环境构建</span><br><span class="line">npm run build:sit</span><br><span class="line">#生产环境构建</span><br><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在开发中，使用的是 node 的环境下。所以我们写的环境的配置文件中的字段都是可以取到值得比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process.env.BASE_URL</span><br></pre></td></tr></table></figure>
<p>当我们能取到这些值得时候，我们就可以在不同环境的打包的时候，把不同环境下的 api 的前缀在打包的时候进行更换。用命令来构建 webpack 的打包就比较方便了。可以在我们的 api 请求拦截器的时候进行拦截比如我使用的是 axios，配置是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL = process.env.NODE_ENV === &apos;development&apos; ? &apos;/buy-api/&apos; : process.env.BASE_URL;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>解决移动端打印日志烦恼——vConsole</title>
    <url>/2018/05/08/%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E7%83%A6%E6%81%BC%E2%80%94%E2%80%94%E2%80%94%E2%80%94vConsole/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>平时我们在 web 应用开发过程中，我们可以使用 console.log 去输出日志来调试程序。但是在移动端，比如在手机上，console.log 的信息我们是看不到的。这种情况下，我们可以选择使用 alert 弹出一些信息，但是这种方法不怎么方便<a id="more"></a>，也会阻断 JS 线程，导致后面的线程都不执行。也影响调试体验。那么，如果将 console.log 应用到移动端呢？这就是本片的主要内容，安利一款工具 vConsole</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>vConsole:一个轻量、可拓展、针对手机网页的前端开发者调试面板。</p>
<h3 id="功能和特点"><a href="#功能和特点" class="headerlink" title="功能和特点"></a>功能和特点</h3><ol>
<li>查看 console 日志</li>
<li>查看网络请求</li>
<li>手动执行 JS 命令行</li>
<li>自定义插件</li>
</ol>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul>
<li>直接引入使用引入 dist/vconsole.min.js 到项目中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;path/to/vconsole.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(&apos;Hello world&apos;);</span><br><span class="line">    // 然后点击右下角 vConsole 按钮即可查看到 log</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 vue 项目中使用</li>
</ul>
<ol>
<li>package.json 安装 vconsole 包(可以放在 devDependencies 中)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>main.js 中引入：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 因为vConsole并不需要调用，</span><br><span class="line">// 所以前面加“eslint-disable no-unused-vars”规避掉eslint语法检查</span><br><span class="line"></span><br><span class="line">/* eslint-disable no-unused-vars */</span><br><span class="line">import vConsole from &apos;vconsole&apos;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>此时可以使用 console.log<br>原理：改写了 console.log,重写了实现，用 vConsole 代理</li>
</ol>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode 插件 Settings Sync使用方法</title>
    <url>/2018/04/22/vscode%E6%8F%92%E4%BB%B6sync-setting%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用<code>vscode</code>的时候，我们会根据自己的喜好和提高开发效率进行对编辑器的配置和一些辅助插件的配置。但是我们有时会在不同的电脑也安装<code>vscode</code>，如果我们在安装和配置一遍<code>vscode</code>这是非常繁琐的，也是非常低效。于是乎<code>Settings Sync</code>插件产生了。接下来就简单说下这个插件的使用方法。<a id="more"></a></p>
<h2 id="初次使用-Setting-Sync"><a href="#初次使用-Setting-Sync" class="headerlink" title="初次使用 Setting Sync"></a>初次使用 Setting Sync</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>安装<code>vscode</code>编辑器</p>
</li>
<li><p>安装<code>Setting Sync</code>插件</p>
</li>
</ul>
<h3 id="在github上设置-Personal-access-tokens"><a href="#在github上设置-Personal-access-tokens" class="headerlink" title="在github上设置 Personal access tokens"></a>在github上设置 Personal access tokens</h3><ul>
<li><p>进入github（没有的话，当然自己注册一个账号啦！）</p>
</li>
<li><p>找到个人设置<code>settings</code>并点击</p>
</li>
<li><p>找到<code>Developer settings</code>并点击</p>
</li>
<li><p>找到<code>Personal access tokens</code>并点击</p>
</li>
<li><p>找到<code>Generate new token</code>并点击</p>
</li>
</ul>
<p>然后要记住token值，在插件中需要用到。</p>
<p>如图所示：<br><img src="http://images.wangyuanweb.top/vscode-setting-1.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"><br><img src="http://images.wangyuanweb.top/vscode-setting-2.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"><br><img src="http://images.wangyuanweb.top/vscode-setting-3.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"><br><img src="http://images.wangyuanweb.top/vscode-setting-4.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"><br><img src="http://images.wangyuanweb.top/vscode-setting-5.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"><br><img src="http://images.wangyuanweb.top/vscode-setting-6.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"></p>
<h3 id="在vscode中使用该插件"><a href="#在vscode中使用该插件" class="headerlink" title="在vscode中使用该插件"></a>在vscode中使用该插件</h3><p>首先打开命令工具<code>ctrl+shift+p</code>,然后输入<code>sync</code>关键字,就会出现需要使用的命令。然后如图所示：</p>
<p><img src="http://images.wangyuanweb.top/vscode-setting-7.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"><br><img src="http://images.wangyuanweb.top/vscode-setting-8.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"></p>
<p>具体命令的意思，可以查看插件的文档，很详细。</p>
<h2 id="更新配置的时候出现的问题"><a href="#更新配置的时候出现的问题" class="headerlink" title="更新配置的时候出现的问题"></a>更新配置的时候出现的问题</h2><h3 id="token失效"><a href="#token失效" class="headerlink" title="token失效"></a>token失效</h3><p>这个问题应该是在使用的时候遇到的最多的情况，因为 github 的 token 值是有时间限制的，所以这里简单说一下解决的方法。对已经失效的token更新如图：</p>
<p><img src="http://images.wangyuanweb.top/vscode-setting-9.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"><br><img src="http://images.wangyuanweb.top/vscode-setting-10.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"><br><img src="http://images.wangyuanweb.top/vscode-setting-11.png?imageView2/3/w/600/h/400/q/75%7Cimageslim" alt="settings"></p>
<p>然后把得到的 token 值配置到 vscode 的配置文件中。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这个插件的基本使用方法在这里，一是为了更多的人使用，提供一个参考。而是让自己有资料可查，加深记忆！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>jsx中数组循环生成列表dom</title>
    <url>/2018/04/16/jsx%E4%B8%AD%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8dom/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>列表和条件输出dom节点一样，在数据渲染到前台显示的方式很是常见。我们在做前端业务逻辑的时候也经常遇到这样的需求，比如：用户列表、文章列表等。所以我们需要这个技能。react.js中我们也可以对列表数据进行循环渲染。但是在jsx中有自己的一些规则和技巧。接下来我们就简单一起看下。<a id="more"></a></p>
<h2 id="在jsx中渲染一个存有数据的数组"><a href="#在jsx中渲染一个存有数据的数组" class="headerlink" title="在jsx中渲染一个存有数据的数组"></a>在jsx中渲染一个存有数据的数组</h2><p>现在，我们在学习阶段，先造个列表的数据，存放我们想要渲染的列表中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const list = [</span><br><span class="line">    &#123;name:&apos;小A&apos;,like:&apos;唱歌&apos;&#125;,</span><br><span class="line">    &#123;name:&apos;小B&apos;,like:&apos;跳舞&apos;&#125;,</span><br><span class="line">    &#123;name:&apos;小C&apos;,like:&apos;打球&apos;&#125;,</span><br><span class="line">    &#123;name:&apos;小D&apos;,like:&apos;购物&apos;&#125;,    </span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>我们要把这个列表的数据渲染到页面。首先，我们都知道在jsx中的{}中，我们可以放任何的数据或者是表达式。所以，当我们放一个数组，就会以数组的顺序进行渲染，就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class List extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    [</span><br><span class="line">                        &lt;div&gt;react&lt;/div&gt;,</span><br><span class="line">                        &lt;div&gt;vue&lt;/div&gt;,</span><br><span class="line">                        &lt;div&gt;mvvm&lt;/div&gt;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;List /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样输出的就是一个列表。</p>
<h2 id="使用数组的map方法循环列表"><a href="#使用数组的map方法循环列表" class="headerlink" title="使用数组的map方法循环列表"></a>使用数组的map方法循环列表</h2><p>首先用一个传统的方法来实现循环渲染：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class List extends Compont &#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        const ListArray = [] // 保存每个用户渲染以后 JSX 的数组</span><br><span class="line">        for (let item of list) &#123;</span><br><span class="line">        ListArray.push( // 循环每个用户，构建 JSX，push 到数组中</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;姓名：&#123;item.name&#125;&lt;/div&gt;</span><br><span class="line">                &lt;div&gt;爱好：&#123;item.like&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;&#123;ListArray&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;List /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们用一个新的数组存循环list数组给每个元素加上html标签构成的jsx。然后就直接放到{}插入到dom页面，这样就可以渲染出列表了。</p>
<p>当然，这虽然能解决问题，但是不是我们想要的，接下来我们感受一下map方法的魅力。如下重写上面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class List extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;list.map((item) =&gt; &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;div&gt;姓名：&#123;item.name&#125;&lt;/div&gt;</span><br><span class="line">              &lt;div&gt;爱好：&#123;item.like&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;List /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样我们就完成了一个列表的渲染，但是在运行中会报错，因为没有绑定key，而且我们要绑定的key必须是唯一的，不能重复，这里我们就用索引来代替吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class List extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;list.map((item,index) =&gt; &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;div key=&#123;index&#125;&gt;</span><br><span class="line">              &lt;div&gt;姓名：&#123;item.name&#125;&lt;/div&gt;</span><br><span class="line">              &lt;div&gt;爱好：&#123;item.like&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;List /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>虽然此处我用索引绑定key，但是其实是不严谨的，在实际业务中，一定要找到不同的值进行绑定。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>jsx中组件或元素的条件输出</title>
    <url>/2018/04/15/jsx%E4%B8%AD%E7%9A%84dom%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们都知道，在我们在根据数据状态来展现view的时候，会涉及到组件按条件展示。还有在一个列表的展示的时候难免会遇到数据循环的处理。接下来就简单说下两种情况的处理。<a id="more"></a></p>
<h2 id="组件或元素的条件渲染"><a href="#组件或元素的条件渲染" class="headerlink" title="组件或元素的条件渲染"></a>组件或元素的条件渲染</h2><ul>
<li><p>在react中，你可以创建不同的组件各自封装你需要的东西。之后你可以值渲染其中一部分。这就取决于组件的state状态。</p>
</li>
<li><p>条件渲染在React里就和js里的条件语句一样。使用js里的if或者条件表达式创建元素来显示当前的状态，然后让React来更新UI。创建两个组件:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function BackHome(props) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;h1&gt;BackHome&lt;/h1&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SignIn(props) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;h1&gt;SignIn&lt;/h1&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我创建一个可以按条件显示的组件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SetHome(props) &#123;</span><br><span class="line">    const isState = props.isState;</span><br><span class="line">    if(isState) &#123;</span><br><span class="line">        return &lt;BackHome /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;SignIn /&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;SetHome isState=&#123;false&#125;&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里根据isState的值，来渲染不同的组件。</p>
<p>在条件渲染中，我们可以定义一个储存组件的变量。来通过不同的赋值条件显示。</p>
<h3 id="行内条件使用-amp-amp-操作符"><a href="#行内条件使用-amp-amp-操作符" class="headerlink" title="行内条件使用&amp;&amp;操作符"></a>行内条件使用&amp;&amp;操作符</h3><p>if可以解决条件渲染，但是有时我们会追求简介的写法，下面就简单介绍下&amp;&amp;操作符。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function And(props) &#123;</span><br><span class="line">    cosnt isLength = props.isLength;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;hello&lt;/h1&gt;</span><br><span class="line">            &#123;isLength.length &gt; 0 &amp;&amp; </span><br><span class="line">                &lt;h2&gt; isLength.length&lt;/h2&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isLength = [1,2,3];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;And isLength=&#123;isLength&#125; /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里运用了短路运算，只有前面一个条件为true的时候才会渲染出组件</p>
<ul>
<li>当然使用三目运算符也是很常见的简化方式。</li>
</ul>
<h3 id="阻止组件的渲染"><a href="#阻止组件的渲染" class="headerlink" title="阻止组件的渲染"></a>阻止组件的渲染</h3><p>有一些情况也许你希望一个组件隐藏起来。想要隐藏它就返回null作为输出而不是渲染输出。下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function PageComponent(props) &#123;</span><br><span class="line">  if (!props.num) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;warning&quot;&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Page extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;showComponent: true&#125;</span><br><span class="line">    this.handleToggleClick = this.handleToggleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    this.setState(prevState =&gt; (&#123;</span><br><span class="line">      showComponent: !prevState.showComponent</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;PageComponent warn=&#123;this.state.showComponent&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;this.state.showComponent ? &apos;Hide&apos; : &apos;Show&apos;&#125;</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Page /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>组件的render方法返回null不会影响组件的生命周期方法的运行。比如，componentWillUpdate和componentDidUpdate将一直被调用。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react学习之初识jsx</title>
    <url>/2018/04/05/react%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%9D%E8%AF%86jsx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>jsx</code>是用在<code>React</code>中的一种虚拟<code>dom</code>的一种方式。<code>React</code>有一个核心机制就是虚拟<code>dom</code>，就是对虚拟<code>dom</code>的操作，减少了对实际<code>dom</code>的操作，大大提高了性能。<code>jsx</code>就是<code>javascript</code>和<code>xml</code>结合的一种格式，<a id="more"></a><code>React</code>发明了<code>jsx</code>，利用<code>html</code>语法来创建虚拟<code>dom</code>。当遇到<code>&lt;</code>的时候，<code>jsx</code>就当做<code>html</code>来解析。当遇到<code>{</code>的时候，就当<code>javascript</code>解析。<br>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const List = (</span><br><span class="line">    &lt;ul className=&quot;list&quot;&gt;</span><br><span class="line">        &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>如上面的代码需要注意一点，由于<code>class</code>是<code>javascript</code>中的关键字，所以需要用<code>className</code>来代替，而<code>for</code>用<code>htmlFor</code>代替。其实<code>jsx</code>在执行的过程中是经过翻译器翻译的，翻译成了原生的<code>javascript</code>代码来执行。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><code>jsx</code>中的大括号中放的是<code>javascript</code>代码，所以也可以放表达式，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;a?1:0&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>而且在<code>jsx</code>中，可以循环一个数组来返回列表数据。</p>
</li>
<li><p><code>jsx</code>中绑定事件，可以直接绑定到元素上。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;this.submit.bind(this)&#125;&gt;submit&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>在这里需要注意两点：</p>
<ol>
<li><code>onClick</code>的<code>c</code>必须大写，因为这里是当做<code>javascript</code>来解析的，大小写要区分。</li>
<li><code>this</code>的指向需要手动绑定。</li>
</ol>
<ul>
<li>使用内联样式的时候，传入的属性值不能是字符串了，必须是对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;color:&quot;#fff&quot;&#125;&#125;&gt;jsx&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这里需要主意的就是，并不是双大括号，而是在传入属性的时候里面的大括号是表示的是对象。</p>
<ul>
<li>在组件内部添加<code>html</code>代码的时候，并将<code>html</code>代码渲染到页面上，<code>React</code>会默认转义，如果不想转义可以这样写：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var wy = &apos;&lt;h1&gt;wy&lt;/h1&gt;&apos;</span><br><span class="line">React.render(</span><br><span class="line">    &lt;div dangerouslySetInnerHTML=&#123;&#123;__html:wy&#125;&#125;&gt;&lt;/div&gt;,document.body</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>#小结</p>
<p>在刚接触<code>jsx</code>的时候，看着这种混合在一起的写法会很不适应，不过写的多了，看的多了慢慢也就习惯了。特别和vue不同，在vue中双引号之中也可能是<code>javascript</code>代码，而<code>jsx</code>中是大括号，这点要区分开。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>div+css画三角形的方法和原理</title>
    <url>/2018/03/25/div-css%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其实使用div和css做出三角形，原理就是对div盒子的border属性的运用。首先，先上个简单的代码：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;try&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.try &#123;</span><br><span class="line">    width:0;</span><br><span class="line">    height:0;</span><br><span class="line">    border-top: 50px solid red;</span><br><span class="line">    border-right: 50px solid green;</span><br><span class="line">    border-bottom: 50px solid blue;</span><br><span class="line">    border-left: 50px solid orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行代码，打开浏览器浏览结果。你会看到一个div盒子被四种不同颜色的三角形分割。这是我们实现三角形的第一步！</p>
<h2 id="形成一个三角形"><a href="#形成一个三角形" class="headerlink" title="形成一个三角形"></a>形成一个三角形</h2><p>看图我们可以知道，我们想要的那个方向的三角形显示，其他方向的三块三角形区域隐藏。这样，我们想要的三角形就做好了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div class=&quot;top&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.top&#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-right: 50px solid transparent;</span><br><span class="line">    border-bottom: 50px solid red;</span><br><span class="line">    border-left: 50px solid transparent;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-top: 50px solid transparent;</span><br><span class="line">    border-bottom: 50px solid transparent;</span><br><span class="line">    border-left: 50px solid red;</span><br><span class="line">&#125;</span><br><span class="line">.bottom&#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-top: 50px solid red;</span><br><span class="line">    border-right: 50px solid transparent;</span><br><span class="line">    border-left: 50px solid transparent;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-top: 50px solid transparent;</span><br><span class="line">    border-right: 50px solid red;</span><br><span class="line">    border-bottom: 50px solid transparent;</span><br></pre></td></tr></table></figure>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>div加css可以实现很多的图形，这里主要说三角形的做法。因为在开发中用的比较多！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>create-react-app基本自定义配置</title>
    <url>/2018/03/17/create-react-app%E5%9F%BA%E6%9C%AC%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>create-react-app作为最常用的react脚手架集成了很多的常用功能，比如支持es6、JSX、动态import、Fetch(polyfill)、proxy、postcss、eslint等。但也有些功能并没有提供支持比如Hot-reloading和css预处理器，所以我们需要自定义配置这些功能。<br><a id="more"></a></p>
<p>首先需要npm run eject进行自定义配置。</p>
<h2 id="配置proxy"><a href="#配置proxy" class="headerlink" title="配置proxy"></a>配置proxy</h2><p>在package.json中添加proxy字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;eslintConfig&quot;: &#123;</span><br><span class="line">   &quot;extends&quot;: &quot;react-app&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> &quot;proxy&quot;: &#123;</span><br><span class="line">   &quot;/api&quot;: &#123;</span><br><span class="line">     &quot;target&quot;: &quot;https://m.weibo.cn&quot;,</span><br><span class="line">     &quot;changeOrigin&quot;: true</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<p>在<code>index.js</code>中实验一下代理的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registerServiceWorker();</span><br><span class="line"></span><br><span class="line">fetch(&apos;/api/comments/show?id=4199740256395164&amp;page=1&apos;).then(res =&gt; &#123;</span><br><span class="line">    res.json().then(data =&gt; &#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后运行<code>yarn start</code>打开控制台看下打印的日志，如果成功就会看到请求到的数据了。</p>
<h2 id="配置css的预处理器sass"><a href="#配置css的预处理器sass" class="headerlink" title="配置css的预处理器sass"></a>配置css的预处理器sass</h2><p>首先需要安装对应的<code>loader</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add sass-loader node-sass --dev</span><br></pre></td></tr></table></figure>
<p>然后在修改<code>dev</code>环境的配置,在如下代码所试的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test: /\.css$/,</span><br><span class="line">           use: [</span><br><span class="line">             require.resolve(&apos;style-loader&apos;),</span><br><span class="line">             &#123;</span><br><span class="line">               loader: require.resolve(&apos;css-loader&apos;),</span><br><span class="line">               options: &#123;</span><br><span class="line">                 importLoaders: 1,</span><br><span class="line">               &#125;,</span><br><span class="line">             &#125;,</span><br></pre></td></tr></table></figure>
<p>改为下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test: /\.(css|scss)$/,</span><br><span class="line">           use: [</span><br><span class="line">             require.resolve(&apos;style-loader&apos;),</span><br><span class="line">             &#123;</span><br><span class="line">               loader: require.resolve(&apos;css-loader&apos;),</span><br><span class="line">               options: &#123;</span><br><span class="line">                 importLoaders: 2,</span><br><span class="line">               &#125;,</span><br><span class="line">             &#125;,</span><br></pre></td></tr></table></figure>
<p>然后在<code>use</code>规则的结尾加上一个<code>loader</code>如下`</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">loader: require.resolve(&apos;postcss-loader&apos;),</span><br><span class="line">options: &#123;</span><br><span class="line">    // Necessary for external CSS imports to work</span><br><span class="line">    // https://github.com/facebookincubator/create-react-app/issues/2677</span><br><span class="line">    ident: &apos;postcss&apos;,</span><br><span class="line">    plugins: () =&gt; [</span><br><span class="line">    require(&apos;postcss-flexbugs-fixes&apos;),</span><br><span class="line">    autoprefixer(&#123;</span><br><span class="line">        browsers: [</span><br><span class="line">        &apos;&gt;1%&apos;,</span><br><span class="line">        &apos;last 4 versions&apos;,</span><br><span class="line">        &apos;Firefox ESR&apos;,</span><br><span class="line">        &apos;not ie &lt; 9&apos;, // React doesn&apos;t support IE8 anyway</span><br><span class="line">        ],</span><br><span class="line">        flexbox: &apos;no-2009&apos;,</span><br><span class="line">    &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    loader:require.resolve(&apos;sass-loader&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改生产环境下的方法同上。</p>
<h2 id="配置模块热更新"><a href="#配置模块热更新" class="headerlink" title="配置模块热更新"></a>配置模块热更新</h2><p>模块热跟新就是不刷新页，需要更新的模块自己跟新。首先我们需要安装所需要的模块，执行以下命令进行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react-hot-loader --dev</span><br></pre></td></tr></table></figure>
<p>然后在webpack.config.dev.js配置文件的入口配置中添加以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;react-hot-loader/patch&apos;,</span><br><span class="line">// We ship a few polyfills by default:</span><br><span class="line">require.resolve(&apos;./polyfills&apos;),</span><br></pre></td></tr></table></figure>
<p>然后在<code>babel-loader</code>中添加一个<code>plugins</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(js|jsx|mjs)$/,</span><br><span class="line">    include: paths.appSrc,</span><br><span class="line">    loader: require.resolve(&apos;babel-loader&apos;),</span><br><span class="line">    options: &#123;</span><br><span class="line">        </span><br><span class="line">        // This is a feature of `babel-loader` for webpack (not Babel itself).</span><br><span class="line">        // It enables caching results in ./node_modules/.cache/babel-loader/</span><br><span class="line">        // directory for faster rebuilds.</span><br><span class="line">        cacheDirectory: true,</span><br><span class="line">        plugins: [</span><br><span class="line">        &apos;react-hot-loader/babel&apos;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在修改入口文件代码<code>index.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &apos;./index.css&apos;;</span><br><span class="line">import App from &apos;./App&apos;;</span><br><span class="line">import registerServiceWorker from &apos;./registerServiceWorker&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; AppContainer &#125; from &apos;react-hot-loader&apos;;</span><br><span class="line"></span><br><span class="line">// ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));</span><br><span class="line"></span><br><span class="line">const render = Component =&gt; &#123;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;AppContainer&gt;</span><br><span class="line">            &lt;Component&gt;&lt;/Component&gt;</span><br><span class="line">        &lt;/AppContainer&gt;,</span><br><span class="line">        document.getElementById(&apos;root&apos;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(App);</span><br><span class="line"></span><br><span class="line">if(module.hot) &#123;</span><br><span class="line">    module.hot.accept(&apos;./App&apos;,() =&gt; &#123;</span><br><span class="line">        render(App);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">registerServiceWorker();</span><br><span class="line"></span><br><span class="line">//之前实验proxy代理的代码</span><br><span class="line">fetch(&apos;/api/comments/show?id=4199740256395164&amp;page=1&apos;)</span><br><span class="line">    .then(res =&gt; &#123;</span><br><span class="line">        res.json().then(data =&gt; &#123;</span><br><span class="line">            console.log(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>这样就完成了热更新的配置。到此基本的自定义配置已经完成了。有新的需求在补充。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>js统计数组中元素出现的次数所引出的思考</title>
    <url>/2018/03/16/js%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E6%89%80%E5%BC%95%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="有需求才有动力"><a href="#有需求才有动力" class="headerlink" title="有需求才有动力"></a>有需求才有动力</h2><p>在做项目的时候，有表格数据的展示。在后端的给的数据，前台显示的时候需要知道每个数据的<code>key</code>出现的次数。然后我就想了一下，基本解决需求。下面是我的实现方式。<br><a id="more"></a></p>
<h2 id="统计次数"><a href="#统计次数" class="headerlink" title="统计次数"></a>统计次数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getCount(arr)&#123; </span><br><span class="line">    var obj = &#123;&#125;, k, arr1 = [];</span><br><span class="line">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        k = arr[i];</span><br><span class="line">        if (obj[k]) </span><br><span class="line">            obj[k]++;</span><br><span class="line">        else </span><br><span class="line">            obj[k] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //保存结果&#123;el-&apos;元素&apos;，count-出现次数&#125;</span><br><span class="line">    for (var o in obj) &#123;</span><br><span class="line">        arr1.push(&#123;el: o, count: obj[o]&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里说明一下，首先定义一个函数<code>getCount</code>.参数是一个数组，然后里面的具体逻辑就直接看代码吧···</p>
<h2 id="需求改变"><a href="#需求改变" class="headerlink" title="需求改变"></a>需求改变</h2><p>这时，产品经理过来说这个个数是统计出来了，但是排序有点混乱啊！万一客户需要排序呢？（心里想你是客户吧！！）。没办法，改喽！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getCount(arr, ranktype)&#123; </span><br><span class="line">    var obj = &#123;&#125;, k, arr1 = [];</span><br><span class="line">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        k = arr[i];</span><br><span class="line">        if (obj[k]) </span><br><span class="line">            obj[k]++;</span><br><span class="line">        else </span><br><span class="line">            obj[k] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //保存结果&#123;el-&apos;元素&apos;，count-出现次数&#125;</span><br><span class="line">    for (var o in obj) &#123;</span><br><span class="line">        arr1.push(&#123;el: o, count: obj[o]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    //排序（降序）</span><br><span class="line">    arr1.sort(function (n1, n2) &#123;</span><br><span class="line">        return n2.el - n1.el</span><br><span class="line">    &#125;);</span><br><span class="line">    //如果ranktype为1，则为升序，反转数组</span><br><span class="line">    if(ranktype===1)&#123;</span><br><span class="line">        arr1=arr1.reverse();</span><br><span class="line">    &#125;</span><br><span class="line">    return arr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样加一点代码，就实现了。默认是降序排的，如果参数<code>ranktype</code>为1就是升序！</p>
<h2 id="需求又来了！！！（我要拿刀了！！！）"><a href="#需求又来了！！！（我要拿刀了！！！）" class="headerlink" title="需求又来了！！！（我要拿刀了！！！）"></a>需求又来了！！！（我要拿刀了！！！）</h2><p>这时，产品经理过来说排序是出来了，万一客户需要取出一部分排序呢？（心里想你是客户吧！！）。没办法，改喽！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getCount(arr, rank,ranktype)&#123; </span><br><span class="line">    var obj = &#123;&#125;, k, arr1 = [];</span><br><span class="line">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        k = arr[i];</span><br><span class="line">        if (obj[k]) </span><br><span class="line">            obj[k]++;</span><br><span class="line">        else </span><br><span class="line">            obj[k] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //保存结果&#123;el-&apos;元素&apos;，count-出现次数&#125;</span><br><span class="line">    for (var o in obj) &#123;</span><br><span class="line">        arr1.push(&#123;el: o, count: obj[o]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    //排序（降序）</span><br><span class="line">    arr1.sort(function (n1, n2) &#123;</span><br><span class="line">        return n2.count - n1.count</span><br><span class="line">    &#125;);</span><br><span class="line">    //如果ranktype为1，则为升序，反转数组</span><br><span class="line">    if(ranktype===1)&#123;</span><br><span class="line">        arr1=arr1.reverse();</span><br><span class="line">    &#125;</span><br><span class="line">    var rank1 = rank || arr1.length;</span><br><span class="line">    return arr1.slice(0,rank1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样加一点代码，一个判断参数就又实现了。<code>rank</code>排序的前几位。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
  </entry>
  <entry>
    <title>实现footer置底</title>
    <url>/2018/03/08/%E5%AE%9E%E7%8E%B0footer%E7%BD%AE%E5%BA%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是footer置底"><a href="#什么是footer置底" class="headerlink" title="什么是footer置底"></a>什么是footer置底</h1><p>页脚置底（Sticky footer）就是让网页的footer部分始终在浏览器窗口的底部。<br>当网页内容足够长以至超出浏览器可视高度时，页脚会随着内容被推到网页底部；但如果网页内容不够长，置底的页脚就会保持在浏览器窗口底部。<br><a id="more"></a></p>
<h1 id="有哪些实现方法呢？请看下面："><a href="#有哪些实现方法呢？请看下面：" class="headerlink" title="有哪些实现方法呢？请看下面："></a>有哪些实现方法呢？请看下面：</h1><h2 id="将内容部分的底部外边距设为负数"><a href="#将内容部分的底部外边距设为负数" class="headerlink" title="将内容部分的底部外边距设为负数"></a>将内容部分的底部外边距设为负数</h2><p>这是个比较主流的用法，把内容部分最小高度设为100%，再利用内容部分的负底部外边距值来达到当高度不满时，页脚保持在窗口底部，当高度超出则随之推出的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">  </span><br><span class="line">      content</span><br><span class="line">      </span><br><span class="line">    &lt;div class=&quot;push&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.wrapper &#123;</span><br><span class="line">  min-height: 100%;</span><br><span class="line"></span><br><span class="line">  /* 等于footer的高度 */</span><br><span class="line">  margin-bottom: -50px;</span><br><span class="line">&#125;</span><br><span class="line">.footer,</span><br><span class="line">.push &#123;</span><br><span class="line">  height: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法需要容器里有额外的占位元素（如.push）.需要注意的是.wrapper的margin-bottom值需要和.footer的负的height值保持一致，这一点不太友好。</p>
<h2 id="将页脚的顶部外边距设为负数"><a href="#将页脚的顶部外边距设为负数" class="headerlink" title="将页脚的顶部外边距设为负数"></a>将页脚的顶部外边距设为负数</h2><p>既然能在容器上使用负的margin bottom，那能否使用负margin top吗？当然可以。给内容外增加父元素，并让内容部分的底部内边距与页脚高度的值相等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;content-inside&quot;&gt;</span><br><span class="line">      content</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.content &#123;</span><br><span class="line">  min-height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.content-inside &#123;</span><br><span class="line">  padding: 20px;</span><br><span class="line">  padding-bottom: 50px;</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">  height: 50px;</span><br><span class="line">  margin-top: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这种方法和上一种一样，都需要额外添加不必要的html元素。</p>
<h2 id="使用calc-设置内容的高度"><a href="#使用calc-设置内容的高度" class="headerlink" title="使用calc()设置内容的高度"></a>使用calc()设置内容的高度</h2><p>有一种方法不需要任何多余元素——使用CSS3新增的计算函数calc()，这样元素间就不会有重叠发生，也不需要控制内外边距了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    content</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">  min-height: calc(100vh - 70px);</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">  height: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能你会疑惑内容高度calc()中为什么减去70px，而不是footer的高度50px，因为假设俩元素有20px的间距，所以70px=50px+20px.</p>
<h2 id="使用flexbox弹性布局"><a href="#使用flexbox弹性布局" class="headerlink" title="使用flexbox弹性布局"></a>使用flexbox弹性布局</h2><p>以上三种方法的footer高度都是固定的，通常来说这不利于网页布局：内容会改变，它们都是弹性的，一旦内容超出固定高度就会破坏布局。所以给footer使用flexbox吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    content</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">  min-height: 100%;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line">.content &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Grid网格布局"><a href="#使用Grid网格布局" class="headerlink" title="使用Grid网格布局"></a>使用Grid网格布局</h2><p>grid比flexbox还要新很多，并且更加简洁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    content</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">  min-height: 100%;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-rows: 1fr auto;</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">  grid-row-start: 2;</span><br><span class="line">  grid-row-end: 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>footer置底有很多方式，这是我现在整理总结的，等有发现继续追加~~~</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>用git命令更新fork的项目</title>
    <url>/2018/02/27/%E6%9B%B4%E6%96%B0fork%E7%9A%84%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v </span><br><span class="line">git remote add upstream git@github.com:xxx/xxx.git</span><br><span class="line">git fetch upstream</span><br><span class="line">git merge upstream/master</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="基本展示"><a href="#基本展示" class="headerlink" title="基本展示"></a>基本展示</h1><p><img src="http://images.wangyuanweb.top/git-01.jpg" alt="演示图片01"></p>
<p><img src="http://images.wangyuanweb.top/git-02.jpg" alt="演示图片02"></p>
<p><img src="http://images.wangyuanweb.top/git-03.jpg" alt="演示图片03"></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>git技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>初识react</title>
    <url>/2018/01/14/%E5%88%9D%E8%AF%86react/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="react-基本浏览所得"><a href="#react-基本浏览所得" class="headerlink" title="react 基本浏览所得"></a>react 基本浏览所得</h2><ol>
<li>jsx 属性必须使用驼峰命名</li>
<li>react 渲染更新的时候只更新改变的一部分<a id="more"></a></li>
<li>定义组件的时候，组件的命名要首字母大写</li>
<li>组件返回的只能只有一个根元素，所以外面通常有个<code>div</code>包裹</li>
<li>组件内部不能修改 props</li>
<li>改变组件内部的状态只能使用<code>setState</code>方法，不能直接更新</li>
<li>状态更新可能是异步的，不应该依靠它们的值来计算下一个状态</li>
<li>解决状态更新异步的问题，可以在<code>setState</code>方法中接受一个函数</li>
<li>类定义组件需要手动绑定<code>this</code>,不会自动绑定<code>this</code></li>
<li>在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现</li>
<li>react 是单向数据流，多个组件公用的状态，要提高到离他们最近的父组件中去</li>
</ol>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的px2rem</title>
    <url>/2017/12/31/webpack%E4%B8%AD%E7%9A%84px2rem/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="vue做移动端适配，借助px2rem插件方便的将px单位转换为rem"><a href="#vue做移动端适配，借助px2rem插件方便的将px单位转换为rem" class="headerlink" title="vue做移动端适配，借助px2rem插件方便的将px单位转换为rem"></a>vue做移动端适配，借助px2rem插件方便的将px单位转换为rem</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install px2rem-loader --save</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="在build下的-utils-js中，找到generateLoaders-方法，在这里添加。"><a href="#在build下的-utils-js中，找到generateLoaders-方法，在这里添加。" class="headerlink" title="在build下的 utils.js中，找到generateLoaders 方法，在这里添加。"></a>在build下的 utils.js中，找到generateLoaders 方法，在这里添加。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const px2remLoader = &#123;</span><br><span class="line">loader: &apos;px2rem-loader&apos;,</span><br><span class="line">options: &#123;</span><br><span class="line">        remUnit: 37.5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function generateLoaders (loader, loaderOptions) &#123;</span><br><span class="line">const loaders = [cssLoader, px2remLoader]</span><br><span class="line">if (loader) &#123;</span><br><span class="line">    loaders.push(&#123;</span><br><span class="line">        loader: loader + &apos;-loader&apos;,</span><br><span class="line">        options: Object.assign(&#123;&#125;, loaderOptions, &#123;</span><br><span class="line">            sourceMap: options.sourceMap</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重启项目，会发现自己设置的px被转为rem-了"><a href="#重启项目，会发现自己设置的px被转为rem-了" class="headerlink" title="重启项目，会发现自己设置的px被转为rem 了"></a>重启项目，会发现自己设置的px被转为rem 了</h2><h2 id="以上实现转换适用于："><a href="#以上实现转换适用于：" class="headerlink" title="以上实现转换适用于："></a>以上实现转换适用于：</h2><ol>
<li><p>组件中编写的<style></style>下的css</p>
</li>
<li><p>从index.js或者main.js中import ‘../../static/css/reset.css’引入css</p>
</li>
<li><p>在组件的&lt;script type=”text/ecmascript-6″&gt; import ‘../../static/css/reset.css’中引入css</p>
</li>
</ol>
<h2 id="另外的情况"><a href="#另外的情况" class="headerlink" title="另外的情况"></a>另外的情况</h2><ol>
<li><p>组件<code>&lt;style&gt;&lt;/style&gt;</code>中<code>@import “../../static/css/reset.css</code> (可考虑上面（2）、（3）的形式引入)</p>
</li>
<li><p>外部样式:<code>&lt;link rel=”stylesheet” href=”static/css/reset.css”&gt;</code></p>
</li>
<li><p>元素内部样式：<code>style=”height: 417px; width: 550px;”</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>vue再遇监视对象改变</title>
    <url>/2017/12/15/vue%E5%86%8D%E9%81%87%E7%9B%91%E8%A7%86%E5%AF%B9%E8%B1%A1%E6%94%B9%E5%8F%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="造坑"><a href="#造坑" class="headerlink" title="造坑"></a>造坑</h2><p>在 vue 项目中，我们都知道对吸引人的莫过于数据的双向绑定。今天我要说的就是在数据绑定操作中遇到的问题。话不多说，上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h5&gt;互动记录&lt;/h5&gt;</span><br><span class="line">&lt;div class=&quot;check_box_style&quot;&gt;</span><br><span class="line">    &lt;el-form-item :label=&quot;`$&#123;item&#125;届`&quot; v-for=&quot;item in enumsConfig.SysExpert.active&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;box_style&quot;&gt;</span><br><span class="line">            &lt;span v-for=&quot;(ele,index) in enumsConfig.SysExpert.status&quot; :key=&quot;index&quot; style=&quot;margin-right:10px;&quot; class=&quot;colorC&quot; :class=&quot;&#123; colorActive: expert_status_map[item] &amp;&amp; expert_status_map[item].includes(ele.key) &#125;&quot; @click=&quot;setExpertStatus(item,ele.key)&quot;&gt;&#123;&#123;ele.title&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>主要需求就是根据<code>enumsConfig.SysExpert.status</code>中的<code>key</code>在不在<code>expert_status_map[item]</code>来高亮。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li><p>当我在做这个组键的时候，是有编辑页面和添加页面公用同一个页面，所以在业务逻辑上面有一点分歧。首先，在需求上面，编辑页面的互动记录是点击每一个按钮，都调用一次接口。对数据进行操作。但是在添加页面的时候，只是最后一起把按钮选择的数据传过去。</p>
</li>
<li><p>重点是<code>expert_status_map</code>需要一个类似这样的数据结构</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    2016:[a,b,c],</span><br><span class="line">    2017:[b,c,e]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>然后我<code>data</code>中存的<code>expert_status_map</code>数据是个空对象，所以传统的赋值<code>this.expert_status_map[item] = []</code>看似很成功，但是在操作的时候，发现虽然数据改变了，但是<code>html</code>高亮并没有发生变化。</li>
</ol>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>最后看了 vue 官方文档：</p>
<p><img src="http://images.wangyuanweb.top/vue.png" alt="vue"></p>
<p>这样赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$set(this.expert_status_map, item, []);</span><br></pre></td></tr></table></figure>
<p>这样vue就能检测到数据的变化啦！</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>当vuex遇到web storage</title>
    <url>/2017/11/07/%E5%BD%93vuex%E9%81%87%E5%88%B0web-storage/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="遇到的业务需求"><a href="#遇到的业务需求" class="headerlink" title="遇到的业务需求"></a>遇到的业务需求</h2><p>在写一个vue后台项目的时候，遇到了登录权限的管理。这时，后台给我的权限数据我获取之后，需要保存下来以备后来使用。然后我想到了vue的数据状态管理vuex和html5的本地存储功能。<br><a id="more"></a></p>
<h2 id="确定使用方案"><a href="#确定使用方案" class="headerlink" title="确定使用方案"></a>确定使用方案</h2><p>在这个项目中，我考虑着权限获取之后要保存在本地，然后页面刷新又不用再次取数据。我决定是用web storage存储。大家知道vuex在页面刷新的时候数据是清空的。</p>
<h2 id="介绍web-storage"><a href="#介绍web-storage" class="headerlink" title="介绍web storage"></a>介绍web storage</h2><p>这个api的作用就是使得网页可以在浏览器端储存数据，它分成两类：sessionStorage和localStorage。sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；localStorage保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。除了保存期限的长短不同，这两个对象的属性和方法完全一样。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>存储数据</li>
</ul>
<p>sessionStorage和localStorage保存的数据，都以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sessionStorage.setItem(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">localStorage.setItem(&quot;key&quot;,&quot;value&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>读取数据</li>
</ul>
<p>读取数据使用getItem方法。它只有一个参数，就是键名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var valueSession = sessionStorage.getItem(&quot;key&quot;);</span><br><span class="line">var valueLocal = localStorage.getItem(&quot;key&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>清除数据</li>
</ul>
<p>removeItem方法用于清除某个键名对应的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sessionStorage.removeItem(&apos;key&apos;);</span><br><span class="line">localStorage.removeItem(&apos;key&apos;);</span><br></pre></td></tr></table></figure>
<p>clear方法用于清除所有保存的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sessionStorage.clear();</span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>虽然，这样也解决了数据存储问题，但是却遇到了另外几个问题：</p>
<ol>
<li>像用户权限这样重要的数据暴露出去是非常不安全的。</li>
<li>权限数据是在登录完成时获取的，那样如果后台数据变化，刷新浏览器不会更新数据。</li>
<li>用户自己改变了权限，也必须先退出再登录，才能更新。</li>
<li>数据清空的等到浏览器关闭</li>
</ol>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>基于以上问题，最后改用了vuex，通过它来进行权限数据的存储。在路由开始之前调用钩子函数，来更新vuex中的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    api.sysenums.sysEnums()(res =&gt; &#123;</span><br><span class="line">        store.dispatch(&apos;getInitEmus&apos;, res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>知识有限，忘指教。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>数据管理</tag>
        <tag>本地存储</tag>
      </tags>
  </entry>
  <entry>
    <title>再遇Event对象使用场景</title>
    <url>/2017/11/03/%E5%86%8D%E9%81%87Event%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在项目开发中遇到了这样一个需求：在上传图片过程中，之前是通过直接点击<code>input</code>标签的<code>type=&#39;file&#39;</code>来实现选择和浏览本地文件。</p>
<p>但是,现在遇到的问题是，通过点击其他的按钮来触发这个节点的点击事件。<a id="more"></a>开始觉得绑定一个点击的click事件，最后发现不能够自动触发上传文件的点击，然后搜索了一下，想起来了<code>event</code>事件对象，然后结合之前学习的，又看了一下资料，记录一下解决问题的历程。</p>
<h2 id="Event对象"><a href="#Event对象" class="headerlink" title="Event对象"></a>Event对象</h2><p>Event对象本身是一个构造函数，所以，既然是对象，就可以实例化：</p>
<pre><code>event = new Event(&apos;click&apos;);
</code></pre><p>Event构造函数接受两个参数。第一个参数是字符串，表示事件的名称；第二个参数是一个对象，表示事件对象的配置。该参数可以有以下两个属性。</p>
<pre><code>event = new Event(eventName, configObj);
</code></pre><p>其中configObj有两个配置参数</p>
<pre><code>bubbles：布尔值，可选，默认为false，表示事件对象是否冒泡。
cancelable：布尔值，可选，默认为false，表示事件是否可以被取消。
</code></pre><p>当我们触发这个对象生成的事件用<code>dispatchEvent</code>方法</p>
<pre><code>let event = new Event(&apos;click&apos;);
dom.dispatchEvent(event);
</code></pre><p>这样就可以点击其他节点，触发本节点的事件了。</p>
<pre><code>const event = new Event(&apos;click&apos;);
document.querySelector(&apos;.el-upload.el-upload--text&apos;).dispatchEvent(event);
</code></pre><p>用这种方法就可以解决上述问题了。     </p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2017/11/03/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>相信在开发中，代码的管理和版本的迭代也是非常重要的，如果做不好这些工作，开发中是非常糟糕的。刚开始学习的时候也不知道这些，最后在工作和网上看到了一些关于版本控制工具的介绍和使用技巧和优缺点的介绍。最后个人觉得<strong> git </strong>是个很好的版本控制工具，至于优点用过才知道，最好的功能莫过于和 <strong> github </strong>结合使用，列举了一些操作命令，一方面供自己查询，另一方面也好大家参考。</p>
<h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><p>在新建之前首先需要装上git，然后进行以下操作。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="config配置"><a href="#config配置" class="headerlink" title="config配置"></a>config配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>
<h2 id="add-delete文件"><a href="#add-delete文件" class="headerlink" title="add/delete文件"></a>add/delete文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
<h2 id="同步提交code"><a href="#同步提交code" class="headerlink" title="同步提交code"></a>同步提交code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
<h2 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h2><p>在打tag的时候先<code>build</code>然后<code>git push</code>然后<code>git tag xx</code>然后在用<code>git push origin xx</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure></p>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
<h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>JS/JQ获取各种高度和宽度</title>
    <url>/2017/10/31/jsjq%E8%8E%B7%E5%8F%96%E5%90%84%E7%A7%8D%E9%AB%98%E5%BA%A6%E5%92%8C%E5%AE%BD%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript:"></a>Javascript:</h2><p>网页可见区域宽： document.body.clientWidth</p>
<p>网页可见区域高： document.body.clientHeight</p>
<p>网页可见区域宽： document.body.offsetWidth (包括边线的宽)</p>
<p>网页可见区域高： document.body.offsetHeight (包括边线的高)<br><a id="more"></a></p>
<p>网页正文全文宽： document.body.scrollWidth</p>
<p>网页正文全文高： document.body.scrollHeight</p>
<p>网页被卷去的高： document.body.scrollTop</p>
<p>网页被卷去的左： document.body.scrollLeft</p>
<p>网页正文部分上： window.screenTop</p>
<p>网页正文部分左： window.screenLeft</p>
<p>屏幕分辨率的高： window.screen.height</p>
<p>屏幕分辨率的宽： window.screen.width</p>
<p>屏幕可用工作区高度： window.screen.availHeight</p>
<p>屏幕可用工作区宽度： window.screen.availWidth</p>
<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery:"></a>JQuery:</h2><p>$(document).ready(function(){</p>
<p>alert($(window).height()); //浏览器当前窗口可视区域高度</p>
<p>alert($(document).height()); //浏览器当前窗口文档的高度</p>
<p>alert($(document.body).height());//浏览器当前窗口文档body的高度</p>
<p>alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin</p>
<p>alert($(window).width()); //浏览器当前窗口可视区域宽度</p>
<p>alert($(document).width());//浏览器当前窗口文档对象宽度</p>
<p>alert($(document.body).width());//浏览器当前窗口文档body的宽度</p>
<p>alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin</p>
<p>})</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown常用语法</title>
    <url>/2017/10/28/makedown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="斜体、粗体和下划线"><a href="#斜体、粗体和下划线" class="headerlink" title="斜体、粗体和下划线"></a>斜体、粗体和下划线</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*或_斜体_</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>例如：</p>
<p><em>斜体</em>或_斜体_</p>
<p><strong>粗体</strong></p>
<p><strong><em>加粗斜体</em></strong></p>
<p><del>删除线</del></p>
<hr>
<h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">欢迎来到[前端小白不自在](http://wnagyuan0108.github.io)</span><br></pre></td></tr></table></figure>
<p>欢迎来到<a href="http://wnagyuan0108.github.io" rel="external nofollow noopener noreferrer" target="_blank">前端小白不自在</a></p>
<h2 id="自链接"><a href="#自链接" class="headerlink" title="自链接"></a>自链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;http://wnagyuan0108.github.io&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p><a href="http://wnagyuan0108.github.io" rel="external nofollow noopener noreferrer" target="_blank">http://wnagyuan0108.github.io</a></p>
<hr>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 有序一</span><br><span class="line">2. 有序二</span><br><span class="line">3. 有序三</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<ol>
<li>有序一</li>
<li>有序二</li>
<li>有序三</li>
</ol>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 无序一</span><br><span class="line">* 无序二</span><br><span class="line">* 无序三</span><br><span class="line">或者</span><br><span class="line">- 无序一</span><br><span class="line">- 无序二</span><br><span class="line">- 无序三</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<ul>
<li>无序一</li>
<li>无序二</li>
<li>无序三</li>
</ul>
<h2 id="列表对齐"><a href="#列表对齐" class="headerlink" title="列表对齐"></a>列表对齐</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-  我是前端小白不自在</span><br><span class="line"></span><br><span class="line">    我是前端小白不自在</span><br><span class="line">    </span><br><span class="line">    我是前端小白不自在(空一个tab)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>我是前端小白不自在</p>
<p>  我是前端小白不自在</p>
<p>  我是前端小白不自在</p>
</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>两个tab、三个~~~、三个<code>`</code></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><pre><code>&gt; 我是前端小白不自在
&gt;&gt; 我是前端小白不自在
&gt;&gt;&gt; 我是前端小白不自在
</code></pre><p>例如：</p>
<blockquote>
<p>我是前端小白不自在</p>
<blockquote>
<p>我是前端小白不自在</p>
<blockquote>
<p>我是前端小白不自在</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><ul>
<li><img src="图片地址 “图片Title”" alt="图片Alt"><pre><code>![前端小白不自在](https://ss0.baidu.com/73x1bjeh1BF3odCf/it/u=78676840,294168160&amp;fm=85&amp;s=A3F3CB26F0CEACBC7447D3010300B0CD &quot;markdown&quot;)
</code></pre></li>
</ul>
<h2 id="html代码可以直接解析"><a href="#html代码可以直接解析" class="headerlink" title="html代码可以直接解析"></a>html代码可以直接解析</h2><pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;王园&lt;/td&gt;
        &lt;td&gt;王园&lt;/td&gt;
        &lt;td&gt;王园&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>技术文档</tag>
      </tags>
  </entry>
</search>
