---
title: 前端每日一题
categories: WEB前端
copyright: true
date: 2021-01-12 15:41:25
top: true
tags: 题目
---
## 简介
记录前端需要掌握的知识点，通过答题进行巩固和提升。让自己的基础更牢固，原理更加熟识！！！
## 题目
1. vue的双向绑定原理是什么？
<!--more-->
    <details>
    <summary>答案</summary>
    ```
    vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过ES5提供的Object.defineProperty()方法来劫持(监视)各个属性的setter,getter，在数据变动的时发布消息给订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送发送给绑定的视图，而不是对所有的数据都执行一次检测。
    具体的步骤：
    1. 需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上getter和setter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
    2. compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
    3. Watcher订阅者是Observer和compile之间通信桥梁，主要做的事情是：
        - 在自身实例化时往属性订阅器(dep)里面添加自己
        - 自身必须有一个update()的方法
        - 待属性变动dep.notice()通知的时候，能调用自身的update()方法，并触发compile中绑定的回调，则功成身退
    4. MVVM作为数据绑定的入口，整合observer、compile和watcher三者，通过observer来监听自己的model数据变化，通过compile来编译模板指令，最终利用watcher搭起的observer和compile之间的通信桥梁，达到数据变化---试图更新;视图交互变化(input)-->数据model变更的双向绑定效果

    版本比较： vue是基于依赖收集的双向绑定； 3.0版本之前使用Object.definePropetry,3.0新版使用Proxy

    1. 基于数据劫持/依赖收集 的双向绑定的优点
    不需要显示的调用，Vue利用数据劫持+发布订阅，可以直接通知变化并且驱动视图
    直接得到精确的变化数据，劫持了属性setter，当属性值改变，我们可以精确的获取变化的内容newValue，不需要额外的diff操作
    2. Object.defineProperty的缺点
    不能监听数组：因为数组没有getter和setter，因为数组长度不确定，如果太长性能负担太大
    只能监听属性，而不是整个对象，需要遍历循环属性
    只能监听属性变化，不能监听属性的删减
    3. proxy的好处
    可以监听数组
    监听整个对象不是属性
    13种来截方法，强大很多
    返回新对象而不是直接修改原对象，更符合immutable；
    4. proxy的缺点
    兼容性不好，而且无法用polyfill磨平；
    ```
    </details>
    
2. Loader和Plugin的区别是什么
    <details>
    <summary>答案</summary>
    ```
    1. 作用不同：
    Loader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。
    Plugin直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。
    2. 用法不同：
    Loader在module.rules中配置，也就是说作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）
    Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。
    ```
    </details>
3. 请解释React中props和state的区别
    <details>
    <summary>答案</summary>
    ```
    1. props
    函数组件的props就是一个函数的入参组件
    类组件：this.props 包括被该组件调用或者定义的props
    2. state
    组件中的state包含了随时可以发生变化的数据
    state由用户定义，它是一个普通javascript对象
    3. 区别
    props是传递组件的(类似函数的形参)，而state是在组件内被组件自己管理的(类似在一个函数内声明变量)。
    props是不可修改的，所有React组件必须向纯函数一样保护它们的props不被更改
    state是在组件中创建的，一般在constructor中初始化state
    state是多变的、可修改的，每次setState都异步更新的
    ```
    </details>

4. 浏览器的本地存储的cookie了解多少
    <details>
    <summary>答案</summary>
    ```
    Cookie最开始被设计出来其实并不是做本地存储的，而是为了弥补http在状态管理上的不足
    http协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，这次事件就完成了，但是下次发请求如何让服务端直到客户端是谁呢？在这个需求下就产生了Cookie
    Cookie本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面版的Application这一栏可以看到)都会携带相同的Cookie，服务器拿Cookie进行解析，便能拿到客户端的状态 Cookie的作用就是用来做状态存储的，但是也有很多缺陷：
    1. 容量缺陷。Cookie的体积上限只有4KB，只能用来存储少量的信息
    2. 性能缺陷。Cookie紧跟域名，不管域名下面的某一个地址需不需要这个Cookie，请求都会携带上完整的Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容
    3. 安全缺陷。由于Cookie以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截取，然后进行一系列的篡改，在Cookie的有限期内重新发送给服务器，这是很危险的。另外，在HttpOnly为false的情况下，Cookie信息能直接通过js脚本来读取。
    ```
    </details>

5. 浏览器本地存储的WebStorate了解多少
    <details>
    <summary>答案</summary>
    ```
    WebStorage又可以分为localStorege和sessionStorage

    localStorage
    和Cookie异同：相同的一点是：针对一个域名，即在同一个域名下，会存储相同的一段localStorage

    区别：

    1. 容量：localStorage的容量上限为5M，相对于Cookie的4K大大增加。当然这个5M是针对一个域名的，因此对于一个域名是持久存储的
    2. 只存在客户端，默认不参与和服务端的通信。这样很好地避免了Cookie带来地性能问题和安全问题
    3. 接口封装。通过localStorage暴露在全局，并通过它的setItem和getItem等方法进行操作，非常方便。
    看看如何具体操作localStorage？

    ```
    let obj={name:"zhufeng",age:10};
    localStorage.setItem("name","zhufeng");
    localstorage.setItem("message",JSON.stringify(obj));
    //接着进入相同的域名时就能拿到相应的值：
    let name=localStorage.getItem("name");
    let info=JSON.parse(localStorage.getItem("info"))
    ```
    在这里能得到，localStorage其实存储的都是字符串，如果是存储对象需要调用JSON的stringify方法，并且用JSON.parse来解析成对象 应用场景：利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源，比如官网的logo，存储Base64格式的图片资源，因此要好好利用localStorage

    sessionStorage
    特点：sessionStorage和localStorage是一致的

    1. 容量。容量上限为5M
    2. 只存在客户端，默认不参与和服务端的通信
    3. 接口封装。除了sessionStorage名字有所变化，存储方式、操作方式均和localStorage一样
    但是sessionStorage和localStorage有一个本质的区别：前者只是会话级别的存储，并不是持久化存储。会话结束后也就是页面关闭，这部分sessionStorage就不存在了

    应用场景：
    1. 可以用它对表单信息进行维护，将表单信息存储存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
    2. 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用sessionStorage就再合适不过了。事实上微博采取这样的存储方式。
    ```
    </details>
    
6. 说一下vue-router的原理是什么
    <details>
    <summary>答案</summary>
    ```
    实现原理：vue-router的原理就是更新视图而不重新请求页面

    vue-router可以通过mode参数设置为三种模式：hash模式、history模式、abstract模式。

    1. hash模式 默认是hash模式，基于浏览器history api，使用window.addEventListener('hashchange',callback,false)对浏览器地址进行监听。当调用push时，把新路由添加到浏览器访问历史的栈顶。使用replace时，把浏览器访问历史的栈顶路由替换成新路由 hash的值等于url中#及其以后的内容。浏览器是根据hash值的变化，将页面加载到相应的DOM位置。锚点变化只是浏览器的行为，每次锚点变化后依然会在浏览器中留下一条历史记录，可以通过浏览器的后退按钮回到上一个位置

    2. History history模式，基于浏览器history api ，使用window.onpopstate对浏览器地址进行监听。对浏览器history api中的pushState()、replaceState()进行封装，当方法调用，会对浏览器的历史栈进行修改。从而实现URL的跳转而无需加载页面 但是他的问题在于当刷新页面的时候会走后端路由，所以需要服务端的辅助来兜底，避免URL无法匹配到资源时能返回页面

    3. abstract 不涉及和浏览器地址的相关记录。流程跟hash模式一样，通过数组维护模拟浏览器的历史记录栈 服务端下使用。使用一个不依赖于浏览器的浏览器历史虚拟管理后台

    4. 总结 hash模式和history模式都是通过window.addEvevtListenter()方法监听 hashchange和popState进行相应路由的操作。可以通过back、foward、go等方法访问浏览器的历史记录栈，进行各种跳转。而abstract模式是自己维护一个模拟的浏览器历史记录栈的数组
    ```
    </details>
    
7. 防抖节流原理、区别以及应用，请用js实现
    <details>
    <summary>答案</summary>
    #### 防抖
    ```
    原理：在时间被触发n秒之后再执行回调，如果在这n秒内又被触发，则重新计时

    适用场景：

    按钮提交场景：防止多次提交按钮，只执行最后提交的一次
    搜索框联想场景：防止联想发送请求，只发送最后一次输入
    ```
    //简易版实现
    function debounce(func,wait){
        let timeout;
        return function(){
            const context=this;
            const args=arguments;
            clearTimeout(timeout);
            timeout=setTimeout(() => {
                func.apply(context,args);
            }, wait);
        }
    }
    //立即执行版实现：有时候希望立刻执行函数，然后等到停止触发n秒后，才可以重新执行。
    function debound1(func,wait,immediate){
        let timeout;
        return function(){
            const context=this;
            const args=arguments;
            if(timeout) clearTimeout(timeout);
            if(immediate){
                const callNow=!timeout;
                timeout=setTimeout(() => {
                    timeout=null;
                }, wait);
                if(callNow) func.apply(context,args);
            }else{
                timeout=setTimeout(() => {
                    func.apply(context,args);
                }, wait);
            }
        }
    }

    //返回值版实现
    //func函数可能会有返回值，所以需要返回函数结果，但是当immediate为false的时候，因为使用了setTimeout，我们将func.apply(context,args)的返回值赋给变量，最后在return的时候，值将会一直是undefined，所以只在immediate为true的时候返回函数的执行结果
    function debounce2(func,wait,immediate){
        let timeout,result;
        return function(){
            const context=this;
            const args=arguments;
            if(timeout) clearTimeout(timeout);
            if(immediate){
                const callNow=!timeout;
                timeout=setTimeout(() => {
                    timeout=null;
                }, wait)
                if (callNow) result=func.apply(context,args);
            }else{
                timeout=setTimeout(() => {
                    func.apply(context,args);   
                }, wait);
            }
            return result;
        }
    }
    ```
    #### 节流：
    原理： 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效

    适用场景：

    拖拽场景：固定时间内只执行一次，防止高频次触发位置变动
    缩放场景：监控浏览器resize
    ```
    //使用时间戳实现:使用时间戳，当触发事件发生的时候，我们取出当前的时间戳，然后减去之前的时间戳（最开始设值为0），如果大于设置的时间周期，就执行函数，然后更新时间戳为当前时间戳，如果小于，就不执行 

    function throttle(func,wait){
        let context,args;
        let previous=0;
        return function(){
            let now=+new Date();
            context=this;
            args=arguments;
            if(now-previous > wait){
                func.apply(context,args);
                previous=now
            }
        }
    }
    //使用定时器实现：当触发事件的时候，我们设置一个定时器，在触发事件的时候，如果定时器存在，就不执行，知道定时器执行，然后执行函数，清空定时器，这样就可以设置下定时器
    function throttle1(func,wait){
        let timeout;
        return function(){
            const context=this;
            const args=arguments;
            if(!timeout){
                timeout=setTimeout(() => {
                    timeout=null;
                    func.apply(context,args);
                }, wait);
            }
        }
    }

    //区别:节流不管事件触发多频繁保证在一定时间内一定会执行一次函数。防抖是只在最后一次事件触发后才会执行一次函数
    // flag版本
    const throttle2=(func,wait)=>{
        let flag=true;
        return function(...args){
            if(!flag) return;
            flag=flase;
            setTimeout(() => {
                func.apply(this,args)
                flag=true;
            }, wait);
        } 
    }
    ```
    ```
    </details>
    
8. 在css中link和@import的区别是什么
    <details>
    <summary>答案</summary>
    ```
    1. 从属关系区别
    @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

    2. 加载顺序区别
    加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。

    3. 兼容性区别
    @import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。

    4. DOM可控性区别
    可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。

    5. 权重区别(该项有争议，下文将详解)
    link引入的样式权重大于@import引入的样式。
    ```
    </details>
9. 常见的loader以及作用的总结
    <details>
    <summary>答案</summary>
    ```
    raw-loader：加载文件原始内容（utf-8）
    file-loader：把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件
    url-loader:和file-loader类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中
    source-map-loader:加载额外的Source Map文件，以方便断点调试
    svg-inline-loader：将压缩后的 SVG 内容注入代码中
    image-loader：加载并且压缩图片文件
    json-loader 加载 JSON 文件（默认包含）
    handlebars-loader: 将 Handlebars 模版编译成函数并返回
    babel-loader：把ES6转化成ES5
    ts-loader: 将 TypeScript 转换成 JavaScript
    awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader
    css-loader：加载css，支持模块化、压缩、文件导入等特性
    style-loader：把css代码注入到js中，通过DOM操作去加载css
    eslint-loader：通过ESLint检查JS代码
    tslint-loader：通过 TSLint检查 TypeScript 代码
    postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀
    vue-loader：加载 Vue.js 单文件组件
    cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里
    ```
    </details>
10. 计算属性和普通属性的区别是什么
    <details>
    <summary>答案</summary>
    ```
    computed属性是vue计算属性，是数据层到视图层的数据转化映射； 计算属性是基于他们的依赖进行缓存的，只有在相关依赖发生改变时，他们才会重新求值，也就是说，只要他的依赖没有发生变化，那么每次访问的时候计算属性都会立即返回之前的计算结果，不再执行函数；

    computed是响应式的，methods并非响应式。
    调用方式不一样，computed的定义成员像属性一样访问，methods定义的成员必须以函数形式调用
    computed是带缓存的，只有依赖数据发生改变，才会重新进行计算，而methods里的函数在每次调用时都要执行。
    computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的
    computed不支持异步，当computed内有异步操作时无效，无法监听数据的变化
    如果声明的计算属性计算量非常大的时候，而且访问量次数非常多，改变的时机却很小，那就需要用到computed；缓存会让我们减少很多计算量。
    ```
    </details>
11. webpack中source map是什么？生产环境怎么用
    <details>
    <summary>答案</summary>
    ```
    source map是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。

    map文件只要不打开开发者工具，浏览器是不会加载的

    线上环境一般有三种处理方案：
    hidden-source-map：借助第三方错误监控平台Sentry使用
    nosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比source map高
    source：通过nginx设置将.map文件只对白名单开放(公司内网)
    注意的是：避免在生产中使用 inline- 和 eval- ，因为它们会增加bundle体积大小，并降低整体性能。
    ```
    </details>
12. 浏览器缓存机制对于开发很重要，强缓存的内容能了解多少呢？
    <details>
    <summary>答案</summary>
    ```
    强缓存： 浏览器中的缓存作用分为两个情况，一种是需要发送HTTP请求，一种是不需要发送 首先是检查强缓存，这个阶段不需要发送http请求 如何来检查呢？通过相应的字段来进行，但是说起这个字段就有意思啦 在http/1.0和http/1.1当中，这个字段是不一样的。在早期，也就是http/1.0时期，使用的是Expires，而http/1.1使用的是Cache-Contronl

    Expires
    Expries即过期的时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求

    Expires: Wed, 22 Nov 2020 08:30:00 GMT
    表示资源在2020年11月22号8点30分过期，过期了就得向服务端发送请求
    这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的，因此这种方式很快在后来的http/1.1版本就抛弃了。
    Cache-Control
    在http1.1中，采用了一个非常关键的字段：Cache-Control。 它和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age，比如这个例子：

    Cache-Control:max-age=3600
    代表这个响应返回后在3600秒，也就是一个小时之内可以直接使用缓存
    如果你觉得它只有max-age一个属性的话，那就想错了
    它其实可以组合非常多的指令，完成更多的场景的缓存判断，将一些关键的属性列举如下：
    public：客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存
    private：只有浏览器能缓存，中间的代理服务器不能缓存
    no-cache：跳过当前的强缓存，发送http请求，即直接进入协商缓存阶段
    no-store：非常简单粗暴，不进行任何形式的缓存
    s-maxage：这和max-age长得非常像，但是区别在于s-maxage是针对代理服务器的缓存时间。
    值得注意的是：当Expires和Cache-Control同时存在的话，Cache-Control会优先考虑 还存在一种情况是：当资源缓存时间超时了，也就是强缓存失效了，接下就要进入第二部分--协商缓存
    ```
    </details>
13. 介绍js全部数据类型，基本数据类型和引用数据类型的区别
    <details>
    <summary>答案</summary>
    ```
    一、JavaScript全部数据类型
    内置类型
    空值 null
    未定义 undefined
    布尔值 boolean
    数字 number
    字符串 string
    对象 object
    符号 symbol
    长整型 bigInt
    1.基本数据类型
    undefined null number boolean string symbol

    基本数据类型是按值访问的，就是说我们可以操作保存在变量中的实际的值
    
    1.1基本数据类型的值是不可变的
    
    1.2基本数据类型不可以添加属性和方法
    
    1.3基本数据类型的赋值是简单赋值
    
    1.4基本数据类型的比较是值的比较
    
    1.5基本数据类型是存放在栈区的
    
    2.引用类型
    
    JS中除了上面的基本类型之外就是引用类型了，也可以说是对象，比如：object array function data等
    
    2.1引用类型的值是可以改变
    2.2引用类型可以添加属性和方法
    2.3引用类型的赋值是对象引用
    2.4引用类型的标胶是引用的比较
    2.5引用类型是同时存在栈区和堆区的
    二、基本数据类型和引用数据类型的区别
    1.声明变量时不同的内存分配
    原始值：存储在栈(stack)中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。是因为这些原始类型占据的空间是固定的，所以可以将它们存储在较小的内存区域---栈中，这样存储便于迅速查询变量的值
    
    引用值：存储在堆(heap)中的对象。也就是说，存储在变量处的值是一个指针(point)，指向存储对象的内存地址。是因为引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查询的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。
    
    2.不同的内存分配机制也带来了不同的访问机制
    在js中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。而原始类型的值是可以直接访问到的。
    
    3.复制变量时的不同
    原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，它们只是拥有相同的value而已
    
    引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中同一个对象，他们中任何一个做出的改变都会反映在另一个身上。(需要理解的一点是：复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了)
    
    4.参数传递的不同(把实参复制给形参的过程)
    首先我们应该明确的一点是：ESCMAScript中所有函数的参数都是按值来传递的。 但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？这就是因为内存分配时的差别。
    
    原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响
    
    引用值：对象变量里面的值是这个对象在堆内存中的内存地址，这一点很重要！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因，因为它们都指向同一个对象。
    ```
    </details>
14. react-router里的link标签和a标签有什么区别
    <details>
    <summary>答案</summary>
    ```
    区别
    从最终渲染的DOM来看，这两者都是链接，都是a标签，区别是： Link标签是react-router里实现路由跳转的链接，一般配合Route使用，react-router接下了其默认的链接跳转行为，区别于传统的页面跳转，Link标签的"跳转"行为只会触发相匹配的Route对应的页面内容更新，而不会刷新整个页面

    Link标签做的三件事情：

    1.有onclick那就执行onclick
    2.click的时候阻止a标签默认事件
    3.根据跳转href(即使是to)，用history(web前端路由两种方式之一，history&hash)跳转，此时只是链接变了，并没有刷新页面
    而标签就是普通的超链接了，用于从当前页面跳转到href指向的里一个页面(非锚点情况)

    a标签默认事件禁掉之后做了什么才实现了跳转？
    let domArr=document.getElementByTagName('a');
    [...domArr].forEach(item=>{
        item.addEventListener('click',function(){
            location.href=this.href
        })
    })
    ```
    </details>
15. 能不能说一说XSS攻击
    <details>
    <summary>答案</summary>
    ```
    什么是XSS攻击？
    XSS全称是Cross Site Scripting[跨站脚本]，为了和css区分，故叫它xss。XSS攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息进行操作。

    这些操作一般可以完成下面这些事情 1.窃取Cookie 2.监听用户行为，比如输入账号密码后直接发送到黑客服务器 3.修改DOM伪造登录表单 4.在页面中生成浮窗广告

    通常情况下，XSS攻击的实现有三种方式 --- 存储型、反射型和文档型。原理比较简单，一一介绍

    存储型
    存储型，将恶意脚本存储了起来，确实，存储型的XSS将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果

    常见的场景是留言评论区提交一段代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中直接执行，相当于执行一段位置逻辑的js代码，是非常恐怖的。这就是存储型的xss攻击

    反射型
    反射型xss指的是恶意脚本作为网络请求的一部分 比如我输入

    http://baidu.com?q=
    这样在服务端会拿到q参数，然后将内容返回给浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样被攻击了

    之所以叫它反射型，是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后在反射到HTML文档中，执行解析。和存储型不一样的是：服务器并不会存储这些恶意脚本

    文档型
    文档型的XSS攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的html文档 这样的劫持方式包括wifi路由劫持或者本地恶意软件等

    防范措施
    明白三种xss攻击的原理，发现一个共同点：都是让恶意脚本直接能在浏览器中执行 那么要防范它，就是要避免这些脚本代码的执行 为了完成这一点，必须做到一个信念，两个利用。

    一个信念
    千万不要相信任何用户的输入！ 无论是在前端和服务端，都要对用户的输入进行转码或过滤

    如


    转码后变为：
    
    <script>alert('你完蛋了')</script>
    这样的代码在html解析的过程中是无法执行的 当然也可以利用关键词过滤的方式，将script标签给删除。那么现在的内容只剩下


    什么都没有
    
    利用CSP
    CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能： 1.限制其他域下的资源加载 2.禁止向其他域提交数据 3.提供上报机制，能帮助我们及时发现XSS攻击
    
    利用HttpOnly
    很多XSS攻击脚本都是用来窃取Cookie，而设置Cookie的HttpOnly属性后，JavaScript便无法读取Cookie的值，这样也很好的防范XSS攻击。
    
    总结
    xss攻击是指浏览器中执行恶意脚本，然后拿到用户的信息进行操作。主要分为存储型、反射型和文档型。防范的措施包括：
    
    一个信念：不要相信用户的输入，对输入的内容转码或者过滤，让其不可执行 两个利用:利用CSP,利用Cookie的HttpOnly属性
    ```
    </details>
16. 谈谈你对重绘和回流的理解
    <details>
    <summary>答案</summary>
    ```
    我们首先来回顾一下渲染流水线的流程: 图片链接：http://img.zhufengpeixun.cn/chonghui_1.png 
    接下来，我们将来以此为依据来介绍重绘和回流，以及让更新视图的另一种方式 -- 合成
    
    ![](https://gitee.com/wangyuan0108/image/raw/master/20210112175340.png)

    回流
    首先介绍回流，回流也叫重排

    触发条件
    简单来说:就是当我们对DOM结构的修改引发DOM几何尺寸变化的时候，会发生回流的过程 具体一点，有以下的操作会触发回流： 1.一个DOM元素的几何属性变化，常见的几何属性有width height padding margin left top border等等，这个很好理解 2.使DOM节点发生增减或者移动 3.读写offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作 4.调用window.getComputedStyle方法

    回流过程
    依照上面的渲染流水线，触发回流的时候，如果DOM结构发生改变，则重新渲染DOM树，然后将后面的流程(包括主线程之外的任务)全部走一遍。 图片链接：http://img.zhufengpeixun.cn/chonghui_2.png
    ![](https://gitee.com/wangyuan0108/image/raw/master/20210112175438.png)
    相当于将解析和合成的过程重新又走了一遍，开销是非常大的
    
    重绘
    触发条件
    当DOM的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)

    重绘过程
    由于没有导致DOM几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。流程如下： 图片链接：http://img.zhufengpeixun.cn/chonghui_3.png
    ![](https://gitee.com/wangyuan0108/image/raw/master/20210112175602.png)
    跳过了生成布局树和建图层树的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作
    
    可以看到，重绘不一定导致回流，但回流一定发生了重绘

    合成
    还有一种情况，是直接合成。比如利用CSS3的transform opacity filter这些属性就可以实现合成的效果，也就是大家所说的GPU加速

    GUP加速的原因
    在合成的情况下，会直接跳到布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理，交给它处理有两大好处：
    
    1.能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进程加速生成，而GPU是擅长处理位图数据的 2.没有占用主线程的资源，即使主线程卡住啦，效果依然能够流畅地展示
    ```
    </details>
17. 简单说下你理解的语意化，怎样来保证你写的符合语意化？HTML5语意化标签了解下
    <details>
    <summary>答案</summary>
    ```
    很多时候我们写HTML，为了方便都会直接使用div和span标签，在通过class来确定具体样式。网站哪一部分为标题，哪一部分为导航，哪一部分为头部和尾部，都只能通过class来进行确定。 但是class命名规范却又没有一套统一的标准，依次导致很多时候无法确定整体网站的结构 因此，在HTML5出现后，添加了关于页面布局结构的新标签。而在html书写过程中，根据不同的内容使用合适的标签进行开发，即为语义化。

    在编程中，语义指的是一段代码的含义(这个HTML的元素有什么作用，扮演了什么样的角色)。HTML语义元素清楚地向浏览器和开发者描述其意义，例如form、table以及img等

    1.优点：对搜索引擎友好，有了良好的结构和语义，网页内容自然容易被搜索引擎抓取
    2.HTML5新增语义元素 article aside details figcaption figure footer> header main mark nav section summary time
    3.为什么要语义化？
    语义化的优势主要在于以下几点：
    其他开发者便于阅读代码，通过不同标签明白每个模块的作用和区别
    结构明确、语义清晰的页面能有更好的用户体验，在样式(css)没有加载前也有较为明确的结构，更如img这一类的，在图片无法加载的情况下有alt标签告知用户此处图片的具体内容；
    利于seo，语义化便于搜索引擎爬虫理解，和搜索引擎建立良好的沟通，能让爬虫爬取更多关键有效的信息
    方便其他设备阅读(如屏幕阅读器，盲人设备和移动设备等)
    4.如何语义化？
    一般的网站分为头部、导航、文章(或其他模块)、侧栏、底部，根据不同的部位，使用不同的标签进行书写。
    表示页面不同位置的标签：header、nav、article、section、footer、aside
    表示具体元素的作用或者意义的标签：a、abbr、address、audio、blockquote、caption、code、datalist、del、detail、ol、ul、figure、figuration、img、input、mark、p等
    - 尽可能少的使用无语义的标签div和span
    - 在语义不明显时，既可以使用div或者p时，尽量用p，因为p在默认情况下有上下间距，对兼容特殊终端有利；
    - 不要使用纯样式标签，如b、font、u等，改用css设置
    - 需要强调的文本，可以包含在strong或者em标签中(浏览器预设样式，能用css指定就不用他们)，strong默认样式是加粗(不要加b)，em是斜体(不用i)
    - 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，，单元格用td
    - 表单域要用fieldset标签包起来，并用legend标签说明表单的用途
    - 每个input标签对应的说明文件都需要使用label标签。并且通过input设置为id属性，在label标签中设置for=someld来让说明文本和相对应的input关联起来
    5.注意点： em、strong、dfn、code、samp、kbd、var、cite等，虽然这些标签定义的文本大多会呈现处特殊的样式，但实际上，这些标签都拥有确切的语义 我们并不反对使用它们，但是如果您只是为了达到某种视觉效果而使用这些标签的话，我们建议您可以使用样式表，那么做会达到更加丰富的效果。
    ```
    </details>
    
18. 常见的plugin以及作用的总结
    <details>
    <summary>答案</summary>
    ```
    define-plugin：定义环境变量(Webpack4 之后指定 mode 会自动配置)
    ignore-plugin：忽略部分文件
    commons-chunk-plugin：提取公共代码
    html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)
    web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用
    uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)
    terser-webpack-plugin: 支持压缩 ES6 (Webpack4)
    mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)
    webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度
    serviceworker-webpack-plugin：为网页应用增加离线缓存功能
    clean-webpack-plugin: 目录清理
    ModuleConcatenationPlugin: 开启 Scope Hoisting
    speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)
    webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)
    ```
    </details>
    
19. 能不能说一说CSRF攻击
    <details>
    <summary>答案</summary>
    ```
    ## 什么是CSRF

    CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

    ## 一个典型的CSRF攻击有着如下的流程：

    * 受害者登录a.com，并保留了登录凭证（Cookie）。
    * 攻击者引诱受害者访问了b.com。
    * b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。
    * a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
    * a.com以受害者的名义执行了act=xx。
    * 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

    ## 几种常见的攻击类型

    * GET类型的CSRF
    * POST类型的CSRF
    * 链接类型的CSRF

    ## CSRF的特点

    * 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
    * 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
    * 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
    * 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

    CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。

    ## 防护策略

    CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。

    上文中讲了CSRF的两个特点：

    * CSRF（通常）发生在第三方域名。
    * CSRF攻击者不能获取到Cookie等信息，只是使用。

    针对这两点，我们可以专门制定防护策略，如下：

    * 阻止不明外域的访问
    * 同源检测
    * Samesite Cookie
    * 提交时要求附加本域才能获取的信息
    * CSRF Token
    * 双重Cookie验证
    ```
    </details>
    
20. css伪类和伪元素区别
    <details>
    <summary>答案</summary>
    ```
    1.伪类(pseudo-classes)
    其核心就是用来选择DOM树之外的信息，不能够被普通选择器选择的文档之外的元素，用来添加一些选择器的特殊效果
    比如 :hover :active :visited :first-child :focus :lang等
    由于状态的变化是非静态的，所以元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又失去这个样式
    由此看可以看出，它的功能和class有些类似，但是它是基于文档之外的抽象，所以叫伪类
    2.伪元素(pseudo-elements)
    DOM树没有定义的虚拟元素
    核心就是需要创建通常不存在于文档的元素
    比如::before ::after 选择的是元素指定内容，表示选择元素内容的之前的内容或之后内容
    伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于文档中，所以称为伪元素。用于将特殊的效果添加到某些选择器
    3.两者区别
    表示方法
    css2中伪类、伪元素都是单冒号：表示
    css2.1后规定伪类用单冒号表示，伪元素用双冒号::表示
    浏览器同样接受css2时代已经存在的伪元素(:before :after :first :line :first-letter等)的单冒号写法
    css2之后所有新增的伪元素(::selection)，应该采用双冒号的写法
    css3中，伪类与伪元素在语法上也有所区别，伪元素修改以::开头。浏览器对以:开头的伪元素也继续支持，但建议规范书写为::开头
    定义不同
    伪类即假的类，可以添加类来达到效果
    伪元素即假元素，需要通过添加元素才能到达效果
    总结
    伪类和伪元素都是用来表示文档树之外的"元素"
    伪类和伪元素分别用单冒号:和双冒号::来表示
    伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)
    是否需要添加元素才能达到效果，如果是则是伪元素，反之是伪类
    4.相同之处
    伪类和伪元素都不会出现在源文件和DOM树中。也就是说在html源文件中是看不到伪类和伪元素的
    不同之处
    伪类其实就是基于普通DOM元素而产生的不同状态，他是DOM元素的某一特征
    伪元素能够创建在DOM树中不存在的抽象对象，而且这些抽象对象是能够访问到的
    ```
    </details>
    
21. Vuex和localStorage的区别是什么
    <details>
    <summary>答案</summary>
    ```
    1.最重要的区别
    vuex存储在内存
    localstorage以文件的方式存储在本地
    localstorage只能存储字符串类型的数据，存储对象需要JSON的stringify和parse方法进行处理。读取内存比读取硬盘速度要快

    2.应用场景
    vuex是一个转为为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用域组件之间的传值
    localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用的
    vuex能做到数据的响应式，localstorage不能做到
    3.永久性
    刷新页面时vuex存储的值会丢失，localstorage不会丢失
    很多人觉得用localstorage可以代替vuex，对于不变的数据确实可以，但是是当两个组件公用一个数据源(对象或数组)时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因在区别1那里
    ```
    </details>
    
22. 浏览器缓存机制对于开发很重要，协商缓存的内容能了解多少呢
    <details>
    <summary>答案</summary>
    ```
    协商缓存
    强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag来决定是否使用缓存，这就是协商缓存 具体来说，这样的缓存tag分为两种：Last-Modified和ETag。这两者各有优劣之分，并不存在谁对谁有绝对的优势

    Last-Modified
    最后的修改时间。在浏览器第一次给服务器发送请求时，服务器会在响应头中加上这个字段 浏览器接收到后，如果再次请求，会在请求头中携带if-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间 服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比： 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的http请求响应的流程一样 否则返回304，告诉浏览器直接用缓存

    ETag
    ETag是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发送给服务器 服务器接接收到If-None-Match后，会跟服务器上该资源的ETag进行对比： 如果两者不一样，说明要更新了。返回新的资源，跟常规的http请求响应的流程一样 否则返回304，告诉浏览器直接用缓存

    两者对比：
    1.在精准度上，ETag优于Last-Modified。优于ETag是按照内容给资源上标识，一次能准确感知资源的变化。而Last-Modified就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况
    编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效
    Last-Modified能够感知的单位时间是秒，如果文件在1秒内改变了多次，那么这时候的Last-Modified并没有体现出修改了
    2.在性能上，Last-Modified由于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而ETag需要根据文件的具体内容生成哈希值

    另外，如果两种方式都支持的话，服务器优先考虑ETag
    ```
    </details>
23. 说一下事件循环机制（node 浏览器）
    <details>
    <summary>答案</summary>
    ```
    1. 为什么会有Event Loop?
    JS的任务分为两种：同步和异步，他们的处理方式也各自不同，同步任务是直接放在主线程上排队依次执行，异步任务会放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓存区，任务下一步会被移到调用栈然后主线程执行调用栈的任务

    调用栈：调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出

    JS是单线程的，单线程是指js引擎中解析和执行js代码的线程只有一个(主进程)，每次只能做一件事情，而ajax请求中，主线程在等待响应的过程中回去做其他事情，浏览器先在事件注册ajax的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说js处理ajax请求方式是异步的

    综上所述，检查调用栈是否为空以及讲某个任务添加到调用栈中的过程就是event loop，这就是JS实现异步的核心

    2. 浏览器中的Event Loop
    Micro-Task 与 Macro-Task 浏览器端事件循环中的异步队列有两种：macro(宏任务)队列和micro(微任务)队列 常见的macro-task:setTimeout、setInterval、script(整体代码)、I/O操作、UI渲染等 常见的micro-task：new Promise().then(回调)、MutationObserve等

    requestAnimationFrame requestAnimationFrame也属于异步执行的方法，但是该方法既不属于宏任务也不属于微任务，按照MDN定义：

    window.requestAnimationFrame()告诉浏览器---希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行 requestAnimationFrame是GUI渲染之前执行，但是在Micro-Task之后，不过requestAnimationFrame不一定会在当前帧必须执行，由浏览器根据当前的策略自行决定在哪一帧执行

    >Event Loop过程
    1.检查macro-task是否为空，非空到达2，为空到达3
    2.执行macro-task中的一个任务
    3.继续检查micro-task队列是否为空，若是空到达4，否则是到达5
    4.取出micro-task中的任务执行，执行完成返回到达3
    5.执行视图更新
    当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。

    3. node中的Event Loop

    node中的Event Loop和浏览器中的是完全不相同的东西。node.js采用v8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一件基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是这里面的实现

    1.v8引擎解析JS脚本

    2.解析后的代码，调用node API

    3.libuv库负责node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop(事件循环)，以异步的方式将任务的执行结果返回给V8引擎

    4.v8引擎在将结果返回给用户

    六大阶段
    其中libuv引擎中的事件循环分为六个阶段，它们会按照顺序反复运行。每当进入一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一个阶段

    1.timer阶段：这个阶段执行timer(setTimeout、setInterval)的回调，并且是由poll阶段控制的
    2.I/O callbacks阶段：处理一些上一轮循环中的少数未执行的I/O回调
    3.idle,prepare阶段：仅node内部使用
    4.poll阶段：获取新的I/O事件，适当的条件下node将阻塞在这里
    5.check阶段：执行setImmediate()的回调
    6.close callbacks阶段：执行socket的close事件回调
    poll阶段
    poll是一个至关重要的阶段，这一阶段中，系统会做两件事情 1.回到timmer阶段执行回调 2.执行I/O回调，并且在进入该阶段时如果没有设定timer的话，会发生以下两件事情

    >如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者到达系统限制
    >如果 poll 队列为空时，会有两件事发生
    如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
    如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去 当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。
    Micro-Task 与 Macro-Task
    Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。

    常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等
    常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等
    setTimeout 和 setImmediate
    二者非常相似，区别主要在于调用时机不同。

    setImmediate 设计在poll阶段完成时执行，即check阶段
    setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行
    setTimeout(function timeout () {
    console.log('timeout');
    },0);
    setImmediate(function immediate () {
    console.log('immediate');
    });
    1.对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。 2.首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调 3.如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了

    process.nextTick
    这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行

    4. node与浏览器的Event Loop差异
    Node端，microtask 在事件循环的各个阶段之间执行
    浏览器端，microtask 在事件循环的 macrotask 执行完之后执行
    ```
    </details>
24. webpack的构建流程是什么
    <details>
    <summary>答案</summary>
    ```
    webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程

    初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数
    开始编译：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译；
    确定入口：根据配置中的entry找出所有的入口文件；
    编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，在递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
    完成模块编译：在经过第四步使用loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
    输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
    输出完成：再确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统
    在以上系统中，webpack会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用webpack提供的API改变webpack的运行结果
    ```
    </details>
25. import和commonJs在webpack打包过程中有什么不同
    <details>
    <summary>答案</summary>
    ```
    1.es6模块调用commonjs模块
    可以直接使用commonjs模块，commonjs模块将不会被webpack的模块系统编译而是原样输出，并且commonjs模块没有default属性

    2.es6模块调用es6模块
    被调用的es6模块不会添加{esModule:true}，只有调用者才会添加{esModule:true}，并且可以进行tree-shaking操作，如果被调用的es6模块只是import进来，但是并没有被用到，那么被调用的es6模块将会被标记为/* unused harmony default export */，在压缩时此模块将被删除(如果被调用的es6模块里有立即执行语句，那么这些语句将会被保留)

    3.commonjs模块引用es6模块
    es6模块编译后会添加{__esModule:true}。如果被调用的es6模块中恰好有export default语句，那么编译后的es6模块将会添加default属性

    4.commonjs模块调用commonjs模块
    commonjs模块会原样输出
    ```
    </details>
26. dev-server是怎么跑起来的
    <details>
    <summary>答案</summary>
    ```
    dev-server运行配置
    安装webpack-dev-server的npm包
    在webpack.config.js进行配置
    devServer中常用的配置对象属性如下：

    1.contentBase:"./" 本地服务器在哪个目录搭建页面，一般在当前目录即可
    2.historyApiFallback：true 搭建spa应用时会用到。它使用的时HTML5 History Api，任意的跳转或404响应可以指向index.html页面
    3.inline：true 用来支持dev-server自动刷新的配置，webpack有两种模式支持自动刷新，一种是iframe模式，一种是inline模式；使用iframe模式是不需要在devServer进行配置的。只需使用特定的URL格式访问即可；不过我们一般还是常用inline模式，在devServer中对inline设置为true后，当启动webpack-dev-server时仍需要配置inline才能生效
    4.hot:true 启动webpack热模块替换特性
    5.port 端口号(默认8080)
    怎么跑起来的
    1.启动HTTP服务
    2.webpack构建时输出Bundle到内存，HTTP服务从内存中读取Bundle文件
    3.监听文件变化，重新执行第二个步骤
    dev-server 实际上是一个HTTP服务器，所以还可以做静态资源的访问和API的Proxy代码

    1.静态资源访问

    {
        devServer:{
            contentBase:'public'
        }
    }
    2.Proxy代理

    {
        devServer:{
            proxy:{
                '/api':{
                    target:'http://api.target.com'
                }
            }
        }
    }
    ```
    </details>
27. 如何实现webpack持久化缓存
    <details>
    <summary>答案</summary>
    ```
    服务端设置HTTP缓存头(Cache-Control等)
    打包依赖(dependencies)和运行时(runtime)到不同chunk(在webpack中，编译后的单独文件称为chunk)，即作splitChunk，因为它们几乎是不变的
    延迟加载：使用import()方式，可以动态加载的文件分到独立的chunk，以得到自己的chunkhash
    保证hash值稳定：编译过程和文件内容的更改尽量不影响其他文件hash的计算。对于低版本webpack生成的增量数字ID不稳定问题，可用HashedModuleldsPlugin基于文件路径生成解决
    ```
    </details>
28. webpack热更新的原理
    <details>
    <summary>答案</summary>
    ```
    基础概念
    1.webpack compiler：将js编译成Bundle 2.Bundle Server：提供文件在浏览器的访问，实际上就是一个服务器 3.HMR Server：将热更新的文件输出给HMR Runtime 4.HMR Runtime：会注入到bundle.js中，与HRM Server通过webSocket链接，接收文件变化，并更新对应文件 5.bundle.js：构建输出的文件

    原理
    1.启动阶段

    webpack Compiler将对应文件打包成bundle.js(包含注入的HMR Server)，发送给Bundler Server
    浏览器即可访问服务器的方式去获取bundle.js
    2.更新阶段(文件发生变化)

    webpack compiler重新编译，发送给HMR Server
    HMR Server可以知道有哪些资源、哪些模块发生了变化，通知HRM Runtime
    HRM Runtime更新代码
    HMR原理详解
    使用webpack-dev-server去启动本地服务，内部实现只要使用了webpack、express、websocket

    使用express启动本地服务，当浏览器访问资源时对此响应
    服务端和客户端使用websocket实现长连接
    webpack监听源文件的变化，即当开发者保存文件时触发webpack的重新编译
    每次编译都会生成hash值，已改动模块的json文件、已改动模块代码的js文件
    编译完成后通过socket向客户端推送当前编译的hash戳
    客户端的websocket监听到有文件改动推送过来的hash戳，会和上一次对比
    一直就走缓存
    不一致就通过ajax和jsonp向服务端获取最新资源
    使用内存文件系统去替换有修改的内容实现局部刷新
    1.server端

    启动webpack-dev-server服务器
    创建webpack实例
    创建server服务器
    添加webpack的done事件回调
    编译完成向客户端发送消息
    创建express应用app
    设置文件系统为内存文件系统
    添加webpack-dev-middleware中间件
    中间件负责返回生成的文件
    启动webpack编译
    创建http服务器并启动服务
    使用sockjs在浏览器端和服务端之间建立一个websocket长连接
    创建socket服务器
    2.client端

    webpack-dev-server/client端会监听到此hash消息
    客户端收到ok消息后会执行reloadApp方法进行更新
    在reloadApp中会进行判断，是否支持热更新，如果支持的话发生webpackHotUpdate事件，如果不支持就直接刷新浏览器
    在webpack/hot/dev-server.js会监听webpackHotUpdate事件
    在check方法里会调用module.hot.check方法
    HotModuleReplacement.runtime请求Manifest
    通过调用JsonpMainTemplate.runtime的hotDownloadManifest方法
    调用JsonpMainTemplate.runtime的hotDownloadUpdateChunk方法通过JSONP请求获取最新的模块代码
    补丁js取回来或会调用JsonpMainTemplate.runtime.js的webpackHotUpdate方法
    然后会调用HotModuleReplacement.runtime.js的hotAddUpdateChunk方法动态更新模块代码
    然后调用hotApply方法进行热更新
    ```
    </details>
29. 浏览器的缓存机制对于开发很重要，缓存位置的内容能了解多少呢
    <details>
    <summary>答案</summary>
    ```
    缓存位置
    当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那么这些资源究竟缓存在什么位置呢？

    浏览器中的缓存位置一共有四种：按优先级从高到第排列分别是：
    Service Worker
    MEmory Cache
    Disk Cache
    Push Cache
    Service Worker
    Service Worker借鉴了Web Worker的思路，既让js运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽是如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是Service Worker Cache

    Memory Cache和Disk Cache
    Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。 Disk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是它的优势在于存储容量和存储时长。

    那浏览器如何决定将资源放进内存还是硬盘呢？
    比较大的js、css文件会直接被丢进磁盘，反之丢进内存
    内存使用率比较高的时候，文件优先进入磁盘
    Push Cache
    推送缓存，是一种低级的网络功能-使用网络堆栈的任何东西都可以使用它，有用的关键是一致性和可预测性，这是浏览器缓存的最后一道防线，它是http/2中的内容，虽然现在应用的并不广泛，但随着http/2的推广，它的应用越来越广泛。

    对浏览器的缓存机制来做个总结
    首先强缓存可用，直接使用
    否则进入协商缓存，即发送HTTP请求，服务器通过请求头中的If-Modified-Since或者If-None-Match字段检查资源是否更新
    若资源更新，返回资源和200状态码
    否则返回304，告诉浏览器直接从缓存获取资源
    ```
    </details>
30. webpack打包时的Hash码是怎样生成的？随机值存在一样的情况，如何避免
    <details>
    <summary>答案</summary>
    ```
    1.Hash值
    webpack生态中存在多种计算hash的方式

    hash
    chunkhash
    contenthash
    hash代表每次webpack编译中生成的hash值，所有使用这种方式的文件hash都相同。每次构建都会使webpack计算新的hash。 chunkhash基于入口文件及其关联的chunk生成，某个文件的改动只会影响与它有关联的chunk的hash值，不会影响其他文件 contenthash根据文件内容创建。当文件内容发生变化时，contenthash发生变化

    2.避免相同随机值
    webpack在计算hash后分割chunk。产生相同随机值可能是因为这些文件属于同一个chunk，可以将某一个文件提到独立的chunk(如放入entry)
    ```
    </details>
31. 如何加快页面的渲染速度，都有哪些方式
    <details>
    <summary>答案</summary>
    ```
    > 1.静态资源的优化
    主要是减少静态资源的加载时间，只要包括html、js、css和图片

    a.减少http请求数：合并js、css、制作雪碧图以及使用http缓存

    b.减少资源的大小：压缩图片、压缩文件、小兔使用base64编码

    c.异步组件和图片懒加载

    d.CDN加速和缓存(bootCND):客户端可通过最佳的网络链路加载静态资源，提高访问的速度和成功率。(CDN:通过在网络各处放置节点服务器构成的一层智能虚拟网络，可将用户的请求重新导向离用户最近的服务节点上)

    2.接口访问的优化

    a.http持久连接(Conention:keep-alive)

    b.后端优化和并请求(比如在进入一个商品详情页的时候后端会提供一个接口获取商品的基本信息，然后当用户点击加入购物车时)

    c.数据接口缓存到localStorage，减少请求

    3.页面渲染速度的优化

    a.由于浏览器的js引擎线程和GUI渲染线程是互斥的，所以在执行js的时候会阻塞它的渲染，所以一般会将css放到顶部，优先渲染，js在底部

    b.减少dom操作

    c.使用虚拟dom渲染方案，做到最小化操纵真实的dom

    d.事件代理：利用事件冒泡原理，把函数注册到父级元素上

    e.减少页面的重绘和回流
    ```
    </details>
32. HTTP请求特征是什么
    <details>
    <summary>答案</summary>
    ```
    支持客户-服务器模式
    简单快速：客户向服务器请求服务时，只需传送方法和路径。请求方法常用的有GET、POST、HEAD。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因此通信速度很快
    灵活：HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记
    无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
    无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要前面信息时应答会很快。
    ```
    </details>
33. react里组件通信有几种方式，分别怎样进行通信
    <details>
    <summary>答案</summary>
    ```
    react组件间通信常见的几种情况：
    父组件向子组件通信
    子组件向父组件通信
    跨级组件通信
    非嵌套关系的组件通信
    1.父组件向子组件通信：父组件通过props向子组件传递需要的信息
    //子组件Child
    const Child = props => {
        return 
    {props.name} 


    }
    //父组件Parent
    const Parent=()=>{
        return 
    }
    2.子组件向父组件通信：props+回调的方式
    //子组件Child
    const Child=props=>{
        const cb=msg=>{
            return ()=>{
                props.callback(msg)
            }
        }
        return (
            sunny
        )
    }

    //父组件 Parent
    class Parent extends Component{
        callback(msg){
            console.log(msg);
        }
        render(){
            return 
        }
    }
    3.跨级组件通信：即父组件向子组件的子组件通信，向更深子组件通信
    // 使用props，利用中间组件层层传递，但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。
    //使用context,context相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现


    //context方式实现跨级组件通信
    //context设计目的是为了共享那些对于一个组件而言是"全局"的数据
    const BatteryContext=createContext();
    //子组件的子组件
    class GrandChild extends Component{
        render(){
            return(
                
                    {
                        color=>
    红色的：{{color}}

                    }
                
            )
        }
    }


    //子组件
    const Child=()=>{
        return(
            
        )
    }
    //父组件
    class Parent extends Component{
        state={
            color:'red'
        }
        render(){
            const {color}=this.state
            return(
                
                    
                
            )
        }
    }
    4.非嵌套关系的组件通信：既没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件
    1)可以使用自定义事件通信(发布订阅模式)
    2)可以通过redux等进行全局状态管理
    3)如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点，结合父子间通信方式进行通信
    ```
    </details>
34. 说一下栈和堆的区别，垃圾回收时栈和堆的区别
    <details>
    <summary>答案</summary>
    ```
    一、堆和栈的区别

    1、存放的数据不同

    堆中存放对象，需要手动释放内存。（垃圾回收机制）

    栈中存放局部变量，内存的释放是系统控制实现的。（局部变量的存活时间是这个函数调用完之后）

    2、空间大小不一样

    堆的空间大，栈的空间小

    二、垃圾回收机制（主要针对堆和方法区）

    1、使用目的：避免发生内存泄漏和内存溢出的情况，使得系统能更好地使用内存。（在JVM中，程序计数器是唯一一个没有规定任何OOM的区域）       

    2、垃圾回收机制的对象：堆和方法区中的对象。

    3、垃圾回收机制什么时候进行：垃圾回收机制运行不确定，由JVM确定，在运行时是间歇执行的。

    4、垃圾回收机制如何确定对象？（可达性分析）

    垃圾回收机制有个Root对象（栈（包括虚拟机栈和本地方法栈）中的引用对象，方法区中的静态变量、常量的引用对象），在对对象进行可达性分析时就是判断对象与Root之间是否有直接或间接引用。根据相关的引用判断对象是否会被回收，如果判断对象应该被回收，则查看对象是否重写了finalize（）方法或是是否已经调用过finalize（）方法，若对象没有重写方法，或者已经调用过方法了，则回收对象；否则，对象进去队列中，等待执行自己的finalize()方法。

    {  a、垃圾回收机制中的引用

            强引用：只要引用存在，垃圾回收机制就不会回收。

            软引用：用来描述一些有用，但不是必须的引用，在系统将要发生内存溢出异常之前，把弱引用对象作为第二次垃圾回收的对象。它起到一个缓存作用，当内存足够时，通过弱引用查询数据，当内存不足时，自动删除这部分数据，并且从真实数据来源查询数据。

            弱引用：在下一次垃圾回收机制启动时，一定会被删除的对象。用于查看弱引用监控对象是否被标记为即将回收的垃圾（isEnQueued()）

            虚引用：对象被回收时收到一个系统通知。用于检测对象是否已经从内存中删除。

    b、final、finally、finalize的区别：

            final是一个修饰符，final修饰的类不能被继承，因此不能与抽象类同时使用。final修饰的变量不可变，final修饰的方法不可重写。（子类可以使用父类的final方法，但是不能重写）

            finally是在异常处理之后要执行的清除任务，例如垃圾回收之类的。

            finalize是垃圾回收机制在回收对象之前要做的操作，对象可能在执行finalize中“起死回生”。

    }

    5、垃圾处理方法：标记-清除，标记-整理，复制

    标记-清除：标记阶段：通过可达性分析，标记与Root相连的对象，未标记的为垃圾对象。

                    清除阶段：将未标记的对象清除

    标记-整理：标记阶段：通过可达性分析，标记与Root相连的对象（有直接引用和间接引用），未标记的为垃圾对象。

                    整理阶段：将所有标记了的对象整理压缩到内存的一段，之后清除边界所有空间

    复制：将内存空间分为两部分，使用其中一部分，在垃圾回收时，将使用部分的存活对象复制到未使用的空间中，并清除使用部分的空间。

    三者的区别：时间复杂度：标记-清除>标记-整理>复制

                        内存利用率：标记-整理=标记-清除>复制（只使用一半）

                        内存整齐度：标记-整理=复制>标记清除

    垃圾回收机制有哪些？（老年代、新生代）

    针对老年代和新生代使用Full GC,老年代回收使用标记-整理/标记-清除的方式。（标记-整理：单线程、多线程收集器。标记-清除：CMS(并行)）

    针对新生代使用Minor GC,使用复制算法，如果空间不够（对象较大），可以直接进入老年代。

    分代回收：G1回收器（并行）

    { 单线程是指：垃圾回收线程只有一个在运行。

    多线程是指：垃圾回收线程有多个在运行。

    串行、并行：用户程序与垃圾收集器交替执行-串行。用户程序与垃圾收集器同时执行-并行。（Parallel Scavenge（并行清除）、CMS、G1）

    新生代：Serial（单线程）、ParNew(多线程)、Parallel Scavenge(并行多线程。目的：达到一个可控制的吞吐量。其他垃圾收集器主要关注缩短用户程序停顿时间。缩短用户程序停顿时间是以牺牲新生代空间和吞吐量为代价的，新生代空间少，垃圾回收频繁，用户程序停顿时间整体变多，吞吐量变小（吞吐量：用户程序运行时间在整体程序运行时间所占比重）)

    老年代：Serial Old 、Parallel Old、CMS(使用标记-清除的垃圾处理方法，目的：用户程序停顿时间小（则吞吐量小）。四大步骤：1、初始标记（标记与Root直接联系的）2、并发标记（在运行时标记与Root有关的对象）3、重新标记（修改由于用户程序运行而发生变化的对象）4、并发清除)

    分代回收：G1（整体：标记-整理，局部：复制）目的：可预测的停顿时间。将堆分成大小独立的区域。将原来的整个空间划分成小空间，可以针对小空间进行垃圾回收。系统针对每个空间大小和回收该空间所停顿的时间会维护一个列表，可以根据这个列表选择要回收的区域。此外，每一个区域都有一个Rememberbe Set,用来记录区域中对象的引用对象所在的区域。四大步骤：1、初始标记 2、并发标记 3、最终标记：程序运行过程中，将对象的引用变化记录在线程的Rememberbe Set Logs中，最终标记阶段负责将Rememberbe Set Logs放入到Rememberbe Set中。筛选回收：根据列表选择符合自己要求的区域进行回收。

    }

    三、有内存回收策略（垃圾回收机制）就必定有内存分配策略（堆）

    1、大多数情况，新生代在Eden上分配，如果空间不够，会发生Minor GC。

    2、大对象、长期存活的对象直接进入老年代。

    3、对象年龄动态判断。对象达到某一存活时间就进入老年代，这个时间可以动态改变。当空间中，某一存活时间的对象空间多于总空间的一半，则将这一空间的对象放入老年代。

    4、空间分配担保。如果在进行Minor GC之前，老年代的最大可用连续空间大于新生代所以对象的总空间，则执行。若不大于，就要检查HandlePromotionFailure是否允许担保，如果允许，就查看老年代最大连续空间是否大于以前晋升到老年代的对象的平均大小，如果大于，则执行，如果小于或者不允许担保，执行Full GC。

    （引起Full GC的条件：不允许空间担保、老年代空间不足、CMS使用标记-清除算法，会造成空间碎片，导致空间不足）

    四、在new一个对象时，需要在分配内存之前，先进行类的加载

    java中的所有类需要类加载器加载到JVM中，才可以运行。

    类的加载过程：加载：JVM获取相关信息，并在内存中生成一个该类的对象，作为数据访问的入口

                            验证：保证Class文件的字节流中的信息符合虚拟机的要求，不会损害虚拟机的安全

                            准备：为类变量（static修饰的变量）分配内存（方法区内存）并设置初始值。（注：实例变量在对象实例化时，随着对象一起分配到堆中）

                            解析：将常量池的符号引用，变为直接引用的过程。（将语义信息与具体操作相连接）（实现JAVA动态绑定，可以将解析放在初始化之后）

                        初始化：真正执行类中定义的java程序。初始化发生时机：主动引用（new）、被动引用(引用方式不会触发初始化，子类引用父类的静态字段，子类不会初始化)

    两个类相等：类本身相等，还是用同一类加载器加载。

    类加载器的分类：启动类加载器（负责将lib目录下的类加载到虚拟机内存中）、

                                扩展类加载器（负责将lib/ext目录下的文件加载到内存中）、

                                应用程序类加载器（负责将自己的java代码编译成class文件加载到内存中）

    类加载器之间的层次关系：双亲委派模型（一个类加载器首先将类加载请求发给父类加载器，只有当父类加载器无法加载，自己才加载，避免了类的重复加载）

    

    三、内存泄漏、内存溢出定义，什么原因导致的？

    1）所谓内存溢出（OOM）就是，程序申请内存空间，但是得不到足够的空间。

        内存泄漏就是：程序申请内存空间之后，无法释放已申请的内存空间，例如有老年代指向这个对象，则在对象使用完之后，无法释放该对象的空间，出现内存泄漏。

    2）原因：使用静态集合类hashmap Set Vector，HashMap中的对象为空，不能回收对象，必须将HashMap设置为空，才能回收对象

                    监听器，在释放连接时要删除监听器。

                    物理连接：数据库与网络的连接需要显示关闭。数据库连接一般使用DataSource.getConnection()，需要使用close()关闭。

                    内部类与外部模块的引用

                    单例模式，单例的存活周期是jvm整个生命周期，如果它引用一个短生命的对象，则这个对象无法释放空间，会发生内存泄漏。
    ```
    </details>
35. 布局都有什么方式，float和position有什么区别
    <details>
    <summary>答案</summary>
    ```
    布局方式

    1.静态块级 2.弹性布局(flex) 3.网络布局(grid) 4.自适应布局(根据当前访问设备进行多套样式来适配) 5.响应式布局(通过媒体查询进行适配，rem/em) 6.浮动布局(float) 7.定位布局(position)

    float和position有什么区别？

    >float：none left right inherit
    特性：

    浮动会脱离文档流，并且会随着分辨率和窗口尺寸的变化而变化
    浮动后面的元素如果是块级元素，会占据块级元素的文本位置，但会与块级元素背景和边框重叠
    多个浮动不会产生重叠现象
    会将块级元素和行内元素变为行内块元素
    >position：relative absolute fixed static 
    特性
    relative和static不会脱离文档流
    absolute和fixed会脱离文档流
    absolute根据relative定位。fixed根据body定位
    absolute和fixed会触发BFC
    定位的优先级高于浮动
    ```
    </details>
36. 请用js代码实现事件代理
    <details>
    <summary>答案</summary>
    
    </details>
37. 对虚拟dom的理解？虚拟dom主要做了什么？虚拟dom本身时什么
    <details>
    <summary>答案</summary>
    ```
    什么是虚拟DOM?
    从本质上来说，Virtual Dom是一个JS对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。

    虚拟dom是对DOM的抽象，这个对象是更加轻量级的对DOM的描述。它设计的最初目的，就是更好的跨平台，比如node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟dom，因为学你dom本身就是js对象。在代码渲染到页面之前，vue或者react会把代码转换成一个对象(虚拟DOM)。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。

    在vue或者react内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。

    另外现代前端框架的一个基本要求就是无需手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发正写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提升开发效率

    为什么要用Virtual Dom？
    1.保证性能下限，再不进行手动优化的情况下，提供能过得去的性能
    看一下页面渲染的一个过程

    解析HTML --- 生成DOM --- 生成cssDom -- Layout -- Paint -- Compiler

    下面对比一下修改DOM时真实DOM操作和Virtual Dom的过程，来看一下它们重排重绘的性能消耗

    真实DOM：生成HTML字符串+重建所有的DOM元素
    Virtual Dom：生成VNode+DOMDiff+必要的dom更新 Virtual Dom的更新DOM的准备工作耗费更多的时间，也就是js层面，相对于更多的DOM操作它的消费是极其便宜的。尤大大曾说到：框架给你的保证时，你不需要手动优化的情况下，我依然可以给你提供过得去的性能
    2.跨平台
    Virtual Dom本质上时JS对象，可以很方便的跨平台操作，比如服务端渲染、uniapp等

    Virtual Dom真的比真实DOM性能好么？
    1.首次渲染大量DOM时，由于多了一层虚拟DOM的计算，比innerHTML插入慢
    2.正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的
    ```
    </details>
38. 移动端需要注意什么
    <details>
    <summary>答案</summary>
    
    </details>
39. 响应式布局用到的技术有几种方式
    <details>
    <summary>答案</summary>
    ```
    方案一：百分比布局
    利用对属性设置百分比来适配不同屏幕，注意这里的百分比是相对于父元素； 能够设置的属性有 width、height、padding、margin，其他属性比如 border、font-size 不能用百分比设置的
    方案二：使用媒体查询 (CSS3 @media 查询)
    利用媒体查询设置不同分辨率下的css 样式，来适配不同屏幕
    方案三.rem 响应式布局
    当前页面中元素的rem 单位的样式值都是针对于html 元素的font-size 的值进行动态计算的，所以有两种方法可以达到适配不同屏幕：
    方案四.vw 响应式布局
    根据 PSD 文件宽度或高度作为标准，元素单位 px 转换为 vw 或 vh，比如font-size: 12px，PSD 文件宽度 375，转换公式 12 * 100 / 375，则样式改为font-size: 3.2vw，下面是我经常使用的工具，有利于提高转换效率。
    方案五.flex 弹性盒子布局
    利用 flex 属性来适配不同屏幕，下图利用简单的属性实现栏目响应式
    ```
    </details>
40. 词法作用域和this的区别
    <details>
    <summary>答案</summary>
    ```
    js只有词法作用域没有动态作用域
    词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本都够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它进行查找。
    eval()，with可以“欺骗“词法作用域，会导致代码运行变慢，不要使用它们
    需要明确的是，事实上，javascript并不具有动态作用域，它只有词法作用域，简单明了，但是this机制某种程度上很像动态作用域
    ```
    </details>
41. 介绍React高阶组件，适用于什么场景
    <details>
    <summary>答案</summary>
    ```
     React高阶组件不是组件，是接收一个wrapperComponent组件作为参数，对wrapperComponent组件做包装处理，添加额外的props属性，最终返回一个新组建的函数；
    * 高阶组件主要有两种形式：属性代理和反向继承；
    * 属性代理： 
        *  1）其实就是接收一个组件当参数，返回一个有状态(类组件)或者无状态(纯函数)的新组件(添加了额外的新属性) 
        *  2）属性代理可以做到：操作props,抽离state,通过ref可以访问到wrapperComponent组件实例
    * 反向继承： 
        *  1）其实就是一个函数接收一个wrapperComponent参数，返回一个继承了wrapperComponent组件的子类(子组件)，且在子组件的render()方法中返回的 super.render()方法； 
        *  2）反向继承可以做到：操作state,渲染劫持
    * 公共点： 属性代理和反向继承的实现有些类似的地方，都是返回一个继承了某个父类的子类，只不过属性代理中继承的是 React.Component，反向继承中继承的是传入的组件 WrappedComponent。
    * 高阶组件应用场景： 
        *  1）代发复用 
        *  2）权限控制(页面级别和页面元素级别)  
        *  3）组件渲染性能追踪，监控组件的渲染时间 
        *  4）数据校验 
        *  5）错误统一处理
    ```
    </details>
42. 说一下vue的keep-alive是如何实现的，具体缓存的是什么
    <details>
    <summary>答案</summary>
    ```
    - props:
    include 字符串或者表达式   只有名称匹配的组件才会被匹配
    exclude 字符串或者表达式  任何匹配的都不会被缓存
    max 最多合一缓存多少组件实例

    > keep-alive 包裹动态组件时 会缓存失活的组件实例

    ##### 实现流程：
        1.判断组件`name`,不在include或者exclude中直接返回 vnode，说明该组件不被缓存
        2.获取组件实例的key， 如果有获取实例的key ,赋值重新生成
        3.key 生成规则： cid+"::"+tag 
        4： 如果缓存对象存在， 直接从缓存中读取组件实例给vnode ，否则 添加到缓存对象中
        5： 最大缓存处理： 当缓存组件超过max时，清除keys数组内第一个组件(LRU缓存淘汰)


    ##### render函数： 
        1.会在keep-alive组件内部写自己的内容，所以可以去获取默认的solt内容，然后根据这个区获取组件
        2.keep-alive 默认只对第一个组件有效，所以获取的时第一个子组件
        3.和keep-alive搭配一起使用的一般有：`动态组件`和`router-view`

        keep-alive 具体是通过cache数组缓存所有组件的vnode实例，当cache内原有组件被使用时，会将key从keys中山湖。然后push到`keys`数组最后，以便清除掉最不常用的组件


    ##### 步骤总结：
        1.获取到keep-alive下的第一个子组件的实例对象，通过它获取组件的name
        2.通过组件name去匹配 原来的include和exclude，判断当前组件是否需要被缓存，不需要，直接返回当前组件 的实例的vnode
        3.需要缓存：判断它当前是否在缓存数组里面，存在则将其原来位置上的key给移除，同时，将该组件的key放到数组的最后面
        4.不存在： 将key放入数组，然后判断当前key数组的是否超过max的范围，超过，削减未使用时间最长的一个组件的key值
        5.最后将组件的keepAlive属性置为true


        keep-alive组件本身的创建过程和patch过程
            缓存渲染的时候，会根据vnode.componentinstance(首次渲染时undefined)和keepAlive属性 判断不会执行组件的createed，mounted等钩子函数，而是对缓存的组件执行patch过程：
            **直接将缓存的DOM对象直接插入到目标元素中，完成了数据更新情况下的渲染过程**

        首次渲染：
            组件的首次渲染：判断组件的abstract属性，才往父组件里面挂载dom
            判断当前的keepAlive和componentInstance是否存在，来判断是否要 执行prepatch还是执行创建coponentinstance
            prepatc操作就不会执行组件的mounted和created钩子函数，而是直接将DOM插入

    ##### LRU缓存淘汰策略
    从内存中追踪出最长时间未使用的数据，并置换新的数据
    使用链表保存缓存数据：
        1.新数据插入到链表头部
        2.每当缓存命中（缓存数据被访问），将数据移动到头部
        3.链表慢的时候，将链表尾的数据丢弃
    ```
    </details>
43. 请描述下css盒模型基本概念
    <details>
    <summary>答案</summary>
    ```
    标准模型和IE模型的区别：计算高度和宽度的不同。

    css如何设置这两种模型：

    box-sizing:content-box;

    box-sizing:border-box;


    盒子的大小
    盒子的大小指的是盒子的宽度和高度。大多数初学者容易将宽度和高度误解为width和height属性，然而默认情况下width和height属性只是设置content（内容）部分的宽和高。盒子真正的宽和高按下面公式计算：

    盒子的宽度 = 内容宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距
    
    盒子的高度 = 内容高度 + 上填充 + 下填充 + 上边框 + 下边框 + 上边距 + 下边距

    盒子的宽度 = width + padding-left + padding-right + border-left + border-right + margin-left + margin-right
    
    盒子的高度 = height + padding-top + padding-bottom + border-top + border-bottom + margin-top + margin-bottom

    box-sizing属性值
    
    content-box：默认值，width和height属性分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距、边框、外边距。
    
    border-box：为元素设定的width和height属性决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去 边框 和 内边距 才能得到内容的宽度和高度。
    
    inherit：规定应从父元素继承box-sizing属性的值


    当box-sizing：content-box时，这种盒子模型成为标准盒子模型，当box-sizing: border-box时，这种盒子模型称为IE盒子模型。
    ```
    </details>
44. React组件中怎么做事件代理？它的原理是什么
    <details>
    <summary>答案</summary>
    ```
    ### 如何做事件代理：
    - 事件管理中心(bankForRegistrationName)会在react-render过程中保存所有所有dom事件
    - document作为事件委托者，用来分发事件(dispatchEvent),通过dom节点唯一标识(_debugID)去事件管理(bankForRegistrationName)触发事件
    ### 原理
    - 1、React 借鉴事件委托的方式将大部分事件委托给了 Document 对象。
    - 2、React 中的事件分为 3 类。分别是 DiscreteEvent（离散事件），UserBlockingEvent（用户阻塞事件），ContinuousEvent（连续事件）。不同类型的事件代表了不同的优先级。
    - 3、事件委托需要区分捕获和冒泡，有些事件由于没有冒泡过程，只能在捕获阶段进行事件委托。
    - 4、没有进行委托的事件是 Form 事件和 Media 事件，原因是这些事件委托后会触发两次回调函数。
    ### React 使用了合成事件，它的好处是：
    - 1、合成事件做了浏览器的兼容处理
    - 2、React 想通过 SyntheticEvent 实现跨平台事件机制。
    - 3、原生事件升级、改造，比如 React 的 onChange 事件，它为表单元素定义了统一的值变动事件，例如 blur、change、focus、input 等。
    ```
    </details>
45. Promise构造函数是同步还是异步执行，then呢？
    <details>
    <summary>答案</summary>
    ```
    promise构造函数是同步执行的，then方法本身是同步执行，then方法中的回调函数加入微任务异步执行。
    ```
    </details>
46. 说一下mobx盒redux有什么区别
    <details>
    <summary>答案</summary>
    ```
    Mobx解决的问题
    传统react使用的数据管理库为Redux。Redux要解决的问题是统一数据流，数据流完全可控并可追踪。要实现该目标，便需要进行相关的约束

    Redux由此引出dispatch action reducer等概念，对state的概念进行强约束，然而对于一些项目来说，太过强，便失去了灵活性。Mobx便是填补此空缺的

    这里对Redux和Mobx进行简单的对比：
    1.Redux的编程范式是函数式的而Mox是面向对象的；

    2.因此数据上来说Redux理想的是immutable，每次都返回一个新的数据，而Mobx从始至终都是一份引用。因此Redux是支持数据回溯的；

    3.然而和Redux相比，使用mobx的组件可以做到精准更新，这一点得益于Mobx的observable；对应的Redux是用dispath进行广播，通过Provider和connect来比对前后差别控制更新粒度，有时需要自己写SCU；Mox更加精细。



    Mobx和Redux
    1.共同点

    为了解决状态管理混乱，无法有效同步的问题
    统一维护管理应用状态
    某一状态只有一个可信数据来源(通常命名为store,指状态容器)
    操作更新状态方式统一，并且可控(通常以action方式提供更新状态的途径)
    支持将store与React组件连接，如react-redux，mobx-react
    2.区别 
    > Redux

    Redux更多的是遵循Flux模式的一种实现，是一个JavaScript库，它所关注的主要是以下几个方面：

    - Action:一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性：
    - type:action类型
    - payload:负载数据
    - Reducer:定义状态如何响应不同动作(action)，如何更新状态
    - Store:管理action和reducer及相关的对象
    - 维护应用状态并支持访问状态(getState())
    - 支持监听action的分发，更新状态(dispatch(action))
    - 支持订阅store的变更(subscribe(listener))
    - 异步流：由于Redux所有对Store状态的变更，都应该通过action触发，异步任务(通常都是业务或获取数据任务)也不例外，而为了不将业务或数据相关的任务混入React组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等
    > Mobx

    Mobx是一个透明函数响应式编程的状态管理库，使得状态管理简单可伸缩：

    - Action：定义改变状态的动作函数，包括如何变更状态
    - Store：集中管理模块状态(State)和动作(action)
    - Derivation(衍生):从应用状态中派生而出，且没有任何其他影响的数据
    对比总结

    - 1.redux将数据保存单一的store中，mobx将数据保存在分散的多个store中
    - 2.redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作
    - 3.redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
    - 4.mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用
    - 5.mobx中有更多的抽象和封装，调试比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
    ```
    </details>
47. css预处理器的概念
    <details>
    <summary>答案</summary>
    ```
    CSS预处理器定义了一种新的语言（专门的编程语言），其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。CSS预处理语言具有以下特点：

    - 不需要考虑浏览器兼容问题，因为CSS预处理器最终编译和输出的仍是标准的CSS样式。
    - 可以使用变量、简单逻辑判断、函数等基本编程技巧。
    - CSS选择器可以进行嵌套，减少较多重复的选择器语句。
    - 减少CSS代码冗余，为CSS提供样式复用机制，提高CSS代码的可维护性。
    ```
    </details>
48. shouldComponentUpdate是为了解决什么问题
    <details>
    <summary>答案</summary>
    ```
    询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。
    这个方法用来判断是否需要调用 render 方法重新描绘 dom。
    因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。
    ```
    </details>
49. react里setState到底是异步还是同步
    <details>
    <summary>答案</summary>
    ```
    有时表现出异步,有时表现出同步

    - setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。
    - setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
    - setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。
    ```
    </details>
50. react-redux的工作流程是什么
    <details>
    <summary>答案</summary>
    ```
    1）Redux

    Redux源码主要分为以下几个模块文件

    - compose.js 提供从右到左进行函数式编程
    - createStore.js 提供作为生成唯一store的函数
    - combineReducers.js 提供合并多个reducer的函数，保证store的唯一性
    - bindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作
    - applyMiddleware.js 这个方向通过中间件来增强dispatch的功能
    2）工作流程
    - 1.const store = createStore(fn) 产生数据
    - 2. action:{type: Symble('action001',payload:'payload')}定义行为
    - 3.dispatch 发起action:store.dispatch(doSomething('action001'))
    - 4.reducer:处理action,返回新的state 通俗点解释：
    - 5. 首先，用书通过VIew发出Action，发出方式就用到了dispatch方法
    - 6. 然后，Store自动调用了Reducer,并且传入了两个参数：当前State和收到的Action，Reducer返回新的State
    - 7. State一旦有变化，Store就会调用监听函数，来更新View

    2）react-redux

    1.Provider：Provider的作用是从最外部封装了整个应用，并向connect模块传递Store

    2.connect：负责连接React和Redux

    - 获取state:connect通过context获取Provider中的store，通过stroe.getState()获取整个store tree上所有state 包装原组件:将state和action通过props的方式传入到原组件内部wrapWithConnect返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件WrappedComponent，并把connect中传入的mapStateToProps，mapStateToProps与组件上原有的props合并后，通过属性的方式传给WrappedComponent

    - 监听store tree的变化:connect缓存了store tree中的state的状态，通过当前state状态和变更前state状态进行比较，从而确定了是否调用this.setState()方法触发Connect及其子组件的重新渲染
    ```
    </details>
51. 添加原生事件不移除为什么会内存泄漏，还有哪些地方会存在内存泄漏
    <details>
    <summary>答案</summary>
    ```
    ### 添加原生事件不移除会内存泄漏的原因
    var button = document.getElementById('button');
    function onClick(e){
        button.innerHTML = 'text'
    }
    button.addEventListener('click', onClick);
    给元素button添加一个事件处理器onclick,而处理器使用了button的引用。而老版本的IE是无法检测DOM节点和JavaScript代码之间的循环引用，因此会导致内存泄漏。
    如今，现代的浏览器（包括IE和Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用removeEventListener

    #### 其他内存泄漏
    - 以外的全局变量（如果必须使用全局变量存储大量数据时，确保用完后把它设置为null或者重新定义，与全局变量相关的增加内存消耗的一个主因是缓存，缓存数据是为了重用，缓存必须有一个大小上线才有用）
    - 被遗忘的计时器，比如下面示例代码，尽管这个定时器不再需要，里面的回调也不再需要，可是定时器回调函数没有被回收，这样someSource，如果存储了大量数据，也是无法被回收，因此需要把定时器清除。
    - 脱离DOM的引用（当你保存了一个dom的引用，然后将该dom从html中删除后，你应该将这个引用赋为null，否则GC不会回收，这个dom仍然在内存中，保存DOM元素引用的时候，要小心谨慎）
    - 闭包，闭包包含这外面函数的活动对象，无法被GC回收
    ```
    </details>
52. 怎么处理项目中的异常捕获行为
    <details>
    <summary>答案</summary>
    ```
    一、代码执行的错误捕获
    1.try…………catch

    能捕获到代码执行的错误
    捕获不到语法的错误
    无法处理异步中的错误
    使用try……catch包裹，影响代码可读性
    2.window.onerror

    无论是异步还是非异步错误，onerror都能捕获到运行时错误
    onerrer主要是来捕获预料之外的错误，而try……catch则是用来在可预见情况下监控特定的错误，两者结合使用更高效
    window.onerror函数只有在返回true的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示：Uncaught Error:xxxxx
    当我们遇到报404网络请求异常的时候，onerror是无法帮助我们捕获到异常的
    缺点：监听不到资源加载的报错error，事件处理函数只能声明一次，不会重复执行多个回调

    3.window.addEventListener('error',function,boolean)

    可以监听到资源加载报错，也可以注册多个事件处理函数

    window.addEventListener("error",(msg,url,row,col,error)=>{},true)

    但是这种方式虽然可以捕捉到网络请求的异常，却无法判断HTTP的状态是404还是其他比如500等等，所以还需要配合服务端日志才进行排查分析才可以

    4.window.addEventListener('unhandledrejection')

    捕获Promise错误，当Promise被reject处理器的时候，会触发unhandledrejection事件；这可能发生在window下，但也可能发生在Worker中。这对于调试回退错误处理非常有用

    二、资源加载的错误捕获
    1.imgObj.onerror()，图片不存在的时候就会触发onerror事件
    2.performance.getEntries()，获取到成功加载的资源，对比可以间接的捕获错误
    3.window.addEventListener('error',function,true)，会捕获但是不冒泡，所以window.onerror不会触发，捕获阶段可以触发
    ```
    </details>
53. 点击一个按钮，浏览器会做些什么事情
    <details>
    <summary>答案</summary>
    ```
    1.点击按钮会创建一个event实例
    2.然后把事件放到事件队列中，让他等候处理
    3.Event循环线程处理这个事件
    4.沿着DOM路径找到触发事件的元素
    5.如果这个元素上有处理这个事件的默认行为，并且要在DOM事件阶段周期之前执行，就执行他的默认行为
    6.捕获阶段
    7.目标阶段
    8.冒泡阶段
    9.如果这个元素上有处理这个事件的默认行为，并且要在DOM事件处理阶段周期之后执行，就执行他的默认行为
    ```
    </details>
54. promise有没有解决异步的问题
    <details>
    <summary>答案</summary>
    ```
    Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一的接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层一层的嵌套回调函数。

    Promise 解决了 callback 回调地狱的问题，async await 是异步操作的终极解决方案。
    ```
    </details>
55. css预处理器的好处
    <details>
    <summary>答案</summary>
    ```
    CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。
    ```
    </details>
56. 与http相关的协议有哪些？tcp/ip dns uri/url https
    <details>
    <summary>答案</summary>
    ```
    在互联网中，任何协议都不会单独的完成信息交换，HTTP也一样。虽然HTTP属于应用层的协议，但是它仍然需要其他层次的协议的配合完成信息的交换，那么在完成一次HTTP请求和响应的过程中，需要哪些协议呢？一起来观看下

    TCP/IP
    TCP/IP协议一定听说过，TCP/IP我们称之为协议簇，什么意思呢？就是TCP/IP协议簇中不仅仅只有TCP协议和IP协议，它是一系列网络通信协议的统称。而其中最核心的两个协议就是TCP/IP协议，其他的还有UDP、ICMP、ARP等等，共同构成了一个复杂但有层次的协议栈

    TCP协议的全称是Transmission Control Protocol的缩写，意思是传输控制协议，HTTP使用TCP作为通信协议，这是因为TCP是一种可靠的协议，而可靠能保证数据不丢失。

    IP协议的全称是Internet Protocol的缩写，它主要解决的是通信双方寻址的问题。IP协议使用IP地址来标识互联网上的每一台计算机，可以把IP地址想象成你的手机号码，你要与别人通话必须要知道他人的手机号码，计算机网络中信息交换必须先要知道对方的IP地址

    DNS
    有没有想过为什么你可以输入www.baidu.com就能获取到你想要的网站？是因为计算机网络中的每个端系统都有一个IP地址存在，而把IP地址转换为便于人类记忆的协议的就是DNS 协议

    DNS的全称是域名系统(Domain Name System),它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网

    URI/URL
    我们可以输入www.baidu.com地址来访问百度官网，那么这个地址有什么规定么？可以随意输入么？我们输入的地址格式必须要满足URI的规范

    URI的全称Uniform Resource Identifier，中文名称是统一资源标识符，使用它就能够唯一地标记互联网上的资源

    URL的全称是Uniform Resource Locator，中文名称是统一资源定位符，也就是我们俗称的网址，实际上就是URI的一个子集

    URI不仅包括URL，还包括URN(统一资源名称)

    HTTPS
    HTTPS一般是明文传输，很容易被攻击者窃取重要信息，鉴于此，HTTPS应运而生。HTTPS的全称为Hyper Text Transfer Protocol over SecureSocket Layer，HTTPS和HTTP有很大的不同在于HTTPS是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS在HTTP的基础上增加了SSL层，也就是说HTTPS = HTTP + SSL
    ```
    </details>
57. cdn有哪些优化静态资源加载速度的机制
    <details>
    <summary>答案</summary>
    ```
    资源调度：CDN会根据用户接入网络的ip寻找距离用户最优路径的服务器。调度的方式主要有DNS调度、http 302调度、使用 HTTP 进行的 DNS 调度（多用于移动端）；
    缓存策略和数据检索：CDN服务器使用高效的算法和数据结构，快速的检索资源和更新读取缓存；
    网络优化：从OSI七层模型进行优化，达到网络优化的目的。
    L1物理层：硬件设备升级提高速度
    L2数据链路层：寻找更快的网络节点、确保 Lastmile 尽量短
    L3路由层：路径优化，寻找两点间最优路径
    L4传输层：协议TCP优化，保持长连接、TCP快速打开
    L7应用层：静态资源压缩、请求合并
    ```
    </details>
58. 说说你理解的node中间层怎样做的请求合并转发
    <details>
    <summary>答案</summary>
    ```
    - 1. 什么是中间层？
    - 就是前端---请求---> nodejs ----请求---->后端 ----响应--->nodejs--数据处理---响应---->前端。这么一个流程，这个流程的好处就是当业务逻辑过多，或者业务需求在不断变更的时候，前端不需要过多当去改变业务逻辑，与后端低耦合。前端即显示，渲染。后端获取和存储数据。中间层处理数据结构，返回给前端可用可渲染的数据结构。
    - nodejs是起中间层的作用，即根据客户端不同请求来做相应的处理或渲染页面，处理时可以是把获取的数据做简单的处理交由底层java那边做真正的数据持久化或数据更新，也可以是从底层获取数据做简单的处理返回给客户端。
    - 通常我们把Web领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。
    -  以SSR来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做SEO，他的好处是比较好理解的
    - 2. 中间层可以做的事情
    - 代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，我们可以利用代理，转发请求到多个服务端。
    - 缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，node中间层可以直接处理一部分缓存需求。
    • 限流：node中间层，可以针对接口或者路由做响应的限流。
    • 日志：相比其他服务端语言，node中间层的日志记录，能更方便快捷的定位问题（是在浏览器端还是服务端）。
    • 监控：擅长高并发的请求处理，做监控也是合适的选项。
    • 鉴权：有一个中间层去鉴权，也是一种单一职责的实现。
    • 路由：前端更需要掌握页面路由的权限和逻辑。
    • 服务端渲染：node中间层的解决方案更灵活，比如SSR、模板直出、利用一些JS库做预渲染等等。
    • 3. node转发API（node中间层）的优势
    • 可以在中间层把java|php的数据，处理成对前端更友好的格式
    • 可以解决前端的跨域问题，因为服务器端的请求是不涉及跨域的，跨域是浏览器的同源策略导致的
    • 可以将多个请求在通过中间层合并，减少前端的请求
    • 4. 如何做请求合并转发
    • 使用express中间件multifetch可以将请求批量合并
    • 使用express+http-proxy-middleware实现接口代理转发
    ```
    </details>
59. webpack做了什么？使用webpack构建时有无做了一些自定义操作
    <details>
    <summary>答案</summary>
    ```
    > webpack做了什么？

    - 1.webpack本质上只是一个js引用程序的静态打包器，它能够基于文件的依赖，递归的构建一个文件依赖关系图，最终将文件打包称为一个或多个bundle；
    - 2.webpack基于entry识别哪个/哪些模块是构建打包的入口
    - 3.webpack基于output，将构建打包的文件输出到指定的目录
    - 4.从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理
    - 5.经过Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再把每个chunk转换成一个单独的文件加入到输出列表

    > webpack构建时有无做一些自定义操作

    - 1.alias：指定别名，能在一定程度上降低开发对文件路径的输入难度，缓存路径能提升些打包速度
    - 2.module对loader处理添加fallback，能在loader处理中，依次进行指定的预处理或后处理，自定义loader组件也可以在此进行特殊替换
    - 3.optimization-splitChunks-cacheGroups自定义打包中的性能优化部分，对共用模块的拆分、识别以及提取后的指定部分
    - 4.自定义的plugins配置：CopyWebpackPlugin对静态文件的拷贝，ProgressBarPlugin打包进度的监控，HappyPack多线程打包等等
    - 5.stats调整打包过程中控制台的输出，详细到每个文件的大小、耗时及打包状态等各种显示优化
    - devServer-before:添加打包前的优化，可以实现较为简洁的mock数据
    ```
    </details>
60. webapck如何用localStorage离线缓存静态资源
    <details>
    <summary>答案</summary>
    ```
    1.在配置webpack时，我们可以使用html-webpack-plugin来注入到和html一段脚本来实现将第三方或者共用资源进行静态化存储在html中注入一段标识，例如<% HtmlWebpackPlugin.options.loading.html %>，在html-webpack-plugin中即可通过配置html属性，将script注入进去

    2.利用webpack-manifest-plugin并通过配置webpack-manifest-plugin，生成manifestjson文件，用来对比js资源的差异，做到是否替换，当然，也要写缓存script

    3.在我们做CI以及CD的时候，也可以通过编辑文件流来实现静态化脚本的注入，来降低服务器的压力，提高性能

    4.可以通过自定义plugin或者html-webpack-plugin等周期函数，动态注入前端静态化存储script
    ```
    </details>
61. 使用import时，webpack对node_modules里的依赖会做什么
    <details>
    <summary>答案</summary>
    ```
    ES6 Module
    不同于CommonJS和AMD的模块加载翻噶嘛，ES6在JS语言层面上实现了模块功能。它的设计思想是:尽量的静态化，使得编译时就能确定模块的依赖关系。在遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到的时候，再到模块里面去取值。这和CommonJS模块规范的最大不同。

    webpack会对node_modules里的依赖做什么
    webpack会根据定义的引入方式判断模块类型，再进行相关编译转化。当使用import引入时，babel默认会把ES6的模块转化成CommonJS规范，然后会将node_module里的依赖打包成自执行函数的样式

    (function(modules){
        //执行逻辑
    })([模块数组])
    在模块数组中将模块传入，在函数体中经过一系列操作最终将模块通过module.exports导出
    ```
    </details>
62. 关于vue项目进行优化，你有哪些方法
    <details>
    <summary>答案</summary>
    ```
    1.代码层面的优化
    v-if 和 v-show 区分使用场景
    computed 和 watch 区分使用场景
    v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
    长列表性能优化
    事件的销毁
    图片资源懒加载
    路由懒加载
    第三方插件的按需引入
    优化无限列表性能
    服务端渲染 SSR or 预渲染
    2.Webpack 层面的优化
    Webpack 对图片进行压缩
    减少 ES6 转为 ES5 的冗余代码
    提取公共代码
    模板预编译
    提取组件的 CSS
    优化 SourceMap
    构建结果输出分析
    Vue 项目的编译优化
    3.基础的 Web 技术的优化
    开启 gzip 压缩
    浏览器缓存
    CDN 的使用
    使用 Chrome Performance 查找性能瓶颈
    ```
    </details>
63. 为什么组件中的data必须是一个函数，然后return一个对象，而new Vue实例里，data可以直接是一个对象
    <details>
    <summary>答案</summary>
    ```
    如果组件中也是使用data对象的话，那么各个组件间会互相覆盖data，因为是同一个data对象
    而写成函数后，每次函数返回的对象则是全新的，不会互相影响
    ```
    </details>
64. redux和vuex有什么区别，说一下他们的共同思想
    <details>
    <summary>答案</summary>
    ```
    Redux和Vuex区别
    Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值就可以
    Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state就可以
    Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数 -- store改变(vue检测到数据变化自动渲染)
    通俗理解就是:Vuex弱化dispatch，通过commit进行store状态的一次变更；取消了action概念，不必传入特定的action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加建议

    共同思想
    单一的数据源

    变化可以预测

    本质上:Redux和Vuex都是对MVVM思想的服务，将数据从视图中抽离的一种方案

    形式上:Vuex借鉴了Redux，将store作为全局的数据中心，进行数据管理
    ```
    </details>
65. 说一下react.Component和react.PureComponent的区别
    <details>
    <summary>答案</summary>
    ```
    区别
    Component是React App的基本构建的单位，也是React中基本代码复用单位。PureComponent与Component在除了其shouldComponentUpdate方法的实现之外几乎完全相同。PureComponent已经替我们实现了shouldComponentUpdate方法

    对于PureComponent而言，当其props或者state改变时，新旧props与state将进行浅对比。另一方面，Component默认的情况下与其shouldComponentUpdate方法并不进行新旧props与state的对比

    对于基本类型来说，浅拷贝将会检查其值是否相同。对于引用类型的变量来说，如果只是更新了其中的一个元素，那么更新前后的数组仍是相等的

    因此意味着相比Component，PureComponent的性能表象会更好，但是使用PureComponent时要满足如下条件：

    props和state必须都是不可变对象
    props和state不能有层级嵌套的结构，否则对子层的改变无法反映在浅拷贝中
    如果数据改变无法反映在浅拷贝上，则应该调用forceUpdate来强制更新Component
    一个PureComponent的子Component也应当是PureComponent
    通俗回答
    React.Component需要自己实现shouldComponentUpdate()
    React.PureComponent通过props和state的钱比较来实现shouldComponentUpdate()
    如果定义了shouldComponentUpdate()，无论组件是否是PureComponent，都会执行shouldComponentUpdate()结果来判断是否update。如果组件未实现shouldComponentUpdate(),则判断该组件是否是PureComponent，如果是的话，会对新旧props、state进行比较，一旦新旧不一致，就会触发update
    React.PureComponent优点:不需要开发者自己实现shouldComponentUpdate，就可以进行简单的判断来提升性能
    React.PureComponent缺点：可能会因深层的数据不一致而产生错误的否定判断，从而shouldComponentUpdate结果返回false，界面得不到更新。
    ```
    </details>
66. 说一下你对react context的理解
    <details>
    <summary>答案</summary>
    ```
    在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单向数据流在某些场景中并不适用。单纯一对父子组件传递并无问题，但是组件之间层层依赖深入，props就需要层层传递，很显然这样做太繁琐了

    Context提供了一种在组件之间共享此类值的方式，而不必显式的通过组件书的层层传递props

    可以把context当作特定一个组件树内共享的store，用来当作数据传递。简单来说，当你不想在组件树种通过层层传递props或者satte的方式来传递数据时，可以使用context来实现跨层级的组件数据传递

    JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数

    假如以JS的作用域链作为类比，React组件提供的context对象其实好比一个提供给子组件访问的作用域，而context对象的属性可以看成作用域上的活动对象。由于组件的context由其父节点链上所有组件通过getChildContext()返回的context对象组合而成，所以，组件通过context是可以访问到其父组件链上所有节点组件提供的context属性。
    ```
    </details>
67. 说一下mysql和mongodb的区别
    <details>
    <summary>答案</summary>
    ```
    mysql
    在不同的引擎上有不同的存储方式
    查询语句是使用传统的sql语句，拥有建委成熟的体系，成熟度很高
    开源数据库的份额在不断增加，mysql的份额在持续增长
    mysql的缺点就是在处理海量数据处理的时候效率明显会变低

    mongodb
    mongodb是非关系型文档类型(可以存放xml、bson、json等自述性类型，结构未分层树状的数据)数据库

    数据结构由键值对组成
    虚拟内存+持久化的存储方式
    结构特点未可以通过副本集以及分片来实现高可用
    数据是存储在硬盘上的，只不过需要经常读取的数据会被加载内存中，将数据存储在物理内存中，从而达到高效读写
    mongodb的优点
    适量级的内存的mongodb性能迅速。它将数据存储在物理内存中，使数据读写非常快
    mongodb的高可用和集群架构拥有十分高的扩展性
    在副本集中，当主库遇到问题，无法继续提供服务的时候，副本集将选择一个新的主库继续提供服务
    mongodb的bson和json格式的数据十分适合文档格式的存储和查询
    mongodb的缺点
    mongodb本身没有自带事务机制，若需要实现事务机制，需要通过一个额外的表，从逻辑上自行实现事务
    占用空间过大
    由于nosql兴起时间短，应用经验相比关系型数据库较少
    ```
    </details>
68. webpack里面的插件是如何实现的
    <details>
    <summary>答案</summary>
    ```
    实现分析
    webpack本质是一个事件流机制，核心模块：tapable(Sync + Async)Hooks 构造出 === Compiler(编译) + Compilation(创建bundles)
    compiler对象代表了完整的webpack环境配置。这个对象在启动webpack时被一次性建立，并配置好所有可操作的设置，包括options、loader和plugin。当在webpack环境中应用一个插件时，插件将收到此compiler对象的引用。可以使用它来访问webpack的主环境
    compilation对象代表了一次资源版本构建。当运行webpack开发环境中间件时，每当检测到一个文件变化，就会创建一个新的compilation，从而生成一个新的编译资源。一个compilation对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态的信息。compilation对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用
    创建一个插件函数，在其prototype上定义apply方法，指定一个webpack自身的事件钩子
    函数内部处理webpack内部实例的特定数据
    处理完成后，调用webpack提供的回调函数
    ```
    </details>
69. 使用ts的优势有哪些
    <details>
    <summary>答案</summary>
    ```
    优势
    类型检测:在TS中为变量制定具体类型时，IDE会做出类型检测，这个特性减少在开发阶段犯错几率

    语法提示:在IDE里编写TS代码时，IDE会根据当前的上下文把类、变量、方法和关键字都给你提示出来，提高开发效率

    便于重构:修改变量或者方法的名字很边界，当你做出修改的时候，IDE会帮你自动引用这个变量或者调用这个方法的代码自动帮你修改

    活跃社区:TS拥抱ES6的规范，也支持部分起草规范，大部分的第三方库提供TS类型定义的文件

    TypeScript的最大特点是静态类型，不同于JavaScript的动态类型，静态类型有以下优势：

    第一，静态类型检查可以做到early fail，编写的代码即使没有被执行到，但是发生类型不匹配的时候，语言在编译阶段(解释执行也一样),可以在运行前发现
    第二，静态类型对阅读代码是友好的，针对大型应用，方法很多，调用关系复杂，不可能每个函数都有人编写细致的文档，所以静态类型就是非常重要的提示和约束。此外TS还实现了类、接口、美剧、泛型，方法重载等语法糖，方便前端开发
    ```
    </details>
70. 直接给一个数组项赋值，vue能检测到变化吗
    <details>
    <summary>答案</summary>
    ```
    由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：

    当你利用索引直接设置一个数组项时，例如： vm.items[indexOfItem] = newValue
    当你修改数组的长度时，例如： vm.items.length = newLength
    为了解决第一个问题，Vue 提供了以下操作方法：
    通过索引来修改数组，使其能成为响应式，解决直接使用赋值不能响应的问题
    Vue.set(vm.data,2,'huanpu','name')    对数组
    Vue.$set(vm.data,'K','V')　　对对象

    1. 参数一表示要处理的数组名称。
    2. 参数二表示要处理的数组的索引。
    3. 参数三表示要处理的数组的值。
    为了解决第二个问题，Vue 提供了以下操作方法：
    // Array.prototype.splice
    vm.items.splice(newLength)
    newLength  就是指的你更新的长度
    ```
    </details>
71. vue组件间的通信有哪几种方式
    <details>
    <summary>答案</summary>
    ```
    - 父子间通信 父->子通过props、子->父$on、$emit(发布订阅) 
    - 获取父子组件实例的方式 $parent、$children
    - 在父组件中提供数据子组件进行消费 Provide、inject 插件
    - Ref 获取实例的方式调用组件的属性或者方法
    - Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue 
    - Vuex状态管理实现通信 $attrs $listeners



    ### Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式:
    - 1. props / $emit 适用 父子组件通信 这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。
    - 2. ref 与 $parent / $children 适用 父子组件通信
        + ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
        + $parent/$children：访问父 / 子实例
    - 3. EventBus($emit/$on)适用于 父子、隔代、兄弟组件通信 这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。
    - 4. $attrs/$listeners 适用于 隔代组件通信
        + $attrs:包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过v-bind="$attrs"传入内部组件。通常配合inheritAttrs选项一起使用。
        + $listeners:包含了父作用域中的 (不含 .native 修饰器的) v-on事件监听器。它可以通过v-on="$listeners"传入内部组件
    - 5. provide / inject 适用于 隔代组件通信 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。
    - 6. Vuex 适用于 父子、隔代、兄弟组件通信。Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。
        + Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
        + 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。
    ```
    </details>
72. 项目如何管理模块
    <details>
    <summary>答案</summary>
    ```
    在一个项目内，当有多个开发者一起协作开发时，或者功能越来越多、项目越来越庞大时，保证项目井然有序的进行是相当重要的。一般会从下面几点来考证一个项目是否管理的很好：
    - 可扩展性：能够很方便、很清晰的扩展一个页面、组件、模块
    - 组件化：多个 页面之间共用的大块代码可以独立成组件，多个页面、组件之间共用的小块代码可以独立成公共模块
    - 可阅读性：阅读性良好（包括目录文件结构、代码结构），能够很快捷的找到某个页面、组件的文件，也能快捷的看出项目有哪些页面、组件
    - 可移植性：能够轻松的对项目架构进行升级，或移植某些页面、组件、模块到其他项目
    - 可重构性：对某个页面、组件、模块进行重构时，嫩恩狗保证在重构之后功能不会改变、不会产生新bug
    - 开发友好：开发者在开发某一功能时，嫩恩狗有比较好的体验（不好的体验比如：多个文件相隔很远）
    - 协作型：多人协作，很少产生代码冲突，文件覆盖等问题
    - 可交接性：当有人要离开项目时，交接给其他人是很方便的
    过个项目之间，如何管理好项目之间联系，比如共用组件、公共模块等，保证快捷高效开发、不重复造轮子，也是很重要的。一般会从下面几点来考证多个项目之间是否管理的很好：
    - 组件化：多个项目共用的代码应当独立出来，成为一个单独的组件项目
    - 版本化：组件项目与应用项目都应当版本化管理，特别是组件项目的版本应当符合semver语义化版本规范
    - 统一性：多个项目之间应当使用相同的技术选型、ui框架、脚手架、开发工具、构建工具、测试库、目录规范、代码规范等，相同功能应指定使用固定某一个库
    - 文档化：组件项目一定需要相关的文档，应用项目在必要的时候也要形成相应的文档
    ```
    </details>
73. 在那个生命周期内调用异步请求
    <details>
    <summary>答案</summary>
    ```
    一般来说，可以在，created，mounted中都可以发送数据请求，但是，大部分时候，会在created发送请求。
    Created的使用场景：如果页面首次渲染的就来自后端数据。因为，此时data已经挂载到vue实例了。
    在 created（如果希望首次选的数据来自于后端，就在此处发请求）（只发了异步请求，渲染是在后端响应之后才进行的）、beforeMount、mounted（在mounted中发请求会进行二次渲染） 这三个钩子函数中进行调用。
    因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是最常用的是在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求

    有两个优点：
    第一点：能更快获取到服务端数据，减少页面 loading 时间；
    第二点：放在 created 中有助于一致性，因为ssr 不支持 beforeMount 、mounted 钩子函数。
    ```
    </details>
74. 说明一下js封装的原理
    <details>
    <summary>答案</summary>
    ```
    封装也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特征。

    通俗来讲就是，将用户不需要知道的数据和方法隐藏起来，外部无法直接访问。在java中用private、protected关键字来进行修饰。在js中可以用闭包实现。
    ```
    </details>
75. 回调函数和任务队列的区别
    <details>
    <summary>答案</summary>
    ```
    1.回调函数 回调函数是作为参数传给另一个函数的函数，这个函数会在另一个函数执行完成后执行

    2.任务队列 任务队列是一个事件的队列，IO设备完成一项任务后，就在队列中添加一个事件，表示相关的异步任务可以进入执行栈中了

    同步任务：主线程上排队执行的任务，前一个任务执行完成后才能执行下一个任务

    异步任务：不进入主线程，进入任务队列的任务。只有当主线程上的同步任务执行完成后，主线程会读取任务队列中的任务，开始异步执行

    任务队列中的事件包括IO设备的事件、用户产生的事件。只要指定过回调函数，这些事件发生时就会进入任务队列，等待主线程读取

    异步任务必须指定回调函数，当主线程开始执行异步任务时，就是执行对应的回调函数
    ```
    </details>
76. 写出常用的页面优化实现方案
    <details>
    <summary>答案</summary>
    ```
    一、页面内容优化

    减少http请求次数
    减少DNS查询次数
    避免页面跳转
    缓存ajax
    延迟加载（一般用在图片多的页面中，滚动时才加载）
    预加载
    减少DOM元素数量
    减少iframe数量
    避免404
    二、css优化

    将样式表置顶将 （CSS放在 HEAD中，防止浏览器有可能还未下载和解析到 CSS就已经开始渲染页面）
    避免css表达式
    用link代替@import
    避免使用filters
    css文件合并与压缩
    三、js代码优化

    将脚本置底（将脚本内容在页面信息内容加载后再加载）
    使用外部javascript和css文件
    去除重复脚本，避免重复的资源请求
    减少DOM访问（修改和访问DOM元素会造成页面的重绘和重排，循环对DOM操作更是减慢页面加载速度）
    js文件合并与压缩
    四、图片优化

    优化图片大小
    尽量使用css sprite（精灵图也叫雪碧图）
    不要在html中缩放图片
    使用小且可缓存的favicon.ico
    五、减少Cookie传输

    Cookie包含在每次请求和响应中，太大的Cookie会严重影响数据传输，因此哪些数据需要写入Cookie需要慎重考虑，尽量减少Cookie中传输的数据量。
    六、浏览器端使用缓存

    CSS、JavaScript、Logo、图标这些静态资源文件更新的频率都比较低，而这些文件又几乎是每次HTTP请求都需要的，如果将这些文件缓存在浏览器中，可以极好地改善性能。
    用法：通过设置HTTP头中的Cache-Control和Expires属性，可设定浏览器缓存，缓存时间可以是数天，甚至是数月。
    七、服务器端使用压缩

    在服务器端对文件进行压缩，在浏览器对文件解压缩，可有效减少通信传输的数据量。文本文件的压缩率可达80%以上，因此HTML、CSS、JavaScript文件启用GZip压缩可达到较好的效果。但是压缩对服务器和浏览器产生一定的压力，在通信带宽良好，而服务器资源不足的情况下要权衡考虑。
    ```
    </details>
77. 请你谈谈对无状态的理解（react部分）
    <details>
    <summary>答案</summary>
    ```
    不依赖自身的状态state
    可以是类组件或者函数组件
    可以完全避免使用this关键字。由于使用的是箭头函数事件无需绑定
    有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件
    使用场景：组件不要管理state
    无状态组件指的是组件内部不维护state，只根据外部组件传入的props进行渲染的组件，当props改变时，组件重新渲染 有状态组件内部使用state，维护自身状态的变化，有状态组件根据外部组件传入的props和自身的state，进行渲染
    ```
    </details>
78. 如何理解事件委托
    <details>
    <summary>答案</summary>
    ```
    利用事件冒泡机制处理指定一个事件处理程序，来管理某一类型的所有事件。

    事件委托的好处
    利用冒泡的原理，将事件加到父级身上，触发执行效果，这样只在内存中开辟一块空间，既节省资源又减少DOM操作，提高性能
    可以为动态添加的元素绑定事件
    ```
    </details>
79. BFC是什么？触发BFC的条件是什么？有哪些应用场景
    <details>
    <summary>答案</summary>
    ```
    1.什么是BFC？
    W3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为"visiable"的块级盒子，都会为他们的内容创建新的BFC（Block Fromatting Context， 即块级格式上下文）。

    2.触发条件
    一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可： 下列方式会创建块格式化上下文：

    根元素()
    浮动元素（元素的 float 不是 none）
    绝对定位元素（元素的 position 为 absolute 或 fixed）
    行内块元素（元素的 display 为 inline-block）
    表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）
    表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）
    匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）
    overflow 值不为 visible 的块元素 -弹性元素（display为 flex 或 inline-flex元素的直接子元素）
    网格元素（display为 grid 或 inline-grid 元素的直接子元素） 等等。

    3.应用场景
    1. 防止浮动导致父元素高度塌陷
    2. 避免外边距折叠
    ```
    </details>
80. 说一下单向数据流有什么好处
    <details>
    <summary>答案</summary>
    ```
    *  1.React单项数据流是通过父组件给子组件传递props，由外到内单向的传递，但是子组件不能修改父组件传递进来的数据，这样能够保证数据的统一管理，防止子组件随意修改props数据，造成数据混乱；
    *  2.单向数据流动方向可以跟踪，流动单一，追查问题的时候跟踪方便快捷。
    *  3.view发出action后不在修改原有state，而是返回一个新的，可以保存state的历史记录，可以复原场景，容易测试；
    *  4.所有数据只有一份，组件数据只有唯一的入口和出口(父组件是组件数据唯一入口)，使得程序更直观更容易理解，有利于应用的可维护性；
    *  5.如果子组件需要改变父组件传递进来的props数据，可以通过callback回调函数传递给父组件，然后合并更新父组件的props，生成新的props，在传递到子组件里；
    *  6.一旦父组件传递的props状态发生改变，就会更新父子页面，因此子页面可以通过 PureComponent,shouldCompomentUpdate,Memo()；
    ```
    </details>
81. React怎么做数据检查和变化
    <details>
    <summary>答案</summary>
    ```
    - angular有脏检查机制，Vue通过Object.defineProporty来劫持对象的get、set方法，实现双向绑定

    - 相比较react而言，react是单向数据流动的UI渲染框架，本身不存在数据的检测这一机制，所有的数据改变都是通过setState来手动实现的

    - React本身不具备数据检查的功能(这个指向双向绑定的特点)，但是在遇到组件更新时会在shouldCommponentUpdate这个生命周期函数中进行数据检查相关操作(即本次更新是否返回新的状态)

    - React响应数据的变化主要是通过生成新的虚拟dom，再将其映射为真实的dom树构建完成来生成新的页面

    - React的数据是不可变的，通过this.setState或者Hook的setState，生成新的数据而不会去做数据检查

    - 新生成的数据，生成新的虚拟dom，与旧的虚拟dom通过diff算法进行对比，然后确定需要更新的部分
    ```
    </details>
82. 类数组转化为数组
    <details>
    <summary>答案</summary>
    ```
    1.ES6语法 Array.from(arr)
    2.用Array.prototype.slice.call(arr)方法转化为数组 或 [].slice.call(arr)
    3.用[...arr]方法转化为数组
    4.用Array.prototype.forEach.call(arr,callback)方法
    5.用Array.prototype.forEach.apply(arr,[callback])方法
    6.用Array.prototype.forEach.bind(arr,[callback])方法
    ```
    </details>
83. 说一下关于tree-shaking的原理
    <details>
    <summary>答案</summary>
    ```
    Tree-shaking的本质是消除无用的js代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为DCE（dead code elimination）。

    Tree-shaking 是 DCE 的一种新的实现，Javascript同传统的编程语言不同的是，javascript绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对javascript来说更有意义。

    ES6 module 特点：

    只能作为模块顶层的语句出现
    import 的模块名只能是字符串常量
    import binding 是 immutable的
    ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。

    所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6之前的模块化，比如我们可以动态require一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。

    这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。
    ```
    </details>
84. vue中的key有什么作用
    <details>
    <summary>答案</summary>
    ```
    key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。

    Vue 的 diff 过程可以概括为：

    oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会在新节点和旧节点会进行两两对比

    即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配.

    如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx > EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。


    所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速!

    更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。
    更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快
    ```
    </details>
85. 说一下vue的父组件和子组件生命周期钩子函数执行顺序
    <details>
    <summary>答案</summary>
    ```
    加载渲染过程
    父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted


    子组件更新过程
    父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated


    父组件更新过程
    父 beforeUpdate -> 父 updated


    销毁过程
    父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed
    ```
    </details>
86. 使用过vue ssr吗？说说ssr
    <details>
    <summary>答案</summary>
    ```
    - Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。

    即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染

    服务端渲染 SSR 的优缺点如下：

    （1）服务端渲染的优点：

    更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

    更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

    （2) 服务端渲染的缺点：

    更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；

    更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。

    ```
    </details>
87. 什么情况下出现浏览器分层（css部分）
    <details>
    <summary>答案</summary>
    ```
    ### 分层和合成
    通常页面的组成是十分复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，以及还有一些比较炫酷的3D动画效果。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种"牵一发而动全身"的绘制策略会严重影响页面的渲染效率。

    为了提升每帧的渲染效率，Chrome引入了分层和合成的机制

    你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应着一个图层，Chrome合成器最终将这些图层合成了用于显示页面的图片。如果你比较熟悉PS的话，就很好的理解这个过程，PS中一个项目是由很多图层构成的，每个图层都可以是一张单独的图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了

    在这个过程中，将素材分解为多个图层操作的就称之为分层，最后将这些图层合并在一起的操作就称为合成。所以，分成和合成通常是一起使用的

    考虑一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者渐变，这个时候合成器只需要将两个层进行相应的变化操作就可以，显卡处理这些操作驾轻就熟，所以合成时间非常短

    ### 生成层的方式
    在某些特定的条件下，浏览器会主动将渲染层提至合成层，那么影响这个合成因素有哪些？

    - 3D transforms:translate3d,translateZ等
    - video,canvas,iframe等
    - 通过Element.animate()实现的opacity动画转化
    - 通过CSS动画实现的opacity动画转换
    - position:fixed
    - will-change
    - filter
    - 有合成层后代同时本身overflow不为visible(如果本身是因为明确的定位因素产生的SelfPaintingLayer,则需要z-index不为auto)
    ```
    </details>
88. 说明下js继承的原理
    <details>
    <summary>答案</summary>
    ```
    1.继承是什么？
    顾名思义：一个对象上想拥有被继承对象的方法属性，就继承过来就好。

    在oop中，通过类的继承来实现代码的复用，通过实例化一个类可以创建许多对象，在js中继承是通过原型来实现的

    let use=function(name){
        this.name=name;
        this.getName=function(){
            console.log(this.name)
        }
    };
    let use1=new use('zf')
    let use2=new use('zf')
    console.log(use1.name === use2.name)
    console.log(use1.getName === use2.getName)
    在上述代码中，我们通过构造函数use，创建两个对象。实际上是通过复制构造函数use的原型对象来创建use1和use2.原型对象中有个constructor指向了use函数，实际上还是通过这个构造函数来创建对象。

    假如不用原型(更准确地说原型对象中没有用户定义地属性)，那么这两个对象就无法共享任何属性，对于这个例子来说，getName的逻辑都是一样的。不需要两份getName，所有的use对象其实可以共享这个getName方法。这个逻辑非常像java类中的静态函数，只不过静态函数只能够调用静态变量和静态方法。在js中，可以通过getName定义在原型中，以达到所有对象共享这个函数

    let user=function(name){
        this.name=name;
    };
    user.prototype.getName=function(){
        console.log(this.name)
    }
    user.prototype.color=new String('block');
    let user1=new user(new String('sunny'));
    let user2=new user(new String('sunny'));
    console.log(user1.name === user2.name);
    console.log(user1.getName === user2.getName);
    console.log(user1.color === user2.color);
    这里一目了然，在原型对象中定义的变量和方法能够被所有多个对象共享。原型的属性被对象共享，但是它不属于对象本身

    user1.hasOwnPrototype('name')//true
    user2.hasOwnPrototype('getName');//false
    这里需要注意的是：原型对象的属性不是实例对象自身的属性。只要修改原型对象，变化就会立刻体现在所有实例对象上。反之，如果对象的属性被修改，原型的对象中相同的属性并不会修改

    2.继承的实现原理
    从构造函数实例化说起，当你调用new时候，js实际上执行的是

    var obj=new Object();
    obj.__proto__=Foo.prototype;
    Foo.call(obj)
    当你执行时

    obj.getName
    先检查obj是否有getName属性。如果没有，它会查找Object.getPrototype(obj).getName，如果仍旧没有的话，继续查找Object.getPrototypeOf(Object.getPrototypeOf(obj)).getName

    实现一个继承：b继承于a

    function A(a){
        this.a=a;
    }
    A.prototype={
        a:null;
        //作为一种在隐藏类中的优化分配空间的考虑
        //如果a并不是在每个实例化都被初始化，那么这样做的话是有效果的。
        dosomething:function(){
            //..
        }
    }

    function B(a,b){
        A.call(this,a);
        this.b=b
    }
    B.prototype=Object.create(A.prototype,{
        b:{
            value:null,
            enumerable:true,
            configurable:true,
            writable:true,
        },
        dosomething:{
            value:function(){
                A.prototype.doSomething.apply(this,..arr)
                //...
            },
            enumerable:true,
            configurable:true,
            writable:true,
        }
    });
    B.prototype.constructor=B;

    var b =new B();
    b.dosomething()
    最重要的部分

    类型被定义在.prototype中
    用Object.create()来继承 Object.create()的实现原或者是ES5之前的版本polyfill
    if(typeof Object.create !== "function"){
        Object.create=function(proto,propertiesObject){
            if(typeof proto !== 'object' && typeof proto !=='function'){
                throw new Error('对象原型是一个对象'+proto)
            }else if(proto === null){
                throw new Error('对象的原型已经为null')
            }
            function F(){
                F.prototype=proto;
                return new F()
            }
        }
    }
    ```
    </details>
89. 说一下vue单页和多页的区别
    <details>
    <summary>答案</summary>
    ```
    定义
    SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用（一个html页面），一开始只需要加载一次js、css的相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。

    MPA多页面应用（MultiPage Application），指有多个独立页面的应用（多个html页面），每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。

    区别
    1.刷新方式

    SPA：相关组件切换，页面局部刷新或更改
    MPA：整页刷新
    2.路由模式

    SPA：可以使用hash，也可以使用history
    MPA：普通链接跳转
    3.用户体验

    SPA：页面片段间时间的切换快，用户体验良好，当初次加载文件过多时，需要做相关调优。
    MPA：页面切换加载缓慢，流畅度不够，用户体验比较差，尤其网速慢的时候
    4.转场动画

    SPA：容易实现转场动画
    MPA：无法实现转场动画
    5.数据传递

    SPA：容易实现数据传递，方法有很多（通过路由带参数传值，Vuex传值等等）
    MPA：依赖url传参，cookie，本地存储
    6.搜索引擎优化（SEO）

    SPA：需要单独方案，实现较为困难，不利于SEO检索，可利用服务器端渲染（SSR）优化
    MPA：实现方法容易
    7.使用范围

    SPA:高要求的体验度，追求界面流畅的应用
    MPA：适用于追求高度支持搜索引擎的应用
    8.开发成本

    SPA：较高，长需要借助专业的框架
    MPA：较低，但也页面代码重复的多
    9.维护成本

    SPA：相对容易
    MPA：相对复杂
    10.结构

    SPA：一个主页面+许多模块的组件
    MPA：许多完整的页面
    11.资源文件

    SPA：组件公用的资源只需要加载一次
    MPA：每个页面都需要自己加载公用的资源
    ```
    </details>
90. 说一下vue的$nextTick的原理
    <details>
    <summary>答案</summary>
    ```
    概念：
    nextTick就是一个异步方法。nextTick 方法主要是使用了宏任务和微任务（事件循环机制），定义了一个异步方法，多次调用 nextTick 会将方法存入 队列中，通过这个异步方法清空当前队列。 所以这个 nextTick 方法就是异步方法 。

    nextTick是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数。所有放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码；

    使用nextTick保证当前视图渲染完成。

    promise是浏览器内部自己实现的一个微任务，内部使用的不是setTimeout，详细请看面试题中的promise总结。

    nextTick中定义的三个重要变量：
    1.callbacks：用来存储所有需要执行的回调函数

    2.pending：用来标志是否正在执行回调函数

    3.timerFunc：用来触发执行回调函数

    nextTick的使用场景：
    1. 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。

    2.在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。

    nextTick和$nextTick区别
    1.nextTick(callback)：当数据发生变化，更新后执行回调。在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

    2.$nextTick(callback)：当dom发生变化，更新后执行的回调。将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。

    3.这两个方法没有太大的不同。区别在于：nextTick(callback) 是全局的方法；而 $nextTick(callback) 是回调的 this 自动绑定到调用它的实例上；所以用的更多的是$nextTick(callback)！

    原理：
    当调用nextTick方法时会传入两个参数，回调函数和执行回调函数的上下文环境，如果没有提供回调函数，那么将返回promise对象。首先将拿到的回调函数存放到数组中，判断是否正在执行回调函数，如果当前没有在pending的时候，就会执行timeFunc，多次执行nextTick只会执行一次timerFunc，timeFunc其实就是执行异步的方法，在timeFunc方法中选择一个异步方法（首先判断是否支持promise，如果支持就将flushCallbacks放在promise中异步执行，并且标记使用微任务。如果不支持promise就看是否支持MutationObserver方法，如果支持就new了一个MutationObserver类，创建一个文本节点进行监听，当数据发生变化了就会异步执行flushCallbacks方法。如果以上两个都不支持就看是否支持setImmediate方法，如果支持setImmediate 就去异步执行flushCallbacks方法。如果以上三种方法都不支持，就使用setTimeout），然后异步去执行flushCallbacks方法，flushCallbacks中就是将传递的函数依次执行。

    nextTick多次调用会维持一个数组，之后会异步的把数组中的方法以此执行，这样的话用户就会在视图更新之后再获取到真实的dom元素。
    ```
    </details>
91. v-model是如何实现的，语法糖实际是什么
    <details>
    <summary>答案</summary>
    ```
    #### 语法糖：
    指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。糖在不改变其所在位置的语法结构的前提下，实现了运行时的等价。可以简单理解为，加糖后的代码编译后跟加糖前一样,代码更简洁流畅，代码更语义自然.

    #### 实现
    - 1.作用在普通表单元素上
    动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message 设置为目标值

    - 2.作用在组件上
    在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件

    本质是一个父子组件通信的语法糖，通过prop和$.emit实现

    因此父组件v-model语法糖本质上可以修改为 ''

    在组件的实现中，我们是可以通过 v-model属性 来配置子组件接收的prop名称，以及派发的事件名称。
    ```
    </details>
92. 怎样理解vue的单向数据流
    <details>
    <summary>答案</summary>
    ```
    数据从父级组件传递给子组件，只能单向绑定。

    子组件内部不能直接修改从父级传递过来的数据。

    

    所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。


    这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。


    额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。


    这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。


    子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。
    ```
    </details>
93. react ssr实现过程
    <details>
    <summary>答案</summary>
    ```
    SSR是传统服务端渲染的一种方式，与之相关的是客户端渲染 CSR(Client Side Rendering)。客户端渲染是目前比较流行的页面渲染方式，只需请求少量的html代码，依赖浏览器解析执行JS代码来渲染页面。随着越来越多的前端框架如React、Vue的出现，对SSR有推进作用，现在的开发者更倾向于将其称之为"同构"，即客户端和服务端渲染的一个整合，页面的渲染在服务端完成，事件和交互的绑定在客户端完成

    基于Koa的React SSR实现过程
    实现流程如下：

    node server 接收客户端请求，得到当前的请求路径，服务端和客户端使用同一套路由规则，在路由配置表根据path匹配具体的组件，请求对应的数据，将数据通过props/context/store形式传入组件，利用React提供的服务端渲染api renderToString/renderToNodeStream将组件渲染为生成带有标记的html字符串或者数据流，在输出最终的html之前，把数据带入，服务端输出后，客户端就能得到组件数据，客户端利用ReactDOM渲染，根据服务端携带的标记更新React组件树，并附带事件响应。

    1.使用koa渲染一段最基本的服务端渲染
    渲染一段html
    在html中引入一个script表示执行客户端打包的文件
    const app=new Koa();
    const router=new Router();
    app.use(serve('./public'));

    router.get(["/","/about"],async ssr=>{
        //...
        ssr.body=`
            
            
                
                
                
            
            
                
    ${content}

                
            
            `
    })
    //...
    app.use(router.routes()).use(router.allowedMenthods());
    app.listen(3000,()=>{
        console.log('监听成功!')
    })
    2.打包客户端文件
    新建客户端的入口文件 index.js
    新建public下的APP.js用来同构
    配置webpack打包客户端的文件，打包生成bundle.js文件
    module.exports={
        mode:'development',
        entry:{
            index:path.join(__dirname,'../src/client/index.js')
        },
        output:{
            path:path.join(__dirname,'../dist/public')
            filename:'bundle.js'
        }
    }
    3.配置一个静态资源服务器
    使用koa-static
    配置到public文件夹
    安装koa-router避免全局中间件匹配导致koa-static失效
    4.配置服务端的打包
    注意target
    webpack-node-externals 避免打包 nodejs的api
    配置完成之后，打包客户端和服务端，然后再dist下启动项目，看到页面内容，完成客户端渲染
    5.真正的服务端渲染
    在服务端，引入的reate-dom/server的renderToString渲染app组件
    渲染完成后，放入id=root的div内容，实现服务器端渲染
    客户端改写render为hydrate，消除警告
    6.前后端路由绑定
    仿照react-router官网，在APP.js创建一个基本的路由
    直接运行会报错，因为服务器端没有dom，需要进行路由拆分
    拆分前端路由browRouter，后端路由staticRouter分别绑定
    定义一个 npm-run-all --parallel build:* 一键打包两端代码 路由绑定完成，接下来就要请求数据
    7.数据请求
    编写一个接口getData返回自定义数据
    客户端使用axios在componentDidMount中请求数据，但这只是客户端渲染
    1.使用server render的方法，让服务器端直接将数据绑定好
    使用react-router-config改写路由，使用renderRoutes渲染路由
    需要数据的组件提供loadData方法，后端使用matchRoutes匹配到对应的方法，直接执行即可
    后端执行请求后即可获得数据，然后将赋值到window对象就可以
    前端在componentsDidMount里面去获取数据就可以
    2.需要借助于redux进行多级路由的数据处理
    新建一个store/index.js
    定义一个reducer，initStore，并调用createStore创建store
    客户端和服务端分别提供createStore方法，获取对应端的数据
    在两端分别绑定Provider传入store即可
    在组件中通过mapStateToProps获取store中的数据进行渲染
    8.改写我们的后端数据请求
    在调用组件的loadData方法时，将store传入
    在loadData执行完成之后去触发store.dispatch去修改组件渲染
    在window中注入的对象改为store.getState()就可以
    在客户端createClientStore中需要引入store的默认项为window注入项即可
    9.路由切换时候的数据获取
    编写数据为空判断，如果是路由切换，使用ajax渲染即可
    ajax请求得到数据之后，调用mapDispatch方法修改store就可以重新渲染
    ```
    </details>
94. react ssr实现原理是什么，需要注意什么事项
    <details>
    <summary>答案</summary>
    ```
    核心原理
    服务端接收到客户端的请求路由后，查找对应的数据，以props、context、store的形式注入组件中，然后基于react提供的api:renderToString将组件转换为html字符串输出到客户端。客户端使用该数据进行渲染，保证数据的一致性 React SSR之所以能够实现，本质是虚拟dom的存在。判断环境是服务器环境，可以操作JS对象，把虚拟DOM映射成字符串输出。判断环境是客户端环境，可以操作JS对象，将虚拟DOM映射成真实DOM，完成页面挂载

    注意事项
    客户端需要使用ReactDOM.hydrate来渲染组件
    客户端路由和服务端路由的机制不同，需要在两个环境中配置路由。服务端路由需要解析url从而渲染对应的html字符串，而客户端可以自动匹配URL中的路由，将对应的组件渲染成DOM
    服务端执行环境没有window和document等宿主对象，并且执行组件的construct、componentWillReceiveProps、render生命周期，所以必须避免代码中的此类调用。可以通过typeof window或webpack.definePlugin来对客户端和服务端做区分
    服务端和客户端需要不同的webpack配置
    入口文件不一样
    服务端无需将第三方模块打包进源代码中，服务端渲染的代码，如果加载第三方模块，这些第三方模块是不需要被打包到最终的源码中，因为node环境下通过npm已经安装这些包，直接引用就好，不需要额外再打包到代码里。可以使用webpack-node-externals插件解决这个问题
    服务端需要配置:  target:node
    服务端的数据仓库store的隔离性
    数据的获取需要放在componentDidMount生命周期中执行，需要在服务端配置接口请求的代理
    hook的异步更新机制在服务端不适用
    store不能是单例，因为所有用户共享一个store
    服务端渲染的性能关键在于是否做好缓存，但要注意缓存，运用不当可能会引发内存泄漏以及数据的不一致性
    ```
    </details>
95. 子组件可以直接改变父组件的数据吗？说说你的理由（vue部分）
    <details>
    <summary>答案</summary>
    ```
    可以,但是不提倡，要是为了维护父子组件的单向数据流

    每次父组件发生更新时，子组件中所有的prop都将会刷新为最新的值

    如果这样做的话，Vue会在浏览器控制台中发出警告

    Vue提倡单向数据流，即父级props的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件的状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破环了单向数据流，当应用复杂情况时，debug的成本会非常高

    只有通过$emit派发一个自定义事件，父组件接收后，由父组件修改
    ```
    </details>
96. 能说下vue-router中常用的hash和history路由模式实现原理吗？
    <details>
    <summary>答案</summary>
    ```
    vue-router通过hash和HTML5的history API两种方式实现了前端路由。
    更新视图但不重新请求页面是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：
    • hash 这种方式是利用URL中的hash值（“#xxx“）
    • HTML5 history API（是HTML5提供对history栈中内容的操作 https://developer.mozilla.org/zh-CN/docs/Web/API/History）
    在vue-router中，提供mode来决定采用哪种方式。
    默认为hash，
    • 可以通过push将新路由添加到浏览器访问历史栈顶
    • 可以通过replace方法替换当前的路由
    若为history，
    • 可以通过back，forward，go等方法读取到浏览器历史记录栈的信息，并进行跳转操作
    • pushState（相当于hash模式的push），replaceState（相当于hash模式的replace）等方法还可以对浏览器历史记录栈进行修改
    • 监听popState（window.onpopstate）事件
    两种模式的区别：
    • pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可以修改#后面的部分，因此只能设置与当前同文档的URL
    • pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可以添加短字符串
    • history模式则会将URL修改得就和正常请求后端的URL一样,如后端没有配置对应/user/id的路由处理，则会返回404错误
    ```
    </details>
97. 实现数组去重
    <details>
    <summary>答案</summary>
    ```
    -1.双循环去重
    循环是比较笨拙的方法，它实现的原理很简单：先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组；因为它的时间复杂度是O(n^2)，如果数组长度很大，那么将会非常耗费内存.

    function unique(arr) {
        if (!Array.isArray(arr)) {
            console.log('type error!')
            return
        }
        let res = [arr[0]]
        for (let i = 1; i < arr.length; i++) {
            let flag = true
            for (let j = 0; j < res.length; j++) {
                if (arr[i] === res[j]) {
                    flag = false;
                    break
                }
            }
            if (flag) {
                res.push(arr[i])
            }
        }
        return res

    2、indexOf()去重
    数组的indexOf()方法可返回某个指定的元素在数组中首次出现的位置。该方法首先定义一个空数组res，然后调用indexOf方法对原来的数组进行遍历判断，如果元素不在res中，则将其push进res中，最后将res返回即可获得去重的数组.（判断新创建的数组中是否有a[i]，如果没有indexOf返回-1，并且把a[i]放入该新数组中）
    function unique(arr) {
        if (!Array.isArray(arr)) {
            console.log('type error!')
            return
        }
        let res = []
        for (let i = 0; i < arr.length; i++) {
            if (res.indexOf(arr[i]) === -1) {
                res.push(arr[i])
            }
        }
        return res
    }

    3、相邻元素去重
    这种方法首先调用了数组的排序方法sort()，然后根据排序后的结果进行遍历及相邻元素比对，如果相等则跳过改元素，直到遍历结束.
    function unique(arr) {
        if (!Array.isArray(arr)) {
            console.log('type error!')
            return
        }
        arr = arr.sort()
        let res = [arr[0]]
        for (let i = 1; i < arr.length; i++) {
            if (arr[i] !== arr[i-1]) {
                res.push(arr[i])
            }
        }
        return res
    }

    4、对象属性去重(推荐，因为只需要遍历一遍)

    创建空对象，遍历数组，将数组中的值设为对象的属性，并给该属性赋初始值1，每出现一次，对应的属性值增加1，这样，属性值对应的就是该元素出现的次数了.对象中，若无 arr[i]属性，则数组push，obj添加arr[i]属性
    function unique(arr) {
        if (!Array.isArray(arr)) {
            console.log('type error!')
            return
        }
        let res = [],
            obj = {}
        for (let i = 0; i < arr.length; i++) {
            if (!obj[arr[i]]) {
                res.push(arr[i])
                obj[arr[i]] = 1
            } else {
                obj[arr[i]]++
            }
        }
        return res
    }
    5、set与解构赋值去重(推荐，便利，快速)

    ES6中新增了数据类型set，set的一个最大的特点就是数据不重复。Set函数可以接受一个数组（或类数组对象）作为参数来初始化，利用该特性也能做到给数组去重.
    function unique(arr) {
        if (!Array.isArray(arr)) {
            console.log('type error!')
            return
        }
        return [...new Set(arr)]
    }
    6、set与Array.from(推荐，便利，快速)
    function unique(arr) {
        if (!Array.isArray(arr)) {
            console.log('type error!')
            return
        }
        return Array.from(new Set(arr))
    }
    ```
    </details>
98. 描述下js中的prototype的概念
    <details>
    <summary>答案</summary>
    ```
    ## Prototype
    在js中，prototype对象是实现面向对象的一个重要机制。每个函数就是一个对象，函数对象都有一个子对象prototype对象，类是以函数的形式来定义的。prototype表示该函数的原型，也表示一个类的成员的集合。 

    原型:每一个函数内部都具有一个prototype属性。构造函数创造的实例对象内部有一个内部属性[prototype],作为一个指针，指向构造函数原型所指的对象，所有的实例共享原型对象上的属性和方法

    原型是js中非常重要的概念，换句话说，原型是js语言的一个特征。js中任何对象都有原型，函数对象有原型(函数充当构造函数时原型会起作用)，普通的object也有原型，原型是一个object,他也有原型，这就构成了一个原型链，直到Object.prototype。Object.prototype的原型是null。

    读取对象的某个属性时，JS引擎先寻找对象本身的属性，如果找不到就到它的原型去找，如果还是找不到，那就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，就会返回undefined。如果对象自身和它的原型，都定义了同名属性，那么优先读取到对象自身的属性，这叫做覆盖。
    ```
    </details>
99. 实现数组扁平化
    <details>
    <summary>答案</summary>
    ```
    1. es6的Generator函数 （无视数据类型）
    function *flatten(arr) {
        for (const item of arr) {
            if(Array.isArray(item)) {
                yield *flatten(item)
            } else {
                yield item
            }
        }
    }
    const newArr = [...flatten([1, true, {isNewHero: true, name: '阿古朵'}, [2, {name: ['韩信', '赵云']}, [3]]])]
    2. join + split (只对数字类型的数组有效)
    [1, 2, 3, [4, 5, [6]]].join(',').split(',').map(item => parseInt(item))
    3. toString + split (只对数字类型的数组有效)
    [1, 2, 3, [4, 5, [6]]].toString().split(',').map(item => parseInt(item))
    4. reduce + concat (无视数据类型)
    function flatten(arr) {
        return arr.reduce((result, item) => {
            return result.concat(Array.isArray(item) ? flatten(item) : item);
        }, []);
    }
    5. 数组falt()方法 (可以指定深度，默认深度为1，传Infinity表示彻底扁平化)(无视数据类型)
    [1, 2, 3, [4, 5, [6]]].falt(Infinity)
    6. forEach+isArray+push (深度可控，无视数组类型)
    const eachFlat = (arr = [], depth = 1) => {
        const result = []; // 缓存递归结果
        (function flat(arr, depth) {
            // forEach会自动去除数组空位
            arr.forEach((item) => {
                // 控制递归深度
                if (Array.isArray(item) && depth > 0) {
                    // 递归数组
                    falt(item, depth-1)
                } else {
                    // 缓存数据
                    result.push(item)
                }
            })
        })(arr, depth)
        // 返回递归结果
        return result;
    }
    console.log(eachFlat([{id:'123'}, true, 3, [4, 5, [6]]], Infinity))
    ```
    </details>
100. react事件绑定原理是什么
    <details>
    <summary>答案</summary>
    ```
    React并不是将click事件绑在该div的真实DOM，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂在销毁时统一订阅和移除事件

    另外冒泡到document上的事件也不是原生浏览器事件，而是React自己实现的合成事件。因此我们如果不想要事件冒泡的话，调用event.stopPropagation是无效的，而应该调用event.preventDefault进行阻止
    ```
    </details>
101. 为什么不建议使用通配符初始化css样式
    <details>
    <summary>答案</summary>
    ```
    第一方面： 通配符为通用选择，会影响页面的性能，导致页面的加载速度减慢。 第二方面： 回影响css样式的展示，因为通配符的权重是0，而默认不设置时时的权重是null。 导致没有设置选择器样式的标签不能正常继承父类的样式。

    参考答案
    采用*{pading:0;margin:0;}这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。出于性能的考虑，并不是所有标签都会有 padding 和 margin，因此对常见的具有默认 padding和 margin 的元素初始化即可，并不需使用通配符*来初始化。

    综合答案： 
    第一方面：
    影响网站的性能，虽然写起来很简单，但是通配符会把所有的标签都遍历一遍，当网站较大，样式比较多的
    时候，这样写就大大的加强了网站运行的负载，会使网站加载时间延长。因此一般大型的网站都有分层次的一套初始化样式。再有一种情况就是，*{padding:0;margin:0} , 并不是所有的标签都会有padding和margin，因此对于常见的具有padding和margin属性的标签进行样式初始化就可以了，没有必要使用通配符选中所有的标签进行样式的初始化。
    第二方面： 
    由于权重问题，会影响其他没有选择器设置样式的标签继承来自父类的样式。因为通配符*的权重是0，而默认情况为null,权重0 > null。 例如： 
   设置了div{color:"red"} 因为没有设置span的样式，他会继承父元素的样式，会呈现red,但是如果*{color:"green"},那么最终span的颜色为green。
    ```
    </details>
102. 说一下koa2和express区别
    <details>
    <summary>答案</summary>
    ```
    #### Koa
    - 基于node的一个web开发框架，利用co作为底层运行框架，利用Generator的特性，实现“无回调”的异步处理；
    - ES7;
    - 更小、更富有表现力、更健壮的基石；
    - 利用async函数、Koa丢弃回调函数，增强错误处理；
    - 很小的体积，因为没有捆绑任何中间件；
    - 类似堆栈的方式组织和执行；
    - 低级中间件层中提供高级“语法糖”，提高了互操性、稳健性；
    #### Express
    - Node的基础框架，基础Connect中间件，自身封装了路由、视图处理等功能；
    - 线性逻辑，路由和中间件完美融合，清晰明了；
    - 弊端是callback回调方式，不可组合、异常不可捕获；
    - ES5;
    - connect的执行流程： connect的中间件模型是线性的，即一个一个往下执行；

    #### 区别

    - Handler的处理

    Express普通回调函数，在同一线程上完成当前进程的所有Http请求；

    Koa利用Generator Function作为响应器，co作为底层运行框架，利用Generator特性，实现“协程响应”；

    - 路由

    Express的路由是自身集成的； Koa的需要引入中间件Koa-router；

    - 启动方式

    koa采用new Koa()
    express采用传统的函数形式function； 

    - 回调

    Koa没有回调
    express有回调； 

    - Http Request

    koa1使用this取代Express的req、res；

    - Context

    Koa新增了一个Context对象，用来代替Express的Request和Response，作为请求的上下文对象。 
    还有Node原生提供的req、res、socket等对象； 

    - 生命周期

    Express的生命周期不确定：express内部执行异步函数，不能确定什么时候执行完； 
    Koa确定：koa是基于await/async，在执行下一步操作的时候，必须等待前端await执行完； 

    - 异步流程

    Express采用callback来处理异步(ES5)；
    Koa1采用generator(ES6)；
    Koa2采用async/await(ES7)；

    - 错误处理

    Express使用callback捕获异常，深层次的异常捕获不了；
    Koa使用try catch，很好的解决异常捕获；

    - 中间件

    koa2的中间件：
            
    1、通过async await实现的，中间件执行的顺序是“洋葱圈”模型。

    2、中间件之间通过next函数联系，当一个中间件调用next()后，会将控制权交给下一个中间件，直到下一个中间件不再执行next()后，
    会沿路返回，将控制权交给前一个中间件。

    Express中间件：

    1、一个接一个顺序执行，response响应写在最后一个中间件中。

    2、特点：

    a.app.use用来注册中间件；

    b.遇到http请求，根据path和method判断触发哪些中间件；

    c.实现next机制，即上一个中间件会通过next触发下一个中间件；
    ```
    </details>
103. link标签定义
    <details>
    <summary>答案</summary>
    ```
    > 定义文档与外部资源的关系

    **特征：**
    1. link 元素是空元素，它仅包含属性
    2. 此元素只能存在于 head 部分，不过它可出现任何次数。

    **常见属性：**
    1. href: 目标文档或资源的 URL。
    2. rel: 定义当前文档与目标文档之间的关系。
    3. type: 规定目标 URL 的 MIME 类型。
    2. charset: 定义目标 URL 的字符编码方式。
    4. media: 规定文档将显示在什么设备上。

    **rel 常用取值：**   
    ` stylesheet、icon、preload、alternate、author、canonical、dns-prefetch、external、help、licence、manifest、modulepreload、next、pingback、prefetch、prev、search、shortlink、sidebar、tag`
    ```
    </details>
104. 渲染过程中遇到js文件怎么处理（浏览器解析过程）
    <details>
    <summary>答案</summary>
    ```
    JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。

    也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。

    JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。

    原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。

    这是什么情况？

    这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。前面我们介绍，不完整的CSSOM是无法使用的，但JavaScript中想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。
    ```
    </details>
105. Object.is()与原来的比较操作符"==="、"=="的区别
    <details>
    <summary>答案</summary>
    ```
    Object.is() 方法判断两个值是否为同一个值。如果满足以下条件则两个值相等:

    - 都是 undefined
    - 都是 null
    - 都是 true 或 false
    - 都是相同长度的字符串且相同字符按相同顺序排列
    - 都是相同对象（意味着每个对象有同一个引用）
    - 都是数字且
    - 都是 +0
    - 都是 -0
    - 都是 NaN
    - 或都是非零而且非 NaN 且为同一个值

    与== 运算不同。  == 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 "" == false 判断为 true), 而 Object.is不会强制转换两边的值。

    与=== 运算也不相同。 === 运算符 (也包括 == 运算符) 将数字 -0 和 +0 视为相等 ，而将Number.NaN 与NaN视为不相等.
    ```
    </details>
106. 三种事件模型是什么
    <details>
    <summary>答案</summary>
    ```
    事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。

    DOM0 级事件模型 第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。

    IE事件模型 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。

    DOM2 级事件模型 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。
    ```
    </details>
107. doctype的作用是什么
    <details>
    <summary>答案</summary>
    ```
    Doctype可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。

    　　由于历史的原因，浏览器对页面的渲染方式是不一样的。在W3C标准出来之前，浏览器对页面的渲染没有同一的标准，产生了差异，quirks mod（混杂模式或者兼容模式），但在W3C标准出台之后，浏览器对页面的渲染有了同一的标准即（严格模式或标准模式）。但是为了保证以前就得页面仍然正常显示，有的浏览器就保存了这两种渲染模式（标准兼容模式）。那么究竟采用哪一种方式进行渲染，就要看DOCTYPE生命中的DTD。　　

    1、文档类型定义（DTD）Document Type Definition
    　　是一套为了进行程序间的数据交换而建立的关于标记符的语法规则。
    　　可通过比较文档和文档类型定义文件来检查文档是否符合规范，元素和标签使用是否正确。

    2、两种呈现模式：标准模式和混杂模式
    　　在标准模式中，浏览器以其支持的最高标准呈现页面；
    　　在混杂模式中，页面以一种比较宽松的向后兼容(兼容老的版本)的方式显示。混杂模式通常模拟老式浏览器的行为以防止老站点无法工作。

    3、模式触发
    　　浏览器根据DOCTYPE是否存在以及使用的哪种DTD来选择要使用的呈现方法。
    　　 如果XHTML、HTML 4.01文档包含形式完整的DOCTYPE，那么它一般以标准模式呈现。
    　　包含过渡DTD和URI的DOCTYPE也导致页面以标准模式呈现，但是有过渡DTD而没有URI会导致页面以混杂模式呈现。
    　　DOCTYPE不存在或形式不正确会导致HTML和XHTML文档以混杂模式呈现。

    

    html5既然没有DTD，也就没有严格模式与宽松模式的区别，html5有相对宽松的语法，事实上，已经尽可能大的实现了向后兼容。
    ```
    </details>
108. iframe有哪些缺点
    <details>
    <summary>答案</summary>
    ```
    ⒈iframe会阻塞主页面的Onload事件；

    ⒉iframe和主页面共享链接池，而浏览器对相同城的链接有限制，所以会影响页面的并行加载；

    ⒊使用iframe之前需要考虑这两个缺点，如果需要使用iframe，最好是通过JavaScript；

    ⒋动态给iframe添加src属性值，这样可以可以绕开以上两个问题

    ⒌不利于seo

    ⒍代码复杂，无法一下被搜索引擎索引到

    ⒎iframe框架页面会增加服务器的http请求，对于大型网站不可取

    ⒏很多的移动设备无法完全显示框架，设备兼容性差
    ```
    </details>
109. 说说你对浏览器的理解
    <details>
    <summary>答案</summary>
    ```
    浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。

    HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。

    但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。简单来说浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。从Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分
    ```
    </details>
110. 谈谈你对ajax的理解
    <details>
    <summary>答案</summary>
    ```
    AJAX全称为“Asynchronous JavaScript And XML”（异步JavaScript和XML） 是指一种创建交互式网页应用的开发技术、改善用户体验，实现无刷新效果。

    优点

    a、不需要插件支持

    b、优秀的用户体验

    c、提高Web程序的性能

    d、减轻服务器和带宽的负担

    缺点

    a、浏览器对XMLHttpRequest对象的支持度不足，几乎所有浏览器现在都支持

    b、破坏浏览器“前进”、“后退”按钮的正常功能，可以通过简单的插件弥补

    c、对搜索引擎的支持不足
    ```
    </details>
111. 简单介绍使用图片base64编码的优点和缺点
    <details>
    <summary>答案</summary>
    ```
    1. 优点

    （1）base64格式的图片是文本格式，占用内存小，转换后的大小比例大概为1/3，降低了资源服务器的消耗；

    （2）网页中使用base64格式的图片时，不用再请求服务器调用图片资源，减少了服务器访问次数。

    （3）base64编码的字符串，更适合不同平台、不同语言的传输；

    （4）算法是编码, 不是压缩, 编码后只会增加字节数，但是算法简单, 几乎不会影响效率，算法可逆, 解码很方便, 不用于私密信息通信;

    （5）解码方便, 但毕竟编码了, 肉眼还是不能直接看出原始内容;

    2. 缺点

    （1）base64格式的文本内容较多，存储在数据库中增大了数据库服务器的压力；

    （2）网页加载图片虽然不用访问服务器了，但因为base64格式的内容太多，所以加载网页的速度会降低，可能会影响用户的体验。

    （3）base64无法缓存，要缓存只能缓存包含base64的文件，比如js或者css，这比直接缓存图片要差很多，而且一般HTML改动比较频繁，所以等同于得不到缓存效益。
    ```
    </details>
112. 请说出目前主流的js模块化实现的技术有哪些？他们的区别在哪
    <details>
    <summary>答案</summary>
    ```
    CommonJS
    CommonJS的出发点:js没有完善的模块系统，标准库较少，缺少包管理工具。伴随着NodeJS的兴起，能让JS在任何地方运行，特别是服务端，也达到了具备开发大型项目的能力，所以CommonJS营运而生

    NodeJS是CommonJS规范的主要实践者，有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际上使用时，用module.exports定义当前模块对外输出的接口，用require加载模块

    commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，由于网络原因限制，更合理的方法是使用异步加载。



    暴露模块：module.exports=value或exports.xxx=value




    引入模块：require(xxx)





    CommonJS规范



    一个文件就是一个模块，拥有单独的作用域

    普通方式定义的变量、函数、对象都属于该模块内容

    通过require来加载模块

    通过exports和module.exports来暴露块中的内容


    2.注意事项

    当exports和module.exports同时存在，module.exports会覆盖exports

    当模块内全是exports时，就等同于module.exports

    exports就是module.exports的子集

    所有代码都运行在模块作用域，不会污染全局作用域

    模块可以多次加载，但只会在第一次加载时运行时结果就会被缓存，以后再加载的时候就直接读取缓存结果

    模块加载顺序，按照代码出现的顺序同步加载

    __dirname代表当前文件所在的文件夹路径

    __filename代表当前模块文件所在的文件夹路径+文件名

    ES6模块化
    ES6在语言标准的层面上，实现了模块功能，而且实现的相当简单，主要为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能

    其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号，这类似AMD的引用写法

    ES6的模块不是对象，import命令会被JS引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因此，是的静态分析成为可能




    export export可以导出的是一个对象中包含的多个属性、方法。export default只能导出一个可以不具名的函数，我们可以通过import进行引用





    import



    import {fn} from './xxx'  export导出的方式

    import fn from './xxx' export default导出的方式
    AMD
    Asynchronous Module Definition，异步加载模块。它是一个在浏览器端模块化开发的规范，不是原生js的规范，使用AMD规范进行页面开发需要用到对应的函数库，RequireJS

    AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行

    使用require.js实现AMD规范的模块化:用require.config()指定引用路径等，用define()定义模块，用require()加载模块

    //定义模块
    define('moduleName',['a','b'],function(a,b){
        return someExportValue
    })
    //引入模块
    require(['a','b'],function(a,b){
        //执行代码逻辑
    })



    Require JS主要解决的问题



    文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器

    js加载的时候浏览器会停止页面渲染，加载文件愈多，页面相应事件就越长

    异步前置加载




    语法 define(id,dependencies,factory)



    id:可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名(去掉扩展名)

    dependencies是一个当前模块用来的模块名称数组

    factory工厂方法，模块初始化要执行的函数或对象，如果为函数，应该只被执行一次，如果是对象，此对象应该为模块的输出值
    CMD
    CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD推崇依赖前置，提前执行，CMD推崇依赖就近，延迟执行。此规范其实是在sea.js推广过程中产生的。

    因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id；CMD推崇依赖就近，所以一般不在define的参数中写依赖，而是在factory中写

    define(id,deps,factory) ---- factory有三个参数:function(require,exports,module){}

    require是factory函数的第一个参数，require是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口

    exports是一个对象，用来向外提供模块接口

    module是一个对象，上面存储了与当前模块相关联的一些属性和方法

    //定义没有依赖的模块
    define(function(require,exports,module){
        export.xxx=val
        module.exports=val
    })
    //定义有依赖的模块
    define(function(require,exports,module){
        //同步引入模块
        var module1=reuqire('./module1.js')
        //异步引入模块
        require.async('./module2.js',function(val){
            //代码逻辑
        })
        exports.xxx=value 
    })
    //引入模块
    define(function(require){
        const val1=require('./module1.js')
        val1.show()
    })
    UMD通用模块规范
    一种整合CommonJS和AMD规范的方法，希望能解决跨平台模块方案

    运行原理



    UMD先判断是否支持NodeJS的模块(exports)是否存在，存在就是用nodejs模块模式，




    在判断是否支持AMD(define是否存在)，存在则使用AMD方式加载



    (function (window,factory){
        if(typeof exports === 'Object'{
            module.exports=factory();
        }else if(typeof define === 'function' && define.amd){
            define(factory);
        }else{
            window.eventUtil=factory()
        })
    })(this,function(){
        //执行代码
    })
    总结
    CommonJS是同步加载的。主要是在nodejs也就是服务端应用的模块化机制，通过module.export导出声明，通过require()加载。每一个文件都是一个模块。它有自己的作用域，文件内的变量，属性函数等不能被外界访问。node会将模块缓存，第二次加载会直接在缓存中获取

    AMD是异步加载的。主要应用在浏览器环境下。requireJS是遵循AMD规范化的模块化工具。它是通过rdefine()定义声明，通过
    require([‘a’,‘b’],function(a,b){})加载

    ES6的模块的运行机制与Common不一样，js引擎对脚本静态分析的时候，遇到模块加载指令后会生成一个只读引用，等到脚本真正执行的时候才会通过去模块中获取值，在引用到执行的过程中模块中的值发生了变化，导入的这里也会跟着变化，ES6模块是动态引用，并不会缓存值，模块里总是绑定其所在的模块。
    ```
    </details>
113. for in和Object.keys的区别
    <details>
    <summary>答案</summary>
    ```
    ####for in
    遍历对象及其原型链上可枚举的属性；

    如果用于遍历数组，处理遍历其元素外，还会遍历开发者对数组对象自定义的可枚举属性及其原型链上的可枚举属性；

    遍历对象返回的属性名和遍历数组返回的索引都是 string 类型；

    某些情况下，可能按随机顺序遍历数组元素

    ####Object.keys


    返回对象自身可枚举属性组成的数组

    不会遍历对象原型链上的属性以及 Symbol 属性

    对数组的遍历顺序和 for in 一致
    for of

    ES6中添加的循环语法；

    for of支持遍历数组、类对象（例如DOM NodeList对象）、字符串、Map对象、Set对象；

    for of不支持遍历普通对象，可通过与Object.keys()搭配使用遍历；（见示例二）

    for of遍历后的输出结果为数组元素的值；

    搭配实例方法entries()，同时输出数组内容和索引；（见示例三）

    ```
    </details>
114. 哪些操作会造成内存泄漏
    <details>
    <summary>答案</summary>
    ```
    1、闭包引起的内存泄漏；
    2、意外的全局变量引起的内存泄漏；
    3、没有清理的DOM元素引起的内存泄漏；
    4、被遗忘的定时器或者回调函数；
    5、子元素存在引用引起的内存泄漏；
    ```
    </details>
115. 什么是浏览器的同源策略
    <details>
    <summary>答案</summary>
    ```
    一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。同源政策主要限制了三个方面:

    第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。

    第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM 。

    第三个是当前域下 ajax 无法发送跨域请求。

    同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

    ```
    </details>
116. 说一下你理解的margin重叠的问题
    <details>
    <summary>答案</summary>
    ```
    一、相邻元素margin重叠
    二、父元素和子元素之间margin重叠

    1.父元素与子元素margin-top重叠

    2.父元素与子元素margin-bottom重叠

    对于margin-top重叠：

    1.让父元素变成非块状格式化上下文元素（即非BFC）：在父元素中加“overflow:hidden;”

    2.给父元素添加border属性：例如1px solid red；

    3.在父元素中添加padding-top；

    4.在父元素和子元素之间添加空格文字图片等；

    3.关于margin值的计算：


    （1）如果两个margin都是正值，那么取margin值最大那个，例如父元素设置margin-top为20px，而子元素也设置了margin-top为50px，那么最终是以子元素的margin-top为准；

    （2）如果两个margin值为一正一负，则最终的margin值以这两个margin值相加的结果为准；

    （3）如果两个margin值都为负数，则取这两个负margin值中绝对值最大的那个负margin值为准；
    ```
    </details>
117. display、position和float的相互关系
    <details>
    <summary>答案</summary>
    ```
    三个属性
    display属性规定元素生成框的类型。较为常见的有none-缺省值（用于隐藏元素，元素会消失于视界和文档流中），block-块级元素，inline-block-行内块级元素，list-item列表样式块级元素……….（display种类很多，可查阅资料http://www.w3school.com.cn/cssref/pr_class_display.asp）

    position属性规定元素的定位类型，常用于布局。static-默认值，元素出现在正常文档流中（此时不受top、left、right、bottom、z-index等属性影响）；absolute-绝对定位，脱离文档流，相对于它第一个非static父元素进行定；fixed-固定定位，脱离文档流，相对于浏览器窗口进行定位；relative生成相对定位的元素，没有脱离文档流，相对于其正常文档流中的位置进行定位。

    float属性，定义一个元素浮动方向，最初用于图像使文本环绕，现在是一种布局方式。不论浮动元素本身是何种框类型，浮动后会生成一个块级框。

    三个属性的关系
    如果display的值为none，那么后两者就不会产生作用，也不会有任何的盒子产生；
    除此之外，如果元素为absolute或者fixed定位，那么float的属性值相当于‘none’，display的属性如下面的表格所示。 盒的位置根据“top”，“right”，“bottom”和“left”属性与盒的包含块决定。
    如果float属性的值为不是none，那么元素将会浮动，元素的display属性将如下表所示；
    如果元素是根元素，那么元素的属性如下表所示；否则元素的display属性则根据设定来取值。
    ```
    </details>
118. 前端需要注意哪些seo
    <details>
    <summary>答案</summary>
    ```
    (1)合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。

    (2)语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。

    (3)重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。

    (4)重要内容不要用 js 输出：爬虫不会执行 js 获取内容

    (5)少用 iframe：搜索引擎不会抓取 iframe 中的内容

    (6)非装饰性图片必须加 alt

    (7)提高网站速度：网站速度是搜索引擎排序的一个重要指标

    (8)格应该使用caption表格标题标签

    (9)img标签应使用 “alt” 属性加以说明

    (10)
    + 1、strong、em标签 : 需要强调时使用。strong标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容，em标签强调效果仅次于strong标签。
    　　　 + 2、 b、i标签: 只是用于显示效果时使用，在SEO中不会起任何效果。

    (11)文本缩进不要使用特殊符号   应当使用CSS进行设置。版权符号不要使用特殊符号 © 可以直接使用输入法，拼“banquan”，选择序号5就能打出版权符号©。

    (12)巧妙利用CSS布局，将重要内容的HTML代码放在最前面，最前面的内容被认为是最重要的，优先让“蜘蛛”读取，进行内容关键词抓取。

    (13)文本缩进不要使用特殊符号   应当使用CSS进行设置。版权符号不要使用特殊符号 & copy; 可以直接使用输入法，拼“banquan”，选择序号5就能打出版权符号©。

    (14)尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容

    (15)谨慎使用 display：none ：对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。因为搜索引擎会过滤掉display:none其中的内容。

    (16)不断精简代码

    (17)js代码如果是操作DOM操作，应尽量放在body结束标签之前，html代码之后。
    ```
    </details>
119. 说一下html布局元素的分类有哪些？以描述下每种布局元素的应用场景
    <details>
    <summary>答案</summary>
    ```
    1.内联元素
    span i em a strong br input textarea
    display: inline;
    和其他的内联元素在同一行从左到右排列，不可以直接操作宽高以及相关的css属性，可以设置内外边距的左右值，（marign，padding的左右值）；
    宽高由自身的内容的宽高决定（文本，图片）；
    只能容纳行内元素，不能嵌套块级元素

    2.块级元素
    h1-h6,div,ul,ol,dl,li,table,li,form
    display:block;
    独占一行，每个元素会从新的一行开始，可以直接设置宽高以及相关css属性；
    在不设置宽的情况下，宽度等于父元素的宽度；
    在不设置高度的情况下，高度等于内容的高度

    3.行内块级元素
    综合了前两种的情况又各有取舍
    display：inline-block
    不自动换行
    能够识别宽高，padding，lineheight，margin
    默认排列方式为从左到右

    应用场景：
    内联元素：用于不指定宽高，有内容撑起宽高，不占满一行
    块状元素：用于指定宽高，沾满一行
    内联块级元素：用于指定宽高，不占满一行
    ```
    </details>
120. 网页验证码是干嘛的，是为了解决什么安全问题
    <details>
    <summary>答案</summary>
    ```
    区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水

    有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试
    ```
    </details>
121. 简单说下v8引擎的垃圾回收机制
    <details>
    <summary>答案</summary>
    ```
    v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

    新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步:

    首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。
    如果对象不存活，则释放对象的空间。
    最后将 From 空间和 To 空间角色进行交换。
    新生代对象晋升到老生代有两个条件：

    第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

    第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。

    老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。

    由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。
    ```
    </details>
122. 说一说对json的理解
    <details>
    <summary>答案</summary>
    ```
    JavaScript Object Notation
    JSON所谓的基于文本，也就是说它仅仅依靠文本来表示，不像Http协议，什么超文本、又有音频视频等，所以JSON是一种轻量级的数据。

    独立于语言：JSON数据是跨平台的，通用的，不是说只可以在JavaScript中解析，它可以在任意支持的语言上解析，如Java、C#等等。

    JSON的两种结构：对象和数组

    1、JSON对象：以“{”开始，以“}”结束，里面则是一系列的键（key）值（value）对，键和值用“:”分开，每对键值对之间用“,”分开。参考以下语法结构：

    {key1:value1,key2:value2,key3:value3...}
    其中键（key）是字符串，而值（value）可以是字符串，数值，true,false,null,对象或数组，也就是说某个键（key）的值（value）可以是一个数组，数组里面又是一些JSON对象，这种表示稍微复杂一些，但是参照这些理解可以很容易分辨出来。

    2、JSON数组：以”[”开始，”]”结束，如同程序语言一样，例如C#，Button[] btnArray,则BtnArray是一个Button类型的数组，里面就存放Button类型的对象，那么JSON数组也一样，里面存放的也是JSON对象，参考下面语法结构：

    [{key1:value1,key2:value2},{key3:value3,key4:value4},{key5:value5,key6:value6},{key7:value7,key8:value8}]
    这里就有4个JSON对象，对象与对象之间用“,”分开。

    JSON字符串与JSON对象：

    JSON字符串，就是要满足JSON格式要求的字符串，

    例如：String str = "{"StudentID":100,"Name":"Me","Hometown":"China"}";
    JSON对象，指符合json格式要求的对象，

    例如C#中 JObject json = JObject.Parse("{"StudentID":100,"Name":"Me","Hometown":"China"}");
    ```
    </details>
123. 渲染页面是常见的不良现象有哪些（浏览器渲染过程）
    <details>
    <summary>答案</summary>
    ```
    渲染过程中遇到JS文件怎么处理
    Javascript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。也就是说，如果你想首屏渲染的快，就越不应该再首屏加载JS文件，这也是都建意将script标签放在body标签底部的原因。当然在当下，并不是说script标签必须放在底部，因为你可以给script标签加defer或者async属性。

    JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。

    原本DOM和CSSOM的构建是互不影响的，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再回复DOM构建。这是因为JavaScript不只是可以改变DOM，它还可以改变样式，也就是说它可以更改CSSOM。前面我们介绍，不完整的CSSOM是无法使用的，但JavaScript中想访问CSSOM并更改它，那么再执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。

    你真的了解回流和重绘吗


    重绘:当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如background-color。

    回流:当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建


    async和defer的作用是什么有什么区别


    情况1 <script src="script.js"></script>

    没有defer或async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行

    情况2 <script async src="script.js"></script>(异步下载)

    asnyc属性表示异步执行引入的JavaScript，与defer的区别在于，如果已经加载好，就会开始执行–无论此刻时HTML解析阶段还是DOMContentLoaded触发之后。需要注意的时，这种方式加载的JavaScript依然会阻塞load时间。换句话说，async-script可能在DOMContentLoaded触发之前或之后执行，但一定在load触发之前执行。

    情况3 <script defer src="script.js"></script>(延迟执行)

    defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。

    defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。

    在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。


    为什么操作DOM慢

    因为DOM是属于渲染引擎中的东西，而js又是js引擎中的东西。当我们通过js操作DOM的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作DOM次数一多，也就等同于一直在进行线程之间的通信，并且操作DOM可能还会带来重绘回流的情况，所以也就导致了性能上的问题。

    渲染页面时常见哪些不良现象？
    由于浏览器的渲染机制不同，在渲染页面时会出现两种常见的不良现象----白屏问题和FOUS（无样式内容闪烁）

    FOUC：由于浏览器渲染机制（比如firefox），再CSS加载之前，先呈现了HTML，就会导致展示出无样式内容，然后样式突然呈现的现象；

    白屏：有些浏览器渲染机制（比如chrome）要先构建DOM树和CSSOM树，构建完成后再进行渲染，如果CSS部分放在HTML尾部，由于CSS未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把js文件放在头部，脚本会阻塞后面内容的呈现，脚本会阻塞其后组件的下载，出现白屏问题。
    ```
    </details>
124. componentWillReceiveProps的触发条件是什么
    <details>
    <summary>答案</summary>
    ```
    componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。这个东西十分好用，但是一旦用错也会造成十分严重的后果。

    在componentWillReceiveProps这个回调函数中，我们可以获取到就是props，通过this.props来获取，然后新的props则是通过函数的参数传入，在这里我们可以比较两个props从而对本组件的state作出安全的变更然后重新渲染我们的组件或者是触发子组件内的某些方法。


    ```
    </details>
125. javascript代码中的“use strict”是什么意思？为什么使用它
    <details>
    <summary>答案</summary>
    ```
    use strict”：严格模式
    为什么使用严格模式？


    消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;

    消除代码运行的一些不安全之处，保证代码运行的安全；

    提高编译器效率，增加运行速度；

    为未来新版本的Javascript做好铺垫。
    ```
    </details>
126. 什么是polyfill
    <details>
    <summary>答案</summary>
    ```
    Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。

    比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。

    一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API
    ```
    </details>
127. 说一下vue的什么周期以及每个阶段做的事情
    <details>
    <summary>答案</summary>
    ```
    beforeCreate(创建前) 在数据观测和初始化事件还没有开始

    created(创建后) 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来

    beforeMounted(挂载前)在挂载开始之前被调用，相关的render函数首次被调用。实例已完成下面的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上

    mounted(挂载后)在el被新创建的vm.$el替换，并挂载到实例上去之后调用。实例已经完成下面的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中，此过程中可进行ajax交互

    beforeUpdate(更新前)在数据更新之前调用，发生在虚拟dom重新渲染和打补丁之前。可以在该钩子中进一步更改状态，不会触发重复渲染过程

    update(更新后)在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件dom已经更新，所以可以执行依赖于dom操作。但是在大多数情况下，在此期间避免更改状态，因为这可能会导致更新无法循环。此钩子在服务端渲染期间不被调用

    beforeDestroy(销毁前) 在实例销毁之前调用。实例仍然完全可以用。

    destroyed(销毁后) 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。此钩子在服务端渲染期间不被调用
    ```
    </details>
128. 你所理解，同步和异步的区别是什么
    <details>
    <summary>答案</summary>
    ```
    同步：js主线程代码在解析执行过程中，能够立刻拿到函数或其他方法的执行结果或等待函数执行完毕后拿到执行结果，再向下执行

    异步：在解析过程中无法立刻拿到执行结果，将异步代码放入任务队列中，等主线程执行完毕后，再去执行任务队列的代码
    ```
    </details>
129. js创建对象的几种方式
    <details>
    <summary>答案</summary>
    ```
    1、通过"字面量"方式创建
    let obj = {name: 'lisi'};
    let obj = {};
    2、通过"构造函数"方式创建
    function Person(){};
    let obj = new Person();
    3、通过object方式创建
    先通过object构造器new一个对象，再往里丰富成员信息。

    let obj = new Object();
    obj.name = 'zhangsan';
    obj.password = '123456';
    4、使用工厂模式创建对象
    function createObject(name){
        let obj = new Object();
        obj.username = name;
    }
    5、通过原型模式创建对象
    function Person(){}
    Person.prototype.username = 'zhangsan';
    Person.prototype.password = '123456';
    ```
    </details>
130. 说一下你所理解js中的作用域与变量声明提升
    <details>
    <summary>答案</summary>
    ```
    1.全局作用域、函数作用域、块级作用域
    2.在es6之前用var 声明的变量和函数声明会存在一个变量提升的问题，无论我们在函数中任何地方生成的变量都会被提到函数的首部，我们可以在函数声明前取到，而不会报错
    3.造成变量提升的原因是js引擎在函数声明前，会有一个解析的过程，创建执行上线文，初始化代码执行前的一些对象，当我们访问一个变量的时候，会去变量的执行上下文的作用域链上查找
    4.作用域链的首段指向的是当前执行上下文中的变量对象，这个对象是执行上下文中的一个属性对象，包含了函数的形参、函数声明、函数中变量，这些都是在js解析的过程中生成的
    ```
    </details>
131. 内部属性[[class]]是什么
    <details>
    <summary>答案</summary>
    ```
    对象的[[class]]属性
    所有typeof返回值为“object”的对象（如数组）都包含一个内部属性[[class]]，这个属性无法直接访问，一般通过Object.prototype.toString(…)来查看。


    console.log(Object.prototype.toString.call([1,2,3]));  //[object Array]


    console.log(Object.prototype.toString.call(/\d/));    //[object RegExp]



    多数情况下，对象的内部[[class]]属性和创建该对象的内建原生构造函数相对应，不过也不总是这样。

    2.基本类型值的[[class]]属性
    虽然Null()和Undefined()这样的原生构造函数并不存在，但是内部[[class]]属性仍然是“Null”和“Undefined”。

    console.log(Object.prototype.toString.call(null)); //[object Null]

    console.log(Object.prototype.toString.call(undefined)); //[object Undefined]
    其他基本类型值的情况有所不同：

    console.log(Object.prototype.toString.call("abc")); //[object String]

    console.log(Object.prototype.toString.call(42));  //[object Number]

    console.log(Object.prototype.toString.call(true)); //[object Boolean]
    基本类型值被各自的封装对象自动包装，所以他们的内部[[class]]属性分别为“String”，“Number”和“Boolean”。

    3.封装对象
    由于基本类型值没有.length和.toString()这样的属性和方法，需要通过封装对象才能访问，此时Javascript引擎会自动为基本类型值包装一个封装对象。

    //封装对象包装
    var b = 'abc';
    console.log(b.length); //3
    console.log(b.toUpperCase()); //ABC
    一般不直接使用封装对象（即通过new操作创建基本类型值），优先考虑使用“abc”和“42”这样的基本类型值，而不是new String(“abc”) 和 new Number(42)。

    4.拆封
    如果想要得到封装对象中的基本类型值，可以使用valueOf()函数。

    //封装对象的拆封
    var s = new String( "abc" );
    var n = new Number( 42 );
    var b = new Boolean( true );

    console.log(s.valueOf()); //abc
    console.log(n.valueOf()); //42
    console.log(b.valueOf()); //true
    ```
    </details>
132. 检测浏览器版本有哪些方式
    <details>
    <summary>答案</summary>
    ```
    1.通过 userAgent 来判断浏览器的类型,但是User-Agent 是可以通过代码修改的，所以纯粹检测User-Agent可能会带来一定的风险

    2、通过浏览器特有的属性来判断
    ```
    </details>
133. react高阶组件、render props和hooks有什么区别，为什么不断迭代？
    <details>
    <summary>答案</summary>
    ```
    三者都能用来进行逻辑复用。区别在于高阶组件为接收组件，对其进行包装，Render props 为在 render 中渲染共享数据，而 hooks 是以函数调用的形式共享数据。

    为什么要不断迭代？

    在大部分情况下，高阶组件和 Render props 都存在各自的缺陷：


    重名问题

    嵌套问题

    无法在 return 之外访问数据的问题

    数据来源不清晰的问题
    …
    不断迭代是为了解决上述问题，让我们可以用更加简洁的方式实现组件逻辑复用，让写代码变得更加轻松和愉快。

    ```
    </details>
134. 说一下vue template到render的过程
    <details>
    <summary>答案</summary>
    ```
    过程解析
    vue的模板编译过程如下：template - ast - render函数

    vue在模板编译中执行compileToFunctions将template转化成render函数

    compileToFunctions的主要核心点:


    调用parse方法将template转化为ast树(抽象语法树)
    parse的目的：是把template转化为ast树，它是一种用js对象的形式来描述整个模板。

    解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来达到构成ast树

    ast元素节点(type)总共三种类型：普通元素–1，表达式–2，纯文本–3


    对静态节点做优化 这个过程主要分析出哪些是静态节点，在其做一个标记，为后面的更新渲染可以直接跳过，静态节点做优化
    深度遍历AST,查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的dom永远不会改变，这对运行时模板更新起到优化作用

    3.生成代码 generate将ast抽象语法树编译成render字符串并将静态部分放到staticRender中，最后通过new Function(render)生成render函数
    ```
    </details>
135. 如何解决跨域问题
    <details>
    <summary>答案</summary>
    ```
    1、通过jsonp跨域
    2、document.domain+iframe跨域
    3、location.hash+iframe
    4、window.name+iframe跨域
    5、postMessage跨域
    6、跨域资源共享（CORS）
    7、nginx代理跨域
    8、nodejs中间件代理跨域
    9、WebSocket协议跨域
    ```
    </details>
136. margin和padding分别适合什么场景使用
    <details>
    <summary>答案</summary>
    ```
    margin:

    需要在border外侧添加空白时；

    空白处不需要背景（色）时；

    上下相连的两个盒子之间的空白，需要相互抵消时。
    padding：

    需要在border内测添加空白时；

    空白处需要背景（色）时；

    上下相连的两个盒子之间的空白，希望等于两者之和时。
    ```
    </details>
137. css多列等高如何实现
    <details>
    <summary>答案</summary>
    ```
    1. 真实等高布局flex:弹性盒子布局flex，默认值就是自带等高布局的特点。
    <div class="box">
        <div class="left"></div>
        <div class="center"></div>
        <div class="right"></div>
    </div>
    .box{
        display:flex;  
        }
        .left{
            width: 100px;
            background-color: grey;
        }
        .center{
            flex:1;
            background:red
        }
        right{
            width: 100px;
            background:yellow
        }
    2. 真实等高布局table-cell:table布局天然就具有等高的特性
    display设置为table-cell,此元素会作为一个表格单元格显示，类似于标签<td><th>
    3.假等高列布局 内外边距底部正负值
    实现：设置父容器的overflow属性为hidden。给每列设置比较大的底内边距，然后用数值相似的负外边距消除这个高度。

    .box {
    overflow: hidden;
    }
    .box > div{
    /**
    * padding-bottom 设置比较大的正值。
    * margin-bottom 设置绝对值大的负值。
    **/
    padding-bottom: 10000px;
    margin-bottom: -10000px;
    float:left;
    width:30%;
    }

    .left {
    background-color: greenyellow;
    }
    .center {
    background-color: gray;
    }
    .right {
    background-color: yellowgreen;
    }
    ```
    </details>
138. 如何处理HTML5新标签的浏览器兼容问题
    <details>
    <summary>答案</summary>
    ```
    方法一 :

    1、使用静态资源的html5shiv包

    2、载入后，初始化新标签的css

    header, section, footer, aside, nav, main, article, figure { display: block; }

    方法二：

    IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签
    ```
    </details>
139. 介绍一下你对浏览器内核的理解
    <details>
    <summary>答案</summary>
    ```
    主要分成两个部分：渲染引擎(Render Engine)和JS引擎。
    其中渲染引擎：负责取得网页的内容(html,xml和图像等)，整理讯息(例如假如css)，以及计算网页的显示方式，然后输出到显示器或打印机。
    浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。
    JS引擎：解析和执行JavaScript来实现网页的动态效果。
    常见的浏览器内核有
    Trident内核：IE，360，搜过浏览器；
    Gecko内核：Netscape6及以上版本，
    Presto内核：Opera
    Blink内核：Opera；
    Webkit内核：Safari，Chrome
    ```
    </details>
140. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的
    <details>
    <summary>答案</summary>
    ```
    1、在浏览器生成二维码，二维码中包含登录信息和服务端给它生成了一个唯一标识码UUID，同时服务端监听服务端登录请求。
    2、在客户端使用扫一扫登录网页版时，此时uid已经登录且有访问授权码access_token信息。
    3、扫描网页的二维码，获取到服务器生成的UUID，然后将access_token及UUID发送给服务端。
    4、服务端验证通过后，生成登录授权码并且通知网页端。
    5、网页端获得授权码后即可向服务器申请用户登录信息，完成登录。
    ```
    </details>
141. 说一下你所理解的渲染原理
    <details>
    <summary>答案</summary>
    ```
    (1)首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。

    (2)然后对 CSS 进行解析，生成 CSSOM 规则树。

    (3)根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。

    (4)当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

    (5)布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。
    ```

    ```
    浏览器解析这三个东西


    解析HTML/XHTML/SVG, 生成DOM树(事实上，Webkit有三个C++的累对应这三类文档以用于解析)

    解析css文件产生CSS Rule树(css规则树)

    解析javaScript，通过DOM API和CSSOM API来操作DOM树和CSS Rule树


    解析完成后，浏览器会根据DOM树和CSS Rule树来构造渲染树(Rendering Tree)


    渲染树并不完全等同于DOM树，因为一些display:none的东西就没必要放在渲染树中了

    CSS Rule树主要是为了完成匹配并把CSS Rule附加到渲染树上的每个DOM结点

    然后，计算每个DOM节点的位置，这就叫做layout的reflow过程


    最后通过调用操作系统Native GUI的API绘制(painting)

    抛去其中的细节，再简单一i但的说法就是: DOM树解析 => css解析 => 渲染(也就是构建渲染树以及最终呈现到浏览器上的过程)

    渲染

    计算css样式，这一步对应着总体流程中的这句话，CSS Rule树主要是为了完成匹配并把CSS Rule附加到渲染树上的每个DOM节点，在渲染树中，每一个文本字符串都被当做一个独立的renderer。每个渲染对象都包含了与之对应的计算过样式的DOM对象(或者一个文本块)。换就话说，渲染树描述了DOM的直观表现形式。

    构建Render Tree。

    Layout-定位坐标和大小，是否换行，各种position，overflow，z-index属性

    正式开画

    注意：JavaScript如果动态修改了DOM属性或是CSS属性会导致重新Layout(Reflow), 当然有些属性改变不会

    Repaint(重绘)
    当在页面上修改了一些不需要改变定位的样式的时候（比如background-color,border-color,visibility)，浏览器只会将新的样式重新绘制给元素（这就叫一次“重绘”或者“重新定   义样式”）。这时只需要屏幕的一部分要重画。

    Reflow(重排)
    当页面上的改变影响了文档内容、结构或者元素定位时，就会发生重排（或称“重新布局”）。重排通常由以下改变触发：


    DOM 操作（如元素增、删、改或者改变元素顺序）

    内容的改变，包括 Form 表单中文字的变化

    计算或改变 CSS 属性

    增加或删除一个样式表

    浏览器窗口的操作（改变大小、滚动窗口）

    激活伪类（如:hover状态）
    ```
    </details>
142. 如何判断一个对象是否属于某个类
    <details>
    <summary>答案</summary>
    ```
    第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。

    第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。

    第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的 [[Class]] 属性来进行判断。
    ```
    </details>
143. 什么是dom和bom
    <details>
    <summary>答案</summary>
    ```
    DOM：文档对象模型，描述了处理网页内容的方法和接口。最根本对象是document（window.document）。
    由于DOM的操作对象是文档，所以DOM和浏览器没有直接关系。
    部署在服务器上的文件夹、右键查看源代码等。
    BOM：浏览器对象模型，描述了与浏览器进行交互的方法和接口。由navigator、history、screen、location、window五个对象组成的，最根本对象是window。
    用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。
    浏览器的标签页、地址栏、搜索栏、菜单栏、滚动条等。
    DOM是W3C的标准，BOM没有相关标准。
    ```
    </details>
144. css选择符有哪些
    <details>
    <summary>答案</summary>
    ```
    id 选择器（#myid）

    类选择器（.myclassname）

    标签选择器（div,h1,p）

    后代选择器（h1 p）

    相邻后代选择器（子）选择器（ul>li）

    兄弟选择器（li~a）

    相邻兄弟选择器（li+a）

    属性选择器（a[rel=“external”]）

    伪类选择器（a:hover,li:nth-child）

    伪元素选择器（::before、::after）

    通配符选择器（*）
    ```
    </details>
145. 标准模式和兼容模式各有什么区别
    <details>
    <summary>答案</summary>
    ```
    标准模式与兼容模式（怪异模式）各有什么区别?

    Standards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（兼容）模式（也就是松散呈现模式或者怪异模式）用于呈现为传统浏览器而设计的网页。

    标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。
    兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。简单说就是尽可能的显示能显示的东西给用户看。

    具体区别：
    1.盒模型
    在严格模式中 ：width是内容宽度 ，元素真正的宽度 = width;
    在兼容模式中 ：width则是=width+padding+border

    2.兼容模式下可设置百分比的高度和行内元素的高宽
    在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。
    在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。

    3.用margin:0 auto设置水平居中在IE下会失效
    使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）
    body{text-align:center};#content{text-align:left}

    4.兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效
    ```
    </details>
146. css如何阻塞文档解析（浏览器解析过程）
    <details>
    <summary>答案</summary>
    ```
    浏览器渲染网页阻塞顺序
    1：构建DOM树时，如遇到JS元素时，会阻塞DOM树和CSS规则树的构建，优先执行JS文件

    2：构建DOM树时，如遇到CSS元素时，会开启异步请求线程，该线程会先下载CSS文件，再构建CSS规则树，该线程会阻塞JavaScript引擎线程，但不会阻塞DOM树的构建

    3：CSS解析和JS解析互斥，也就是说JS解析时会阻塞CSS解析而CSS解析时也会阻塞JS解析

    4：JS解析时，如果JS还操作了CSS，而这个CSS还没有下载或构建解析，则会延迟执行JS，直到完成CSS下载构建解析，再会继续执行JS
    ```
    </details>
147. 说一下你所了解的js的作用域链
    <details>
    <summary>答案</summary>
    ```
    js有一个根作用域，是环境作用域，在浏览器下为windows作用域，此时称为AO，活动对象

    当有函数执行的时候产生一个函数作用域，这时该函数作用域成为AO，根作用域为VO，函数作用域中有一个outer属性指向根作用域

    当函数中有函数执行时又建立一个函数作用域，该函数作用域为AO，outer属性指向上一个函数作用域

    当函数中出现块作用域时，outer指向外层块作用域或调用它的函数

    变量查找会随着outer一直向上查找直到找到或到根作用域为止

    ```
    </details>
148. domContentLoaded事件和Load事件的区别
    <details>
    <summary>答案</summary>
    ```
    DOMContentLoaded 事件

    当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载


    Load 事件

    当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。
    它与DOMContentLoaded不同，后者只要页面DOM加载完成就触发，无需等待依赖资源的加载。


    DOM文档加载的步骤为


    解析HTML结构。

    加载外部脚本和样式表文件。

    解析并执行脚本代码。

    DOM树构建完成。//DOMContentLoaded

    加载图片等外部文件。

    页面加载完毕。//load

    这两个事件的出现主要是用来避免我们需要给一些元素的事件绑定处理函数。但问题是，如果那个元素还没有加载到页面上，但是绑定事件已经执行完了，是没有效果的。

    如果将绑定的函数放在这两个事件的回调中，就能保证在页面的某些元素加载完毕之后再绑定事件的函数
    ```
    </details>
149. Symbol值的强制类型转换
    <details>
    <summary>答案</summary>
    ```
    1、ES6允许从Symbol到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。

    2、Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误）

    3、可以转为布尔值，显式隐式都可以，都为true
    ```
    </details>
150. HTML5有哪些新特性、移除了哪些元素
    <details>
    <summary>答案</summary>
    ```
    HTML5新特性：

    拖放（Drag and drop）API

    语义化标签（header、nav、footer、section、article、aside）

    音频、视频（audio、video）API

    画布（canvas）API

    地理定位（Geolocation）API

    本地离线存储（localStorage），即长期存储数据，浏览器关闭后数据不丢失

    会话存储（sessionStorage），即数据在浏览器关闭后自动删除

    表单控件（calender、date、time、url、email、search）

    新的技术（webworker、websocket）
    移除的元素：

    纯表现的元素：basefont、big、center、font、s、strike、tt、u

    对可用性产生负面影响的元素：frame、frameset、noframes

    ```
    </details>
151. 说一下对DTD的理解
    <details>
    <summary>答案</summary>
    ```
    DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。
    DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。
    ```
    </details>
152. SGML、HTML、XML和XHTML的区别
    <details>
    <summary>答案</summary>
    ```
    > HTML和 XML前身都是SGML(标准通用标记语言)，xml不是HTML的替代品，xml和html是两种不同用途的语言。 XML 不是要替换 HTML；实际上XML 可以视作对 HTML 的补充。XML 和HTML 的目标不同HTML 的设计目标是显示数据并集中于数据外观，而XML的设计目标是描述数据并集中于数据的内容。

    0.SGML
    > SGML(标准通用标记语言)是一个标准，告诉我们如何去指定文档标记，只描述文档标记用怎样的元语言。因此利用了SGML创建了HTML参照和共同遵守的DTD，在HTML中，使用DOCTYPE属性来解析DTD

    1.HTML
    > 超文本标记语言，是一种基本的web网页设计语言。 HTML5是HTML规范的下一个版本。



    注意：




    HTML不是一种编程语言，而是一种标记语言（markup language）




    标记语言是一套标记标签（markup tag）




    HTML使用标记标签来描述网页





    2.XML
    > XML是可扩展标记语言（ExtentsibleMarkup Language），它提供了创建，结构化和编码文档的规则。用于存储数据和允许应用程序之间的通信，也就是说传递数据



    注意：




    XML是一种标记语言，很类似HTML




    XML的设计宗旨是传输数据，而非显示数据




    XML标签没有被预定义，您需要自行定义标签




    XML被设计为具有自我描述性





    &lt;?xml version=&quot;1.0&quot;?&gt;

        &lt;student&gt;

            &lt;name&gt;Zhang &lt;/name&gt;

            &lt;id&gt;150705&lt;/id&gt;

            &lt;birthday&gt;19980204&lt;/birthday&gt;

        &lt;/student&gt;

    3.XHTML

    XHTML是基于XML的HTML。 它提供与HTML相同的功能，但具有与XML文档相同的规则。 这些规则处理标记的结构。
    总的来说，XHTML类似于HTML，但是对语言规则的使用更加严格。特别地，在XHTML中有一些变化，如下：


    所有标签和属性都必须是小写字母；




    结束标签是必需的。如果HTML中没有相应的表示结束的标签，在XHTML中需要在大于号之前插入斜线。如XHTML中的图片标签是<image…/>；




    属性必需用引号括起来，不管是字符串还是数值；




    标签嵌套必须恰当；




    每个XHTML文档都必须有一个文档类型，就像XML和XSL中定义的一样。





    4.HTML与XML的区别
    > xml和html都是用于操作数据或数据结构，在结构上大致是相同的，但它们在本质上却存在着明显的区别。综合网上的各种资料总结如下。

    -（一）、语法要求不同：
    - 1.在html中不区分大小写，在xml中严格区分。

    - 2.在HTML中，有时不严格，如果上下文清楚地显示出段落或者列表键在何处结尾，那么你可以省略&lt;/p&gt;或者&lt;/li&gt;之类的结束标记。在XML中，是严格的树状结构，绝对不能省略掉结束标记。

    - 3.在XML中，拥有单个标记而没有匹配的结束标记的元素必须用一个/ 字符作为结尾。这样分析器就知道不用查找结束标记了。

    - 4.在XML中，属性值必须分装在引号中。在HTML中，引号是可用可不用的。

    - 5.在HTML中，可以拥有不带值的属性名。在XML中，所有的属性都必须带有相应的值。

    - 6.在XML文档中，空白部分不会被解析器自动删除；但是html是过滤掉空格的。
    -（二）、标记不同：
    - 1.html使用固有的标记；而xml没有固有的标记。

    - 2.Html标签是预定义的；XML标签是免费的、自定义的、可扩展的。
    -（三）、作用不同：
    - 1.html是用来显示数据的；xml是用来描述数据、存放数据的，所以可以作为持久化的介质！Html将数据和显示结合在一起，在页面中把这数据显示出来；xml则将数据和显示分开。 XML被设计用来描述数据，其焦点是数据的内容。HTML被设计用来显示数据，其焦点是数据的外观。

    - 2.xml不是HTML的替代品，xml和html是两种不同用途的语言。 XML 不是要替换 HTML；实际上XML 可以视作对 HTML 的补充。XML 和HTML 的目标不同HTML 的设计目标是显示数据并集中于数据外观，而XML的设计目标是描述数据并集中于数据的内容。

    - 3.没有任何行为的XML。与HTML 相似，XML 不进行任何操作。（共同点）

    - 4.对于XML最好的形容可能是: XML是一种跨平台的，与软、硬件无关的，处理与传输信息的工具。

    总的来说，总结以下几点 ：

    XML被设计为传输和存储数据，其焦点是数据的内容

    HTML被设计用来显示数据，其焦点是数据的外观

    HTML旨在显示信息，而XML旨在传输信息
    ```
    </details>
153. 常见的浏览器内核
    <details>
    <summary>答案</summary>
    ```
    1、IE浏览器内核：Trident内核，也是俗称的IE内核；
    2、Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；
    3、Firefox浏览器内核：Gecko内核，俗称Firefox内核；
    4、Safari浏览器内核：Webkit内核；
    5、Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核
    ```
    </details>
154. 什么是文档预解析
    <details>
    <summary>答案</summary>
    ```
    预解析流程：

    1、搜寻预解析关键字

    寻找var关键字

    寻找function关键字

    2、执行预解析

    先应用var关键字声明的标识符，使这些标识符有定义

    标识符有定以后，使用这项标识符就不会报错了

    但因为没有赋值，因此其值为undefined

    至此标识符中保存了函数的引用

    3、几个需要注意的细节

    var 关键字对同一个标识符重复使用时，除第一次有效外，其他均做忽略处理

    预解析时先处理变量声明，再处理函数声明
    ```
    </details>
155. js继承的几种实现方式
    <details>
    <summary>答案</summary>
    ```
    1、原型链继承
    核心： 将父类的实例作为子类的原型

    2、构造继承
    核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）

    3、实例继承
    核心：为父类实例添加新特性，作为子类实例返回

    4、拷贝继承
    5、组合继承
    核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用

    6、寄生组合继承
    核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点
    ```
    </details>
156. react key 是干什么用的，为什么要加上key
    <details>
    <summary>答案</summary>
    ```
    key是React用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识

    在开发过程中，我们需要保证某个元素的key在其同级元素中具有唯一性

    在React Diff算法中React会借助元素的key值来判断该元素是新创建的还是被移动而来的元素，从而减少不必要的元素重新渲染

    此外，React还需要借助Key值来判断元素与状态的关联关系

    几点注意事项:
    key值一定要和具体的元素一一对应
    尽量不要使用数组的index去作为key值
    永远不要试图在render的时候用随机数或者其他操作给元素加上不稳定的key，这样会造成的性能开销比不加key的情况下要糟糕
    ```
    </details>
157. 说一下你理解的https中间人攻击
    <details>
    <summary>答案</summary>
    ```
    一种在网络中劫持会话的攻击方案。
    中间人攻击的实现原理：
    1.本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器

    2.中间人服务器返回中间人自己的证书

    3.客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输

    4.中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密

    5.中间人以客户端的请求内容再向正规网站发起请求

    6.因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据

    7.中间人凭借与正规网站建立的对称加密算法对内容进行解密

    8.中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输

    9.客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

    由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。
    ```
    </details>
158. 说一下你所理解的观察者模式
    <details>
    <summary>答案</summary>
    ```
    观察者模式
    定义
    观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它所有的依赖者都会收到通知并自动更新

    主要解决的问题
    一个对象状态改变给其他对象通知的问题，而且考虑到易用和低耦合，保证高度的协作

    优点
    观察者和被观察者是抽象耦合的
    建立一套触发机制
    缺点
    如果一个被观察对象有很多的直接和间接的观察者的话，将所有的观察者都通知道会花费很多时间。

    如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统奔溃

    观察者模式没有相应的机制让观察者知道所观察的目标对象是怎样发生变化的，而仅仅只是知道观察目标发生了变化
    ```
    </details>
159. 数组去重
    <details>
    <summary>答案</summary>
    ```
    ```
    </details>
160. 说一下你所了解的fiber
    <details>
    <summary>答案</summary>
    ```
    1.背景简介
    react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的。如果需要渲染的组件比较大，js执行会占据主线程时间较长，会导致页面响应效果变差，使react在动画、手势方面应用效果比较差

    页面卡顿:Stack reconciler的工作流程像函数的调用过程。父组件调用子组件像是函数递归；对于庞大的dom树来说，recognition过程会很长，超过了16ms。在其期间，主线程是被js占用的，因此任何交互、布局、渲染都会停止，给用户的画面是页面被卡住了


    实现原理
    旧版React通过递归的方式进行渲染，使用的是JS引擎自身的函数调用栈，会一直执行到空栈为止。而fiber实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现方式是使用了浏览器的requestldeCallback这一个api。fiber其实值得是一种数据结构，它可以用一个纯js对象来进行表示。

    react内部运转分三层：

    Virtual DOM层：描述页面长什么样子
    Reconciler层:负责调用组件声明周期方法，进行Diff运算等
    Renderer层:根据不同的平台，渲染出相应的页面，常见的是react-dom
    为了实现不卡顿的效果，需要有一个调度器(Scheduler)来进行分配。优先级高的任务(键盘输入)可以打断优先级低的任务(diff)的执行，从而更快的生效。任务的优先级有六种：

    synchronous，与之前的Stack Reconciler操作一样，同步执行
    task，在next tick之前执行
    animation，下一帧之前执行
    high，在不久的将来执行
    low，稍微延迟执行也没关系
    offscreen，下一次render时或scroll时才执行
    Fiber Reconclier(react)执行阶段:

    阶段1：生成一个Fiber树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断
    阶段2：将需要更新的节点一次批量更新，这个过程不能被打断。
    Fiber树：Fiber Reconciler在阶段1进行diff计算的时候，会基于virtual DOM树生成一颗Fiber树，它的本质是链表。

    从Stack Reconciler到Fiber Reconciler，源码层面其实是干了意见递归循环的事情
    ```
    </details>
161. 什么是函数柯里化
    <details>
    <summary>答案</summary>
    ```
    把接收多个参数的函数变换为接收一个单一参数（最初函数的第一个参数）的函数，并返回接收剩余参数而且返回结果的新函数的技术。

    JS 函数柯里化的优点：
    可以延迟计算，即如果调用柯里化函数传入参数是不调用的，会将参数添加到数组中存储，等到没有参数传入的时候进行调用；
    参数复用，当在多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化函数
    ```
    </details>
162. 异步编程的实现方式是什么
    <details>
    <summary>答案</summary>
    ```
    1、回调函数

    优点：简单、容易理解
    缺点：不利于维护，代码耦合高，多个异步操作下容易形成回调地狱。

    2、事件监听

    优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数
    缺点：事件驱动型，流程不够清晰

    3、发布/订阅(观察者模式)

    类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者

    4、Promise

    优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；
    缺点：编写和理解，相对比较难

    5、Generation

    优点：函数体内外的数据交换、错误处理机制
    缺点：流程管理不方便

    6、async/await

    优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。
    缺点：错误处理机制
    ```
    </details>
163. 说一下import的原理，和require的不同之处在哪儿
    <details>
    <summary>答案</summary>
    ```
    import的原理
    1.简单来说就是闭包的运用

    2.为了创建 Module 的内部作用域，会调用一个包装函数

    3.包装函数的返回值也就是 Module 向外公开的 API，也就是所有 export 出去的变量

    4.import 也就是拿到 module 导出变量的引用

    与 require 的不同

    CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用

    CommonJS 模块是运行时加载，ES6模块是编译时输出接口，编译时加载（效率更高由于是编译时加载，所以 import 命令会提升到整个模块的头部）

    CommonJS 是运行时加载对应模块，一旦输出一个值，即使模块内部对其做出改变，也不会影响输出值
    而 ES6 模块则不同，import 导入是在 JS 引擎对脚本静态分析时确定，获取到的只是一个只读的引用。等脚本正在运行时，会根据这个引用去对应的模块中取值。所以引用对应的值发生改变时，其导入的值也会发生改变。

    CommonJs模块默认采用非严格模式，ES6 的模块自动采用严格模式（无论你加不加 “use strict”）
    ```
    </details>
164. 使用Object.defineProperty()来进行数据劫持有什么缺点
    <details>
    <summary>答案</summary>
    ```
    1、对于对象而言不能检测新添加的属性。

    2、对于数组而言，虽然可以监听到变化，但是代价非常高昂，消耗性能。所以在Vue中，从性能/体验的性价比考虑，弃用了这个特性

    3、对于树结构，需要递归循环监听，也非常消耗性能。

    vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法.
    ```
    </details>
165. 面向对象的三要素是什么，分别是什么意思？
    <details>
    <summary>答案</summary>
    ```
    封装
    封装就是事物抽象为类，把对外接口暴露，将实现和内部数据隐藏。

    继承
    面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
    通过继承创建的新类称为“子类”或“派生类”。
    被继承的类称为“基类”、“父类”或“超类”。
    继承的过程，就是从一般到特殊的过程。
    要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。
    在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。

    继承概念的实现方式有三类：实现继承、接口继承和可视继承。
    Ø         实现继承是指使用基类的属性和方法而无需额外编码的能力；
    Ø         接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
    Ø         可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。
    在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。
    抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字  Interface 而不是  Class。
    OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。

    多态
    多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
    实现多态，有二种方式，覆盖，重载。
    覆盖，是指子类重新定义父类的虚函数的做法。
    重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
    其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚邦定，它就不是多态。”
    那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。
    ```
    </details>
166. 说一下base64的编码方式
    <details>
    <summary>答案</summary>
    ```
    Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于64个可打印字符来表示二进制数据的方法。

    Base64一般用于在HTTP协议下传输二进制数据，由于HTTP协议是文本协议，所以在HTTP协议下传输二进制数据需要将二进制数据转换为字符数据。

    什么是可打印字符？
    在ASCII码中规定，0 ~ 31、127这33个字符属于控制字符，32~126这95个字符属于可打印字符，也就是说网络传输只能传输这95个字符，不在这个范围内的字符无法传输。那么该怎么才能传输其他字符呢？其中一种方式就是使用Base64。

    转换原理：
    将索引转换为对应的二进制数据的话需要至多6个Bit，而 ASCII码需要8个Bit来表示。4 * 6个Bit可以存储3 * 8个Bit的数据，也就是说3个ASCII字符刚好转换成对应的4个Base64字符。Base64规定，当需要转换的字符不是3的倍数时，一律采用高位补0的方式凑足3的倍数，即用 “=” 填充。
    ```
    </details>
167. 介绍下vue-router中的导航钩子函数
    <details>
    <summary>答案</summary>
    ```
    钩子函数的分类：
    全局导航守卫(router.beforeEach)
    路由独享守卫(router.beforeEnter)
    组件内守卫(router.beforeRouteEnter，beforeRouteLeave，beforeRouteUpdate等)
    路由执行过程：
    1.导航被触发
    2.在失活的组件里调用beforeRouteLeave守卫
    3.调用全局的守卫beforeEach守卫
    4.在重用的组件里调用beforeRouteUpdate守卫
    5.在路由配置中调用路由钩子beforeEnter
    6.解析异步路由组件
    7.在被激活的组件中调用beforeRouteEnter
    8.调用全局守卫beforeResolve守卫
    9.导航被确认
    10.触发全局的afterEach钩子
    11.触发dom更新
    12.调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入
    ```
    </details>
168. 说一下React setState原理
    <details>
    <summary>答案</summary>
    ```
    react的类组件通过state管理内部状态，而唯一改变状态更新的视图只能通过setState和forceUpdate。

    setState最终也会走forceUpdate。那么要知道的是每个类组件都有一个updater对象用于管理state的变化，当调用setState传入partialState时，会将partialState存入updater中的pendingState中，此时updater又会调用emitUpdate来决定当前是否立即更新，判断条件简单来说是否有nextProps或者updateQueue的isPending是否开启

    updateQueue用于批量管理的updater

    如果updateQueue的isPending为true，那么就将当前update直接加入updateQueue的队列中，开启isPending的方式可以是自定义方法和生命周期函数等

    当这些方法执行完毕更新update，调用update的componentUpdate，判断组件的shouldComponentUpdate决定是否调用forceUpdate的进行更新
    ```
    </details>
169. 介绍你所理解的中介者模式
    <details>
    <summary>答案</summary>
    ```
    中介者模式
    定义
    中介者模式(Mediator Pattern)是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。使用中介者模式来集中相关对象之间复杂的沟通和控制方式

    意思:用一个中介对象来封装一系列的对象交互，中介者使各个对象不需要显式的相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互

    主要解决
    对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。

    应用实例
    MVC框架，其中C(控制器)就是M(模型)和V(视图)的中介者。前端的MVVM框架本质是MVC框架的变形，VM(控制器)就是M(模型)和V(视图)的中介者

    优点
    通过将对象彼此解耦，可以增加对象的复用性
    通过将控制逻辑集中，可以简化系统维护
    可以让对象之间所传递的消息变得简单而且大幅减少
    缺点
    中介者常常被用来协调相关的GUI组件
    如果设计不当，中介者对象本身会变得过于复杂
    ```
    </details>
170. 你所理解的前端路由是什么
    <details>
    <summary>答案</summary>
    ```
    1.基于hash
    展示页面也就是切换#后面的内容，呈现给用户不同的页面。现在越来越多的单页面应用基本都是基于hash实现的

    特性:url中hash值的变化并不会重新加载页面，hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换

    我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理

    2.基于history
    基于history新API(history.pushState()+popState事件) window.history.pushState(null,null,“https://www.baidu.com”)

    这两个API的相同之处都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于:pushState会增加一条新的历史记录，而replace则会替换当前的历史记录
    ```
    </details>
171. ssl连接断开后如何恢复？
    <details>
    <summary>答案</summary>
    ```
    一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。

    使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。

    目前所有的浏览器都支持这一种方法。
    但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。
    另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。

    这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。
    ```
    </details>
172. 说一下ajax、axios、fetch三者的区别
    <details>
    <summary>答案</summary>
    ```
    ajax:是指一种创建交互式网页应用的网页开发技术，并且可以做到无需重新加载整个网页的情况下，能够更新部分网页，也叫作局部更新
    优缺点：
    1）局部更新
    2）原生支持，不需要任何插件
    3）原生支持，不需要任何插件
    4）可能破坏浏览器后退功能
    5）嵌套回调，难以处理
    2.axios:是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中
    特点：
    1）从浏览器中创建 XMLHttpRequests
    2）从 node.js 创建 http 请求
    3）支持 Promise API
    4）拦截请求和响应
    5）转换请求数据和响应数据
    6）取消请求
    7）自动转换 JSON 数据
    8）客户端支持防御 XSRF
    3.fetch:使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch函数就是原生js，没有使用XMLHttpRequest对象。
    优缺点：
    1）更加底层，提供的API丰富（request, response）
    2）脱离了XHR，是ES规范里新的实现方式
    3）fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装
    4）fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理

    5）fetch默认不会带cookie，需要添加配置项

    6）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费

    7）fetch没有办法原生监测请求的进度，而XHR可以
    ```
    </details>
173. 用微服务有什么好处
    <details>
    <summary>答案</summary>
    ```
    微服务应用的一个最大的优点是:它们往往比传统的应用程序更有效的利用计算资源。这是因为它们通过扩展组件来处理性能瓶颈问题。这样一来开发人员只需要为额外的组件部署计算资源，而不需要部署一个完整的应用程序的全新迭代。最终的结果是有更多的资源可以提供给其他的任务。

    微服务应用的另一个好处是：它们更快并且更容易更新。当开发者对一个传统的单体应用程序进行时，他们必须做详细的QA测试，以确保变更不会影响其他特性或功能。但有了微服务，开发者可以更新应用程序的单个组件，而不影响其他的部分。测试微服务应用程序仍然是必需的，但它更容易识别和隔离问题，从而加快开发速度并支持DevOps和持续应用程序开发

    微服务应用的第三个好处：微服务架构有助于新兴的云服务，比如事件驱动计算，类似AWS Lambda这样的功能让开发人员能够编写代码 处于休眠状态，直到应用程序事件触发。事件处理时才需要使用计算资源，而企业只需要为每次事件而不是固定数目的计算实例支付

    通俗解释：

    易于开发和维护:因为一个服务只专注一个特定的业务，业务就变得比较清晰，同时维护起来也是比较方便

    单个服务启动比较快：单个服务代码质量不会很多，启动起来就会很快

    便于伸缩：如果系统中有三个服务ABC，服务B的访问量比较大，我们可以将服务B集群部署

    单体应用中，如果需要改动功能，那么则需要重新部署整个单体应用，而微服务不需要，只需要重新部署修改的功能模块的微服务。每一个功能模块都可以替换和独立维护的单元，完全体现了高度复用性、高度维护性，高度扩展性。
    ```
    </details>
174. Reflect对象创建目的是什么
    <details>
    <summary>答案</summary>
    ```
    将 Object 对 象 的 一 些 明 显 属 于 语 言 内 部 的 方 法 （ 比 如 Object.defineProperty，放到 Reflect 对象上。
    修改某些 Object 方法的返回结果，让其变得更合理。
    让 Object 操作都变成函数行为。
    Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象 的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可 以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。
    也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取 默认行为。
    ```
    </details>
175. require模式引入的查找方式是什么
    <details>
    <summary>答案</summary>
    ```
    当node遇到require(x)时，按照下面的顺序处理

    如果 X 是内置模块（比如 require(‘http’)） a. 返回该模块。 b. 不再继续执行。

    如果 X 以 “./” 或者 “/” 或者 “…/” 开头 a. 根据 X 所在的父模块，确定 X 的绝对路径。 b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续 执行。 X X.js X.json X.node

    c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。 X/package.json（main 字段） X/index.js X/index.json X/index.node

    如果 X 不带路径 a. 根据 X 所在的父模块，确定 X 可能的安装目录。 b. 依次在每个目录中，将 X 当成文件名或目录名加载。


    抛出 “not found”
    ```
    </details>
176. addEventListener在removeListener会不会造成内存泄漏
    <details>
    <summary>答案</summary>
    ```
    removeListener 用于移除事件监听， 但是要其参数完全要和addEventListener中的参数一致，但是值得注意的是，如果addEventListener中的第二个参数（函数）是匿名函数，使用removeListener无效，虽然第二个参数的代码一样，但是写匿名函数时，所指向的内存空间是不一样的，不能认为是完全相同的参数
    ```
    </details>