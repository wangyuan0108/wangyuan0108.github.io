---
title: 前端每日一题
categories: WEB前端
copyright: true
date: 2021-01-12 15:41:25
top: true
tags: 题目
---
## 简介
记录前端需要掌握的知识点，通过答题进行巩固和提升。让自己的基础更牢固，原理更加熟识！！！
## 题目
1. vue的双向绑定原理是什么？
    <details>
    <summary>答案</summary>
    vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过ES5提供的Object.defineProperty()方法来劫持(监视)各个属性的setter,getter，在数据变动的时发布消息给订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送发送给绑定的视图，而不是对所有的数据都执行一次检测。
    具体的步骤：

    1. 需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上getter和setter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
    2. compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
    3. Watcher订阅者是Observer和compile之间通信桥梁，主要做的事情是：
        - 在自身实例化时往属性订阅器(dep)里面添加自己
        - 自身必须有一个update()的方法
        - 待属性变动dep.notice()通知的时候，能调用自身的update()方法，并触发compile中绑定的回调，则功成身退
    4. MVVM作为数据绑定的入口，整合observer、compile和watcher三者，通过observer来监听自己的model数据变化，通过compile来编译模板指令，最终利用watcher搭起的observer和compile之间的通信桥梁，达到数据变化---试图更新;视图交互变化(input)-->数据model变更的双向绑定效果

    版本比较： vue是基于依赖收集的双向绑定； 3.0版本之前使用Object.definePropetry,3.0新版使用Proxy

    1. 基于数据劫持/依赖收集 的双向绑定的优点
    不需要显示的调用，Vue利用数据劫持+发布订阅，可以直接通知变化并且驱动视图
    直接得到精确的变化数据，劫持了属性setter，当属性值改变，我们可以精确的获取变化的内容newValue，不需要额外的diff操作
    2. Object.defineProperty的缺点
    不能监听数组：因为数组没有getter和setter，因为数组长度不确定，如果太长性能负担太大
    只能监听属性，而不是整个对象，需要遍历循环属性
    只能监听属性变化，不能监听属性的删减
    3. proxy的好处
    可以监听数组
    监听整个对象不是属性
    13种来截方法，强大很多
    返回新对象而不是直接修改原对象，更符合immutable；
    4. proxy的缺点
    兼容性不好，而且无法用polyfill磨平；
    </details>
<!--more-->

2. Loader和Plugin的区别是什么
    <details>
    <summary>答案</summary>
    1. 作用不同：
    Loader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。
    Plugin直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。
    2. 用法不同：
    Loader在module.rules中配置，也就是说作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）
    Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。
    </details>
3. 请解释React中props和state的区别
    <details>
    <summary>答案</summary>
    1. props
    函数组件的props就是一个函数的入参组件
    类组件：this.props 包括被该组件调用或者定义的props
    2. state
    组件中的state包含了随时可以发生变化的数据
    state由用户定义，它是一个普通javascript对象
    3. 区别
    props是传递组件的(类似函数的形参)，而state是在组件内被组件自己管理的(类似在一个函数内声明变量)。
    props是不可修改的，所有React组件必须向纯函数一样保护它们的props不被更改
    state是在组件中创建的，一般在constructor中初始化state
    state是多变的、可修改的，每次setState都异步更新的
    </details>

4. 浏览器的本地存储的cookie了解多少
    <details>
    <summary>答案</summary>
    Cookie最开始被设计出来其实并不是做本地存储的，而是为了弥补http在状态管理上的不足
    http协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，这次事件就完成了，但是下次发请求如何让服务端直到客户端是谁呢？在这个需求下就产生了Cookie
    Cookie本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面版的Application这一栏可以看到)都会携带相同的Cookie，服务器拿Cookie进行解析，便能拿到客户端的状态 Cookie的作用就是用来做状态存储的，但是也有很多缺陷：
    1. 容量缺陷。Cookie的体积上限只有4KB，只能用来存储少量的信息
    2. 性能缺陷。Cookie紧跟域名，不管域名下面的某一个地址需不需要这个Cookie，请求都会携带上完整的Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容
    3. 安全缺陷。由于Cookie以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截取，然后进行一系列的篡改，在Cookie的有限期内重新发送给服务器，这是很危险的。另外，在HttpOnly为false的情况下，Cookie信息能直接通过js脚本来读取。
    </details>

5. 浏览器本地存储的WebStorate了解多少
    <details>
    <summary>答案</summary>
    WebStorage又可以分为localStorege和sessionStorage

    localStorage
    和Cookie异同：相同的一点是：针对一个域名，即在同一个域名下，会存储相同的一段localStorage

    区别：

    1. 容量：localStorage的容量上限为5M，相对于Cookie的4K大大增加。当然这个5M是针对一个域名的，因此对于一个域名是持久存储的
    2. 只存在客户端，默认不参与和服务端的通信。这样很好地避免了Cookie带来地性能问题和安全问题
    3. 接口封装。通过localStorage暴露在全局，并通过它的setItem和getItem等方法进行操作，非常方便。
    看看如何具体操作localStorage？

    ```
    let obj={name:"zhufeng",age:10};
    localStorage.setItem("name","zhufeng");
    localstorage.setItem("message",JSON.stringify(obj));
    //接着进入相同的域名时就能拿到相应的值：
    let name=localStorage.getItem("name");
    let info=JSON.parse(localStorage.getItem("info"))
    ```
    在这里能得到，localStorage其实存储的都是字符串，如果是存储对象需要调用JSON的stringify方法，并且用JSON.parse来解析成对象 应用场景：利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源，比如官网的logo，存储Base64格式的图片资源，因此要好好利用localStorage

    sessionStorage
    特点：sessionStorage和localStorage是一致的

    1. 容量。容量上限为5M
    2. 只存在客户端，默认不参与和服务端的通信
    3. 接口封装。除了sessionStorage名字有所变化，存储方式、操作方式均和localStorage一样
    但是sessionStorage和localStorage有一个本质的区别：前者只是会话级别的存储，并不是持久化存储。会话结束后也就是页面关闭，这部分sessionStorage就不存在了

    应用场景：
    1. 可以用它对表单信息进行维护，将表单信息存储存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
    2. 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用sessionStorage就再合适不过了。事实上微博采取这样的存储方式。
    </details>

6. 说一下vue-router的原理是什么
    <details>
    <summary>答案</summary>
    实现原理：vue-router的原理就是更新视图而不重新请求页面

    vue-router可以通过mode参数设置为三种模式：hash模式、history模式、abstract模式。

    1. hash模式 默认是hash模式，基于浏览器history api，使用window.addEventListener('hashchange',callback,false)对浏览器地址进行监听。当调用push时，把新路由添加到浏览器访问历史的栈顶。使用replace时，把浏览器访问历史的栈顶路由替换成新路由 hash的值等于url中#及其以后的内容。浏览器是根据hash值的变化，将页面加载到相应的DOM位置。锚点变化只是浏览器的行为，每次锚点变化后依然会在浏览器中留下一条历史记录，可以通过浏览器的后退按钮回到上一个位置

    2. History history模式，基于浏览器history api ，使用window.onpopstate对浏览器地址进行监听。对浏览器history api中的pushState()、replaceState()进行封装，当方法调用，会对浏览器的历史栈进行修改。从而实现URL的跳转而无需加载页面 但是他的问题在于当刷新页面的时候会走后端路由，所以需要服务端的辅助来兜底，避免URL无法匹配到资源时能返回页面

    3. abstract 不涉及和浏览器地址的相关记录。流程跟hash模式一样，通过数组维护模拟浏览器的历史记录栈 服务端下使用。使用一个不依赖于浏览器的浏览器历史虚拟管理后台

    4. 总结 hash模式和history模式都是通过window.addEvevtListenter()方法监听 hashchange和popState进行相应路由的操作。可以通过back、foward、go等方法访问浏览器的历史记录栈，进行各种跳转。而abstract模式是自己维护一个模拟的浏览器历史记录栈的数组

    </details>

7. 防抖节流原理、区别以及应用，请用js实现
    <details>
    <summary>答案</summary>
    #### 防抖
    原理：在时间被触发n秒之后再执行回调，如果在这n秒内又被触发，则重新计时

    适用场景：

    按钮提交场景：防止多次提交按钮，只执行最后提交的一次
    搜索框联想场景：防止联想发送请求，只发送最后一次输入
    ```
    //简易版实现
    function debounce(func,wait){
        let timeout;
        return function(){
            const context=this;
            const args=arguments;
            clearTimeout(timeout);
            timeout=setTimeout(() => {
                func.apply(context,args);
            }, wait);
        }
    }
    //立即执行版实现：有时候希望立刻执行函数，然后等到停止触发n秒后，才可以重新执行。
    function debound1(func,wait,immediate){
        let timeout;
        return function(){
            const context=this;
            const args=arguments;
            if(timeout) clearTimeout(timeout);
            if(immediate){
                const callNow=!timeout;
                timeout=setTimeout(() => {
                    timeout=null;
                }, wait);
                if(callNow) func.apply(context,args);
            }else{
                timeout=setTimeout(() => {
                    func.apply(context,args);
                }, wait);
            }
        }
    }

    //返回值版实现
    //func函数可能会有返回值，所以需要返回函数结果，但是当immediate为false的时候，因为使用了setTimeout，我们将func.apply(context,args)的返回值赋给变量，最后在return的时候，值将会一直是undefined，所以只在immediate为true的时候返回函数的执行结果
    function debounce2(func,wait,immediate){
        let timeout,result;
        return function(){
            const context=this;
            const args=arguments;
            if(timeout) clearTimeout(timeout);
            if(immediate){
                const callNow=!timeout;
                timeout=setTimeout(() => {
                    timeout=null;
                }, wait)
                if (callNow) result=func.apply(context,args);
            }else{
                timeout=setTimeout(() => {
                    func.apply(context,args);   
                }, wait);
            }
            return result;
        }
    }
    ```
    #### 节流：
    原理： 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效

    适用场景：

    拖拽场景：固定时间内只执行一次，防止高频次触发位置变动
    缩放场景：监控浏览器resize
    ```
    //使用时间戳实现:使用时间戳，当触发事件发生的时候，我们取出当前的时间戳，然后减去之前的时间戳（最开始设值为0），如果大于设置的时间周期，就执行函数，然后更新时间戳为当前时间戳，如果小于，就不执行 

    function throttle(func,wait){
        let context,args;
        let previous=0;
        return function(){
            let now=+new Date();
            context=this;
            args=arguments;
            if(now-previous > wait){
                func.apply(context,args);
                previous=now
            }
        }
    }
    //使用定时器实现：当触发事件的时候，我们设置一个定时器，在触发事件的时候，如果定时器存在，就不执行，知道定时器执行，然后执行函数，清空定时器，这样就可以设置下定时器
    function throttle1(func,wait){
        let timeout;
        return function(){
            const context=this;
            const args=arguments;
            if(!timeout){
                timeout=setTimeout(() => {
                    timeout=null;
                    func.apply(context,args);
                }, wait);
            }
        }
    }

    //区别:节流不管事件触发多频繁保证在一定时间内一定会执行一次函数。防抖是只在最后一次事件触发后才会执行一次函数
    // flag版本
    const throttle2=(func,wait)=>{
        let flag=true;
        return function(...args){
            if(!flag) return;
            flag=flase;
            setTimeout(() => {
                func.apply(this,args)
                flag=true;
            }, wait);
        } 
    }
    ```
    </details>

8. 在css中link和@import的区别是什么
    <details>
    <summary>答案</summary>
    1. 从属关系区别
    @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

    2. 加载顺序区别
    加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。

    3. 兼容性区别
    @import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。

    4. DOM可控性区别
    可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。

    5. 权重区别(该项有争议，下文将详解)
    link引入的样式权重大于@import引入的样式。
    </details>
9. 常见的loader以及作用的总结
    <details>
    <summary>答案</summary>
    raw-loader：加载文件原始内容（utf-8）
    file-loader：把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件
    url-loader:和file-loader类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中
    source-map-loader:加载额外的Source Map文件，以方便断点调试
    svg-inline-loader：将压缩后的 SVG 内容注入代码中
    image-loader：加载并且压缩图片文件
    json-loader 加载 JSON 文件（默认包含）
    handlebars-loader: 将 Handlebars 模版编译成函数并返回
    babel-loader：把ES6转化成ES5
    ts-loader: 将 TypeScript 转换成 JavaScript
    awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader
    css-loader：加载css，支持模块化、压缩、文件导入等特性
    style-loader：把css代码注入到js中，通过DOM操作去加载css
    eslint-loader：通过ESLint检查JS代码
    tslint-loader：通过 TSLint检查 TypeScript 代码
    postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀
    vue-loader：加载 Vue.js 单文件组件
    cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里
    </details>
10. 计算属性和普通属性的区别是什么
    <details>
    <summary>答案</summary>
    computed属性是vue计算属性，是数据层到视图层的数据转化映射； 计算属性是基于他们的依赖进行缓存的，只有在相关依赖发生改变时，他们才会重新求值，也就是说，只要他的依赖没有发生变化，那么每次访问的时候计算属性都会立即返回之前的计算结果，不再执行函数；

    computed是响应式的，methods并非响应式。
    调用方式不一样，computed的定义成员像属性一样访问，methods定义的成员必须以函数形式调用
    computed是带缓存的，只有依赖数据发生改变，才会重新进行计算，而methods里的函数在每次调用时都要执行。
    computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的
    computed不支持异步，当computed内有异步操作时无效，无法监听数据的变化
    如果声明的计算属性计算量非常大的时候，而且访问量次数非常多，改变的时机却很小，那就需要用到computed；缓存会让我们减少很多计算量。
    </details>
11. webpack中source map是什么？生产环境怎么用
 <details>
    <summary>答案</summary>
    </details>
12. 浏览器缓存机制对于开发很重要，强缓存的内容能了解多少呢？
 <details>
    <summary>答案</summary>
    </details>
13. 介绍js全部数据类型，基本数据类型和引用数据类型的区别
 <details>
    <summary>答案</summary>
    </details>
14. react-router里的link标签和a标签有什么区别
 <details>
    <summary>答案</summary>
    </details>
15. 能不能说一说XSS攻击
 <details>
    <summary>答案</summary>
    </details>
16. 谈谈你对重绘和回流的理解
 <details>
    <summary>答案</summary>
    </details>
17. 简单说下你理解的语意化，怎样来保证你写的符合语意化？HTML5语意化标签了解下
 <details>
    <summary>答案</summary>
    </details>
18. 常见的plugin以及作用的总结
 <details>
    <summary>答案</summary>
    </details>
19. 能不能说一说CSRF攻击
 <details>
    <summary>答案</summary>
    </details>
20. css伪类和伪元素区别
 <details>
    <summary>答案</summary>
    </details>
21. Vuex和localStorage的区别是什么
 <details>
    <summary>答案</summary>
    </details>
22. 浏览器缓存机制对于开发很重要，协商缓存的内容能了解多少呢
23. 说一下时间循环机制（node 浏览器）
24. webpack的构建流程是什么
25. import和commonJs在webpack打包过程中有什么不同
26. dev-server是怎么跑起来的
27. 如何实现webpack持久化缓存
28. webpack热更新的原理
29. 浏览器的缓存机制对于开发很重要，缓存位置的内容能了解多少呢
30. webpack打包时的Hash码是怎样生成的？随机值存在一样的情况，如何避免
31. 如何加快页面的渲染速度，都有哪些方式
32. HTTP请求特征是什么
33. react里组件通信有几种方式，分别怎样进行通信
34. 说一下栈和堆的区别，垃圾回收时栈和堆的区别
35. 布局都有什么方式，float和position有什么区别
36. 请用js代码实现事件代理
37. 对虚拟dom的理解？虚拟dom主要做了什么？虚拟dom本身时什么
38. 移动端需要注意什么
39. 响应式布局用到的技术有几种方式
40. 词法作用域和this的区别
41. 介绍React高阶组件，适用于什么场景
42. 说一下vue的keep-alive是如何实现的，具体缓存的是什么
43. 请描述下css盒模型基本概念
44. React组件中怎么做事件代理？它的原理是什么
45. Promise构造函数是同步还是异步执行，then呢？
46. 说一下mobx盒redux有什么区别
47. css预处理器的概念
48. shouldComponentUpdate是为了解决什么问题
49. react里setState到底是异步还是同步
50. react-redux的工作流程是什么
51. 添加原生事件不移除为什么会内存泄漏，还有哪些地方会存在内存泄漏
52. 怎么处理项目中的异常捕获行为
53. 点击一个按钮，浏览器会做些什么事情
54. promise有没有解决异步的问题
55. css预处理器的好处
56. 与http相关的协议有哪些？tcp/ip dns uri/url https
57. cdn有哪些优化静态资源加载速度的机制
58. 说说你理解的node中间层怎样做的请求合并转发
59. webpack做了什么？使用webpack构建时有无做了一些自定义操作
60. webapck如何用localStorage离线缓存静态资源
61. 使用import时，webpack对node_modules里的依赖会做什么
62. 关于vue项目进行优化，你有哪些方法
63. 为什么组件中的data必须是一个函数，然后return一个对象，而new Vue实例里，data可以直接是一个对象
64. redux和vuex有什么区别，说一下他们的共同思想
65. 说一下react.Component和react.PureComponent的区别
66. 说一下你对react context的理解
67. 说一下mysql和mongodb的区别
68. webpack里面的插件是如何实现的
69. 使用ts的优势有哪些
70. 直接给一个数组项赋值，vue能检测到变化吗
71. vue组件间的通信有哪几种方式
72. 项目如何管理模块
73. 在那个生命周期内调用异步请求
74. 说明一下js封装的原理
75. 回调函数和任务队列的区别
76. 写出常用的页面优化实现方案
77. 请你谈谈对无状态的理解（react部分）
78. 如何理解事件委托
79. BFC是什么？触发BFC的条件是什么？有哪些应用场景
80. 说一下单向数据流有什么好处
81. React怎么做数据检查和变化
82. 类数组转化为数组
83. 说一下关于tree-shaking的原理
84. vue中的key有什么作用
85. 说一下vue的父组件和子组件生命周期钩子函数执行顺序
86. 使用过vue ssr吗？说说ssr
87. 什么情况下出现浏览器分层（css部分）
88. 说明下js继承的原理
89. 说一下vue单页和多页的区别
90. 说一下vue的$nextTick的原理
91. v-model是如何实现的，语法糖实际是什么
92. 怎样理解vue的单向数据流
93. react ssr实现过程
94. react ssr实现原理是什么，需要注意什么事项
95. 子组件可以直接改变父组件的数据吗？说说你的理由（vue部分）
96. 能说下vue-router中常用的hash和history路由模式实现原理吗？
97. 实现数组去重
98. 描述下js中的prototype的概念
99. 实现数组扁平化
100. react事件绑定原理是什么
101. 为什么不建议使用通配符初始化css样式
102. 说一下koa2和express区别
103. link标签定义
104. 渲染过程中遇到js文件怎么处理（浏览器解析过程）
105. Object.is()与原来的比较操作符"==="、"=="的区别
106. 三种事件模型是什么
107. doctype的作用是什么
108. iframe有哪些缺点
109. 说说你对浏览器的理解
110. 谈谈你对ajax的理解
111. 简单介绍使用图片base64编码的优点和缺点
112. 请说出目前主流的js模块化实现的技术有哪些？他们的区别在哪
113. for in和Object.keys的区别
114. 哪些操作会造成内存泄漏
115. 什么是浏览器的同源策略
116. 说一下你理解的margin重叠的问题
117. display、position和float的相互关系
118. 前端需要注意哪些seo
119. 说一下html布局元素的分类有哪些？以描述下每种布局元素的应用场景
120. 网页验证码是干嘛的，是为了解决什么安全问题
121. 简单说下v8引擎的垃圾回收机制
122. 说一说对json的理解
123. 渲染页面是常见的不良现象有哪些（浏览器渲染过程）
124. componentWillReceiveProps的触发条件是什么
125. javascript代码中的“use strict”是什么意思？为什么使用它
126. 什么是polyfill
127. 说一下vue的什么周期以及每个阶段做的事情
128. 你所理解，同步和异步的区别是什么
129. js创建对象的几种方式
130. 说一下你所理解js中的作用域与变量声明提升
131. 内部属性[[class]]是什么
132. 检测浏览器版本有哪些方式
133. react高阶组件、render props和hooks有什么区别，为什么不断迭代？
134. 说一下vue template到render的过程
135. 如何解决跨域问题
136. margin和padding分别适合什么场景使用
137. css多列等高如何实现
138. 如何处理HTML5新标签的浏览器兼容问题
139. 介绍一下你对浏览器内核的理解
140. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的
141. 说一下你所理解的渲染原理
142. 如何判断一个对象是否属于某个类
143. 什么事dom和bom
144. css选择符有哪些
145. 标准模式和兼容模式各有什么区别
146. css如何阻塞文档解析（浏览器解析过程）
147. 说一下你所了解的js的作用域链
148. domContentLoaded事件和Load事件的区别
149. Symbol值的强制类型转换
150. HTML5有哪些新特性、移除了哪些元素
151. 说一下对DTD的理解
152. SGML、HTML、XML和XHTML的区别
153. 常见的浏览器内核
154. 什么是文档预解析
155. js继承的几种实现方式
156. react key 是干什么用的，为什么要加上key
157. 说一下你理解的https中间人攻击
158. 说一下你所理解的观察者模式
159. 无
160. 说一下你所了解的fiber
161. 什么是函数柯里化
162. 异步编程的实现方式是什么
163. 说一下import的原理，和require的不同之处在哪儿
164. 使用Object.defineProperty()来进行数据劫持有什么缺点