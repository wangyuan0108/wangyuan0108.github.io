---
title: 前端每日一题
categories: WEB前端
copyright: true
date: 2021-01-12 15:41:25
top: true
tags: 题目
---
## 简介
记录前端需要掌握的知识点，通过答题进行巩固和提升。让自己的基础更牢固，原理更加熟识！！！
## 题目
1. vue的双向绑定原理是什么？
    <details>
    <summary>答案</summary>
    ```
    vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过ES5提供的Object.defineProperty()方法来劫持(监视)各个属性的setter,getter，在数据变动的时发布消息给订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送发送给绑定的视图，而不是对所有的数据都执行一次检测。
    具体的步骤：
    1. 需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上getter和setter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
    2. compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
    3. Watcher订阅者是Observer和compile之间通信桥梁，主要做的事情是：
        - 在自身实例化时往属性订阅器(dep)里面添加自己
        - 自身必须有一个update()的方法
        - 待属性变动dep.notice()通知的时候，能调用自身的update()方法，并触发compile中绑定的回调，则功成身退
    4. MVVM作为数据绑定的入口，整合observer、compile和watcher三者，通过observer来监听自己的model数据变化，通过compile来编译模板指令，最终利用watcher搭起的observer和compile之间的通信桥梁，达到数据变化---试图更新;视图交互变化(input)-->数据model变更的双向绑定效果

    版本比较： vue是基于依赖收集的双向绑定； 3.0版本之前使用Object.definePropetry,3.0新版使用Proxy

    1. 基于数据劫持/依赖收集 的双向绑定的优点
    不需要显示的调用，Vue利用数据劫持+发布订阅，可以直接通知变化并且驱动视图
    直接得到精确的变化数据，劫持了属性setter，当属性值改变，我们可以精确的获取变化的内容newValue，不需要额外的diff操作
    2. Object.defineProperty的缺点
    不能监听数组：因为数组没有getter和setter，因为数组长度不确定，如果太长性能负担太大
    只能监听属性，而不是整个对象，需要遍历循环属性
    只能监听属性变化，不能监听属性的删减
    3. proxy的好处
    可以监听数组
    监听整个对象不是属性
    13种来截方法，强大很多
    返回新对象而不是直接修改原对象，更符合immutable；
    4. proxy的缺点
    兼容性不好，而且无法用polyfill磨平；
    ```
    </details>
<!--more-->
    
2. Loader和Plugin的区别是什么
    <details>
    <summary>答案</summary>
    ```
    1. 作用不同：
    Loader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。
    Plugin直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。
    2. 用法不同：
    Loader在module.rules中配置，也就是说作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）
    Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。
    ```
    </details>
3. 请解释React中props和state的区别
    <details>
    <summary>答案</summary>
    ```
    1. props
    函数组件的props就是一个函数的入参组件
    类组件：this.props 包括被该组件调用或者定义的props
    2. state
    组件中的state包含了随时可以发生变化的数据
    state由用户定义，它是一个普通javascript对象
    3. 区别
    props是传递组件的(类似函数的形参)，而state是在组件内被组件自己管理的(类似在一个函数内声明变量)。
    props是不可修改的，所有React组件必须向纯函数一样保护它们的props不被更改
    state是在组件中创建的，一般在constructor中初始化state
    state是多变的、可修改的，每次setState都异步更新的
    ```
    </details>

4. 浏览器的本地存储的cookie了解多少
    <details>
    <summary>答案</summary>
    ```
    Cookie最开始被设计出来其实并不是做本地存储的，而是为了弥补http在状态管理上的不足
    http协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，这次事件就完成了，但是下次发请求如何让服务端直到客户端是谁呢？在这个需求下就产生了Cookie
    Cookie本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面版的Application这一栏可以看到)都会携带相同的Cookie，服务器拿Cookie进行解析，便能拿到客户端的状态 Cookie的作用就是用来做状态存储的，但是也有很多缺陷：
    1. 容量缺陷。Cookie的体积上限只有4KB，只能用来存储少量的信息
    2. 性能缺陷。Cookie紧跟域名，不管域名下面的某一个地址需不需要这个Cookie，请求都会携带上完整的Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容
    3. 安全缺陷。由于Cookie以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截取，然后进行一系列的篡改，在Cookie的有限期内重新发送给服务器，这是很危险的。另外，在HttpOnly为false的情况下，Cookie信息能直接通过js脚本来读取。
    ```
    </details>

5. 浏览器本地存储的WebStorate了解多少
    <details>
    <summary>答案</summary>
    ```
    WebStorage又可以分为localStorege和sessionStorage

    localStorage
    和Cookie异同：相同的一点是：针对一个域名，即在同一个域名下，会存储相同的一段localStorage

    区别：

    1. 容量：localStorage的容量上限为5M，相对于Cookie的4K大大增加。当然这个5M是针对一个域名的，因此对于一个域名是持久存储的
    2. 只存在客户端，默认不参与和服务端的通信。这样很好地避免了Cookie带来地性能问题和安全问题
    3. 接口封装。通过localStorage暴露在全局，并通过它的setItem和getItem等方法进行操作，非常方便。
    看看如何具体操作localStorage？

    ```
    let obj={name:"zhufeng",age:10};
    localStorage.setItem("name","zhufeng");
    localstorage.setItem("message",JSON.stringify(obj));
    //接着进入相同的域名时就能拿到相应的值：
    let name=localStorage.getItem("name");
    let info=JSON.parse(localStorage.getItem("info"))
    ```
    在这里能得到，localStorage其实存储的都是字符串，如果是存储对象需要调用JSON的stringify方法，并且用JSON.parse来解析成对象 应用场景：利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源，比如官网的logo，存储Base64格式的图片资源，因此要好好利用localStorage

    sessionStorage
    特点：sessionStorage和localStorage是一致的

    1. 容量。容量上限为5M
    2. 只存在客户端，默认不参与和服务端的通信
    3. 接口封装。除了sessionStorage名字有所变化，存储方式、操作方式均和localStorage一样
    但是sessionStorage和localStorage有一个本质的区别：前者只是会话级别的存储，并不是持久化存储。会话结束后也就是页面关闭，这部分sessionStorage就不存在了

    应用场景：
    1. 可以用它对表单信息进行维护，将表单信息存储存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
    2. 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用sessionStorage就再合适不过了。事实上微博采取这样的存储方式。
    ```
    </details>
    
6. 说一下vue-router的原理是什么
    <details>
    <summary>答案</summary>
    ```
    实现原理：vue-router的原理就是更新视图而不重新请求页面

    vue-router可以通过mode参数设置为三种模式：hash模式、history模式、abstract模式。

    1. hash模式 默认是hash模式，基于浏览器history api，使用window.addEventListener('hashchange',callback,false)对浏览器地址进行监听。当调用push时，把新路由添加到浏览器访问历史的栈顶。使用replace时，把浏览器访问历史的栈顶路由替换成新路由 hash的值等于url中#及其以后的内容。浏览器是根据hash值的变化，将页面加载到相应的DOM位置。锚点变化只是浏览器的行为，每次锚点变化后依然会在浏览器中留下一条历史记录，可以通过浏览器的后退按钮回到上一个位置

    2. History history模式，基于浏览器history api ，使用window.onpopstate对浏览器地址进行监听。对浏览器history api中的pushState()、replaceState()进行封装，当方法调用，会对浏览器的历史栈进行修改。从而实现URL的跳转而无需加载页面 但是他的问题在于当刷新页面的时候会走后端路由，所以需要服务端的辅助来兜底，避免URL无法匹配到资源时能返回页面

    3. abstract 不涉及和浏览器地址的相关记录。流程跟hash模式一样，通过数组维护模拟浏览器的历史记录栈 服务端下使用。使用一个不依赖于浏览器的浏览器历史虚拟管理后台

    4. 总结 hash模式和history模式都是通过window.addEvevtListenter()方法监听 hashchange和popState进行相应路由的操作。可以通过back、foward、go等方法访问浏览器的历史记录栈，进行各种跳转。而abstract模式是自己维护一个模拟的浏览器历史记录栈的数组
    ```
    </details>
    
7. 防抖节流原理、区别以及应用，请用js实现
    <details>
    <summary>答案</summary>
    #### 防抖
    ```
    原理：在时间被触发n秒之后再执行回调，如果在这n秒内又被触发，则重新计时

    适用场景：

    按钮提交场景：防止多次提交按钮，只执行最后提交的一次
    搜索框联想场景：防止联想发送请求，只发送最后一次输入
    ```
    //简易版实现
    function debounce(func,wait){
        let timeout;
        return function(){
            const context=this;
            const args=arguments;
            clearTimeout(timeout);
            timeout=setTimeout(() => {
                func.apply(context,args);
            }, wait);
        }
    }
    //立即执行版实现：有时候希望立刻执行函数，然后等到停止触发n秒后，才可以重新执行。
    function debound1(func,wait,immediate){
        let timeout;
        return function(){
            const context=this;
            const args=arguments;
            if(timeout) clearTimeout(timeout);
            if(immediate){
                const callNow=!timeout;
                timeout=setTimeout(() => {
                    timeout=null;
                }, wait);
                if(callNow) func.apply(context,args);
            }else{
                timeout=setTimeout(() => {
                    func.apply(context,args);
                }, wait);
            }
        }
    }

    //返回值版实现
    //func函数可能会有返回值，所以需要返回函数结果，但是当immediate为false的时候，因为使用了setTimeout，我们将func.apply(context,args)的返回值赋给变量，最后在return的时候，值将会一直是undefined，所以只在immediate为true的时候返回函数的执行结果
    function debounce2(func,wait,immediate){
        let timeout,result;
        return function(){
            const context=this;
            const args=arguments;
            if(timeout) clearTimeout(timeout);
            if(immediate){
                const callNow=!timeout;
                timeout=setTimeout(() => {
                    timeout=null;
                }, wait)
                if (callNow) result=func.apply(context,args);
            }else{
                timeout=setTimeout(() => {
                    func.apply(context,args);   
                }, wait);
            }
            return result;
        }
    }
    ```
    #### 节流：
    原理： 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效

    适用场景：

    拖拽场景：固定时间内只执行一次，防止高频次触发位置变动
    缩放场景：监控浏览器resize
    ```
    //使用时间戳实现:使用时间戳，当触发事件发生的时候，我们取出当前的时间戳，然后减去之前的时间戳（最开始设值为0），如果大于设置的时间周期，就执行函数，然后更新时间戳为当前时间戳，如果小于，就不执行 

    function throttle(func,wait){
        let context,args;
        let previous=0;
        return function(){
            let now=+new Date();
            context=this;
            args=arguments;
            if(now-previous > wait){
                func.apply(context,args);
                previous=now
            }
        }
    }
    //使用定时器实现：当触发事件的时候，我们设置一个定时器，在触发事件的时候，如果定时器存在，就不执行，知道定时器执行，然后执行函数，清空定时器，这样就可以设置下定时器
    function throttle1(func,wait){
        let timeout;
        return function(){
            const context=this;
            const args=arguments;
            if(!timeout){
                timeout=setTimeout(() => {
                    timeout=null;
                    func.apply(context,args);
                }, wait);
            }
        }
    }

    //区别:节流不管事件触发多频繁保证在一定时间内一定会执行一次函数。防抖是只在最后一次事件触发后才会执行一次函数
    // flag版本
    const throttle2=(func,wait)=>{
        let flag=true;
        return function(...args){
            if(!flag) return;
            flag=flase;
            setTimeout(() => {
                func.apply(this,args)
                flag=true;
            }, wait);
        } 
    }
    ```
    ```
    </details>
    
8. 在css中link和@import的区别是什么
    <details>
    <summary>答案</summary>
    ```
    1. 从属关系区别
    @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

    2. 加载顺序区别
    加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。

    3. 兼容性区别
    @import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。

    4. DOM可控性区别
    可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。

    5. 权重区别(该项有争议，下文将详解)
    link引入的样式权重大于@import引入的样式。
    ```
    </details>
9. 常见的loader以及作用的总结
    <details>
    <summary>答案</summary>
    ```
    raw-loader：加载文件原始内容（utf-8）
    file-loader：把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件
    url-loader:和file-loader类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中
    source-map-loader:加载额外的Source Map文件，以方便断点调试
    svg-inline-loader：将压缩后的 SVG 内容注入代码中
    image-loader：加载并且压缩图片文件
    json-loader 加载 JSON 文件（默认包含）
    handlebars-loader: 将 Handlebars 模版编译成函数并返回
    babel-loader：把ES6转化成ES5
    ts-loader: 将 TypeScript 转换成 JavaScript
    awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader
    css-loader：加载css，支持模块化、压缩、文件导入等特性
    style-loader：把css代码注入到js中，通过DOM操作去加载css
    eslint-loader：通过ESLint检查JS代码
    tslint-loader：通过 TSLint检查 TypeScript 代码
    postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀
    vue-loader：加载 Vue.js 单文件组件
    cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里
    ```
    </details>
10. 计算属性和普通属性的区别是什么
    <details>
    <summary>答案</summary>
    ```
    computed属性是vue计算属性，是数据层到视图层的数据转化映射； 计算属性是基于他们的依赖进行缓存的，只有在相关依赖发生改变时，他们才会重新求值，也就是说，只要他的依赖没有发生变化，那么每次访问的时候计算属性都会立即返回之前的计算结果，不再执行函数；

    computed是响应式的，methods并非响应式。
    调用方式不一样，computed的定义成员像属性一样访问，methods定义的成员必须以函数形式调用
    computed是带缓存的，只有依赖数据发生改变，才会重新进行计算，而methods里的函数在每次调用时都要执行。
    computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的
    computed不支持异步，当computed内有异步操作时无效，无法监听数据的变化
    如果声明的计算属性计算量非常大的时候，而且访问量次数非常多，改变的时机却很小，那就需要用到computed；缓存会让我们减少很多计算量。
    ```
    </details>
11. webpack中source map是什么？生产环境怎么用
    <details>
    <summary>答案</summary>
    ```
    source map是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。

    map文件只要不打开开发者工具，浏览器是不会加载的

    线上环境一般有三种处理方案：
    hidden-source-map：借助第三方错误监控平台Sentry使用
    nosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比source map高
    source：通过nginx设置将.map文件只对白名单开放(公司内网)
    注意的是：避免在生产中使用 inline- 和 eval- ，因为它们会增加bundle体积大小，并降低整体性能。
    ```
    </details>
12. 浏览器缓存机制对于开发很重要，强缓存的内容能了解多少呢？
    <details>
    <summary>答案</summary>
    ```
    强缓存： 浏览器中的缓存作用分为两个情况，一种是需要发送HTTP请求，一种是不需要发送 首先是检查强缓存，这个阶段不需要发送http请求 如何来检查呢？通过相应的字段来进行，但是说起这个字段就有意思啦 在http/1.0和http/1.1当中，这个字段是不一样的。在早期，也就是http/1.0时期，使用的是Expires，而http/1.1使用的是Cache-Contronl

    Expires
    Expries即过期的时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求

    Expires: Wed, 22 Nov 2020 08:30:00 GMT
    表示资源在2020年11月22号8点30分过期，过期了就得向服务端发送请求
    这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的，因此这种方式很快在后来的http/1.1版本就抛弃了。
    Cache-Control
    在http1.1中，采用了一个非常关键的字段：Cache-Control。 它和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age，比如这个例子：

    Cache-Control:max-age=3600
    代表这个响应返回后在3600秒，也就是一个小时之内可以直接使用缓存
    如果你觉得它只有max-age一个属性的话，那就想错了
    它其实可以组合非常多的指令，完成更多的场景的缓存判断，将一些关键的属性列举如下：
    public：客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存
    private：只有浏览器能缓存，中间的代理服务器不能缓存
    no-cache：跳过当前的强缓存，发送http请求，即直接进入协商缓存阶段
    no-store：非常简单粗暴，不进行任何形式的缓存
    s-maxage：这和max-age长得非常像，但是区别在于s-maxage是针对代理服务器的缓存时间。
    值得注意的是：当Expires和Cache-Control同时存在的话，Cache-Control会优先考虑 还存在一种情况是：当资源缓存时间超时了，也就是强缓存失效了，接下就要进入第二部分--协商缓存
    ```
    </details>
13. 介绍js全部数据类型，基本数据类型和引用数据类型的区别
    <details>
    <summary>答案</summary>
    ```
    一、JavaScript全部数据类型
    内置类型
    空值 null
    未定义 undefined
    布尔值 boolean
    数字 number
    字符串 string
    对象 object
    符号 symbol
    长整型 bigInt
    1.基本数据类型
    undefined null number boolean string symbol

    基本数据类型是按值访问的，就是说我们可以操作保存在变量中的实际的值
    
    1.1基本数据类型的值是不可变的
    
    1.2基本数据类型不可以添加属性和方法
    
    1.3基本数据类型的赋值是简单赋值
    
    1.4基本数据类型的比较是值的比较
    
    1.5基本数据类型是存放在栈区的
    
    2.引用类型
    
    JS中除了上面的基本类型之外就是引用类型了，也可以说是对象，比如：object array function data等
    
    2.1引用类型的值是可以改变
    2.2引用类型可以添加属性和方法
    2.3引用类型的赋值是对象引用
    2.4引用类型的标胶是引用的比较
    2.5引用类型是同时存在栈区和堆区的
    二、基本数据类型和引用数据类型的区别
    1.声明变量时不同的内存分配
    原始值：存储在栈(stack)中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。是因为这些原始类型占据的空间是固定的，所以可以将它们存储在较小的内存区域---栈中，这样存储便于迅速查询变量的值
    
    引用值：存储在堆(heap)中的对象。也就是说，存储在变量处的值是一个指针(point)，指向存储对象的内存地址。是因为引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查询的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。
    
    2.不同的内存分配机制也带来了不同的访问机制
    在js中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。而原始类型的值是可以直接访问到的。
    
    3.复制变量时的不同
    原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，它们只是拥有相同的value而已
    
    引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中同一个对象，他们中任何一个做出的改变都会反映在另一个身上。(需要理解的一点是：复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了)
    
    4.参数传递的不同(把实参复制给形参的过程)
    首先我们应该明确的一点是：ESCMAScript中所有函数的参数都是按值来传递的。 但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？这就是因为内存分配时的差别。
    
    原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响
    
    引用值：对象变量里面的值是这个对象在堆内存中的内存地址，这一点很重要！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因，因为它们都指向同一个对象。
    ```
    </details>
14. react-router里的link标签和a标签有什么区别
    <details>
    <summary>答案</summary>
    ```
    区别
    从最终渲染的DOM来看，这两者都是链接，都是a标签，区别是： Link标签是react-router里实现路由跳转的链接，一般配合Route使用，react-router接下了其默认的链接跳转行为，区别于传统的页面跳转，Link标签的"跳转"行为只会触发相匹配的Route对应的页面内容更新，而不会刷新整个页面

    Link标签做的三件事情：

    1.有onclick那就执行onclick
    2.click的时候阻止a标签默认事件
    3.根据跳转href(即使是to)，用history(web前端路由两种方式之一，history&hash)跳转，此时只是链接变了，并没有刷新页面
    而标签就是普通的超链接了，用于从当前页面跳转到href指向的里一个页面(非锚点情况)

    a标签默认事件禁掉之后做了什么才实现了跳转？
    let domArr=document.getElementByTagName('a');
    [...domArr].forEach(item=>{
        item.addEventListener('click',function(){
            location.href=this.href
        })
    })
    ```
    </details>
15. 能不能说一说XSS攻击
    <details>
    <summary>答案</summary>
    ```
    什么是XSS攻击？
    XSS全称是Cross Site Scripting[跨站脚本]，为了和css区分，故叫它xss。XSS攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息进行操作。

    这些操作一般可以完成下面这些事情 1.窃取Cookie 2.监听用户行为，比如输入账号密码后直接发送到黑客服务器 3.修改DOM伪造登录表单 4.在页面中生成浮窗广告

    通常情况下，XSS攻击的实现有三种方式 --- 存储型、反射型和文档型。原理比较简单，一一介绍

    存储型
    存储型，将恶意脚本存储了起来，确实，存储型的XSS将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果

    常见的场景是留言评论区提交一段代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中直接执行，相当于执行一段位置逻辑的js代码，是非常恐怖的。这就是存储型的xss攻击

    反射型
    反射型xss指的是恶意脚本作为网络请求的一部分 比如我输入

    http://baidu.com?q=
    这样在服务端会拿到q参数，然后将内容返回给浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样被攻击了

    之所以叫它反射型，是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后在反射到HTML文档中，执行解析。和存储型不一样的是：服务器并不会存储这些恶意脚本

    文档型
    文档型的XSS攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的html文档 这样的劫持方式包括wifi路由劫持或者本地恶意软件等

    防范措施
    明白三种xss攻击的原理，发现一个共同点：都是让恶意脚本直接能在浏览器中执行 那么要防范它，就是要避免这些脚本代码的执行 为了完成这一点，必须做到一个信念，两个利用。

    一个信念
    千万不要相信任何用户的输入！ 无论是在前端和服务端，都要对用户的输入进行转码或过滤

    如


    转码后变为：
    
    <script>alert('你完蛋了')</script>
    这样的代码在html解析的过程中是无法执行的 当然也可以利用关键词过滤的方式，将script标签给删除。那么现在的内容只剩下


    什么都没有
    
    利用CSP
    CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能： 1.限制其他域下的资源加载 2.禁止向其他域提交数据 3.提供上报机制，能帮助我们及时发现XSS攻击
    
    利用HttpOnly
    很多XSS攻击脚本都是用来窃取Cookie，而设置Cookie的HttpOnly属性后，JavaScript便无法读取Cookie的值，这样也很好的防范XSS攻击。
    
    总结
    xss攻击是指浏览器中执行恶意脚本，然后拿到用户的信息进行操作。主要分为存储型、反射型和文档型。防范的措施包括：
    
    一个信念：不要相信用户的输入，对输入的内容转码或者过滤，让其不可执行 两个利用:利用CSP,利用Cookie的HttpOnly属性
    ```
    </details>
16. 谈谈你对重绘和回流的理解
    <details>
    <summary>答案</summary>
    ```
    我们首先来回顾一下渲染流水线的流程: 图片链接：http://img.zhufengpeixun.cn/chonghui_1.png 
    接下来，我们将来以此为依据来介绍重绘和回流，以及让更新视图的另一种方式 -- 合成
    
    ![](https://gitee.com/wangyuan0108/image/raw/master/20210112175340.png)

    回流
    首先介绍回流，回流也叫重排

    触发条件
    简单来说:就是当我们对DOM结构的修改引发DOM几何尺寸变化的时候，会发生回流的过程 具体一点，有以下的操作会触发回流： 1.一个DOM元素的几何属性变化，常见的几何属性有width height padding margin left top border等等，这个很好理解 2.使DOM节点发生增减或者移动 3.读写offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作 4.调用window.getComputedStyle方法

    回流过程
    依照上面的渲染流水线，触发回流的时候，如果DOM结构发生改变，则重新渲染DOM树，然后将后面的流程(包括主线程之外的任务)全部走一遍。 图片链接：http://img.zhufengpeixun.cn/chonghui_2.png
    ![](https://gitee.com/wangyuan0108/image/raw/master/20210112175438.png)
    相当于将解析和合成的过程重新又走了一遍，开销是非常大的
    
    重绘
    触发条件
    当DOM的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)

    重绘过程
    由于没有导致DOM几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。流程如下： 图片链接：http://img.zhufengpeixun.cn/chonghui_3.png
    ![](https://gitee.com/wangyuan0108/image/raw/master/20210112175602.png)
    跳过了生成布局树和建图层树的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作
    
    可以看到，重绘不一定导致回流，但回流一定发生了重绘

    合成
    还有一种情况，是直接合成。比如利用CSS3的transform opacity filter这些属性就可以实现合成的效果，也就是大家所说的GPU加速

    GUP加速的原因
    在合成的情况下，会直接跳到布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理，交给它处理有两大好处：
    
    1.能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进程加速生成，而GPU是擅长处理位图数据的 2.没有占用主线程的资源，即使主线程卡住啦，效果依然能够流畅地展示
    ```
    </details>
17. 简单说下你理解的语意化，怎样来保证你写的符合语意化？HTML5语意化标签了解下
    <details>
    <summary>答案</summary>
    ```
    很多时候我们写HTML，为了方便都会直接使用div和span标签，在通过class来确定具体样式。网站哪一部分为标题，哪一部分为导航，哪一部分为头部和尾部，都只能通过class来进行确定。 但是class命名规范却又没有一套统一的标准，依次导致很多时候无法确定整体网站的结构 因此，在HTML5出现后，添加了关于页面布局结构的新标签。而在html书写过程中，根据不同的内容使用合适的标签进行开发，即为语义化。

    在编程中，语义指的是一段代码的含义(这个HTML的元素有什么作用，扮演了什么样的角色)。HTML语义元素清楚地向浏览器和开发者描述其意义，例如form、table以及img等

    1.优点：对搜索引擎友好，有了良好的结构和语义，网页内容自然容易被搜索引擎抓取
    2.HTML5新增语义元素 article aside details figcaption figure footer> header main mark nav section summary time
    3.为什么要语义化？
    语义化的优势主要在于以下几点：
    其他开发者便于阅读代码，通过不同标签明白每个模块的作用和区别
    结构明确、语义清晰的页面能有更好的用户体验，在样式(css)没有加载前也有较为明确的结构，更如img这一类的，在图片无法加载的情况下有alt标签告知用户此处图片的具体内容；
    利于seo，语义化便于搜索引擎爬虫理解，和搜索引擎建立良好的沟通，能让爬虫爬取更多关键有效的信息
    方便其他设备阅读(如屏幕阅读器，盲人设备和移动设备等)
    4.如何语义化？
    一般的网站分为头部、导航、文章(或其他模块)、侧栏、底部，根据不同的部位，使用不同的标签进行书写。
    表示页面不同位置的标签：header、nav、article、section、footer、aside
    表示具体元素的作用或者意义的标签：a、abbr、address、audio、blockquote、caption、code、datalist、del、detail、ol、ul、figure、figuration、img、input、mark、p等
    - 尽可能少的使用无语义的标签div和span
    - 在语义不明显时，既可以使用div或者p时，尽量用p，因为p在默认情况下有上下间距，对兼容特殊终端有利；
    - 不要使用纯样式标签，如b、font、u等，改用css设置
    - 需要强调的文本，可以包含在strong或者em标签中(浏览器预设样式，能用css指定就不用他们)，strong默认样式是加粗(不要加b)，em是斜体(不用i)
    - 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，，单元格用td
    - 表单域要用fieldset标签包起来，并用legend标签说明表单的用途
    - 每个input标签对应的说明文件都需要使用label标签。并且通过input设置为id属性，在label标签中设置for=someld来让说明文本和相对应的input关联起来
    5.注意点： em、strong、dfn、code、samp、kbd、var、cite等，虽然这些标签定义的文本大多会呈现处特殊的样式，但实际上，这些标签都拥有确切的语义 我们并不反对使用它们，但是如果您只是为了达到某种视觉效果而使用这些标签的话，我们建议您可以使用样式表，那么做会达到更加丰富的效果。
    ```
    </details>
    
18. 常见的plugin以及作用的总结
    <details>
    <summary>答案</summary>
    ```
    define-plugin：定义环境变量(Webpack4 之后指定 mode 会自动配置)
    ignore-plugin：忽略部分文件
    commons-chunk-plugin：提取公共代码
    html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)
    web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用
    uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)
    terser-webpack-plugin: 支持压缩 ES6 (Webpack4)
    mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)
    webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度
    serviceworker-webpack-plugin：为网页应用增加离线缓存功能
    clean-webpack-plugin: 目录清理
    ModuleConcatenationPlugin: 开启 Scope Hoisting
    speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)
    webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)
    ```
    </details>
    
19. 能不能说一说CSRF攻击
    <details>
    <summary>答案</summary>
    ```
    ## 什么是CSRF

    CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

    ## 一个典型的CSRF攻击有着如下的流程：

    * 受害者登录a.com，并保留了登录凭证（Cookie）。
    * 攻击者引诱受害者访问了b.com。
    * b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。
    * a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
    * a.com以受害者的名义执行了act=xx。
    * 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

    ## 几种常见的攻击类型

    * GET类型的CSRF
    * POST类型的CSRF
    * 链接类型的CSRF

    ## CSRF的特点

    * 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
    * 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
    * 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
    * 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

    CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。

    ## 防护策略

    CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。

    上文中讲了CSRF的两个特点：

    * CSRF（通常）发生在第三方域名。
    * CSRF攻击者不能获取到Cookie等信息，只是使用。

    针对这两点，我们可以专门制定防护策略，如下：

    * 阻止不明外域的访问
    * 同源检测
    * Samesite Cookie
    * 提交时要求附加本域才能获取的信息
    * CSRF Token
    * 双重Cookie验证
    ```
    </details>
    
20. css伪类和伪元素区别
    <details>
    <summary>答案</summary>
    ```
    1.伪类(pseudo-classes)
    其核心就是用来选择DOM树之外的信息，不能够被普通选择器选择的文档之外的元素，用来添加一些选择器的特殊效果
    比如 :hover :active :visited :first-child :focus :lang等
    由于状态的变化是非静态的，所以元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又失去这个样式
    由此看可以看出，它的功能和class有些类似，但是它是基于文档之外的抽象，所以叫伪类
    2.伪元素(pseudo-elements)
    DOM树没有定义的虚拟元素
    核心就是需要创建通常不存在于文档的元素
    比如::before ::after 选择的是元素指定内容，表示选择元素内容的之前的内容或之后内容
    伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于文档中，所以称为伪元素。用于将特殊的效果添加到某些选择器
    3.两者区别
    表示方法
    css2中伪类、伪元素都是单冒号：表示
    css2.1后规定伪类用单冒号表示，伪元素用双冒号::表示
    浏览器同样接受css2时代已经存在的伪元素(:before :after :first :line :first-letter等)的单冒号写法
    css2之后所有新增的伪元素(::selection)，应该采用双冒号的写法
    css3中，伪类与伪元素在语法上也有所区别，伪元素修改以::开头。浏览器对以:开头的伪元素也继续支持，但建议规范书写为::开头
    定义不同
    伪类即假的类，可以添加类来达到效果
    伪元素即假元素，需要通过添加元素才能到达效果
    总结
    伪类和伪元素都是用来表示文档树之外的"元素"
    伪类和伪元素分别用单冒号:和双冒号::来表示
    伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)
    是否需要添加元素才能达到效果，如果是则是伪元素，反之是伪类
    4.相同之处
    伪类和伪元素都不会出现在源文件和DOM树中。也就是说在html源文件中是看不到伪类和伪元素的
    不同之处
    伪类其实就是基于普通DOM元素而产生的不同状态，他是DOM元素的某一特征
    伪元素能够创建在DOM树中不存在的抽象对象，而且这些抽象对象是能够访问到的
    ```
    </details>
    
21. Vuex和localStorage的区别是什么
    <details>
    <summary>答案</summary>
    ```
    1.最重要的区别
    vuex存储在内存
    localstorage以文件的方式存储在本地
    localstorage只能存储字符串类型的数据，存储对象需要JSON的stringify和parse方法进行处理。读取内存比读取硬盘速度要快

    2.应用场景
    vuex是一个转为为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用域组件之间的传值
    localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用的
    vuex能做到数据的响应式，localstorage不能做到
    3.永久性
    刷新页面时vuex存储的值会丢失，localstorage不会丢失
    很多人觉得用localstorage可以代替vuex，对于不变的数据确实可以，但是是当两个组件公用一个数据源(对象或数组)时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因在区别1那里
    ```
    </details>
    
22. 浏览器缓存机制对于开发很重要，协商缓存的内容能了解多少呢
    <details>
    <summary>答案</summary>
    ```
    协商缓存
    强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag来决定是否使用缓存，这就是协商缓存 具体来说，这样的缓存tag分为两种：Last-Modified和ETag。这两者各有优劣之分，并不存在谁对谁有绝对的优势

    Last-Modified
    最后的修改时间。在浏览器第一次给服务器发送请求时，服务器会在响应头中加上这个字段 浏览器接收到后，如果再次请求，会在请求头中携带if-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间 服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比： 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的http请求响应的流程一样 否则返回304，告诉浏览器直接用缓存

    ETag
    ETag是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发送给服务器 服务器接接收到If-None-Match后，会跟服务器上该资源的ETag进行对比： 如果两者不一样，说明要更新了。返回新的资源，跟常规的http请求响应的流程一样 否则返回304，告诉浏览器直接用缓存

    两者对比：
    1.在精准度上，ETag优于Last-Modified。优于ETag是按照内容给资源上标识，一次能准确感知资源的变化。而Last-Modified就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况
    编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效
    Last-Modified能够感知的单位时间是秒，如果文件在1秒内改变了多次，那么这时候的Last-Modified并没有体现出修改了
    2.在性能上，Last-Modified由于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而ETag需要根据文件的具体内容生成哈希值

    另外，如果两种方式都支持的话，服务器优先考虑ETag
    ```
    </details>
23. 说一下事件循环机制（node 浏览器）
    <details>
    <summary>答案</summary>
    ```
    1. 为什么会有Event Loop?
    JS的任务分为两种：同步和异步，他们的处理方式也各自不同，同步任务是直接放在主线程上排队依次执行，异步任务会放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓存区，任务下一步会被移到调用栈然后主线程执行调用栈的任务

    调用栈：调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出

    JS是单线程的，单线程是指js引擎中解析和执行js代码的线程只有一个(主进程)，每次只能做一件事情，而ajax请求中，主线程在等待响应的过程中回去做其他事情，浏览器先在事件注册ajax的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说js处理ajax请求方式是异步的

    综上所述，检查调用栈是否为空以及讲某个任务添加到调用栈中的过程就是event loop，这就是JS实现异步的核心

    2. 浏览器中的Event Loop
    Micro-Task 与 Macro-Task 浏览器端事件循环中的异步队列有两种：macro(宏任务)队列和micro(微任务)队列 常见的macro-task:setTimeout、setInterval、script(整体代码)、I/O操作、UI渲染等 常见的micro-task：new Promise().then(回调)、MutationObserve等

    requestAnimationFrame requestAnimationFrame也属于异步执行的方法，但是该方法既不属于宏任务也不属于微任务，按照MDN定义：

    window.requestAnimationFrame()告诉浏览器---希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行 requestAnimationFrame是GUI渲染之前执行，但是在Micro-Task之后，不过requestAnimationFrame不一定会在当前帧必须执行，由浏览器根据当前的策略自行决定在哪一帧执行

    >Event Loop过程
    1.检查macro-task是否为空，非空到达2，为空到达3
    2.执行macro-task中的一个任务
    3.继续检查micro-task队列是否为空，若是空到达4，否则是到达5
    4.取出micro-task中的任务执行，执行完成返回到达3
    5.执行视图更新
    当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。

    3. node中的Event Loop

    node中的Event Loop和浏览器中的是完全不相同的东西。node.js采用v8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一件基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是这里面的实现

    1.v8引擎解析JS脚本

    2.解析后的代码，调用node API

    3.libuv库负责node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop(事件循环)，以异步的方式将任务的执行结果返回给V8引擎

    4.v8引擎在将结果返回给用户

    六大阶段
    其中libuv引擎中的事件循环分为六个阶段，它们会按照顺序反复运行。每当进入一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一个阶段

    1.timer阶段：这个阶段执行timer(setTimeout、setInterval)的回调，并且是由poll阶段控制的
    2.I/O callbacks阶段：处理一些上一轮循环中的少数未执行的I/O回调
    3.idle,prepare阶段：仅node内部使用
    4.poll阶段：获取新的I/O事件，适当的条件下node将阻塞在这里
    5.check阶段：执行setImmediate()的回调
    6.close callbacks阶段：执行socket的close事件回调
    poll阶段
    poll是一个至关重要的阶段，这一阶段中，系统会做两件事情 1.回到timmer阶段执行回调 2.执行I/O回调，并且在进入该阶段时如果没有设定timer的话，会发生以下两件事情

    >如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者到达系统限制
    >如果 poll 队列为空时，会有两件事发生
    如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
    如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去 当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。
    Micro-Task 与 Macro-Task
    Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。

    常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等
    常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等
    setTimeout 和 setImmediate
    二者非常相似，区别主要在于调用时机不同。

    setImmediate 设计在poll阶段完成时执行，即check阶段
    setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行
    setTimeout(function timeout () {
    console.log('timeout');
    },0);
    setImmediate(function immediate () {
    console.log('immediate');
    });
    1.对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。 2.首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调 3.如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了

    process.nextTick
    这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行

    4. node与浏览器的Event Loop差异
    Node端，microtask 在事件循环的各个阶段之间执行
    浏览器端，microtask 在事件循环的 macrotask 执行完之后执行
    ```
    </details>
24. webpack的构建流程是什么
    <details>
    <summary>答案</summary>
    ```
    webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程

    初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数
    开始编译：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译；
    确定入口：根据配置中的entry找出所有的入口文件；
    编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，在递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
    完成模块编译：在经过第四步使用loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
    输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
    输出完成：再确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统
    在以上系统中，webpack会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用webpack提供的API改变webpack的运行结果
    ```
    </details>
25. import和commonJs在webpack打包过程中有什么不同
    <details>
    <summary>答案</summary>
    ```
    1.es6模块调用commonjs模块
    可以直接使用commonjs模块，commonjs模块将不会被webpack的模块系统编译而是原样输出，并且commonjs模块没有default属性

    2.es6模块调用es6模块
    被调用的es6模块不会添加{esModule:true}，只有调用者才会添加{esModule:true}，并且可以进行tree-shaking操作，如果被调用的es6模块只是import进来，但是并没有被用到，那么被调用的es6模块将会被标记为/* unused harmony default export */，在压缩时此模块将被删除(如果被调用的es6模块里有立即执行语句，那么这些语句将会被保留)

    3.commonjs模块引用es6模块
    es6模块编译后会添加{__esModule:true}。如果被调用的es6模块中恰好有export default语句，那么编译后的es6模块将会添加default属性

    4.commonjs模块调用commonjs模块
    commonjs模块会原样输出
    ```
    </details>
26. dev-server是怎么跑起来的
    <details>
    <summary>答案</summary>
    ```
    dev-server运行配置
    安装webpack-dev-server的npm包
    在webpack.config.js进行配置
    devServer中常用的配置对象属性如下：

    1.contentBase:"./" 本地服务器在哪个目录搭建页面，一般在当前目录即可
    2.historyApiFallback：true 搭建spa应用时会用到。它使用的时HTML5 History Api，任意的跳转或404响应可以指向index.html页面
    3.inline：true 用来支持dev-server自动刷新的配置，webpack有两种模式支持自动刷新，一种是iframe模式，一种是inline模式；使用iframe模式是不需要在devServer进行配置的。只需使用特定的URL格式访问即可；不过我们一般还是常用inline模式，在devServer中对inline设置为true后，当启动webpack-dev-server时仍需要配置inline才能生效
    4.hot:true 启动webpack热模块替换特性
    5.port 端口号(默认8080)
    怎么跑起来的
    1.启动HTTP服务
    2.webpack构建时输出Bundle到内存，HTTP服务从内存中读取Bundle文件
    3.监听文件变化，重新执行第二个步骤
    dev-server 实际上是一个HTTP服务器，所以还可以做静态资源的访问和API的Proxy代码

    1.静态资源访问

    {
        devServer:{
            contentBase:'public'
        }
    }
    2.Proxy代理

    {
        devServer:{
            proxy:{
                '/api':{
                    target:'http://api.target.com'
                }
            }
        }
    }
    ```
    </details>
27. 如何实现webpack持久化缓存
    <details>
    <summary>答案</summary>
    ```
    服务端设置HTTP缓存头(Cache-Control等)
    打包依赖(dependencies)和运行时(runtime)到不同chunk(在webpack中，编译后的单独文件称为chunk)，即作splitChunk，因为它们几乎是不变的
    延迟加载：使用import()方式，可以动态加载的文件分到独立的chunk，以得到自己的chunkhash
    保证hash值稳定：编译过程和文件内容的更改尽量不影响其他文件hash的计算。对于低版本webpack生成的增量数字ID不稳定问题，可用HashedModuleldsPlugin基于文件路径生成解决
    ```
    </details>
28. webpack热更新的原理
    <details>
    <summary>答案</summary>
    ```
    基础概念
    1.webpack compiler：将js编译成Bundle 2.Bundle Server：提供文件在浏览器的访问，实际上就是一个服务器 3.HMR Server：将热更新的文件输出给HMR Runtime 4.HMR Runtime：会注入到bundle.js中，与HRM Server通过webSocket链接，接收文件变化，并更新对应文件 5.bundle.js：构建输出的文件

    原理
    1.启动阶段

    webpack Compiler将对应文件打包成bundle.js(包含注入的HMR Server)，发送给Bundler Server
    浏览器即可访问服务器的方式去获取bundle.js
    2.更新阶段(文件发生变化)

    webpack compiler重新编译，发送给HMR Server
    HMR Server可以知道有哪些资源、哪些模块发生了变化，通知HRM Runtime
    HRM Runtime更新代码
    HMR原理详解
    使用webpack-dev-server去启动本地服务，内部实现只要使用了webpack、express、websocket

    使用express启动本地服务，当浏览器访问资源时对此响应
    服务端和客户端使用websocket实现长连接
    webpack监听源文件的变化，即当开发者保存文件时触发webpack的重新编译
    每次编译都会生成hash值，已改动模块的json文件、已改动模块代码的js文件
    编译完成后通过socket向客户端推送当前编译的hash戳
    客户端的websocket监听到有文件改动推送过来的hash戳，会和上一次对比
    一直就走缓存
    不一致就通过ajax和jsonp向服务端获取最新资源
    使用内存文件系统去替换有修改的内容实现局部刷新
    1.server端

    启动webpack-dev-server服务器
    创建webpack实例
    创建server服务器
    添加webpack的done事件回调
    编译完成向客户端发送消息
    创建express应用app
    设置文件系统为内存文件系统
    添加webpack-dev-middleware中间件
    中间件负责返回生成的文件
    启动webpack编译
    创建http服务器并启动服务
    使用sockjs在浏览器端和服务端之间建立一个websocket长连接
    创建socket服务器
    2.client端

    webpack-dev-server/client端会监听到此hash消息
    客户端收到ok消息后会执行reloadApp方法进行更新
    在reloadApp中会进行判断，是否支持热更新，如果支持的话发生webpackHotUpdate事件，如果不支持就直接刷新浏览器
    在webpack/hot/dev-server.js会监听webpackHotUpdate事件
    在check方法里会调用module.hot.check方法
    HotModuleReplacement.runtime请求Manifest
    通过调用JsonpMainTemplate.runtime的hotDownloadManifest方法
    调用JsonpMainTemplate.runtime的hotDownloadUpdateChunk方法通过JSONP请求获取最新的模块代码
    补丁js取回来或会调用JsonpMainTemplate.runtime.js的webpackHotUpdate方法
    然后会调用HotModuleReplacement.runtime.js的hotAddUpdateChunk方法动态更新模块代码
    然后调用hotApply方法进行热更新
    ```
    </details>
29. 浏览器的缓存机制对于开发很重要，缓存位置的内容能了解多少呢
    <details>
    <summary>答案</summary>
    ```
    缓存位置
    当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那么这些资源究竟缓存在什么位置呢？

    浏览器中的缓存位置一共有四种：按优先级从高到第排列分别是：
    Service Worker
    MEmory Cache
    Disk Cache
    Push Cache
    Service Worker
    Service Worker借鉴了Web Worker的思路，既让js运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽是如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是Service Worker Cache

    Memory Cache和Disk Cache
    Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。 Disk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是它的优势在于存储容量和存储时长。

    那浏览器如何决定将资源放进内存还是硬盘呢？
    比较大的js、css文件会直接被丢进磁盘，反之丢进内存
    内存使用率比较高的时候，文件优先进入磁盘
    Push Cache
    推送缓存，是一种低级的网络功能-使用网络堆栈的任何东西都可以使用它，有用的关键是一致性和可预测性，这是浏览器缓存的最后一道防线，它是http/2中的内容，虽然现在应用的并不广泛，但随着http/2的推广，它的应用越来越广泛。

    对浏览器的缓存机制来做个总结
    首先强缓存可用，直接使用
    否则进入协商缓存，即发送HTTP请求，服务器通过请求头中的If-Modified-Since或者If-None-Match字段检查资源是否更新
    若资源更新，返回资源和200状态码
    否则返回304，告诉浏览器直接从缓存获取资源
    ```
    </details>
30. webpack打包时的Hash码是怎样生成的？随机值存在一样的情况，如何避免
    <details>
    <summary>答案</summary>
    ```
    1.Hash值
    webpack生态中存在多种计算hash的方式

    hash
    chunkhash
    contenthash
    hash代表每次webpack编译中生成的hash值，所有使用这种方式的文件hash都相同。每次构建都会使webpack计算新的hash。 chunkhash基于入口文件及其关联的chunk生成，某个文件的改动只会影响与它有关联的chunk的hash值，不会影响其他文件 contenthash根据文件内容创建。当文件内容发生变化时，contenthash发生变化

    2.避免相同随机值
    webpack在计算hash后分割chunk。产生相同随机值可能是因为这些文件属于同一个chunk，可以将某一个文件提到独立的chunk(如放入entry)
    ```
    </details>
31. 如何加快页面的渲染速度，都有哪些方式
    <details>
    <summary>答案</summary>
    ```
    > 1.静态资源的优化
    主要是减少静态资源的加载时间，只要包括html、js、css和图片

    a.减少http请求数：合并js、css、制作雪碧图以及使用http缓存

    b.减少资源的大小：压缩图片、压缩文件、小兔使用base64编码

    c.异步组件和图片懒加载

    d.CDN加速和缓存(bootCND):客户端可通过最佳的网络链路加载静态资源，提高访问的速度和成功率。(CDN:通过在网络各处放置节点服务器构成的一层智能虚拟网络，可将用户的请求重新导向离用户最近的服务节点上)

    2.接口访问的优化

    a.http持久连接(Conention:keep-alive)

    b.后端优化和并请求(比如在进入一个商品详情页的时候后端会提供一个接口获取商品的基本信息，然后当用户点击加入购物车时)

    c.数据接口缓存到localStorage，减少请求

    3.页面渲染速度的优化

    a.由于浏览器的js引擎线程和GUI渲染线程是互斥的，所以在执行js的时候会阻塞它的渲染，所以一般会将css放到顶部，优先渲染，js在底部

    b.减少dom操作

    c.使用虚拟dom渲染方案，做到最小化操纵真实的dom

    d.事件代理：利用事件冒泡原理，把函数注册到父级元素上

    e.减少页面的重绘和回流
    ```
    </details>
32. HTTP请求特征是什么
    <details>
    <summary>答案</summary>
    ```
    支持客户-服务器模式
    简单快速：客户向服务器请求服务时，只需传送方法和路径。请求方法常用的有GET、POST、HEAD。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因此通信速度很快
    灵活：HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记
    无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
    无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要前面信息时应答会很快。
    ```
    </details>
33. react里组件通信有几种方式，分别怎样进行通信
    <details>
    <summary>答案</summary>
    ```
    react组件间通信常见的几种情况：
    父组件向子组件通信
    子组件向父组件通信
    跨级组件通信
    非嵌套关系的组件通信
    1.父组件向子组件通信：父组件通过props向子组件传递需要的信息
    //子组件Child
    const Child = props => {
        return 
    {props.name} 


    }
    //父组件Parent
    const Parent=()=>{
        return 
    }
    2.子组件向父组件通信：props+回调的方式
    //子组件Child
    const Child=props=>{
        const cb=msg=>{
            return ()=>{
                props.callback(msg)
            }
        }
        return (
            sunny
        )
    }

    //父组件 Parent
    class Parent extends Component{
        callback(msg){
            console.log(msg);
        }
        render(){
            return 
        }
    }
    3.跨级组件通信：即父组件向子组件的子组件通信，向更深子组件通信
    // 使用props，利用中间组件层层传递，但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。
    //使用context,context相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现


    //context方式实现跨级组件通信
    //context设计目的是为了共享那些对于一个组件而言是"全局"的数据
    const BatteryContext=createContext();
    //子组件的子组件
    class GrandChild extends Component{
        render(){
            return(
                
                    {
                        color=>
    红色的：{{color}}

                    }
                
            )
        }
    }


    //子组件
    const Child=()=>{
        return(
            
        )
    }
    //父组件
    class Parent extends Component{
        state={
            color:'red'
        }
        render(){
            const {color}=this.state
            return(
                
                    
                
            )
        }
    }
    4.非嵌套关系的组件通信：既没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件
    1)可以使用自定义事件通信(发布订阅模式)
    2)可以通过redux等进行全局状态管理
    3)如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点，结合父子间通信方式进行通信
    ```
    </details>
34. 说一下栈和堆的区别，垃圾回收时栈和堆的区别
    <details>
    <summary>答案</summary>
    ```
    一、堆和栈的区别

    1、存放的数据不同

    堆中存放对象，需要手动释放内存。（垃圾回收机制）

    栈中存放局部变量，内存的释放是系统控制实现的。（局部变量的存活时间是这个函数调用完之后）

    2、空间大小不一样

    堆的空间大，栈的空间小

    二、垃圾回收机制（主要针对堆和方法区）

    1、使用目的：避免发生内存泄漏和内存溢出的情况，使得系统能更好地使用内存。（在JVM中，程序计数器是唯一一个没有规定任何OOM的区域）       

    2、垃圾回收机制的对象：堆和方法区中的对象。

    3、垃圾回收机制什么时候进行：垃圾回收机制运行不确定，由JVM确定，在运行时是间歇执行的。

    4、垃圾回收机制如何确定对象？（可达性分析）

    垃圾回收机制有个Root对象（栈（包括虚拟机栈和本地方法栈）中的引用对象，方法区中的静态变量、常量的引用对象），在对对象进行可达性分析时就是判断对象与Root之间是否有直接或间接引用。根据相关的引用判断对象是否会被回收，如果判断对象应该被回收，则查看对象是否重写了finalize（）方法或是是否已经调用过finalize（）方法，若对象没有重写方法，或者已经调用过方法了，则回收对象；否则，对象进去队列中，等待执行自己的finalize()方法。

    {  a、垃圾回收机制中的引用

            强引用：只要引用存在，垃圾回收机制就不会回收。

            软引用：用来描述一些有用，但不是必须的引用，在系统将要发生内存溢出异常之前，把弱引用对象作为第二次垃圾回收的对象。它起到一个缓存作用，当内存足够时，通过弱引用查询数据，当内存不足时，自动删除这部分数据，并且从真实数据来源查询数据。

            弱引用：在下一次垃圾回收机制启动时，一定会被删除的对象。用于查看弱引用监控对象是否被标记为即将回收的垃圾（isEnQueued()）

            虚引用：对象被回收时收到一个系统通知。用于检测对象是否已经从内存中删除。

    b、final、finally、finalize的区别：

            final是一个修饰符，final修饰的类不能被继承，因此不能与抽象类同时使用。final修饰的变量不可变，final修饰的方法不可重写。（子类可以使用父类的final方法，但是不能重写）

            finally是在异常处理之后要执行的清除任务，例如垃圾回收之类的。

            finalize是垃圾回收机制在回收对象之前要做的操作，对象可能在执行finalize中“起死回生”。

    }

    5、垃圾处理方法：标记-清除，标记-整理，复制

    标记-清除：标记阶段：通过可达性分析，标记与Root相连的对象，未标记的为垃圾对象。

                    清除阶段：将未标记的对象清除

    标记-整理：标记阶段：通过可达性分析，标记与Root相连的对象（有直接引用和间接引用），未标记的为垃圾对象。

                    整理阶段：将所有标记了的对象整理压缩到内存的一段，之后清除边界所有空间

    复制：将内存空间分为两部分，使用其中一部分，在垃圾回收时，将使用部分的存活对象复制到未使用的空间中，并清除使用部分的空间。

    三者的区别：时间复杂度：标记-清除>标记-整理>复制

                        内存利用率：标记-整理=标记-清除>复制（只使用一半）

                        内存整齐度：标记-整理=复制>标记清除

    垃圾回收机制有哪些？（老年代、新生代）

    针对老年代和新生代使用Full GC,老年代回收使用标记-整理/标记-清除的方式。（标记-整理：单线程、多线程收集器。标记-清除：CMS(并行)）

    针对新生代使用Minor GC,使用复制算法，如果空间不够（对象较大），可以直接进入老年代。

    分代回收：G1回收器（并行）

    { 单线程是指：垃圾回收线程只有一个在运行。

    多线程是指：垃圾回收线程有多个在运行。

    串行、并行：用户程序与垃圾收集器交替执行-串行。用户程序与垃圾收集器同时执行-并行。（Parallel Scavenge（并行清除）、CMS、G1）

    新生代：Serial（单线程）、ParNew(多线程)、Parallel Scavenge(并行多线程。目的：达到一个可控制的吞吐量。其他垃圾收集器主要关注缩短用户程序停顿时间。缩短用户程序停顿时间是以牺牲新生代空间和吞吐量为代价的，新生代空间少，垃圾回收频繁，用户程序停顿时间整体变多，吞吐量变小（吞吐量：用户程序运行时间在整体程序运行时间所占比重）)

    老年代：Serial Old 、Parallel Old、CMS(使用标记-清除的垃圾处理方法，目的：用户程序停顿时间小（则吞吐量小）。四大步骤：1、初始标记（标记与Root直接联系的）2、并发标记（在运行时标记与Root有关的对象）3、重新标记（修改由于用户程序运行而发生变化的对象）4、并发清除)

    分代回收：G1（整体：标记-整理，局部：复制）目的：可预测的停顿时间。将堆分成大小独立的区域。将原来的整个空间划分成小空间，可以针对小空间进行垃圾回收。系统针对每个空间大小和回收该空间所停顿的时间会维护一个列表，可以根据这个列表选择要回收的区域。此外，每一个区域都有一个Rememberbe Set,用来记录区域中对象的引用对象所在的区域。四大步骤：1、初始标记 2、并发标记 3、最终标记：程序运行过程中，将对象的引用变化记录在线程的Rememberbe Set Logs中，最终标记阶段负责将Rememberbe Set Logs放入到Rememberbe Set中。筛选回收：根据列表选择符合自己要求的区域进行回收。

    }

    三、有内存回收策略（垃圾回收机制）就必定有内存分配策略（堆）

    1、大多数情况，新生代在Eden上分配，如果空间不够，会发生Minor GC。

    2、大对象、长期存活的对象直接进入老年代。

    3、对象年龄动态判断。对象达到某一存活时间就进入老年代，这个时间可以动态改变。当空间中，某一存活时间的对象空间多于总空间的一半，则将这一空间的对象放入老年代。

    4、空间分配担保。如果在进行Minor GC之前，老年代的最大可用连续空间大于新生代所以对象的总空间，则执行。若不大于，就要检查HandlePromotionFailure是否允许担保，如果允许，就查看老年代最大连续空间是否大于以前晋升到老年代的对象的平均大小，如果大于，则执行，如果小于或者不允许担保，执行Full GC。

    （引起Full GC的条件：不允许空间担保、老年代空间不足、CMS使用标记-清除算法，会造成空间碎片，导致空间不足）

    四、在new一个对象时，需要在分配内存之前，先进行类的加载

    java中的所有类需要类加载器加载到JVM中，才可以运行。

    类的加载过程：加载：JVM获取相关信息，并在内存中生成一个该类的对象，作为数据访问的入口

                            验证：保证Class文件的字节流中的信息符合虚拟机的要求，不会损害虚拟机的安全

                            准备：为类变量（static修饰的变量）分配内存（方法区内存）并设置初始值。（注：实例变量在对象实例化时，随着对象一起分配到堆中）

                            解析：将常量池的符号引用，变为直接引用的过程。（将语义信息与具体操作相连接）（实现JAVA动态绑定，可以将解析放在初始化之后）

                        初始化：真正执行类中定义的java程序。初始化发生时机：主动引用（new）、被动引用(引用方式不会触发初始化，子类引用父类的静态字段，子类不会初始化)

    两个类相等：类本身相等，还是用同一类加载器加载。

    类加载器的分类：启动类加载器（负责将lib目录下的类加载到虚拟机内存中）、

                                扩展类加载器（负责将lib/ext目录下的文件加载到内存中）、

                                应用程序类加载器（负责将自己的java代码编译成class文件加载到内存中）

    类加载器之间的层次关系：双亲委派模型（一个类加载器首先将类加载请求发给父类加载器，只有当父类加载器无法加载，自己才加载，避免了类的重复加载）

    

    三、内存泄漏、内存溢出定义，什么原因导致的？

    1）所谓内存溢出（OOM）就是，程序申请内存空间，但是得不到足够的空间。

        内存泄漏就是：程序申请内存空间之后，无法释放已申请的内存空间，例如有老年代指向这个对象，则在对象使用完之后，无法释放该对象的空间，出现内存泄漏。

    2）原因：使用静态集合类hashmap Set Vector，HashMap中的对象为空，不能回收对象，必须将HashMap设置为空，才能回收对象

                    监听器，在释放连接时要删除监听器。

                    物理连接：数据库与网络的连接需要显示关闭。数据库连接一般使用DataSource.getConnection()，需要使用close()关闭。

                    内部类与外部模块的引用

                    单例模式，单例的存活周期是jvm整个生命周期，如果它引用一个短生命的对象，则这个对象无法释放空间，会发生内存泄漏。
    ```
    </details>
35. 布局都有什么方式，float和position有什么区别
    <details>
    <summary>答案</summary>
    ```
    布局方式

    1.静态块级 2.弹性布局(flex) 3.网络布局(grid) 4.自适应布局(根据当前访问设备进行多套样式来适配) 5.响应式布局(通过媒体查询进行适配，rem/em) 6.浮动布局(float) 7.定位布局(position)

    float和position有什么区别？

    >float：none left right inherit
    特性：

    浮动会脱离文档流，并且会随着分辨率和窗口尺寸的变化而变化
    浮动后面的元素如果是块级元素，会占据块级元素的文本位置，但会与块级元素背景和边框重叠
    多个浮动不会产生重叠现象
    会将块级元素和行内元素变为行内块元素
    >position：relative absolute fixed static 
    特性
    relative和static不会脱离文档流
    absolute和fixed会脱离文档流
    absolute根据relative定位。fixed根据body定位
    absolute和fixed会触发BFC
    定位的优先级高于浮动
    ```
    </details>
36. 请用js代码实现事件代理
    <details>
    <summary>答案</summary>
    
    </details>
37. 对虚拟dom的理解？虚拟dom主要做了什么？虚拟dom本身时什么
    <details>
    <summary>答案</summary>
    ```
    什么是虚拟DOM?
    从本质上来说，Virtual Dom是一个JS对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。

    虚拟dom是对DOM的抽象，这个对象是更加轻量级的对DOM的描述。它设计的最初目的，就是更好的跨平台，比如node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟dom，因为学你dom本身就是js对象。在代码渲染到页面之前，vue或者react会把代码转换成一个对象(虚拟DOM)。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。

    在vue或者react内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。

    另外现代前端框架的一个基本要求就是无需手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发正写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提升开发效率

    为什么要用Virtual Dom？
    1.保证性能下限，再不进行手动优化的情况下，提供能过得去的性能
    看一下页面渲染的一个过程

    解析HTML --- 生成DOM --- 生成cssDom -- Layout -- Paint -- Compiler

    下面对比一下修改DOM时真实DOM操作和Virtual Dom的过程，来看一下它们重排重绘的性能消耗

    真实DOM：生成HTML字符串+重建所有的DOM元素
    Virtual Dom：生成VNode+DOMDiff+必要的dom更新 Virtual Dom的更新DOM的准备工作耗费更多的时间，也就是js层面，相对于更多的DOM操作它的消费是极其便宜的。尤大大曾说到：框架给你的保证时，你不需要手动优化的情况下，我依然可以给你提供过得去的性能
    2.跨平台
    Virtual Dom本质上时JS对象，可以很方便的跨平台操作，比如服务端渲染、uniapp等

    Virtual Dom真的比真实DOM性能好么？
    1.首次渲染大量DOM时，由于多了一层虚拟DOM的计算，比innerHTML插入慢
    2.正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的
    ```
    </details>
38. 移动端需要注意什么
    <details>
    <summary>答案</summary>
    
    </details>
39. 响应式布局用到的技术有几种方式
    <details>
    <summary>答案</summary>
    ```
    方案一：百分比布局
    利用对属性设置百分比来适配不同屏幕，注意这里的百分比是相对于父元素； 能够设置的属性有 width、height、padding、margin，其他属性比如 border、font-size 不能用百分比设置的
    方案二：使用媒体查询 (CSS3 @media 查询)
    利用媒体查询设置不同分辨率下的css 样式，来适配不同屏幕
    方案三.rem 响应式布局
    当前页面中元素的rem 单位的样式值都是针对于html 元素的font-size 的值进行动态计算的，所以有两种方法可以达到适配不同屏幕：
    方案四.vw 响应式布局
    根据 PSD 文件宽度或高度作为标准，元素单位 px 转换为 vw 或 vh，比如font-size: 12px，PSD 文件宽度 375，转换公式 12 * 100 / 375，则样式改为font-size: 3.2vw，下面是我经常使用的工具，有利于提高转换效率。
    方案五.flex 弹性盒子布局
    利用 flex 属性来适配不同屏幕，下图利用简单的属性实现栏目响应式
    ```
    </details>
40. 词法作用域和this的区别
    <details>
    <summary>答案</summary>
    ```
    js只有词法作用域没有动态作用域
    词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本都够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它进行查找。
    eval()，with可以“欺骗“词法作用域，会导致代码运行变慢，不要使用它们
    需要明确的是，事实上，javascript并不具有动态作用域，它只有词法作用域，简单明了，但是this机制某种程度上很像动态作用域
    ```
    </details>
41. 介绍React高阶组件，适用于什么场景
    <details>
    <summary>答案</summary>
    ```
     React高阶组件不是组件，是接收一个wrapperComponent组件作为参数，对wrapperComponent组件做包装处理，添加额外的props属性，最终返回一个新组建的函数；
    * 高阶组件主要有两种形式：属性代理和反向继承；
    * 属性代理： 
        *  1）其实就是接收一个组件当参数，返回一个有状态(类组件)或者无状态(纯函数)的新组件(添加了额外的新属性) 
        *  2）属性代理可以做到：操作props,抽离state,通过ref可以访问到wrapperComponent组件实例
    * 反向继承： 
        *  1）其实就是一个函数接收一个wrapperComponent参数，返回一个继承了wrapperComponent组件的子类(子组件)，且在子组件的render()方法中返回的 super.render()方法； 
        *  2）反向继承可以做到：操作state,渲染劫持
    * 公共点： 属性代理和反向继承的实现有些类似的地方，都是返回一个继承了某个父类的子类，只不过属性代理中继承的是 React.Component，反向继承中继承的是传入的组件 WrappedComponent。
    * 高阶组件应用场景： 
        *  1）代发复用 
        *  2）权限控制(页面级别和页面元素级别)  
        *  3）组件渲染性能追踪，监控组件的渲染时间 
        *  4）数据校验 
        *  5）错误统一处理
    ```
    </details>
42. 说一下vue的keep-alive是如何实现的，具体缓存的是什么
    <details>
    <summary>答案</summary>
    ```
    - props:
    include 字符串或者表达式   只有名称匹配的组件才会被匹配
    exclude 字符串或者表达式  任何匹配的都不会被缓存
    max 最多合一缓存多少组件实例

    > keep-alive 包裹动态组件时 会缓存失活的组件实例

    ##### 实现流程：
        1.判断组件`name`,不在include或者exclude中直接返回 vnode，说明该组件不被缓存
        2.获取组件实例的key， 如果有获取实例的key ,赋值重新生成
        3.key 生成规则： cid+"::"+tag 
        4： 如果缓存对象存在， 直接从缓存中读取组件实例给vnode ，否则 添加到缓存对象中
        5： 最大缓存处理： 当缓存组件超过max时，清除keys数组内第一个组件(LRU缓存淘汰)


    ##### render函数： 
        1.会在keep-alive组件内部写自己的内容，所以可以去获取默认的solt内容，然后根据这个区获取组件
        2.keep-alive 默认只对第一个组件有效，所以获取的时第一个子组件
        3.和keep-alive搭配一起使用的一般有：`动态组件`和`router-view`

        keep-alive 具体是通过cache数组缓存所有组件的vnode实例，当cache内原有组件被使用时，会将key从keys中山湖。然后push到`keys`数组最后，以便清除掉最不常用的组件


    ##### 步骤总结：
        1.获取到keep-alive下的第一个子组件的实例对象，通过它获取组件的name
        2.通过组件name去匹配 原来的include和exclude，判断当前组件是否需要被缓存，不需要，直接返回当前组件 的实例的vnode
        3.需要缓存：判断它当前是否在缓存数组里面，存在则将其原来位置上的key给移除，同时，将该组件的key放到数组的最后面
        4.不存在： 将key放入数组，然后判断当前key数组的是否超过max的范围，超过，削减未使用时间最长的一个组件的key值
        5.最后将组件的keepAlive属性置为true


        keep-alive组件本身的创建过程和patch过程
            缓存渲染的时候，会根据vnode.componentinstance(首次渲染时undefined)和keepAlive属性 判断不会执行组件的createed，mounted等钩子函数，而是对缓存的组件执行patch过程：
            **直接将缓存的DOM对象直接插入到目标元素中，完成了数据更新情况下的渲染过程**

        首次渲染：
            组件的首次渲染：判断组件的abstract属性，才往父组件里面挂载dom
            判断当前的keepAlive和componentInstance是否存在，来判断是否要 执行prepatch还是执行创建coponentinstance
            prepatc操作就不会执行组件的mounted和created钩子函数，而是直接将DOM插入

    ##### LRU缓存淘汰策略
    从内存中追踪出最长时间未使用的数据，并置换新的数据
    使用链表保存缓存数据：
        1.新数据插入到链表头部
        2.每当缓存命中（缓存数据被访问），将数据移动到头部
        3.链表慢的时候，将链表尾的数据丢弃
    ```
    </details>
43. 请描述下css盒模型基本概念
    <details>
    <summary>答案</summary>
    ```
    标准模型和IE模型的区别：计算高度和宽度的不同。

    css如何设置这两种模型：

    box-sizing:content-box;

    box-sizing:border-box;


    盒子的大小
    盒子的大小指的是盒子的宽度和高度。大多数初学者容易将宽度和高度误解为width和height属性，然而默认情况下width和height属性只是设置content（内容）部分的宽和高。盒子真正的宽和高按下面公式计算：

    盒子的宽度 = 内容宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距
    
    盒子的高度 = 内容高度 + 上填充 + 下填充 + 上边框 + 下边框 + 上边距 + 下边距

    盒子的宽度 = width + padding-left + padding-right + border-left + border-right + margin-left + margin-right
    
    盒子的高度 = height + padding-top + padding-bottom + border-top + border-bottom + margin-top + margin-bottom

    box-sizing属性值
    
    content-box：默认值，width和height属性分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距、边框、外边距。
    
    border-box：为元素设定的width和height属性决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去 边框 和 内边距 才能得到内容的宽度和高度。
    
    inherit：规定应从父元素继承box-sizing属性的值


    当box-sizing：content-box时，这种盒子模型成为标准盒子模型，当box-sizing: border-box时，这种盒子模型称为IE盒子模型。
    ```
    </details>
44. React组件中怎么做事件代理？它的原理是什么
    <details>
    <summary>答案</summary>
    ```
    ### 如何做事件代理：
    - 事件管理中心(bankForRegistrationName)会在react-render过程中保存所有所有dom事件
    - document作为事件委托者，用来分发事件(dispatchEvent),通过dom节点唯一标识(_debugID)去事件管理(bankForRegistrationName)触发事件
    ### 原理
    - 1、React 借鉴事件委托的方式将大部分事件委托给了 Document 对象。
    - 2、React 中的事件分为 3 类。分别是 DiscreteEvent（离散事件），UserBlockingEvent（用户阻塞事件），ContinuousEvent（连续事件）。不同类型的事件代表了不同的优先级。
    - 3、事件委托需要区分捕获和冒泡，有些事件由于没有冒泡过程，只能在捕获阶段进行事件委托。
    - 4、没有进行委托的事件是 Form 事件和 Media 事件，原因是这些事件委托后会触发两次回调函数。
    ### React 使用了合成事件，它的好处是：
    - 1、合成事件做了浏览器的兼容处理
    - 2、React 想通过 SyntheticEvent 实现跨平台事件机制。
    - 3、原生事件升级、改造，比如 React 的 onChange 事件，它为表单元素定义了统一的值变动事件，例如 blur、change、focus、input 等。
    ```
    </details>
45. Promise构造函数是同步还是异步执行，then呢？
    <details>
    <summary>答案</summary>
    
    </details>
46. 说一下mobx盒redux有什么区别
    <details>
    <summary>答案</summary>
    
    </details>
47. css预处理器的概念
    <details>
    <summary>答案</summary>
    
    </details>
48. shouldComponentUpdate是为了解决什么问题
    <details>
    <summary>答案</summary>
    
    </details>
49. react里setState到底是异步还是同步

50. react-redux的工作流程是什么

51. 添加原生事件不移除为什么会内存泄漏，还有哪些地方会存在内存泄漏

52. 怎么处理项目中的异常捕获行为

53. 点击一个按钮，浏览器会做些什么事情

54. promise有没有解决异步的问题

55. css预处理器的好处

56. 与http相关的协议有哪些？tcp/ip dns uri/url https

57. cdn有哪些优化静态资源加载速度的机制

58. 说说你理解的node中间层怎样做的请求合并转发

59. webpack做了什么？使用webpack构建时有无做了一些自定义操作

60. webapck如何用localStorage离线缓存静态资源

61. 使用import时，webpack对node_modules里的依赖会做什么

62. 关于vue项目进行优化，你有哪些方法

63. 为什么组件中的data必须是一个函数，然后return一个对象，而new Vue实例里，data可以直接是一个对象

64. redux和vuex有什么区别，说一下他们的共同思想

65. 说一下react.Component和react.PureComponent的区别

66. 说一下你对react context的理解

67. 说一下mysql和mongodb的区别

68. webpack里面的插件是如何实现的

69. 使用ts的优势有哪些

70. 直接给一个数组项赋值，vue能检测到变化吗

71. vue组件间的通信有哪几种方式

72. 项目如何管理模块

73. 在那个生命周期内调用异步请求

74. 说明一下js封装的原理

75. 回调函数和任务队列的区别

76. 写出常用的页面优化实现方案

77. 请你谈谈对无状态的理解（react部分）

78. 如何理解事件委托

79. BFC是什么？触发BFC的条件是什么？有哪些应用场景

80. 说一下单向数据流有什么好处

81. React怎么做数据检查和变化

82. 类数组转化为数组

83. 说一下关于tree-shaking的原理

84. vue中的key有什么作用

85. 说一下vue的父组件和子组件生命周期钩子函数执行顺序

86. 使用过vue ssr吗？说说ssr

87. 什么情况下出现浏览器分层（css部分）

88. 说明下js继承的原理

89. 说一下vue单页和多页的区别

90. 说一下vue的$nextTick的原理

91. v-model是如何实现的，语法糖实际是什么

92. 怎样理解vue的单向数据流

93. react ssr实现过程

94. react ssr实现原理是什么，需要注意什么事项

95. 子组件可以直接改变父组件的数据吗？说说你的理由（vue部分）

96. 能说下vue-router中常用的hash和history路由模式实现原理吗？

97. 实现数组去重

98. 描述下js中的prototype的概念

99. 实现数组扁平化

100. react事件绑定原理是什么

101. 为什么不建议使用通配符初始化css样式

102. 说一下koa2和express区别

103. link标签定义

104. 渲染过程中遇到js文件怎么处理（浏览器解析过程）

105. Object.is()与原来的比较操作符"==="、"=="的区别

106. 三种事件模型是什么

107. doctype的作用是什么

108. iframe有哪些缺点

109. 说说你对浏览器的理解

110. 谈谈你对ajax的理解

111. 简单介绍使用图片base64编码的优点和缺点

112. 请说出目前主流的js模块化实现的技术有哪些？他们的区别在哪

113. for in和Object.keys的区别

114. 哪些操作会造成内存泄漏

115. 什么是浏览器的同源策略

116. 说一下你理解的margin重叠的问题

117. display、position和float的相互关系

118. 前端需要注意哪些seo

119. 说一下html布局元素的分类有哪些？以描述下每种布局元素的应用场景

120. 网页验证码是干嘛的，是为了解决什么安全问题

121. 简单说下v8引擎的垃圾回收机制

122. 说一说对json的理解

123. 渲染页面是常见的不良现象有哪些（浏览器渲染过程）

124. componentWillReceiveProps的触发条件是什么

125. javascript代码中的“use strict”是什么意思？为什么使用它

126. 什么是polyfill

127. 说一下vue的什么周期以及每个阶段做的事情

128. 你所理解，同步和异步的区别是什么

129. js创建对象的几种方式

130. 说一下你所理解js中的作用域与变量声明提升

131. 内部属性[[class]]是什么

132. 检测浏览器版本有哪些方式

133. react高阶组件、render props和hooks有什么区别，为什么不断迭代？

134. 说一下vue template到render的过程

135. 如何解决跨域问题

136. margin和padding分别适合什么场景使用

137. css多列等高如何实现

138. 如何处理HTML5新标签的浏览器兼容问题

139. 介绍一下你对浏览器内核的理解

140. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的

141. 说一下你所理解的渲染原理

142. 如何判断一个对象是否属于某个类

143. 什么事dom和bom

144. css选择符有哪些

145. 标准模式和兼容模式各有什么区别

146. css如何阻塞文档解析（浏览器解析过程）

147. 说一下你所了解的js的作用域链

148. domContentLoaded事件和Load事件的区别

149. Symbol值的强制类型转换

150. HTML5有哪些新特性、移除了哪些元素

151. 说一下对DTD的理解

152. SGML、HTML、XML和XHTML的区别

153. 常见的浏览器内核

154. 什么是文档预解析

155. js继承的几种实现方式

156. react key 是干什么用的，为什么要加上key

157. 说一下你理解的https中间人攻击

158. 说一下你所理解的观察者模式

159. 无

160. 说一下你所了解的fiber

161. 什么是函数柯里化

162. 异步编程的实现方式是什么

163. 说一下import的原理，和require的不同之处在哪儿

164. 使用Object.defineProperty()来进行数据劫持有什么缺点

165. 面向对象的三要素是什么，分别是什么意思？