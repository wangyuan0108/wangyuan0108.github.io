<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>忆</title>
  
  <subtitle>平凡之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://water.buging.cn/"/>
  <updated>2023-08-01T06:26:37.602Z</updated>
  <id>https://water.buging.cn/</id>
  
  <author>
    <name>Water</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>好用的node包汇总</title>
    <link href="https://water.buging.cn/2023/08/01/%E5%A5%BD%E7%94%A8%E7%9A%84node%E5%8C%85%E6%B1%87%E6%80%BB/"/>
    <id>https://water.buging.cn/2023/08/01/好用的node包汇总/</id>
    <published>2023-08-01T14:23:16.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下面是一个<a href="https://github.com/huaize2020/awesome-nodejs" rel="external nofollow noopener noreferrer" target="_blank">开源项目</a>收集整理的一些很有用、很酷的 Node.js 包。强烈推荐给大家。喜欢的话，别忘了去 <a href="https://github.com/huaize2020/awesome-nodejs" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 上 star 哦。<a id="more"></a></p><h2 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h2><ul><li><a href="https://github.com/expressjs/express" rel="external nofollow noopener noreferrer" target="_blank">Express</a> - Web应用程序框架，为构建单页和多页以及混合Web应用程序提供了一组强大的功能。</li><li><a href="https://github.com/zeit/next.js" rel="external nofollow noopener noreferrer" target="_blank">Next.js</a> - React服务端渲染框架。</li><li><a href="https://github.com/blitz-js/blitz" rel="external nofollow noopener noreferrer" target="_blank">blitz</a> - 全栈 React 框架——建立在 Next.js 之上。</li><li><a href="https://github.com/meteor/meteor" rel="external nofollow noopener noreferrer" target="_blank">Meteor</a> - 超简单，无处不在的数据库，在线数据，纯Javascript Web框架。 <em>（你也许会喜欢 <a href="https://github.com/Urigo/awesome-meteor" rel="external nofollow noopener noreferrer" target="_blank">awesome-meteor</a>)</em></li><li><a href="https://github.com/nuxt/nuxt.js" rel="external nofollow noopener noreferrer" target="_blank">Nuxt.js</a> - Vue服务端渲染框架。</li><li><a href="https://github.com/nestjs/nest" rel="external nofollow noopener noreferrer" target="_blank">Nest</a> -受Angular启发的框架，用于构建高效且可扩展的服务器端应用程序。<em>(你也许会喜欢 <a href="https://github.com/juliandavidmr/awesome-nestjs" rel="external nofollow noopener noreferrer" target="_blank">awesome-nestjs</a>)</em></li><li><a href="https://github.com/cellbang/malagu" rel="external nofollow noopener noreferrer" target="_blank">Malagu</a> - Malagu 是基于 TypeScript 的 Serverless First、可扩展和组件化的应用框架。</li><li><a href="https://github.com/koajs/koa" rel="external nofollow noopener noreferrer" target="_blank">Koa</a> - 由Express背后的团队设计的框架，旨在为Web应用程序和API提供更小，更富表现力和更强大的基础。</li><li><a href="https://github.com/balderdashy/sails" rel="external nofollow noopener noreferrer" target="_blank">sails</a> - Node.js实时MVC框架。</li><li><a href="https://github.com/fastify/fastify" rel="external nofollow noopener noreferrer" target="_blank">Fastify</a> - 快速和低开销的Web框架。</li><li><a href="https://github.com/hapijs/hapi" rel="external nofollow noopener noreferrer" target="_blank">Hapi</a> - 用于创建应用和服务的框架。</li><li><a href="https://github.com/eggjs/egg" rel="external nofollow noopener noreferrer" target="_blank">Egg</a> - 为企业级框架和应用而生。</li><li><a href="https://github.com/feathersjs/feathers" rel="external nofollow noopener noreferrer" target="_blank">Feathers</a> - 基于Express精神构建的微服务框架。</li><li><a href="https://github.com/strongloop/loopback" rel="external nofollow noopener noreferrer" target="_blank">LoopBack</a> - 用于创建REST API并轻松连接到后端数据源的强大框架。</li><li><a href="https://github.com/restify/node-restify" rel="external nofollow noopener noreferrer" target="_blank">Restify</a> - 使你能够构建正确的REST Web服务。</li><li><a href="https://github.com/thinkjs/thinkjs" rel="external nofollow noopener noreferrer" target="_blank">ThinkJS</a> - 支持ES2015 +的框架，WebSockets，REST API。</li><li><a href="https://github.com/midwayjs/midway" rel="external nofollow noopener noreferrer" target="_blank">Midway</a> - 一个面向未来的云端一体 Node.js 框架。</li><li><a href="https://github.com/totaljs/framework" rel="external nofollow noopener noreferrer" target="_blank">total.js</a> - 使用纯JavaScript编写的Node.js框架，类似PHP’s Laravel或Python’s Django或ASP.NET MVC</li><li><a href="http://adonisjs.com/" rel="external nofollow noopener noreferrer" target="_blank">AdonisJs</a> - 基于依赖注入和IoC容器的坚实基础构建的Node.js的真正MVC框架。</li><li><a href="https://github.com/zeit/micro" rel="external nofollow noopener noreferrer" target="_blank">Micro</a> - 具有异步方法的简约微服务框架。</li><li><a href="https://moleculer.services/" rel="external nofollow noopener noreferrer" target="_blank">Moleculer</a> - 快速而强大的微服务框架。</li><li><a href="https://github.com/19majkel94/type-graphql" rel="external nofollow noopener noreferrer" target="_blank">TypeGraphQL</a> - 使用类和装饰器使用TypeScript创建GraphQL API的现代框架。</li><li><a href="https://github.com/senecajs/seneca" rel="external nofollow noopener noreferrer" target="_blank">seneca</a> - 编写微服务的工具包。</li><li><a href="https://github.com/alibaba/beidou" rel="external nofollow noopener noreferrer" target="_blank">beidou</a> - NodeJS &amp; React 同构框架，基于Egg.js开发。</li><li><a href="https://github.com/marblejs/marble" rel="external nofollow noopener noreferrer" target="_blank">Marble.js</a> - 基于TypeScript和RxJS，用于构建服务端应用的函数响应式框架。</li><li><a href="https://github.com/actionhero/actionhero" rel="external nofollow noopener noreferrer" target="_blank">ActionHero</a> - 用于为TCP套接字，WebSocket和HTTP客户端制作可重用和可扩展的API的框架。</li><li><a href="https://github.com/ladjs/lad" rel="external nofollow noopener noreferrer" target="_blank">lad</a> - 最好的Node.js框架，由前Express和Koa团队成员创建。</li><li><a href="https://github.com/talentlessguy/tinyhttp" rel="external nofollow noopener noreferrer" target="_blank">Tinyhttp</a> - 类Express更现代更快的Web框架。</li><li><a href="https://github.com/darukjs/daruk" rel="external nofollow noopener noreferrer" target="_blank">daruk</a> - 基于 typescript 的 Node.js web 框架。</li><li><a href="https://github.com/hemerajs/hemera" rel="external nofollow noopener noreferrer" target="_blank">Hemera</a> - 使用以下工具编写可靠且容错的微服务 <a href="https://nats.io/" rel="external nofollow noopener noreferrer" target="_blank">NATS</a>。</li><li><a href="https://github.com/BackendStack21/restana" rel="external nofollow noopener noreferrer" target="_blank">restana</a> - 用于构建REST微服务的超快速和简约的框架。</li><li><a href="https://github.com/sfast/zeronode" rel="external nofollow noopener noreferrer" target="_blank">Zeronode</a> - 最小的构建块，可实现可靠且容错的微服务。</li></ul><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><ul><li><a href="https://github.com/serverless/serverless" rel="external nofollow noopener noreferrer" target="_blank">serverless</a> - 无服务器框架 – 使用 AWS Lambda、Azure Functions、Google CloudFunctions 等无服务器架构构建 Web、移动和 IoT 应用程序。</li><li><a href="https://github.com/cellbang/malagu" rel="external nofollow noopener noreferrer" target="_blank">Malagu</a> - Malagu 是基于 TypeScript 的 Serverless First、可扩展和组件化的应用框架。云厂商不锁定，目前支持 阿里云函数计算、腾讯云云函数、AWS Lambda、Verce 等等。</li><li><a href="https://github.com/midwayjs/midway" rel="external nofollow noopener noreferrer" target="_blank">Midway</a> - 一个面向未来的云端一体 Node.js 框架。</li></ul><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ul><li><p><strong>通用</strong></p></li><li><p><a href="https://github.com/dmnd/dedent" rel="external nofollow noopener noreferrer" target="_blank">dedent</a> - ES6模板字符串函数，用于去除多行字符串的缩进。</p></li><li><a href="https://github.com/sindresorhus/camelcase" rel="external nofollow noopener noreferrer" target="_blank">camelcase</a> - 将破折号/点号/下划线/空格分隔的字符串转换为驼峰式, 案例：foo-bar→fooBar。</li><li><a href="https://github.com/sindresorhus/string-width" rel="external nofollow noopener noreferrer" target="_blank">string-width</a> - 获取字符串的可视宽度-显示字符串所需的列数。</li><li><a href="https://github.com/sindresorhus/decamelize" rel="external nofollow noopener noreferrer" target="_blank">decamelize</a> - 将驼峰式字符串转化成小写带分隔符带字符串, 案例：unicornRainbow → unicorn_rainbow</li><li><a href="https://github.com/sindresorhus/detect-indent" rel="external nofollow noopener noreferrer" target="_blank">detect-indent</a> - 检查代码缩进。</li><li><a href="https://github.com/sindresorhus/string-length" rel="external nofollow noopener noreferrer" target="_blank">string-length</a> - 获取字符串的真实长度 - 通过正确计算星号并忽略ansi转义码。</li><li><a href="https://github.com/sindresorhus/strip-indent" rel="external nofollow noopener noreferrer" target="_blank">strip-indent</a> - 将字符串每一行中前置的空格删除。</li><li><a href="https://github.com/sindresorhus/strip-bom" rel="external nofollow noopener noreferrer" target="_blank">strip-bom</a> - 从字符串中删除UTF-8字节顺序标记（BOM）。</li><li><a href="https://github.com/sindresorhus/indent-string" rel="external nofollow noopener noreferrer" target="_blank">indent-string</a> - 将字符串每一行缩进。</li><li><a href="https://github.com/sindresorhus/redent" rel="external nofollow noopener noreferrer" target="_blank">redent</a> - 去除多余的缩进并缩进字符串。</li><li><a href="https://github.com/sindresorhus/normalize-newline" rel="external nofollow noopener noreferrer" target="_blank">normalize-newline</a> - Normalize the newline characters in a string to <code>\n</code>.</li><li><a href="https://github.com/jamiebuilds/min-indent" rel="external nofollow noopener noreferrer" target="_blank">min-indent</a> - 取每一行最少前置空格数。</li><li><a href="https://github.com/sindresorhus/trim-right" rel="external nofollow noopener noreferrer" target="_blank">trim-right</a> - 与 String#trim() 类似，但仅删除右侧的空格。</li><li><a href="https://github.com/sindresorhus/splice-string" rel="external nofollow noopener noreferrer" target="_blank">splice-string</a> - 移除或替换字符串的一部分。类似<code>Array#splice</code>.</li></ul><ul><li><strong>国际化</strong></li></ul><ul><li><a href="https://github.com/i18next/i18next" rel="external nofollow noopener noreferrer" target="_blank">i18next</a> - 国际化框架。</li><li><a href="https://github.com/mashpie/i18n-node" rel="external nofollow noopener noreferrer" target="_blank">i18n-node</a> - 具有动态JSON存储的简单翻译模块。</li><li><a href="https://github.com/nodeca/babelfish" rel="external nofollow noopener noreferrer" target="_blank">babelfish</a> - 适用于JavaScript的人性化i18n（node.js +浏览器）。</li></ul><ul><li><strong>唯一ID</strong></li></ul><ul><li><a href="https://github.com/ai/nanoid" rel="external nofollow noopener noreferrer" target="_blank">nanoid</a> - 小巧、安全、URL友好、唯一的字符串ID生成器。</li><li><a href="https://github.com/uuidjs/uuid" rel="external nofollow noopener noreferrer" target="_blank">uuid</a> - 在JavaScript中生成符合RFC规范的UUID。</li><li><a href="https://github.com/dylang/shortid" rel="external nofollow noopener noreferrer" target="_blank">shortid</a> - 短ID生成器。 网址友好。 不可预测的。 集群兼容。</li><li><a href="https://github.com/ulid/javascript" rel="external nofollow noopener noreferrer" target="_blank">ulid</a> - 通用唯一词典分类排序标识符。</li><li><a href="https://github.com/pnegri/uuid-js" rel="external nofollow noopener noreferrer" target="_blank">uuid-js</a> - 用于生成和解析 UUID、TimeUUID 并根据日期生成 TimeUUID 以供范围选择。</li><li><a href="https://github.com/rse/pure-uuid" rel="external nofollow noopener noreferrer" target="_blank">pure-uuid</a> - 基于纯JavaScript全局唯一ID(UUID)。</li></ul><ul><li><strong>编码/解码</strong></li></ul><ul><li><a href="https://github.com/mathiasbynens/he" rel="external nofollow noopener noreferrer" target="_blank">he</a> - HTML实体编码器/解码器。</li><li><a href="https://github.com/ashtuchkin/iconv-lite" rel="external nofollow noopener noreferrer" target="_blank">iconv-lite</a> - 转换字符编码。</li><li><a href="https://github.com/aadsm/jschardet" rel="external nofollow noopener noreferrer" target="_blank">jschardet</a> - JavaScript编码自动识别 (Python版chardet的实现)。</li></ul><ul><li><strong>差异对比</strong></li></ul><ul><li><a href="https://github.com/kpdecker/jsdiff" rel="external nofollow noopener noreferrer" target="_blank">jsdiff</a> - 一种JavaScript文本差异实现。</li><li><a href="https://github.com/cosmicanant/recursive-diff" rel="external nofollow noopener noreferrer" target="_blank">recursive-diff</a> - 查找两个JavaScript对象的差异，支持数组、数字、日期和其他原始数据类型。</li></ul><ul><li><strong>其他</strong></li></ul><ul><li><a href="https://github.com/kurolabs/stegcloak" rel="external nofollow noopener noreferrer" target="_blank">StegCloak</a> - 基于纯JavaScript开发的隐写功能模块，StegCloak可以对文本中的机密信息进行压缩和加密，然后再使用特殊的Unicode不可见字符来隐藏它。</li><li><a href="https://github.com/nodeca/unhomoglyph" rel="external nofollow noopener noreferrer" target="_blank">unhomoglyph</a> - 规范视觉上相似的unicode字符。</li></ul><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul><li><a href="https://github.com/adamwdraper/Numeral-js" rel="external nofollow noopener noreferrer" target="_blank">Numeral.js</a> - 格式化和操作数字。</li><li><a href="https://github.com/MikeMcl/bignumber.js" rel="external nofollow noopener noreferrer" target="_blank">bignumber.js</a> - 用于任意精度十进制和非十进制算术的 JavaScript 库。</li><li><a href="https://github.com/MikeMcl/decimal.js" rel="external nofollow noopener noreferrer" target="_blank">decimal.js</a> - JavaScript的任意精度的十进制类型。</li><li><a href="https://github.com/MikeMcl/big.js" rel="external nofollow noopener noreferrer" target="_blank">big.js</a> - 一个小型，快速的JavaScript库，用于任意精度的十进制算术运算。</li><li><a href="https://github.com/sindresorhus/round-to" rel="external nofollow noopener noreferrer" target="_blank">round-to</a> - 将数字四舍五入到指定的小数位数：<code>1.234</code>→1.2`。</li><li><a href="https://github.com/sindresorhus/unique-random" rel="external nofollow noopener noreferrer" target="_blank">unique-random</a> - 生成连续唯一的随机数。</li><li><a href="https://github.com/sindresorhus/random-int" rel="external nofollow noopener noreferrer" target="_blank">random-int</a> - 生成随机整数。</li><li><a href="https://github.com/sindresorhus/random-float" rel="external nofollow noopener noreferrer" target="_blank">random-float</a> - 生成随机浮点数。</li></ul><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><ul><li><a href="https://github.com/josdejong/mathjs" rel="external nofollow noopener noreferrer" target="_blank">mathjs</a> - 广泛的数学运算库。</li><li><a href="https://github.com/scijs/ndarray" rel="external nofollow noopener noreferrer" target="_blank">ndarray</a> - 多维数组。</li><li><a href="https://github.com/fibo/algebra" rel="external nofollow noopener noreferrer" target="_blank">algebra</a> - 代数结构。</li><li><a href="https://github.com/nodeca/multimath" rel="external nofollow noopener noreferrer" target="_blank">multimath</a> - 在WebAssembly和JS中进行快速图像数学运算。</li></ul><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><ul><li><a href="https://github.com/moment/moment" rel="external nofollow noopener noreferrer" target="_blank">moment</a> - 解析、校验、操作和显示日期。</li><li><a href="https://github.com/iamkun/dayjs" rel="external nofollow noopener noreferrer" target="_blank">dayjs</a> - 仅2KB，不可变的日期时间库。使用与Moment.js同样的API，Moment.js的替代库。</li><li><a href="https://github.com/date-fns/date-fns" rel="external nofollow noopener noreferrer" target="_blank">date-fns</a> - 现代JavaScript日期工具库。</li><li><a href="https://github.com/moment/luxon" rel="external nofollow noopener noreferrer" target="_blank">luxon</a> - 用于处理日期和时间的库。</li><li><a href="https://github.com/hustcc/timeago.js" rel="external nofollow noopener noreferrer" target="_blank">timeago.js</a> - timeago.js是一个很小的（2.0 kb）库，用于使用 *** time ago 语句格式化日期。</li><li><a href="https://github.com/vercel/ms" rel="external nofollow noopener noreferrer" target="_blank">ms</a> - 毫秒转换工具。</li><li><a href="https://github.com/felixge/node-dateformat" rel="external nofollow noopener noreferrer" target="_blank">dateformat</a> - 日期格式化。</li><li><a href="https://github.com/sindresorhus/pretty-ms" rel="external nofollow noopener noreferrer" target="_blank">pretty-ms</a> - 将毫秒转换为人类可读的字符串，如: <code>1337000000</code> → <code>15d 11h 23m 20s</code>。</li><li><a href="https://github.com/samsonjs/strftime" rel="external nofollow noopener noreferrer" target="_blank">strftime</a> - JavaScript版时间格式化Strftime。</li><li><a href="https://github.com/wadey/node-microtime" rel="external nofollow noopener noreferrer" target="_blank">node-microtime</a> - 以微秒为单位获取当前时间。</li><li><a href="https://github.com/JerrySievert/date-utils" rel="external nofollow noopener noreferrer" target="_blank">date-utils</a> - 用于Node.js和浏览器的日期垫片（Polyfills）。</li><li><a href="https://github.com/robrich/pretty-hrtime" rel="external nofollow noopener noreferrer" target="_blank">pretty-hrtime</a> - 将process.hrtime()的结果转换为人可读性的字符串。</li><li><a href="https://github.com/node-modules/humanize-ms" rel="external nofollow noopener noreferrer" target="_blank">humanize-ms</a> - 将人类可读的时间转换为毫秒。</li></ul><h2 id="正则-通配符匹配"><a href="#正则-通配符匹配" class="headerlink" title="正则/通配符匹配"></a>正则/通配符匹配</h2><ul><li><a href="https://github.com/pillarjs/path-to-regexp" rel="external nofollow noopener noreferrer" target="_blank">path-to-regexp</a> - 将路径字符串（如<code>/user/:name</code>）转化为正则。</li><li><a href="https://github.com/isaacs/minimatch" rel="external nofollow noopener noreferrer" target="_blank">minimatch</a> - 最小匹配工具。</li><li><a href="https://github.com/micromatch/micromatch" rel="external nofollow noopener noreferrer" target="_blank">micromatch</a> - 高度优化的通配符和全局匹配库。更快，直接替换到 minimatch 和 multimatch。由webpack、babel core、yarn、jest、browser-sync、documentation.js、stylelint、nyc、ava以及许多其他资源使用！</li><li><a href="https://github.com/fent/randexp.js" rel="external nofollow noopener noreferrer" target="_blank">randexp.js</a> - 根据给定的正则表达式，生成随机字符串。</li><li><a href="https://github.com/substack/safe-regex" rel="external nofollow noopener noreferrer" target="_blank">safe-regex</a> - 检测可能是灾难性的、指数时间的正则表达式。</li><li><a href="https://github.com/sindresorhus/matcher" rel="external nofollow noopener noreferrer" target="_blank">matcher</a> - 简单通配符匹配。</li><li><a href="https://github.com/sindresorhus/escape-string-regexp" rel="external nofollow noopener noreferrer" target="_blank">escape-string-regexp</a> - 转义特殊正则字符。</li><li><a href="https://github.com/sindresorhus/multimatch" rel="external nofollow noopener noreferrer" target="_blank">multimatch</a> - 扩展 minimatch.match() 以支持多种模式。</li><li><a href="https://github.com/sindresorhus/execall" rel="external nofollow noopener noreferrer" target="_blank">execall</a> - 在字符串中查找多个RegExp匹配项。</li></ul><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><a href="https://github.com/medialize/URI.js" rel="external nofollow noopener noreferrer" target="_blank">URI.js</a> - URL转换库。</li><li><a href="https://github.com/ljharb/qs" rel="external nofollow noopener noreferrer" target="_blank">qs</a> - 请求字符串解析器。</li><li><a href="https://github.com/sindresorhus/query-string" rel="external nofollow noopener noreferrer" target="_blank">query-string</a> - 解析和字符串化URL查询字符串。</li><li><a href="https://github.com/unshiftio/url-parse" rel="external nofollow noopener noreferrer" target="_blank">url-parse</a> - 轻量URL解析器，可跨Node.js和浏览器环境无缝运行。</li><li><a href="https://github.com/sindresorhus/normalize-url" rel="external nofollow noopener noreferrer" target="_blank">normalize-url</a> - 规范化URL.</li><li><a href="https://github.com/snd/url-pattern" rel="external nofollow noopener noreferrer" target="_blank">url-pattern</a> - 比正则表达式更易匹配URL和其他字符串，将字符串转化成数据 或 将数据转换成字符串。</li><li><a href="https://github.com/GoogleChromeLabs/native-url" rel="external nofollow noopener noreferrer" target="_blank">native-url</a> - 使用内建URL API实现的NodeJS URL模块。</li><li><a href="https://github.com/jfromaniello/url-join" rel="external nofollow noopener noreferrer" target="_blank">url-join</a> - 将所有参数连接在一起，并将结果url规范化。</li><li><a href="https://github.com/sindresorhus/humanize-url" rel="external nofollow noopener noreferrer" target="_blank">humanize-url</a> - 使URL更可读: <a href="http://sindresorhus.com" rel="external nofollow noopener noreferrer" target="_blank">http://sindresorhus.com</a> → sindresorhus.com。</li><li><a href="https://github.com/pillarjs/parseurl" rel="external nofollow noopener noreferrer" target="_blank">parseurl</a> - 使用记忆化方式解析URL.</li><li><a href="https://github.com/sindresorhus/file-url" rel="external nofollow noopener noreferrer" target="_blank">file-url</a> - 将文件路径转化为文件URL: <code>unicorn.jpg</code> → <code>file:///Users/sindresorhus/unicorn.jpg</code></li><li><a href="https://github.com/pillarjs/encodeurl" rel="external nofollow noopener noreferrer" target="_blank">encodeurl</a> - 将URL编码为”百分比”形式，不编码已编码部分。</li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul><li><a href="https://github.com/json5/json5" rel="external nofollow noopener noreferrer" target="_blank">json5</a> - JSON5是对JSON的扩展，其目的是能够更加容易的阅读和编写。</li><li><a href="https://github.com/benjamine/jsondiffpatch" rel="external nofollow noopener noreferrer" target="_blank">jsondiffpatch</a> - 对比JSON对象，并生成差异和Patch信息。</li><li><a href="https://github.com/json-schema-faker/json-schema-faker" rel="external nofollow noopener noreferrer" target="_blank">json-schema-faker</a> - JSON-Schema + 假数据生成器。</li><li><a href="https://github.com/fastify/fast-json-stringify" rel="external nofollow noopener noreferrer" target="_blank">fast-json-stringify</a> - 比JSON.stringify()快2倍。</li><li><a href="https://github.com/jprichardson/node-jsonfile" rel="external nofollow noopener noreferrer" target="_blank">jsonfile</a> - 轻松读写JSON文件。</li><li><a href="https://github.com/jsonata-js/jsonata" rel="external nofollow noopener noreferrer" target="_blank">jsonata</a> - JSONata 查询和转换语言 - <a href="http://jsonata.org" rel="external nofollow noopener noreferrer" target="_blank">http://jsonata.org</a></li><li><a href="https://github.com/substack/json-stable-stringify" rel="external nofollow noopener noreferrer" target="_blank">json-stable-stringify</a> - 具有自定义排序功能的确定性JSON.stringify(), 可以从字符串化结果中获取确定性哈希值。</li><li><a href="https://github.com/sindresorhus/strip-json-comments" rel="external nofollow noopener noreferrer" target="_blank">strip-json-comments</a> - 去除JSON文件中的注释。让你可以在JSON中使用注释。</li><li><a href="https://github.com/moll/json-stringify-safe" rel="external nofollow noopener noreferrer" target="_blank">json-stringify-safe</a> - 类似于JSON.stringify，但不会引发循环引用。</li><li><a href="https://github.com/sindresorhus/load-json-file" rel="external nofollow noopener noreferrer" target="_blank">load-json-file</a> - 读取并解析JSON文件。</li><li><a href="https://github.com/sindresorhus/write-json-file" rel="external nofollow noopener noreferrer" target="_blank">write-json-file</a> - 序列化并写入JSON文件。</li><li><a href="https://github.com/epoberezkin/fast-json-stable-stringify" rel="external nofollow noopener noreferrer" target="_blank">fast-json-stable-stringify</a> - 确定性JSON.stringify() - 比 @substack 的 json-stable-stringify 更快的版本，不带jsonify。</li><li><a href="https://github.com/aligay/jsonuri" rel="external nofollow noopener noreferrer" target="_blank">jsonuri</a> - 使用”URI样式“的方法来操作数据。</li></ul><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><ul><li><a href="https://github.com/lovell/sharp" rel="external nofollow noopener noreferrer" target="_blank">sharp</a> - 调整JPEG，PNG，WebP和TIFF格式图像大小的最快模块。</li><li><a href="https://github.com/oliver-moran/jimp" rel="external nofollow noopener noreferrer" target="_blank">jimp</a> - 纯JavaScript中的图像处理。</li><li><a href="https://github.com/aheckmann/gm" rel="external nofollow noopener noreferrer" target="_blank">gm</a> - GraphicsMagick 和 ImageMagick 封装。</li><li><a href="https://github.com/soldair/node-qrcode" rel="external nofollow noopener noreferrer" target="_blank">qrcode</a> - 二维码和条形码生成器。</li><li><a href="https://github.com/mapbox/pixelmatch" rel="external nofollow noopener noreferrer" target="_blank">pixelmatch</a> - 最小、最简单、最快的 JavaScript 像素级图像比较库。</li><li><a href="https://github.com/rsmbl/Resemble.js" rel="external nofollow noopener noreferrer" target="_blank">Resemble.js</a> - 图像分析和比较。</li><li><a href="https://github.com/nodeca/pica" rel="external nofollow noopener noreferrer" target="_blank">pica</a> - 使用纯JS中的高质量和快速调整大小（lanczos3）。 当不允许像素化时替代canvas drawImage()。</li><li><a href="https://github.com/cozmo/jsQR" rel="external nofollow noopener noreferrer" target="_blank">jsQR</a> - 一个纯javascript的二维码读取库。 该库接收原始图像，并将定位、提取和解析其中发现的任何二维码。</li><li><a href="https://github.com/EyalAr/lwip" rel="external nofollow noopener noreferrer" target="_blank">lwip</a> - 不需要ImageMagick的轻量级图像处理器.</li><li><a href="https://github.com/nodeca/probe-image-size" rel="external nofollow noopener noreferrer" target="_blank">probe-image-size</a> - 无需完全下载即可获取大多数图像格式的大小.</li><li><a href="https://github.com/deanm/omggif" rel="external nofollow noopener noreferrer" target="_blank">omggif</a> - GIF 89a编码解码器。</li><li><a href="https://github.com/jpeg-js/jpeg-js" rel="external nofollow noopener noreferrer" target="_blank">jpeg-js</a> - 使用纯JavaScript的JPEG编码和解码器。</li><li><a href="https://github.com/lukeapage/pngjs" rel="external nofollow noopener noreferrer" target="_blank">pngjs</a> - 简单的PNG编码解码器。</li><li><a href="https://github.com/scijs/get-pixels" rel="external nofollow noopener noreferrer" target="_blank">get-pixels</a> - 将图像读入ndarray。</li><li><a href="https://github.com/sindresorhus/image-type" rel="external nofollow noopener noreferrer" target="_blank">image-type</a> - 检测Buffer / Uint8Array的图像类型.</li><li><a href="https://github.com/nowelium/node-bitmap" rel="external nofollow noopener noreferrer" target="_blank">node-bitmap</a> - 纯JavaScript Bitmap库。</li></ul><h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><ul><li><a href="https://github.com/fluent-ffmpeg/node-fluent-ffmpeg" rel="external nofollow noopener noreferrer" target="_blank">fluent-ffmpeg</a> - FFMPEG的流畅API (<a href="http://www.ffmpeg.org" rel="external nofollow noopener noreferrer" target="_blank">http://www.ffmpeg.org</a>)</li><li><a href="https://github.com/tnfe/FFCreator" rel="external nofollow noopener noreferrer" target="_blank">FFCreator</a> - 一个基于node.js的高速短视频加工库。</li><li><a href="https://github.com/damianociarla/node-ffmpeg" rel="external nofollow noopener noreferrer" target="_blank">node-ffmpeg</a> - Nodejs版Ffmpeg模块。</li></ul><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li><a href="https://github.com/aui/font-spider" rel="external nofollow noopener noreferrer" target="_blank">font-spider</a> - 字蛛是一个智能 WebFont 压缩工具，它能自动分析出页面使用的 WebFont 并进行按需压缩。</li></ul><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul><li><a href="https://github.com/gka/chroma.js" rel="external nofollow noopener noreferrer" target="_blank">chroma</a> - JavaScript库，用于各种颜色处理。</li><li><a href="https://github.com/davidmerfield/randomColor" rel="external nofollow noopener noreferrer" target="_blank">randomColor</a> - 一个小型脚本，用于优雅的生成颜色。</li><li><a href="https://github.com/briangonzalez/rgbaster.js" rel="external nofollow noopener noreferrer" target="_blank">rgbaster</a> - 一个简单的库，用于从图像中提取主色。</li><li><a href="https://github.com/bgrins/TinyColor" rel="external nofollow noopener noreferrer" target="_blank">TinyColor</a> - 快速、小型的颜色操作和转换库。</li><li><a href="https://github.com/One-com/one-color" rel="external nofollow noopener noreferrer" target="_blank">onecolor</a> - 面向对象的JavaScript颜色解析器/计算工具包，支持RGB，HSV，HSL，CMYK和alpha通道。 颜色空间之间的转换是隐式进行的，并且所有方法都返回新对象，而不是对现有实例进行突变。 可在浏览器和Node.js中使用。</li></ul><h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><ul><li><a href="https://github.com/brix/crypto-js" rel="external nofollow noopener noreferrer" target="_blank">crypto-js</a> - JavaScript加密标准库。</li><li><a href="https://github.com/kelektiv/node.bcrypt.js" rel="external nofollow noopener noreferrer" target="_blank">bcrypt</a> - Node.js版Bcrypt。</li><li><a href="https://github.com/travist/jsencrypt" rel="external nofollow noopener noreferrer" target="_blank">jsencrypt</a> - 用于执行OpenSSL RSA加密、解密和密钥生成的Javascript库。</li><li><a href="https://github.com/dcodeIO/bcrypt.js" rel="external nofollow noopener noreferrer" target="_blank">bcrypt.js</a> - 经过优化bcrypt库，使用纯JavaScript且零依赖。</li><li><a href="https://github.com/kjur/jsrsasign" rel="external nofollow noopener noreferrer" target="_blank">jsrsasign</a> - “jsrsasign”（RSA Sign JavaScript库）是一个开源的免费加密库，支持纯JavaScript中的RSA/RSAPSS/ECDSA/DSA签名/验证、ASN.1、PKCS#1/5/8私钥/公钥、X.509证书、CRL、OCSP、CMS SignedData、TimeStamp、CAdES JSON Web签名/令牌。</li><li><a href="https://github.com/rzcoder/node-rsa" rel="external nofollow noopener noreferrer" target="_blank">node-rsa</a> - Node.js RSA库。</li><li><a href="https://github.com/ricmoo/aes-js" rel="external nofollow noopener noreferrer" target="_blank">aes-js</a> - AES的纯JavaScript实现。</li><li><a href="https://github.com/pvorb/node-md5" rel="external nofollow noopener noreferrer" target="_blank">node-md5</a> - 一个JavaScript函数，用于使用MD5对消息进行哈希处理。</li><li><a href="https://github.com/sindresorhus/crypto-hash" rel="external nofollow noopener noreferrer" target="_blank">crypto-hash</a> - 微型哈希模块，在Node.js和浏览器中使用原生crypto API。</li><li><a href="https://github.com/indutny/hash.js" rel="external nofollow noopener noreferrer" target="_blank">hash.js</a> - 使用纯JavaScript的哈希实现。</li><li><a href="https://github.com/JuneAndGreen/sm-crypto" rel="external nofollow noopener noreferrer" target="_blank">sm-crypto</a> - sm2, sm3, sm4的JavaScript实现。</li><li><a href="https://github.com/crypto-browserify/sha.js" rel="external nofollow noopener noreferrer" target="_blank">sha.js</a> - 使用纯JavaScript中的流式SHA哈希。</li><li><a href="https://github.com/MauriceButler/cryptr" rel="external nofollow noopener noreferrer" target="_blank">cryptr</a> - 非常基础的加密和解密Node.js模块。</li><li><a href="https://github.com/crypto-browserify/pbkdf2" rel="external nofollow noopener noreferrer" target="_blank">pbkdf2</a> - 在Node中具有任何受支持的哈希算法PBKDF2。</li><li><a href="https://github.com/joyent/node-bcrypt-pbkdf" rel="external nofollow noopener noreferrer" target="_blank">bcrypt-pbkdf</a> - POpenBSD <code>bcrypt_pbkdf</code> Javascript实现。</li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li><a href="https://github.com/dominictarr/event-stream" rel="external nofollow noopener noreferrer" target="_blank">event-stream</a> - EventStream就像函数式编程遇到IO。</li><li><a href="https://github.com/rvagg/through2" rel="external nofollow noopener noreferrer" target="_blank">through2</a> - 基于Node stream2 的封装进行转换以避免显式的子类化噪声。</li><li><a href="https://github.com/dominictarr/JSONStream" rel="external nofollow noopener noreferrer" target="_blank">JSONStream</a> - 流JSON.parse和stringify。</li><li><a href="https://github.com/maxogden/mississippi" rel="external nofollow noopener noreferrer" target="_blank">mississippi</a> - 有用的流实用程序模块的集合，用于更好编写的使用流的代码。</li><li><a href="https://github.com/nodejs/readable-stream" rel="external nofollow noopener noreferrer" target="_blank">readable-stream</a> - 可读流。</li><li><a href="https://github.com/mafintosh/pump" rel="external nofollow noopener noreferrer" target="_blank">pump</a> - 将流连接在一起，如果其中一个关闭，则关闭所有流。</li><li><a href="https://github.com/maxogden/concat-stream" rel="external nofollow noopener noreferrer" target="_blank">concat-stream</a> - 可写流，它将字符串或数据连接起来并执行回调。</li><li><a href="https://github.com/uhop/stream-json" rel="external nofollow noopener noreferrer" target="_blank">stream-json</a> - stream-json是用于创建自定义标准兼容JSON处理器的nod​​e.js流组件的集合，该组件所需的内存占用最少。它可以解析远远超出可用内存的JSON文件。甚至单个原始数据项（键，字符串和数字）也可以分段流式传输。还包括流式SAX启发式的基于事件的API。</li><li><a href="https://github.com/dominictarr/split" rel="external nofollow noopener noreferrer" target="_blank">split</a> - 分解流并重新组装它，以便每一行都是一块。匹配器可以是字符串，也可以是正则表达式。</li><li><a href="https://github.com/mafintosh/tar-stream" rel="external nofollow noopener noreferrer" target="_blank">tar-stream</a> - tar-stream是一个流式tar解析器和生成器。</li><li><a href="https://github.com/jahewson/node-byline" rel="external nofollow noopener noreferrer" target="_blank">node-byline</a> - 逐行流阅读器。</li><li><a href="https://github.com/maxogden/ndjson" rel="external nofollow noopener noreferrer" target="_blank">ndjson</a> - 流逐行分隔的json解析器 + 序列化器。</li><li><a href="https://github.com/substack/oppressor" rel="external nofollow noopener noreferrer" target="_blank">oppressor</a> - 流HTTP压缩响应协商程序。</li><li><a href="https://github.com/feross/multistream" rel="external nofollow noopener noreferrer" target="_blank">multistream</a> - 一种流，一个接一个地发出多个其他流（streams2）。</li><li><a href="https://github.com/sindresorhus/get-stream" rel="external nofollow noopener noreferrer" target="_blank">get-stream</a> - 以字符串，缓冲区或数组的形式获取流。</li><li><a href="https://github.com/samcday/node-stream-buffer" rel="external nofollow noopener noreferrer" target="_blank">node-stream-buffer</a> - 使用缓存的可读和可写流。</li><li><a href="https://github.com/mcollina/split2" rel="external nofollow noopener noreferrer" target="_blank">split2</a> - 拆分stream3样式。</li><li><a href="https://github.com/npm/fstream" rel="external nofollow noopener noreferrer" target="_blank">fstream</a> - 高级的Node.js文件操作流。</li><li><a href="https://github.com/mafintosh/pumpify" rel="external nofollow noopener noreferrer" target="_blank">pumpify</a> - 使用泵和全双工，将一系列流合并为单个双工流。</li><li><a href="https://github.com/freeall/progress-stream" rel="external nofollow noopener noreferrer" target="_blank">progress-stream</a> - 读取流的进度。</li><li><a href="https://github.com/grncdr/merge-stream" rel="external nofollow noopener noreferrer" target="_blank">merge-stream</a> - 将多个流合并为一个交错流。</li><li><a href="https://github.com/mafintosh/duplexify" rel="external nofollow noopener noreferrer" target="_blank">duplexify</a> - 将可写和可读流转换为具有异步初始化和stream1/streams2输入支持的stream2双工流。</li><li><a href="https://github.com/sindresorhus/into-stream" rel="external nofollow noopener noreferrer" target="_blank">into-stream</a> - 将缓存/字符串/数组/对象转换为流。</li><li><a href="https://github.com/teambition/merge2" rel="external nofollow noopener noreferrer" target="_blank">merge2</a> - 按顺序或并行的方式将多个流合并为一个流。</li><li><a href="https://github.com/mafintosh/end-of-stream" rel="external nofollow noopener noreferrer" target="_blank">end-of-stream</a> - 当可读/可写/双工流已完成或失败时，调用回调。</li><li><a href="https://github.com/bendrucker/stream-to-promise" rel="external nofollow noopener noreferrer" target="_blank">stream-to-promise</a> - 将流（可读或可写流）转换为Promise。</li><li><a href="https://github.com/gagle/node-streamifier" rel="external nofollow noopener noreferrer" target="_blank">node-streamifier</a> - 将 Buffer/String 转换为可读流。</li><li><a href="https://github.com/dominictarr/stream-spec" rel="external nofollow noopener noreferrer" target="_blank">stream-spec</a> - Stream的可执行规范（让测试流变得更容易）。</li><li><a href="https://github.com/hughsk/from2" rel="external nofollow noopener noreferrer" target="_blank">from2</a> - ReadableStream的便捷封装，其灵感来自through2。</li><li><a href="https://github.com/dominictarr/map-stream" rel="external nofollow noopener noreferrer" target="_blank">dmap-stream</a> - 基于Event-stream事件流重构。</li><li><a href="https://github.com/substack/emit-stream" rel="external nofollow noopener noreferrer" target="_blank">emit-stream</a> - 将event-emiiters转换为流 和 将流转换为event-emiiters。</li><li><a href="https://github.com/dominictarr/stream-combiner" rel="external nofollow noopener noreferrer" target="_blank">stream-combiner</a> - 将管道变成单个流。合并返回的流，写入第一个流并从最后一个流读取的流。</li><li><a href="https://github.com/raynos/duplexer" rel="external nofollow noopener noreferrer" target="_blank">duplexer</a> - 创建一个双工流。</li><li><a href="https://github.com/spion/promise-streams" rel="external nofollow noopener noreferrer" target="_blank">promise-streams</a> - Node.js流的集合，可以很好地与Promises (through, map, reduce等）一起使用。</li><li><a href="https://github.com/maxogden/binary-split" rel="external nofollow noopener noreferrer" target="_blank">binary-split</a> - 快速的换行符（或任何分隔符）分隔符流。</li><li><a href="https://github.com/substack/stream-combiner2" rel="external nofollow noopener noreferrer" target="_blank">stream-combiner2</a> - stream3的stream-combiner。</li><li><a href="https://github.com/almost/through2-concurrent" rel="external nofollow noopener noreferrer" target="_blank">through2-concurrent</a> - 简单的Node.JS流（streams2）转换，可并行执行转换功能（可设置的最大并发数）。</li><li><a href="https://github.com/mcollina/cloneable-readable" rel="external nofollow noopener noreferrer" target="_blank">cloneable-readable</a> - 安全地克隆可读流。</li><li><a href="https://github.com/stream-utils/destroy" rel="external nofollow noopener noreferrer" target="_blank">destroy</a> - 如果可能，销毁流。</li><li><a href="https://github.com/mafintosh/peek-stream" rel="external nofollow noopener noreferrer" target="_blank">peek-stream</a> - 转换流，可让您在决定如何解析前先窥视第一行。</li><li><a href="https://github.com/substack/resumer" rel="external nofollow noopener noreferrer" target="_blank">resumer</a> - 通过流开始暂停，并在下一个tick恢复。</li><li><a href="https://github.com/mafintosh/stream-each" rel="external nofollow noopener noreferrer" target="_blank">stream-each</a> - 迭代流中的所有数据。</li><li><a href="https://github.com/mafintosh/flush-write-stream" rel="external nofollow noopener noreferrer" target="_blank">flush-write-stream</a> - 一种写入流构造函数，支持流完成之前调用的flush函数。</li><li><a href="https://github.com/mafintosh/multi-write-stream" rel="external nofollow noopener noreferrer" target="_blank">multi-write-stream</a> - 创建一个可写流，其可写入多个其他可写流。</li><li><a href="https://github.com/sindresorhus/first-chunk-stream" rel="external nofollow noopener noreferrer" target="_blank">first-chunk-stream</a> - 缓冲并转换流的前n个字节。</li><li><a href="https://github.com/mafintosh/multi-read-stream" rel="external nofollow noopener noreferrer" target="_blank">multi-read-stream</a> - 可读流，它同时从多个可读流中读取。</li><li><a href="https://github.com/parshap/node-stream-reduce" rel="external nofollow noopener noreferrer" target="_blank">node-stream-reduce</a> - 将流数据减少为单个值。</li><li><a href="https://github.com/mafintosh/stream-shift" rel="external nofollow noopener noreferrer" target="_blank">stream-shift</a> - 返回流可读队列中的下一个缓冲区/对象。</li><li><a href="https://github.com/floatdrop/stream-assert" rel="external nofollow noopener noreferrer" target="_blank">stream-assert</a> - 流的断言库。</li><li><a href="https://github.com/schnittstabil/stream-from-promise" rel="external nofollow noopener noreferrer" target="_blank">stream-from-promise</a> - 根据Promise创建流。</li><li><a href="https://github.com/lewisdiamond/stromjs" rel="external nofollow noopener noreferrer" target="_blank">stromjs</a> - 无依赖的流实用程序。流的Lodash。</li><li><a href="https://github.com/suarasaur/exec-stream" rel="external nofollow noopener noreferrer" target="_blank">exec-stream</a> - 将流传入到子进程。</li><li><a href="https://github.com/kikobeats/stream-callback" rel="external nofollow noopener noreferrer" target="_blank">stream-callback</a> – 将流转换为一个回调函数。</li></ul><h2 id="检测-判断"><a href="#检测-判断" class="headerlink" title="检测/判断"></a>检测/判断</h2><ul><li><a href="https://github.com/arasatasaygin/is.js" rel="external nofollow noopener noreferrer" target="_blank">is.js</a> - 微型检查库。</li><li><a href="https://github.com/then/is-promise" rel="external nofollow noopener noreferrer" target="_blank">is-promise</a> - 测试对象是否看起来像一个 Promises-a+ promise。</li><li><a href="https://github.com/watson/is-ci" rel="external nofollow noopener noreferrer" target="_blank">is-ci</a> - 判断当前环境是否为CI服务器。</li><li><a href="https://github.com/enricomarino/is" rel="external nofollow noopener noreferrer" target="_blank">is</a> - JavaScript类型测试库。</li><li><a href="https://github.com/node-modules/is-type-of" rel="external nofollow noopener noreferrer" target="_blank">is-type-of</a> - Node.js完整类型判断。</li><li><a href="https://github.com/sindresorhus/is-stream" rel="external nofollow noopener noreferrer" target="_blank">is-stream</a> - 判断对象是否为流对象。</li><li><a href="https://github.com/wayfind/is-utf8" rel="external nofollow noopener noreferrer" target="_blank">is-utf8</a> - 判断Buffer对象是否UTF8编码。</li><li><a href="https://github.com/isaacs/core-util-is" rel="external nofollow noopener noreferrer" target="_blank">core-util-is</a> - Node.js核心工具 util.is* 函数。</li><li><a href="https://github.com/sindresorhus/is-ip" rel="external nofollow noopener noreferrer" target="_blank">is-ip</a> - 检查字符串是否为IP地址。</li><li><a href="https://github.com/rvagg/isstream" rel="external nofollow noopener noreferrer" target="_blank">isstream</a> - 判断对象是否为流对象。</li><li><a href="https://github.com/miguelmota/is-class" rel="external nofollow noopener noreferrer" target="_blank">is-class</a> - 判断函数是否为 ES6类(class) 类型。</li><li><a href="https://github.com/isaacs/isexe" rel="external nofollow noopener noreferrer" target="_blank">isexe</a> - 检查文件是否可执行文件。</li><li><a href="https://github.com/juliangruber/is-type" rel="external nofollow noopener noreferrer" target="_blank">is-type</a> - Node.js核心类型判断。</li><li><a href="https://github.com/imanhodjaev/is-md5" rel="external nofollow noopener noreferrer" target="_blank">is-md5</a> - JavaScript实用程序，用于检查字符串是否为md5加密。</li><li><a href="https://github.com/inspect-js/is-core-module" rel="external nofollow noopener noreferrer" target="_blank">is-core-module</a> - 判断一个说明符 是否为 Node.js 核心模块。</li></ul><h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><ul><li><a href="https://github.com/validatorjs/validator.js" rel="external nofollow noopener noreferrer" target="_blank">validator.js</a> - 字符串校验库。</li><li><a href="https://github.com/hapijs/joi" rel="external nofollow noopener noreferrer" target="_blank">joi</a> - 基于JavaScript对象的对象模式描述语言和验证器。</li><li><a href="https://github.com/yiminghe/async-validator" rel="external nofollow noopener noreferrer" target="_blank">async-validator</a> - 异步校验。</li><li><a href="https://github.com/typestack/class-validator" rel="external nofollow noopener noreferrer" target="_blank">class-validator</a> - 基于装饰器属性校验的类校验器。</li><li><a href="https://github.com/epoberezkin/ajv" rel="external nofollow noopener noreferrer" target="_blank">ajv</a> - 最快的JSON Schema验证器。支持JSON Schema draft-04/06/07/2019-09/2020-12 and JSON类型定义(RFC8927)。</li><li><a href="https://github.com/ianstormtaylor/superstruct" rel="external nofollow noopener noreferrer" target="_blank">Superstruct</a> - 用简单和可组合的方式在JavaScript和TypeScript中校验数据。</li><li><a href="https://github.com/imbrn/v8n" rel="external nofollow noopener noreferrer" target="_blank">v8n</a> - 流畅的JavaScript校验库。</li><li><a href="https://github.com/oussamahamdaoui/forgJs" rel="external nofollow noopener noreferrer" target="_blank">forgJs</a> - 轻量的JavaScript对象校验器。</li><li><a href="https://github.com/tdegrunt/jsonschema" rel="external nofollow noopener noreferrer" target="_blank">jsonschema</a> - JSON Schema校验器.</li><li><a href="https://github.com/mikeerickson/validatorjs" rel="external nofollow noopener noreferrer" target="_blank">validatorjs</a> - 受Laravel的校验器启发，在浏览器和Node.JS上的数据校验库。</li><li><a href="https://github.com/mafintosh/is-my-json-valid" rel="external nofollow noopener noreferrer" target="_blank">is-my-json-valid</a> - 极快的JSON Schema校验工具。</li><li><a href="https://github.com/nettofarah/property-validator" rel="external nofollow noopener noreferrer" target="_blank">property-validator</a> - 用于JavaScript、Node和Express的易用的属性校验工具。</li><li><a href="https://github.com/Atinux/schema-inspector" rel="external nofollow noopener noreferrer" target="_blank">schema-inspector</a> - 用于净化和验证JS对象的强大工具。</li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li><a href="https://github.com/lodash/lodash" rel="external nofollow noopener noreferrer" target="_blank">lodash</a> - 可提供一致性、自定义、性能和其他功能的实用程序库，比Underscore.js更好更快。</li><li><a href="https://github.com/facebook/immutable-js" rel="external nofollow noopener noreferrer" target="_blank">immutable</a> - 不可变的数据集合。</li><li><a href="https://github.com/reactivex/rxjs" rel="external nofollow noopener noreferrer" target="_blank">RxJS</a> - 用于转换、组合和查询各种数据的函数式响应式库。</li><li><a href="https://github.com/ramda/ramda" rel="external nofollow noopener noreferrer" target="_blank">Ramda</a> - 实用程序库着重于通过自动计算和相反的参数顺序实现的灵活功能组合，避免数据变化。</li><li><a href="https://github.com/immerjs/immer" rel="external nofollow noopener noreferrer" target="_blank">immer</a> - 函数式响应式编程。</li><li><a href="https://github.com/baconjs/bacon.js" rel="external nofollow noopener noreferrer" target="_blank">Bacon.js</a> - 函数式响应式编程。</li><li><a href="https://github.com/dtao/lazy.js" rel="external nofollow noopener noreferrer" target="_blank">Lazy.js</a> - 类似于lodash/underline的工具库，但具有惰性计算，在许多情况下可以转换为卓越的性能.</li><li><a href="https://github.com/origamitower/folktale" rel="external nofollow noopener noreferrer" target="_blank">Folktale</a> - 一套用于JavaScript中的通用函数编程的库，它允许您编写优雅的、模块化的应用程序，并且bug更少及更强的重用性。</li><li><a href="https://github.com/kefirjs/kefir" rel="external nofollow noopener noreferrer" target="_blank">Kefir.js</a> - 响应式库，专注于高性能和低内存使用。</li><li><a href="https://github.com/mout/mout" rel="external nofollow noopener noreferrer" target="_blank">Mout</a> - 该库与其他现有解决方案之间最大的区别是，您可以选择只加载需要的模块/函数，而不需要额外开销。.</li></ul><h2 id="控制反转-依赖注入"><a href="#控制反转-依赖注入" class="headerlink" title="控制反转/依赖注入"></a>控制反转/依赖注入</h2><ul><li><a href="https://github.com/inversify/InversifyJS" rel="external nofollow noopener noreferrer" target="_blank">InversifyJS</a> - 功能强大且轻便的控制反转容器。</li><li><a href="https://github.com/mgechev/injection-js" rel="external nofollow noopener noreferrer" target="_blank">injection-js</a> - 5.1K中的JavaScript和TypeScript的依赖注入库。它提取自Angular的ReflectiveInjector，这意味着它设计合理，功能完整、快速、可靠且经过良好测试。</li><li><a href="https://github.com/zhang740/power-di" rel="external nofollow noopener noreferrer" target="_blank">power-di</a> - 轻量的依赖注入库。</li></ul><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><ul><li><a href="https://github.com/shelljs/shelljs" rel="external nofollow noopener noreferrer" target="_blank">shelljs</a> - 跨平台Unix shell命令。</li><li><a href="https://github.com/sindresorhus/execa" rel="external nofollow noopener noreferrer" target="_blank">execa</a> - 跨平台实现子进程执行 <code>child_process.{execFile,exec}</code>。</li><li><a href="https://github.com/coreybutler/node-windows" rel="external nofollow noopener noreferrer" target="_blank">node-windows</a> - Node.js上支持的Windows脚本。如(daemons, eventlog, UAC等)。</li><li><a href="https://github.com/shelljs/shx" rel="external nofollow noopener noreferrer" target="_blank">shx</a> - Node的可移植Shell命令。</li><li><a href="https://github.com/sindresorhus/clipboardy" rel="external nofollow noopener noreferrer" target="_blank">clipboardy</a> - 跨平台的复制/粘贴。</li><li><a href="https://github.com/IndigoUnited/node-cross-spawn" rel="external nofollow noopener noreferrer" target="_blank">cross-spawn</a> - 跨平台实现 <code>child_process.spawn()</code>。</li><li><a href="https://github.com/darkguy2008/parallelshell" rel="external nofollow noopener noreferrer" target="_blank">parallelshell</a> - 并行运行多个 shell 命令。</li><li><a href="https://github.com/sindresorhus/clipboard-cli" rel="external nofollow noopener noreferrer" target="_blank">clipboard-cli</a> - 跨平台的复制/粘贴。</li><li><a href="https://github.com/ehmicky/gulp-execa" rel="external nofollow noopener noreferrer" target="_blank">gulp-execa</a> - 在Gulp中跨平台命令执行。</li><li><a href="https://github.com/node-modules/runscript" rel="external nofollow noopener noreferrer" target="_blank">runscript</a> - 更容易的运行脚本命令。</li><li><a href="https://github.com/zentrick/cross-spawn-promise" rel="external nofollow noopener noreferrer" target="_blank">cross-spawn-promise</a> - Promise化的cross-spawn。</li><li><a href="https://github.com/tiaanduplessis/shell-exec" rel="external nofollow noopener noreferrer" target="_blank">shell-exec</a> - 通过系统Shell执行命令。</li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li><a href="https://github.com/motdotla/dotenv" rel="external nofollow noopener noreferrer" target="_blank">dotenv</a> - 从 .env文件 加载用于nodejs项目的环境变量。</li><li><a href="https://github.com/kentcdodds/cross-env" rel="external nofollow noopener noreferrer" target="_blank">cross-env</a> - 跨平台设置环境变量。</li><li><a href="https://github.com/tabrindle/envinfo" rel="external nofollow noopener noreferrer" target="_blank">envinfo</a> - 生成关于您的开发环境的报告，用于调试和问题报告。</li><li><a href="https://github.com/npm/node-which" rel="external nofollow noopener noreferrer" target="_blank">which</a> - 跨平台实现的Unix <code>which</code>.</li><li><a href="https://github.com/sindresorhus/user-home" rel="external nofollow noopener noreferrer" target="_blank">user-home</a> - 跨平台获取用户home目录路径。</li><li><a href="https://github.com/sindresorhus/username" rel="external nofollow noopener noreferrer" target="_blank">username</a> - 获取当前用户名。</li><li><a href="https://github.com/npm/osenv" rel="external nofollow noopener noreferrer" target="_blank">osenv</a> - 跨平台环境变量。</li><li><a href="https://github.com/sindresorhus/is-elevated" rel="external nofollow noopener noreferrer" target="_blank">is-elevated</a> - 检查进程是否以提升的权限运行。</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li><a href="https://github.com/jonathanong/ee-first" rel="external nofollow noopener noreferrer" target="_blank">ee-first</a> - 获取一组EventEmitter和Event对中的第一个事件，然后对其进行清理。</li></ul><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><ul><li><p><strong>框架/解决方案</strong></p></li><li><p><a href="https://github.com/tj/commander.js" rel="external nofollow noopener noreferrer" target="_blank">Commander.js</a> - Node.JS命令行界面完整解决方案。</p></li><li><a href="https://github.com/yargs/yargs" rel="external nofollow noopener noreferrer" target="_blank">yargs</a> - 通用可交互命令行工具集合。</li><li><a href="https://github.com/oclif/oclif" rel="external nofollow noopener noreferrer" target="_blank">oclif</a> - 基于Heroku开源Node.js CLI框架。</li><li><a href="https://github.com/sindresorhus/meow" rel="external nofollow noopener noreferrer" target="_blank">meow</a> - CLI应用助手。</li><li><a href="https://github.com/cacjs/cac" rel="external nofollow noopener noreferrer" target="_blank">cac</a> - 用于构建命令行应用的强大框架。</li><li><a href="https://github.com/drew-y/cliffy" rel="external nofollow noopener noreferrer" target="_blank">Cliffy</a> - 可交互命令行框架。</li><li><a href="https://github.com/node-modules/common-bin" rel="external nofollow noopener noreferrer" target="_blank">common-bin</a> - 基于yargs的命令行工具抽象，提供更方便的使用，支持async/generator。</li></ul><ul><li><p><strong>命令行参数解析</strong></p></li><li><p><a href="https://github.com/substack/minimist" rel="external nofollow noopener noreferrer" target="_blank">minimist</a> - 命令行参数解析引擎。</p></li><li><a href="https://github.com/vercel/arg" rel="external nofollow noopener noreferrer" target="_blank">arg</a> - 简单的参数解析。</li><li><a href="https://github.com/npm/nopt" rel="external nofollow noopener noreferrer" target="_blank">nopt</a> - Node/npm参数解析。</li><li><a href="https://github.com/nodeca/argparse" rel="external nofollow noopener noreferrer" target="_blank">argparse</a> - Node.js CLI参数解析。</li><li><a href="https://github.com/yargs/yargs-parser" rel="external nofollow noopener noreferrer" target="_blank">yargs-parser</a> - yargs在使用，优雅参数解析库.</li></ul><ul><li><p><strong>Prompt提示</strong></p></li><li><p><a href="https://github.com/SBoudrias/Inquirer.js" rel="external nofollow noopener noreferrer" target="_blank">Inquirer.js</a> - 通用可交互命令行工具集合。</p></li><li><a href="https://github.com/terkelg/prompts" rel="external nofollow noopener noreferrer" target="_blank">prompts</a> - 轻量、美观、用户友好的交互式命令行提示。</li><li><a href="https://github.com/enquirer/enquirer" rel="external nofollow noopener noreferrer" target="_blank">Enquirer</a> - 用户友好、直观且易于创建的时尚CLI提示。</li><li><a href="https://github.com/moxystudio/node-promptly" rel="external nofollow noopener noreferrer" target="_blank">node-promptly</a> - 简单命令行提示实用程序。</li></ul><ul><li><p><strong>进度条</strong></p></li><li><p><a href="https://github.com/visionmedia/node-progress" rel="external nofollow noopener noreferrer" target="_blank">progress</a> - Node.js的灵活ascii进度条。</p></li><li><a href="https://github.com/bvaughn/progress-estimator" rel="external nofollow noopener noreferrer" target="_blank">progress-estimator</a> - 打印进度条并估计完成Promise所需的时间。</li><li><a href="https://github.com/AndiDittrich/Node.CLI-Progress" rel="external nofollow noopener noreferrer" target="_blank">cli-progress</a> - 在命令行/终端应用中轻松的使用进度条。</li></ul><ul><li><p><strong>样式</strong></p></li><li><p><a href="https://github.com/chalk/chalk" rel="external nofollow noopener noreferrer" target="_blank">chalk</a> - 命令行字符串样式美化工具。</p></li><li><a href="https://github.com/sindresorhus/ora" rel="external nofollow noopener noreferrer" target="_blank">ora</a> - 优雅的命令行loading效果。</li><li><a href="https://github.com/Marak/colors.js" rel="external nofollow noopener noreferrer" target="_blank">colors.js</a> - 获取Node.js控制台的颜色。</li><li><a href="https://github.com/SamVerschueren/listr" rel="external nofollow noopener noreferrer" target="_blank">listr</a> - 命令行任务列表。</li><li><a href="https://github.com/patorjk/figlet.js" rel="external nofollow noopener noreferrer" target="_blank">figlet.js</a> - 用 JavaScript 编写的 FIG，旨在完全实现 FIGfont 规范。</li><li><a href="https://github.com/lukeed/kleur" rel="external nofollow noopener noreferrer" target="_blank">kleur</a> - 最快的Node.js库，使用ANSI颜色格式化命令行文本。</li><li><a href="https://github.com/jorgebucaran/colorette" rel="external nofollow noopener noreferrer" target="_blank">colorette</a> - 在终端中轻松设置文本的颜色和样式。</li><li><a href="https://github.com/gtanner/qrcode-terminal" rel="external nofollow noopener noreferrer" target="_blank">qrcode-terminal</a> - 命令行中显示二维码。</li><li><a href="https://github.com/sindresorhus/boxen" rel="external nofollow noopener noreferrer" target="_blank">boxen</a> - 控制台中创建盒子。</li><li><a href="https://github.com/sindresorhus/terminal-image" rel="external nofollow noopener noreferrer" target="_blank">terminal-image</a> - 在终端中展示图片。</li><li><a href="https://github.com/sindresorhus/log-symbols" rel="external nofollow noopener noreferrer" target="_blank">log-symbols</a> - 为不同日志级别添加色彩图标。</li><li><a href="https://github.com/bokub/gradient-string" rel="external nofollow noopener noreferrer" target="_blank">gradient-string</a> - 终端输出中漂亮的颜色渐变。</li><li><a href="https://github.com/sindresorhus/figures" rel="external nofollow noopener noreferrer" target="_blank">figures</a> - Windows兜底的Unicode符号。</li><li><a href="https://github.com/sindresorhus/terminal-link" rel="external nofollow noopener noreferrer" target="_blank">terminal-link</a> - 在终端中创建可点击的链接。</li><li><a href="https://github.com/standard/snazzy" rel="external nofollow noopener noreferrer" target="_blank">snazzy</a> - 将 JavaScript 标准样式格式化为时尚（即时髦）输出。</li><li><a href="https://github.com/timoxley/columnify" rel="external nofollow noopener noreferrer" target="_blank">columnify</a> - 创建适合控制台输出的基于文本的列。 支持单元格。</li><li><a href="https://github.com/cli-table/cli-table3" rel="external nofollow noopener noreferrer" target="_blank">cli-table3</a> - 命令行的漂亮unicode表。</li><li><a href="https://github.com/eldargab/easy-table" rel="external nofollow noopener noreferrer" target="_blank">easy-table</a> - 漂亮的文本表格。</li><li><a href="https://github.com/notatestuser/treeify" rel="external nofollow noopener noreferrer" target="_blank">treeify</a> - 将javascript对象漂亮地打印为树。</li><li><a href="https://github.com/marvinhagemeister/kolorist" rel="external nofollow noopener noreferrer" target="_blank">kolorist</a> - 使用输入和输出色彩化的小工具。</li><li><a href="https://github.com/aantthony/console-png" rel="external nofollow noopener noreferrer" target="_blank">console-png</a> - 在命令行输出中打印PNG图片。</li></ul><ul><li><p><strong>编辑器</strong></p></li><li><p><a href="https://github.com/slap-editor/slap" rel="external nofollow noopener noreferrer" target="_blank">slap</a> - 基于命令行终端的类Sublime文本编辑器。</p></li></ul><ul><li><p><strong>其他</strong></p></li><li><p><a href="https://github.com/commitizen/cz-cli" rel="external nofollow noopener noreferrer" target="_blank">commitizen</a> - Commitizen命令行实用程序。</p></li><li><a href="https://github.com/yeoman/update-notifier" rel="external nofollow noopener noreferrer" target="_blank">update-notifier</a> - 为你的CLI应用提供的更新提示。</li><li><a href="https://github.com/lukeed/console-clear" rel="external nofollow noopener noreferrer" target="_blank">console-clear</a> - 跨平台清空控制台。</li></ul><h2 id="Node-js管理工具"><a href="#Node-js管理工具" class="headerlink" title="Node.js管理工具"></a>Node.js管理工具</h2><ul><li><a href="https://github.com/nvm-sh/nvm" rel="external nofollow noopener noreferrer" target="_blank">nvm</a> - Node.js版本管理工具。</li><li><a href="https://github.com/coreybutler/nvm-windows" rel="external nofollow noopener noreferrer" target="_blank">nvm for Windows</a> - Node.js版本管理工具Windows版。</li><li><a href="https://github.com/tj/n" rel="external nofollow noopener noreferrer" target="_blank">n</a> - Node.js版本管理工具。</li><li><a href="https://github.com/Schniz/fnm" rel="external nofollow noopener noreferrer" target="_blank">fnm</a> - 快速、轻量的Node.js版本管理工具，由Rust构建。</li><li><a href="https://github.com/isaacs/nave" rel="external nofollow noopener noreferrer" target="_blank">nave</a> - Node.js虚拟环境。</li><li><a href="https://github.com/nodenv/nodenv" rel="external nofollow noopener noreferrer" target="_blank">nodenv</a> - 版本管理工具（类似Ruby的 rbenv ），它支持自动切换。</li><li><a href="https://github.com/ekalinin/nodeenv" rel="external nofollow noopener noreferrer" target="_blank">nodeenv</a> - 与Python的 virtualenv 兼容的Node.js虚拟环境。</li></ul><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><ul><li><p><strong>NPM管理工具</strong></p></li><li><p><a href="https://github.com/pnpm/pnpm" rel="external nofollow noopener noreferrer" target="_blank">pnpm</a> - 快速、节省磁盘空间高效的包管理器。</p></li><li><a href="https://github.com/npm/cli" rel="external nofollow noopener noreferrer" target="_blank">npm</a> - JavaScript包管理工具。</li><li><a href="https://github.com/yarnpkg/berry" rel="external nofollow noopener noreferrer" target="_blank">yarn</a> - 现代包管理工具，拆分成多个不同的包。</li><li><a href="https://github.com/Pana/nrm" rel="external nofollow noopener noreferrer" target="_blank">nrm</a> - 快速切换npm注册服务商，如npm、cnpm、nj、taobao。</li><li><a href="https://github.com/cnpm/cnpm" rel="external nofollow noopener noreferrer" target="_blank">cnpm</a> - NPM中国区镜像客户端。</li></ul><ul><li><p><strong>package.json</strong></p></li><li><p><a href="https://github.com/sindresorhus/read-pkg-up" rel="external nofollow noopener noreferrer" target="_blank">read-pkg-up</a> - 读取最近的package.json文件。</p></li><li><a href="https://github.com/indexzero/node-pkginfo" rel="external nofollow noopener noreferrer" target="_blank">node-pkginfo</a> - 从package.json读取属性的简单方法。</li><li><a href="https://github.com/sindresorhus/pkg-dir" rel="external nofollow noopener noreferrer" target="_blank">pkg-dir</a> - 查找npm包的根目录。</li><li><a href="https://github.com/sindresorhus/read-pkg" rel="external nofollow noopener noreferrer" target="_blank">read-pkg</a> - 读取package.json文件。</li><li><a href="https://github.com/sindresorhus/write-pkg" rel="external nofollow noopener noreferrer" target="_blank">write-pkg</a> - 写入package.json文件。</li><li><a href="https://github.com/npm/read-package-json-fast" rel="external nofollow noopener noreferrer" target="_blank">read-package-json-fast</a> - 类似 read-package-json, 但更快。</li></ul><ul><li><p><strong>语义化版本</strong></p></li><li><p><a href="https://github.com/npm/node-semver" rel="external nofollow noopener noreferrer" target="_blank">semver</a> - NPM使用的JavaScript语义化版本号解析器。</p></li><li><a href="https://github.com/omichelsen/compare-versions" rel="external nofollow noopener noreferrer" target="_blank">compare-versions</a> - 比较semver版本字符串，找出哪个更大，哪个相等，哪个更小。</li></ul><ul><li><p><strong>工具</strong></p></li><li><p><a href="https://github.com/raineorshine/npm-check-updates" rel="external nofollow noopener noreferrer" target="_blank">npm-check-updates</a> - 查找当前package.json依赖允许的更新的版本。</p></li><li><a href="https://github.com/kimmobrunfeldt/concurrently" rel="external nofollow noopener noreferrer" target="_blank">concurrently</a> - 并行执行命令，类似 <code>npm run watch-js &amp; npm run watch-less</code>但更优。</li><li><a href="https://github.com/mysticatea/npm-run-all" rel="external nofollow noopener noreferrer" target="_blank">npm-run-all</a> - 命令行工具，同时运行多个npm脚本（并行或串行）。</li><li><a href="https://github.com/depcheck/depcheck" rel="external nofollow noopener noreferrer" target="_blank">depcheck</a> - 检查你的NPM模块未使用的依赖。</li><li><a href="https://github.com/cnpm/npminstall" rel="external nofollow noopener noreferrer" target="_blank">npminstall</a> - 使 <code>npm install</code> 更快更容易。</li><li><a href="https://github.com/npm/validate-npm-package-name" rel="external nofollow noopener noreferrer" target="_blank">validate-npm-package-name</a> - 校验给定的字符串 是否为 可接受的 npm 包名称。</li><li><a href="https://github.com/sindresorhus/npm-home" rel="external nofollow noopener noreferrer" target="_blank">npm-home</a> - 打开npm包页面。</li><li><a href="https://github.com/sindresorhus/npm-name" rel="external nofollow noopener noreferrer" target="_blank">npm-name</a> - 在npm上检查软件包名称的可用性。</li><li><a href="https://github.com/npm/pacote" rel="external nofollow noopener noreferrer" target="_blank">pacote</a> - 从npm注册商下载tar压缩文件，并获取包的资源信息。</li><li><a href="https://github.com/npm/npm-package-arg" rel="external nofollow noopener noreferrer" target="_blank">npm-package-arg</a> - 根据包名解析信息。</li><li><a href="https://github.com/npm/npm-registry-fetch" rel="external nofollow noopener noreferrer" target="_blank">npm-registry-fetch</a> - 类型fetch()函数，但用于npm仓库。</li><li><a href="https://github.com/node-modules/npm-updater" rel="external nofollow noopener noreferrer" target="_blank">npm-updater</a> - 检查npm包的更新。</li></ul><h2 id="Monorepo"><a href="#Monorepo" class="headerlink" title="Monorepo"></a>Monorepo</h2><p><em>(你也许喜欢 <a href="https://github.com/korfuri/awesome-monorepo" rel="external nofollow noopener noreferrer" target="_blank">awesome-monorepo</a>)</em></p><ul><li><a href="https://github.com/lerna/lerna" rel="external nofollow noopener noreferrer" target="_blank">lerna</a> - 用于管理具有多个包的JavaScript项目的工具。</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ul><li><p><strong>通用</strong></p></li><li><p><a href="https://github.com/jprichardson/node-fs-extra" rel="external nofollow noopener noreferrer" target="_blank">fs-extra</a> - 为 <code>fs</code> 模块提供额外方法。</p></li><li><a href="https://github.com/isaacs/node-graceful-fs" rel="external nofollow noopener noreferrer" target="_blank">graceful-fs</a> - graceful-fs可以替代fs模块，并做了各种改进。</li><li><a href="https://github.com/avoidwork/filesize.js" rel="external nofollow noopener noreferrer" target="_blank">filesize.js</a> - 生成人类可读的文件大小字符串。</li><li><a href="https://github.com/streamich/memfs" rel="external nofollow noopener noreferrer" target="_blank">memfs</a> - Node.js API内存文件系统。</li><li><a href="https://github.com/szwacz/fs-jetpack" rel="external nofollow noopener noreferrer" target="_blank">fs-jetpack</a> - 完全重新设计的文件系统API，方便日常使用。</li><li><a href="https://github.com/sindresorhus/make-dir" rel="external nofollow noopener noreferrer" target="_blank">make-dir</a> - 递归创建文件夹，类似 <code>mkdir -p</code>。</li><li><a href="https://github.com/sindresorhus/find-up" rel="external nofollow noopener noreferrer" target="_blank">find-up</a> - 通过上级父目录查找文件或目录。</li><li><a href="https://github.com/sindresorhus/filenamify" rel="external nofollow noopener noreferrer" target="_blank">filenamify</a> - 将字符串转换为有效的文件名。</li><li><a href="https://github.com/calvinmetcalf/copyfiles" rel="external nofollow noopener noreferrer" target="_blank">copyfiles</a> - 在命令行中复制文件。</li><li><a href="https://github.com/nspragg/filehound" rel="external nofollow noopener noreferrer" target="_blank">filehound</a> - 灵活流畅的文件系统搜索接口。</li><li><a href="https://github.com/sindresorhus/move-file" rel="external nofollow noopener noreferrer" target="_blank">move-file</a> - 移动文件，甚至可以跨设备工作。</li><li><a href="https://github.com/IndigoUnited/node-proper-lockfile" rel="external nofollow noopener noreferrer" target="_blank">proper-lockfile</a> - 进程间和机器间文件锁实用工具。</li><li><a href="https://github.com/bevry/istextorbinary" rel="external nofollow noopener noreferrer" target="_blank">istextorbinary</a> - 检查文件是文本文件还是二进制文件。</li><li><a href="https://github.com/isaacs/node-mkdirp" rel="external nofollow noopener noreferrer" target="_blank">mkdirp</a> - 递归创建文件夹，类似 <code>mkdir -p</code>。</li><li><a href="https://github.com/gliviu/dir-compare" rel="external nofollow noopener noreferrer" target="_blank">dir-compare</a> - Node JS文件夹对比。</li><li><a href="https://github.com/marc136/node-folder-hash" rel="external nofollow noopener noreferrer" target="_blank">folder-hash</a> - 为 文件夹或文件 上创建哈希检验码。</li><li><a href="https://github.com/kevva/lnfs" rel="external nofollow noopener noreferrer" target="_blank">lnfs</a> - 强制创建符号链接。类似<code>ln -fs</code>.</li></ul><ul><li><p><strong>复制</strong></p></li><li><p><a href="https://github.com/AvianFlu/ncp" rel="external nofollow noopener noreferrer" target="_blank">ncp</a> - 使用Node.js进行异步递归文件复制。</p></li><li><a href="https://github.com/sindresorhus/cpy" rel="external nofollow noopener noreferrer" target="_blank">cpy</a> - 文件拷贝。</li></ul><ul><li><p><strong>删除</strong></p></li><li><p><a href="https://github.com/isaacs/rimraf" rel="external nofollow noopener noreferrer" target="_blank">rimraf</a> - 递归删除文件，类似 <code>rm -rf</code>。</p></li><li><a href="https://github.com/sindresorhus/del" rel="external nofollow noopener noreferrer" target="_blank">del</a> - 删除文件/文件夹。</li></ul><ul><li><p><strong>临时</strong></p></li><li><p><a href="https://github.com/bruce/node-temp" rel="external nofollow noopener noreferrer" target="_blank">temp</a> - Node.js临时文件、文件夹、流。</p></li><li><a href="https://github.com/sindresorhus/tempy" rel="external nofollow noopener noreferrer" target="_blank">tempy</a> - 获取随机的临时文件或目录路径。</li><li><a href="https://github.com/sindresorhus/temp-dir" rel="external nofollow noopener noreferrer" target="_blank">temp-dir</a> - 获取系统临时文件夹的真实路径。</li></ul><ul><li><p><strong>监控</strong></p></li><li><p><a href="https://github.com/paulmillr/chokidar" rel="external nofollow noopener noreferrer" target="_blank">chokidar</a> - 最小且高效的跨平台Watch库。</p></li><li><a href="https://github.com/webpack/watchpack" rel="external nofollow noopener noreferrer" target="_blank">watchpack</a> - Watch文件和文件夹。</li></ul><ul><li><p><strong>遍历查找</strong></p></li><li><p><a href="https://github.com/isaacs/node-glob" rel="external nofollow noopener noreferrer" target="_blank">glob</a> - Node.js版glob功能。</p></li><li><a href="https://github.com/sindresorhus/globby" rel="external nofollow noopener noreferrer" target="_blank">globby</a> - 基于fast-glob，但添加了很多有用的特性。</li><li><a href="https://github.com/mrmlnc/fast-glob" rel="external nofollow noopener noreferrer" target="_blank">fast-glob</a> - 非常快速且高效的Node.js glob库。</li><li><a href="https://github.com/AndyOGo/node-sync-glob" rel="external nofollow noopener noreferrer" target="_blank">node-sync-glob</a> - 通过glob模式在本地同步文件和文件夹，包括watch选项。</li></ul><h2 id="解析工具"><a href="#解析工具" class="headerlink" title="解析工具"></a>解析工具</h2><ul><li><p><strong>Markdown</strong></p></li><li><p><a href="https://github.com/markedjs/marked" rel="external nofollow noopener noreferrer" target="_blank">marked</a> - Markdown解析器和编译器，专为提高速度而设计。</p></li><li><a href="https://github.com/wooorm/remark" rel="external nofollow noopener noreferrer" target="_blank">remark</a> - Markdown处理工具。</li><li><a href="https://github.com/markdown-it/markdown-it" rel="external nofollow noopener noreferrer" target="_blank">markdown-it</a> - 支持100%通用Markdown标签解析的扩展&amp;语法插件。</li><li><a href="https://www.npmjs.com/package/turndown" rel="external nofollow noopener noreferrer" target="_blank">turndown</a> - 用 JavaScript 编写的 HTML 到 Markdown 转换器。</li></ul><ul><li><strong>CSV</strong></li></ul><ul><li><a href="https://github.com/mholt/PapaParse" rel="external nofollow noopener noreferrer" target="_blank">PapaParse</a> - 快速而强大的 CSV（分隔文本）解析器，可以优雅地处理大文件和格式错误的输入。</li><li><a href="https://github.com/adaltas/node-csv" rel="external nofollow noopener noreferrer" target="_blank">node-csv</a> - 具有简单api的全功能CSV解析器，并针对大型数据集进行了测试。</li><li><a href="https://github.com/mafintosh/csv-parser" rel="external nofollow noopener noreferrer" target="_blank">csv-parser</a> - 旨在比其他任何人都快的流式CSV解析器。</li><li><a href="https://github.com/sindresorhus/neat-csv" rel="external nofollow noopener noreferrer" target="_blank">neat-csv</a> - 快速的CSV解析器。</li></ul><ul><li><strong>YAML</strong></li></ul><ul><li><a href="https://github.com/nodeca/js-yaml" rel="external nofollow noopener noreferrer" target="_blank">js-yaml</a> - 快速的YAML解析器。</li><li><a href="https://github.com/eemeli/yaml" rel="external nofollow noopener noreferrer" target="_blank">yaml</a> - YAML 的 JavaScript 解析器和字符串化。</li></ul><ul><li><strong>XML</strong></li></ul><ul><li><a href="https://github.com/Leonidas-from-XIV/node-xml2js" rel="external nofollow noopener noreferrer" target="_blank">xml2js</a> - 将XML转换为JavaScript对象的转换器。</li><li><a href="https://github.com/NaturalIntelligence/fast-xml-parser" rel="external nofollow noopener noreferrer" target="_blank">fast-xml-parser</a> - 验证&amp;解析 XML。</li><li><a href="https://github.com/oozcitak/xmlbuilder-js" rel="external nofollow noopener noreferrer" target="_blank">xmlbuilder</a> - XML构建器。</li><li><a href="https://github.com/michaelkourlas/node-js2xmlparser" rel="external nofollow noopener noreferrer" target="_blank">js2xmlparser</a> - 用于将 JavaScript 对象解析为 XML 的流行 Node.js 模块。</li></ul><ul><li><strong>HTML</strong></li></ul><ul><li><a href="https://github.com/fb55/htmlparser2" rel="external nofollow noopener noreferrer" target="_blank">htmlparser2</a> - 宽容的 HTML 和 XML 解析器。</li><li><a href="https://github.com/andrejewski/himalaya" rel="external nofollow noopener noreferrer" target="_blank">himalaya</a> - 将HTML转化为JSON的解析器。</li></ul><ul><li><strong>CSS</strong></li></ul><ul><li><a href="https://github.com/postcss/postcss" rel="external nofollow noopener noreferrer" target="_blank">PostCSS</a> - CSS解析工具。</li><li><a href="https://github.com/less/less.js" rel="external nofollow noopener noreferrer" target="_blank">less</a> - Less动态样式表语言。</li></ul><ul><li><strong>SQL</strong></li></ul><ul><li><a href="https://github.com/oguimbal/pgsql-ast-parser" rel="external nofollow noopener noreferrer" target="_blank">pgsql-ast-parser</a> - 简单的Postgres SQL解析器。</li><li><a href="https://github.com/DTStack/dt-sql-parser" rel="external nofollow noopener noreferrer" target="_blank">dt-sql-parser</a> - 大数据的SQL解析器，用antlr4构建。</li></ul><ul><li><strong>Plist</strong></li></ul><ul><li><a href="https://github.com/joeferner/node-bplist-parser" rel="external nofollow noopener noreferrer" target="_blank">node-bplist-parser</a> - 二进制plist文件解析。</li></ul><ul><li><strong>ini</strong></li></ul><ul><li><a href="https://github.com/npm/ini" rel="external nofollow noopener noreferrer" target="_blank">ini</a> - ini文件解析和序列化。</li></ul><ul><li><strong>其他</strong></li></ul><ul><li><a href="https://github.com/mozilla/readability" rel="external nofollow noopener noreferrer" target="_blank">readability</a> - 可读内容提取库，用于Firefox Reader View的独立提取版本。</li></ul><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li><a href="https://github.com/typicode/husky" rel="external nofollow noopener noreferrer" target="_blank">husky</a> - 现代化的本地Git钩子使操作更加轻松！</li><li><a href="https://github.com/nodegit/nodegit" rel="external nofollow noopener noreferrer" target="_blank">nodegit</a> - <a href="https://libgit2.org/" rel="external nofollow noopener noreferrer" target="_blank">libgit2</a> 的 Node.js 绑定版本。</li><li><a href="https://github.com/steveukx/git-js" rel="external nofollow noopener noreferrer" target="_blank">simple-git</a> - 一个轻量级的接口，用于在任何 node.js 应用程序中运行 git 命令。</li><li><a href="https://github.com/nicoespeon/gitgraph.js/tree/master/packages/gitgraph-node" rel="external nofollow noopener noreferrer" target="_blank">gitgraph-node</a> - 在 Terminal 绘制 git 流程图（支持浏览器、React）。</li><li><a href="https://github.com/observing/pre-commit" rel="external nofollow noopener noreferrer" target="_blank">pre-commit</a> - 自动在您的git储存库中安装git pre-commit脚本，该脚本在pre-commit上运行您的<code>npm test</code>。</li><li><a href="https://github.com/yyx990803/yorkie" rel="external nofollow noopener noreferrer" target="_blank">yorkie</a> - husky的Fork，让 Git 钩子变得简单(在 vue3 中使用)</li><li><a href="https://github.com/IonicaBizau/git-url-parse" rel="external nofollow noopener noreferrer" target="_blank">git-url-parse</a> - 高级别git解析。</li><li><a href="https://github.com/piuccio/git-promise" rel="external nofollow noopener noreferrer" target="_blank">git-promise</a> - 简单的封装，可运行任何git命令，并使用promise处理其输出。</li><li><a href="https://github.com/lukeed/gittar" rel="external nofollow noopener noreferrer" target="_blank">gittar</a> - 下载/提取git仓库 (GitHub, GitLab, BitBucket)，跨平台和优先离线。</li><li><a href="https://github.com/jonschlinkert/parse-git-config" rel="external nofollow noopener noreferrer" target="_blank">parse-git-config</a> - 将 <code>.git/config</code> 解析为 JavaScript 对象。 同步或异步。</li><li><a href="https://github.com/sindresorhus/remote-git-tags" rel="external nofollow noopener noreferrer" target="_blank">remote-git-tags</a> - 从远程仓库中获取标签。</li><li><a href="https://github.com/repo-utils/giturl" rel="external nofollow noopener noreferrer" target="_blank">giturl</a> - 将Git链接转化成Web链接。</li><li><a href="https://gitlab.com/flippidippi/download-git-repo" rel="external nofollow noopener noreferrer" target="_blank">download-git-repo</a> - 下载和提取Git仓库 (支持GitHub, GitLab, Bitbucket)。</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li><a href="https://github.com/winstonjs/winston" rel="external nofollow noopener noreferrer" target="_blank">winston</a> - 多传输异步日志记录库。</li><li><a href="https://github.com/pinojs/pino" rel="external nofollow noopener noreferrer" target="_blank">pino</a> - 受Bunyan启发的超快日志记录库。</li><li><a href="https://github.com/klauscfhq/signale" rel="external nofollow noopener noreferrer" target="_blank">signale</a> - 高度可配置的日志工具。</li><li><a href="https://github.com/trentm/node-bunyan" rel="external nofollow noopener noreferrer" target="_blank">bunyan</a> - 一个用于 Node.js 服务的简单快速的 JSON 日志模块。</li><li><a href="https://github.com/log4js-node/log4js-node" rel="external nofollow noopener noreferrer" target="_blank">log4js-node</a> - 不同于Java log4j的日志记录库。</li><li><a href="https://github.com/nuxt/consola" rel="external nofollow noopener noreferrer" target="_blank">consola</a> - 优雅的Node.js和浏览器日志记录库。</li><li><a href="https://github.com/guigrpa/storyboard" rel="external nofollow noopener noreferrer" target="_blank">storyboard</a> - 一个Chrome浏览器插件，用于查看日志。</li><li><a href="https://github.com/cabinjs/cabin" rel="external nofollow noopener noreferrer" target="_blank">cabin</a> - 提供日志服务和NPM包。</li><li><a href="https://github.com/gulpjs/fancy-log" rel="external nofollow noopener noreferrer" target="_blank">fancy-log</a> - 带上时间前缀的日志记录库。</li><li><a href="https://github.com/balderdashy/captains-log" rel="external nofollow noopener noreferrer" target="_blank">captains-log</a> - 通过简单的配置就可以使用的轻量日志记录库。</li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul><li><a href="https://github.com/Unitech/pm2" rel="external nofollow noopener noreferrer" target="_blank">PM2</a> - 高级进程管理工具。</li><li><a href="https://github.com/remy/nodemon" rel="external nofollow noopener noreferrer" target="_blank">nodemon</a> - 监视应用程序中的更改并自动重新启动服务器。</li><li><a href="https://github.com/foreversd/forever" rel="external nofollow noopener noreferrer" target="_blank">forever</a> - 简单的CLI工具，用于确认提供的代码持续运行。</li><li><a href="https://github.com/petruisfan/node-supervisor" rel="external nofollow noopener noreferrer" target="_blank">supervisor</a> - 当脚本崩溃时重新启动脚本，或者当`*.js’文件更改时重新启动脚本。</li><li><a href="https://github.com/coreybutler/node-windows" rel="external nofollow noopener noreferrer" target="_blank">node-windows</a> - 将脚本作为本机Windows服务运行，并登录到事件查看器。</li><li><a href="https://github.com/coreybutler/node-mac" rel="external nofollow noopener noreferrer" target="_blank">node-mac</a> - 将脚本作为本机Mac守护进程运行，并登录到控制台应用程序。</li><li><a href="https://github.com/coreybutler/node-linux" rel="external nofollow noopener noreferrer" target="_blank">node-linux</a> - 将脚本作为本机系统服务运行，并登录到syslog。</li><li><a href="https://github.com/branneman/current-processes" rel="external nofollow noopener noreferrer" target="_blank">current-processes</a> - 可获取当前正在运行的进程快照（操作系统无关）。</li></ul><h2 id="代码校验-和-格式化工具"><a href="#代码校验-和-格式化工具" class="headerlink" title="代码校验 和 格式化工具"></a>代码校验 和 格式化工具</h2><ul><li><a href="https://github.com/prettier/prettier" rel="external nofollow noopener noreferrer" target="_blank">prettier</a> - ❤”有主见”的多语言代码格式化程序。</li><li><a href="https://github.com/standard/standard" rel="external nofollow noopener noreferrer" target="_blank">standard</a> - JavaScript 代码规范，自带 linter &amp; 代码自动修正。</li><li><a href="https://github.com/eslint/eslint" rel="external nofollow noopener noreferrer" target="_blank">eslint</a> - 插件化并且可配置的 JavaScript 语法规则和代码风格的检查工具。</li><li><a href="https://github.com/stylelint/stylelint" rel="external nofollow noopener noreferrer" target="_blank">stylelint</a> - 功能强大现代风格检查工具，帮助你避免错误和强制约定样式风格。</li><li><a href="https://github.com/okonet/lint-staged" rel="external nofollow noopener noreferrer" target="_blank">lint-staged</a> - 在Git暂存文件上运行风格检查工具。</li><li><a href="https://github.com/conventional-changelog/commitlint" rel="external nofollow noopener noreferrer" target="_blank">commitlint</a> - Git提交信息风格检查工具。</li><li><a href="https://github.com/beautify-web/js-beautify" rel="external nofollow noopener noreferrer" target="_blank">js-beautify</a> - Javascript美化工具。</li><li><a href="https://github.com/xojs/xo" rel="external nofollow noopener noreferrer" target="_blank">xo</a> - 带出色默认配置的JavaScript/TypeScript代码校验 (基于ESLint封装)</li><li><a href="https://github.com/DavidAnson/markdownlint" rel="external nofollow noopener noreferrer" target="_blank">markdownlint</a> - Markdown/CommonMark风格检查工具。</li><li><a href="https://github.com/textlint/textlint" rel="external nofollow noopener noreferrer" target="_blank">textlint</a> - Text 和 Markdown 校验和格式化。</li><li><a href="https://github.com/azz/pretty-quick" rel="external nofollow noopener noreferrer" target="_blank">pretty-quick</a> - 快速美化。</li></ul><h2 id="配置工具"><a href="#配置工具" class="headerlink" title="配置工具"></a>配置工具</h2><ul><li><a href="https://github.com/lorenwest/node-config" rel="external nofollow noopener noreferrer" target="_blank">node-config</a> - Node.js 应用程序配置。</li><li><a href="https://github.com/indexzero/nconf" rel="external nofollow noopener noreferrer" target="_blank">nconf</a> - 可通过文件、环境变量、命令行参数和对象 合并的分层 Node.js 配置。</li><li><a href="https://github.com/mozilla/node-convict/tree/master/packages/convict" rel="external nofollow noopener noreferrer" target="_blank">convict</a> - Convict 扩展了配置 node.js 应用程序的标准模式，提供了更健壮且易于访问。</li><li><a href="https://github.com/dominictarr/rc" rel="external nofollow noopener noreferrer" target="_blank">rc</a> - 懒人的配置加载器。</li></ul><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><ul><li><a href="https://github.com/webpack/webpack" rel="external nofollow noopener noreferrer" target="_blank">webpack</a> - 打包浏览器的模块和资产。</li><li><a href="https://github.com/parcel-bundler/parcel" rel="external nofollow noopener noreferrer" target="_blank">parcel</a> - 快速，零配置的Web应用构建工具。</li><li><a href="https://github.com/gulpjs/gulp" rel="external nofollow noopener noreferrer" target="_blank">gulp</a> - 流式快速构建系统，支持代码而不是配置。</li><li><a href="https://github.com/evanw/esbuild" rel="external nofollow noopener noreferrer" target="_blank">esbuild</a> - 极快的JavaScript打包压缩工具。</li><li><a href="https://github.com/rollup/rollup" rel="external nofollow noopener noreferrer" target="_blank">rollup</a> - 新一代的 ES2015 打包构建工具。</li><li><a href="https://github.com/zeit/pkg" rel="external nofollow noopener noreferrer" target="_blank">pkg</a> - 将Node.js项目打包成可执行文件。</li><li><a href="https://github.com/gruntjs/grunt" rel="external nofollow noopener noreferrer" target="_blank">Grunt</a> - JavaScript任务执行器。</li><li><a href="https://github.com/brunch/brunch" rel="external nofollow noopener noreferrer" target="_blank">Brunch</a> - 前端web应用程序构建工具，具有简单的声明性配置、快速的增量编译和自定的工作流。</li><li><a href="https://github.com/fuse-box/fuse-box" rel="external nofollow noopener noreferrer" target="_blank">FuseBox</a> - 快速构建系统，结合了webpack，JSPM和SystemJS的强大功能，并具有一流的TypeScript支持。</li><li><a href="https://github.com/broccolijs/broccoli" rel="external nofollow noopener noreferrer" target="_blank">Broccoli</a> - 快速、可靠的资产管道，支持固定时间重建和紧凑的构建定义。</li></ul><h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a><strong>ESM</strong></h2><ul><li><a href="https://github.com/vitejs/vite" rel="external nofollow noopener noreferrer" target="_blank">Vite</a> - 新一代前端构建工具。</li><li><a href="https://github.com/snowpackjs/snowpack" rel="external nofollow noopener noreferrer" target="_blank">snowpack</a> - 由ESM支持的前端构建工具。 即时，轻量级，无捆绑开发。</li></ul><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><ul><li><a href="https://github.com/pugjs/pug" rel="external nofollow noopener noreferrer" target="_blank">Pug</a> - 受Haml启发的高性能模板引擎。</li><li><a href="https://github.com/wycats/handlebars.js" rel="external nofollow noopener noreferrer" target="_blank">handlebars.js</a> - Mustache 模板的超集，添加了强大的功能，如helper和更高级的block。</li><li><a href="https://github.com/janl/mustache.js" rel="external nofollow noopener noreferrer" target="_blank">mustache.js</a> - 轻量的JavaScript模板引擎。</li><li><a href="https://github.com/marko-js/marko" rel="external nofollow noopener noreferrer" target="_blank">marko</a> - 基于HTML的模板引擎，编译成CommonJS模块，支持流、异步渲染和自定义标签。</li><li><a href="https://github.com/aui/art-template" rel="external nofollow noopener noreferrer" target="_blank">art-template</a> - 高性能JavaScript模板引擎。</li><li><a href="https://github.com/mozilla/nunjucks" rel="external nofollow noopener noreferrer" target="_blank">nunjucks</a> - 具有继承，异步控制等功能的模板引擎（受Jinja2启发）。</li><li><a href="https://github.com/mde/ejs" rel="external nofollow noopener noreferrer" target="_blank">EJS</a> - 超级简单的模板语言。</li><li><a href="https://github.com/twitter/hogan.js" rel="external nofollow noopener noreferrer" target="_blank">hogan.js</a> -  样式的模板语言。</li><li><a href="https://github.com/olado/doT" rel="external nofollow noopener noreferrer" target="_blank">doT</a> - 最快简洁的JavaScript模板引擎。</li><li><a href="https://github.com/linkedin/dustjs" rel="external nofollow noopener noreferrer" target="_blank">dustjs</a> - 用于浏览器和服务器的异步Javascript模板。</li><li><a href="https://github.com/BorisMoore/jsrender" rel="external nofollow noopener noreferrer" target="_blank">jsrender</a> - 轻巧，功能强大且高度可扩展的模板引擎。</li><li><a href="https://github.com/twigjs/twig.js" rel="external nofollow noopener noreferrer" target="_blank">Twig.js</a> - Twig模板语言的JavaScript实现。</li><li><a href="https://github.com/pillarjs/hbs" rel="external nofollow noopener noreferrer" target="_blank">hbs</a> - Handlebars的Express版本封装。</li><li><a href="https://github.com/PaulGuo/Juicer" rel="external nofollow noopener noreferrer" target="_blank">Juicer</a> - 轻量级JavaScript模板引擎。</li><li><a href="https://github.com/twigkit/tempo" rel="external nofollow noopener noreferrer" target="_blank">tempo</a> - Tempo是一个简单，直观的JavaScript渲染引擎，使您能够以纯HTML格式制作数据模板。</li><li><a href="https://github.com/xtemplate/xtemplate" rel="external nofollow noopener noreferrer" target="_blank">xtemplate</a> - 用于浏览器和Node.js上的高速，可扩展模板引擎库。支持异步控制，继承，包含，逻辑表达式，自定义函数等。</li></ul><h2 id="内容管理系统-CMS"><a href="#内容管理系统-CMS" class="headerlink" title="内容管理系统 (CMS)"></a>内容管理系统 (CMS)</h2><ul><li><a href="https://github.com/TryGhost/Ghost" rel="external nofollow noopener noreferrer" target="_blank">Ghost</a> - 用于专业发布的无头 Node.js CMS。</li><li><a href="https://github.com/strapi/strapi" rel="external nofollow noopener noreferrer" target="_blank">Strapi</a> - 用于构建强大 API 的内容管理框架 (headless-CMS)。</li><li><a href="https://github.com/keystonejs/keystone" rel="external nofollow noopener noreferrer" target="_blank">KeystoneJS</a> - 基于 Express 和 MongoDB 的 CMS 和 Web应用程序平台。</li><li><a href="https://github.com/SoftwareBrothers/admin-bro" rel="external nofollow noopener noreferrer" target="_blank">AdminBro</a> - 为您的所有模型自动生成带有 增删查改(CRUD) 的管理面板。</li><li><a href="https://github.com/apostrophecms/apostrophe" rel="external nofollow noopener noreferrer" target="_blank">ApostropheCMS</a> - 基于 Express 和 MongoDB，拥有直观的内容编辑和管理的内容管理系统。</li><li><a href="https://github.com/tipeio/tipe" rel="external nofollow noopener noreferrer" target="_blank">Tipe</a> - 面向开发人员的下一代 API优先 CMS。使用离线原型和内置编辑器从 GraphQL Schema 中 生成 API优先 的 CMS。</li><li><a href="https://github.com/fiction-com/factor" rel="external nofollow noopener noreferrer" target="_blank">Factor</a> - Vue.js 仪表板框架 和 无头CMS。</li></ul><h2 id="静态网站生成-amp-博客"><a href="#静态网站生成-amp-博客" class="headerlink" title="静态网站生成 &amp; 博客"></a>静态网站生成 &amp; 博客</h2><ul><li><a href="https://github.com/gatsbyjs/gatsby" rel="external nofollow noopener noreferrer" target="_blank">gatsby</a> - 使用React构建快速、现代的应用程序和网站。</li><li><a href="https://github.com/hexojs/hexo" rel="external nofollow noopener noreferrer" target="_blank">hexo</a> - 使用Node.js的快速，简单，强大的博客框架。</li><li><a href="https://github.com/vuejs/vuepress" rel="external nofollow noopener noreferrer" target="_blank">vuepress</a> - 极简的Vue静态网站生成工具。</li><li><a href="https://github.com/netlify/netlify-cms" rel="external nofollow noopener noreferrer" target="_blank">netlify-cms</a> - 基于Git的静态网站生成工具。</li><li><a href="https://github.com/react-static/react-static" rel="external nofollow noopener noreferrer" target="_blank">react-static</a> - 渐进式的React静态网站生成工具。</li><li><a href="https://github.com/gridsome/gridsome" rel="external nofollow noopener noreferrer" target="_blank">gridsome</a> - Vue.js静态网站生成工具。</li><li><a href="https://github.com/vuejs/vitepress" rel="external nofollow noopener noreferrer" target="_blank">vitepress</a> - Vite &amp; Vue.js静态网站生成工具。</li><li><a href="https://github.com/scullyio/scully" rel="external nofollow noopener noreferrer" target="_blank">scully</a> - Angular 应用程序的静态站点生成器。</li></ul><h2 id="文档生成"><a href="#文档生成" class="headerlink" title="文档生成"></a>文档生成</h2><ul><li><a href="https://github.com/facebook/docusaurus" rel="external nofollow noopener noreferrer" target="_blank">Docusaurus</a> - 使用React和Markdown并具有翻译和版本控制功能的文档站点生成器。</li><li><a href="https://github.com/docsifyjs/docsify" rel="external nofollow noopener noreferrer" target="_blank">docsify</a> - API文档生成器。</li><li><a href="https://github.com/jsdoc3/jsdoc" rel="external nofollow noopener noreferrer" target="_blank">JSDoc</a> - API文档生成器，类似于JavaDoc或PHPDoc。</li><li><a href="https://github.com/documentationjs/documentation" rel="external nofollow noopener noreferrer" target="_blank">documentation.js</a> - API文档生成器，支持ES2015+和流程注释。</li><li><a href="https://github.com/jashkenas/docco" rel="external nofollow noopener noreferrer" target="_blank">Docco</a> - 文档生成器，该生成器生成一个HTML文档，该文档显示与代码混合的注释。</li><li><a href="https://github.com/egoist/docute" rel="external nofollow noopener noreferrer" target="_blank">docute</a> - 毫不费力的文档，做就对了。</li><li><a href="https://github.com/esdoc/esdoc" rel="external nofollow noopener noreferrer" target="_blank">ESDoc</a> - 针对ES2015的文档生成器，附加测试代码并衡量文档覆盖范围。</li></ul><h2 id="桌面应用程序"><a href="#桌面应用程序" class="headerlink" title="桌面应用程序"></a>桌面应用程序</h2><ul><li><a href="https://github.com/atom/electron" rel="external nofollow noopener noreferrer" target="_blank">Electron</a> - 使用Web技术构建跨平台的桌面应用程序。 <em>(你也许喜欢 <a href="https://github.com/sindresorhus/awesome-electron" rel="external nofollow noopener noreferrer" target="_blank">awesome-electron</a>)</em></li><li><a href="https://github.com/nwjs/nw.js" rel="external nofollow noopener noreferrer" target="_blank">nw.js</a> - 使用 Web 技术编写应用程序的新方法，并直接从 DOM/WebWorker 调用所有 Node.js 模块。</li></ul><h2 id="实时通信"><a href="#实时通信" class="headerlink" title="实时通信"></a>实时通信</h2><ul><li><a href="https://github.com/socketio/socket.io" rel="external nofollow noopener noreferrer" target="_blank">Socket.io</a> - 实现基于事件的实时双向通信。</li><li><a href="https://github.com/websockets/ws" rel="external nofollow noopener noreferrer" target="_blank">ws</a> - 简单易用，速度极快，经过全面测试的WebSocket客户端和服务器Node.js通信库。</li><li><a href="https://github.com/uWebSockets/uWebSockets" rel="external nofollow noopener noreferrer" target="_blank">µWebSockets</a> - 高度可扩展的WebSocket服务器和客户端库。</li><li><a href="https://github.com/mqttjs/MQTT.js" rel="external nofollow noopener noreferrer" target="_blank">MQTT.js</a> - MQTT客户端-基于Pub-sub的消息协议，用于TCP / IP。</li><li><a href="https://github.com/SocketCluster/socketcluster" rel="external nofollow noopener noreferrer" target="_blank">SocketCluster</a> - 可扩展的HTTP + WebSocket引擎，可以在多个CPU内核上运行。</li><li><a href="https://github.com/faye/faye" rel="external nofollow noopener noreferrer" target="_blank">Faye</a> - 基于Bayeux协议的实时客户端-服务器消息总线。</li><li><a href="https://github.com/primus/primus" rel="external nofollow noopener noreferrer" target="_blank">Primus</a> - 实时框架的抽象层，以防止模块锁定。</li><li><a href="https://github.com/socketio/engine.io" rel="external nofollow noopener noreferrer" target="_blank">engine.io</a> - 基于传输的跨浏览器/跨设备双向通信层的实现Socket.IO。</li><li><a href="https://github.com/sockjs/sockjs-node" rel="external nofollow noopener noreferrer" target="_blank">SockJS-node</a> - WebSocket Node.js服务端实现。</li><li><a href="https://github.com/mcollina/aedes" rel="external nofollow noopener noreferrer" target="_blank">Aedes</a> - 可以在任何流服务器上运行的准系统MQTT服务器。</li><li><a href="https://github.com/elpheria/rpc-websockets" rel="external nofollow noopener noreferrer" target="_blank">rpc-websockets</a> - 通过WebSocket实现JSON-RPC 2.0。</li><li><a href="https://github.com/deepstreamIO/deepstream.io-client-js" rel="external nofollow noopener noreferrer" target="_blank">deepstream.io</a> - 可扩展的实时通信微服务框架。</li><li><a href="https://github.com/heineiuo/isomorphic-ws" rel="external nofollow noopener noreferrer" target="_blank">isomorphic-ws</a> - WebSocket 的同构实现。</li><li><a href="https://github.com/kalm/kalm.js" rel="external nofollow noopener noreferrer" target="_blank">Kalm</a> - 低级套接字路由器和中间件框架。</li></ul><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><ul><li><a href="https://github.com/OptimalBits/bull" rel="external nofollow noopener noreferrer" target="_blank">bull</a> - 持久作业和消息队列。</li><li><a href="https://github.com/squaremo/amqp.node" rel="external nofollow noopener noreferrer" target="_blank">amqp</a>- AMQP 0-9-1 rabbit消息队列连接库。</li><li><a href="https://github.com/SOHU-Co/kafka-node" rel="external nofollow noopener noreferrer" target="_blank">kafka-node</a>- Apache Kafka 0.8 kafka客户端。</li><li><a href="https://github.com/bee-queue/bee-queue" rel="external nofollow noopener noreferrer" target="_blank">bee-queue</a> - 高性能的 基于Redis的任务队列。</li><li><a href="https://github.com/bee-queue/arena" rel="external nofollow noopener noreferrer" target="_blank">arena</a> - bee-queue的交互式UI仪表盘。</li><li><a href="https://github.com/tulios/kafkajs" rel="external nofollow noopener noreferrer" target="_blank">kafkajs</a> - A modern Apache Kafka client for node.js.</li><li><a href="https://github.com/smrchy/rsmq" rel="external nofollow noopener noreferrer" target="_blank">rsmq</a> - 基于Redis的消息队列.</li><li><a href="https://github.com/bbc/sqs-consumer" rel="external nofollow noopener noreferrer" target="_blank">sqs-consumer</a> - 在没有样板文件的情况下构建基于Amazon简单队列服务（SQS）的应用程序.</li><li><a href="https://github.com/taskrabbit/node-resque" rel="external nofollow noopener noreferrer" target="_blank">node-resque</a> - Redis支持的作业队列.</li><li><a href="https://github.com/diamondio/better-queue" rel="external nofollow noopener noreferrer" target="_blank">better-queue</a> - 当你无法使用Redis时，简单高效的作业队列.</li><li><a href="https://github.com/weyoss/redis-smq" rel="external nofollow noopener noreferrer" target="_blank">RedisSMQ</a> - 具有实时监控功能的简单高性能Redis消息队列.</li><li><a href="https://github.com/nodeca/idoit" rel="external nofollow noopener noreferrer" target="_blank">idoit</a> - 具有高级作业控制的Redis支持的作业队列引擎.</li></ul><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><ul><li><a href="https://github.com/node-schedule/node-schedule" rel="external nofollow noopener noreferrer" target="_blank">node-schedule</a> - 类Cron和不类似Cron的Node.js定时任务。</li><li><a href="https://github.com/agenda/agenda" rel="external nofollow noopener noreferrer" target="_blank">agenda</a> - Node.js轻量级定时任务。</li><li><a href="https://github.com/kelektiv/node-cron" rel="external nofollow noopener noreferrer" target="_blank">node-cron</a> - 允许执行定时任务的工具。</li><li><a href="https://github.com/harrisiirak/cron-parser" rel="external nofollow noopener noreferrer" target="_blank">cron-parser</a> - 用于解析crontab指令的Node.js库。</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li><a href="https://github.com/node-inspector/node-inspector" rel="external nofollow noopener noreferrer" target="_blank">node-inspector</a> - 基于Blink开发者工具的调试器。</li><li><a href="https://github.com/GoogleChromeLabs/ndb" rel="external nofollow noopener noreferrer" target="_blank">ndb</a> - Chrome DevTools调试体验改进工具。</li><li><a href="https://github.com/visionmedia/debug" rel="external nofollow noopener noreferrer" target="_blank">debug</a> - 轻量调试工具。</li><li><a href="https://github.com/s-a/iron-node" rel="external nofollow noopener noreferrer" target="_blank">ironNode</a> - 支持ES2015的Node.js开箱即用的调试器。</li><li><a href="https://github.com/mafintosh/why-is-node-running" rel="external nofollow noopener noreferrer" target="_blank">why-is-node-running</a> - 当Node因不明原因继续运行时，使用的分析工具。</li><li><a href="https://github.com/nodejs/llnode" rel="external nofollow noopener noreferrer" target="_blank">llnode</a> - 事后分析工具，使您可以检查对象并从崩溃的Node.js进程中获取信息。</li><li><a href="https://github.com/valyouw/njstrace" rel="external nofollow noopener noreferrer" target="_blank">njsTrace</a> - 检测和跟踪您的代码，查看所有函数调用、参数、返回值以及在每个函数中花费的时间。</li><li><a href="https://github.com/alidavut/locus" rel="external nofollow noopener noreferrer" target="_blank">locus</a> - Locus 是一个调试模块，它允许您通过 REPL 在运行时执行命令。</li><li><a href="https://github.com/watson/stackman" rel="external nofollow noopener noreferrer" target="_blank">stackman</a> - 使用代码摘录和其他优点增强错误堆栈跟踪。</li><li><a href="https://github.com/june07/nim" rel="external nofollow noopener noreferrer" target="_blank">NiM</a> - 管理DevTools调试工具流。</li><li><a href="https://github.com/automation-stack/ctrace" rel="external nofollow noopener noreferrer" target="_blank">ctrace</a> - 将系统调用信息和信号，以更良好的格式显示和扩展。</li><li><a href="https://github.com/joyent/node-vstream" rel="external nofollow noopener noreferrer" target="_blank">vstream</a> - 检测流。</li></ul><h2 id="剖析-分析"><a href="#剖析-分析" class="headerlink" title="剖析/分析"></a>剖析/分析</h2><ul><li><a href="https://github.com/clinicjs/node-clinic" rel="external nofollow noopener noreferrer" target="_blank">Clinic.js</a> - Clinic.js诊断Node.js性能问题。</li><li><a href="https://github.com/davidmarkclements/0x" rel="external nofollow noopener noreferrer" target="_blank">0x</a> - 火焰图分析。</li><li><a href="https://github.com/bnoordhuis/node-heapdump" rel="external nofollow noopener noreferrer" target="_blank">node-heapdump</a> - 存储V8内存堆使用情况，以供以后诊断。</li><li><a href="https://github.com/andywer/leakage" rel="external nofollow noopener noreferrer" target="_blank">leakage</a> - 内存写入泄漏测试。</li><li><a href="https://github.com/node-inspector/v8-profiler" rel="external nofollow noopener noreferrer" target="_blank">v8-profiler</a> - V8性能探测器。</li><li><a href="https://github.com/marcominetti/node-memwatch" rel="external nofollow noopener noreferrer" target="_blank">node-memwatch</a> - 一个 NodeJS 库，用于监视您的内存使用情况，并发现和隔离泄漏。</li><li><a href="https://github.com/hyj1991/v8-analytics" rel="external nofollow noopener noreferrer" target="_blank">v8-analytics</a> - V8引擎CPU 和 堆内存分析。</li><li><a href="https://github.com/sfninja/thetool" rel="external nofollow noopener noreferrer" target="_blank">thetool</a> - 以Chrome DevTools友好格式为您的应用捕获不同的CPU，内存和其他配置文件。</li><li><a href="https://github.com/thlorenz/flamegraph" rel="external nofollow noopener noreferrer" target="_blank">flamegraph</a> - 在Node.js或浏览器中生成火焰图。</li><li><a href="https://github.com/hyj1991/v8-profiler-next" rel="external nofollow noopener noreferrer" target="_blank">v8-profiler-next</a> - V8性能探测器。</li><li><a href="https://github.com/nswbmw/cpu-memory-monitor" rel="external nofollow noopener noreferrer" target="_blank">cpu-memory-monitor</a> - CPU 和内存监视器，自动转储。</li></ul><h2 id="应用性能监控-APM"><a href="#应用性能监控-APM" class="headerlink" title="应用性能监控 (APM)"></a>应用性能监控 (APM)</h2><ul><li><p><strong>解决方案</strong></p></li><li><p><a href="https://github.com/hyj1991/easy-monitor" rel="external nofollow noopener noreferrer" target="_blank">easy-monitor</a> - 企业级 Node.js 应用性能监控和在线故障定位解决方案。</p></li><li><a href="https://github.com/a597873885/webfunny_monitor" rel="external nofollow noopener noreferrer" target="_blank">webfunny_monitor</a> - Webfunny是一款轻量级的前端监控系统，也是一款前端性能监控系统，无埋点监控前端日志，实时分析前端健康状态。</li></ul><ul><li><strong>中间件</strong></li></ul><ul><li><a href="https://github.com/slanatech/swagger-stats" rel="external nofollow noopener noreferrer" target="_blank">swagger-stats</a> - 跟踪 API 调用并监控 API 性能、运行状况和使用指标。</li></ul><ul><li><strong>代理</strong></li></ul><ul><li><a href="https://github.com/siimon/prom-client" rel="external nofollow noopener noreferrer" target="_blank">prom-client</a> - Prometheus代理。</li><li><a href="https://github.com/elastic/apm-agent-nodejs" rel="external nofollow noopener noreferrer" target="_blank">apm-agent-nodejs</a> - Elastic APM Node.js代理。</li><li><a href="https://github.com/apache/skywalking-nodejs" rel="external nofollow noopener noreferrer" target="_blank">skywalking-nodejs</a> - Apache SkyWalking Node.js代理</li></ul><h2 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h2><ul><li><a href="https://github.com/NodeBB/NodeBB" rel="external nofollow noopener noreferrer" target="_blank">NodeBB</a> - 基于Node.js的现代Web论坛。</li><li><a href="https://github.com/cnodejs/nodeclub/" rel="external nofollow noopener noreferrer" target="_blank">nodeclub</a> - Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li><p><strong>驱动</strong></p></li><li><p><a href="https://github.com/mysqljs/mysql" rel="external nofollow noopener noreferrer" target="_blank">MySQL</a> - MySQL 客户端。</p></li><li><a href="https://github.com/brianc/node-postgres" rel="external nofollow noopener noreferrer" target="_blank">PostgreSQL</a> - PostgreSQL客户端。</li><li><a href="https://github.com/mongodb/node-mongodb-native" rel="external nofollow noopener noreferrer" target="_blank">MongoDB</a> - 官方MongoDB驱动。</li><li><a href="https://github.com/luin/ioredis" rel="external nofollow noopener noreferrer" target="_blank">ioredis</a> - Redis客户端。</li><li><a href="https://github.com/Level/levelup" rel="external nofollow noopener noreferrer" target="_blank">LevelUP</a> - LevelDB客户端。</li><li><a href="https://github.com/apache/couchdb-nano" rel="external nofollow noopener noreferrer" target="_blank">couchdb-nano</a> - 官方CouchDB客户端。</li><li><a href="https://github.com/couchbase/couchnode" rel="external nofollow noopener noreferrer" target="_blank">Couchbase</a> - Couchbase客户端（官方）。</li><li><a href="https://github.com/aerospike/aerospike-client-nodejs" rel="external nofollow noopener noreferrer" target="_blank">Aerospike</a> - Aerospike客户端。</li></ul><ul><li><strong>ODM / ORM</strong></li></ul><ul><li><a href="https://github.com/sequelize/sequelize" rel="external nofollow noopener noreferrer" target="_blank">Sequelize</a> - 多方ORM。 支持PostgreSQL，SQLite，MySQL。</li><li><a href="https://github.com/typeorm/typeorm" rel="external nofollow noopener noreferrer" target="_blank">TypeORM</a> - PostgreSQL，MariaDB，MySQL，SQLite等的ORM。</li><li><a href="https://github.com/Automattic/mongoose" rel="external nofollow noopener noreferrer" target="_blank">Mongoose</a> - 优雅的MongoDB对象建模。</li><li><a href="https://github.com/typegoose/typegoose" rel="external nofollow noopener noreferrer" target="_blank">typegoose</a> - Typegoose - 使用 TypeScript 类定义 Mongoose 模型。</li><li><a href="https://github.com/prisma/prisma" rel="external nofollow noopener noreferrer" target="_blank">Prisma</a> - 支持PostgreSQL, MySQL &amp; SQLite，自动生成、类型安全的query builder。</li><li><a href="https://github.com/bookshelf/bookshelf" rel="external nofollow noopener noreferrer" target="_blank">Bookshelf</a> - Backbone.js风格的PostgreSQL，MySQL和SQLite3的ORM。</li><li><a href="https://github.com/Vincit/objection.js" rel="external nofollow noopener noreferrer" target="_blank">Objection.js</a> - 基于SQL查询生成器Knex的轻量级ORM。</li><li><a href="https://github.com/balderdashy/waterline" rel="external nofollow noopener noreferrer" target="_blank">Waterline</a> - 与数据存储区无关的工具，可大大简化与一个或多个数据库的交互。</li><li><a href="https://github.com/robconery/massive-js" rel="external nofollow noopener noreferrer" target="_blank">Massive</a> - PostgreSQL数据访问工具。</li><li><a href="https://github.com/vitaly-t/pg-promise" rel="external nofollow noopener noreferrer" target="_blank">pg-promise</a> - 用于使用Promise的本机SQL的PostgreSQL框架。</li><li><a href="https://github.com/mikro-orm/mikro-orm" rel="external nofollow noopener noreferrer" target="_blank">MikroORM</a> - 基于数据映射器，工作单元和身份映射模式的TypeScript ORM。 支持MongoDB，PostgreSQL，MySQL和SQLite。</li><li><a href="https://github.com/gajus/slonik" rel="external nofollow noopener noreferrer" target="_blank">slonik</a> - 具有严格类型，详细日志记录和断言的PostgreSQL客户端。</li><li><a href="https://github.com/PhilWaldmann/openrecord" rel="external nofollow noopener noreferrer" target="_blank">OpenRecord</a> - PostgreSQL，MySQL，SQLite3和RESTful数据存储的ORM。 类似于ActiveRecord</li><li>Query builder</li><li><a href="https://github.com/tgriesser/knex" rel="external nofollow noopener noreferrer" target="_blank">Knex</a> - PostgreSQL，MySQL和SQLite3的查询构建器，旨在灵活，可移植且易于使用。</li></ul><ul><li><strong>SQL</strong></li></ul><ul><li><a href="https://github.com/mysqljs/sqlstring" rel="external nofollow noopener noreferrer" target="_blank">sqlstring</a> - 简单 SQL 转义和格式，用于MySQL。</li></ul><ul><li><strong>其他</strong></li></ul><ul><li><a href="https://github.com/typicode/lowdb" rel="external nofollow noopener noreferrer" target="_blank">Lowdb</a> - 用于小型项目的微型本地 JSON 数据库（支持 Node、Electron 和浏览器）。</li><li><a href="https://github.com/louischatriot/nedb" rel="external nofollow noopener noreferrer" target="_blank">NeDB</a> - 用于 Node.js、nw.js、Electron和浏览器的嵌入式持久数据库或内存数据库。</li><li><a href="https://github.com/lukechilds/keyv" rel="external nofollow noopener noreferrer" target="_blank">Keyv</a> - 支持多个后端的简单键值(KV)存储。</li><li><a href="https://github.com/oguimbal/pg-mem" rel="external nofollow noopener noreferrer" target="_blank">pg-mem</a> - 内存 PostgreSQL 实例。</li><li><a href="https://github.com/pkosiec/mongo-seeding" rel="external nofollow noopener noreferrer" target="_blank">Mongo Seeding</a> - 使用 JavaScript 和 JSON 文件填充 MongoDB 数据库。</li><li><a href="https://github.com/ForbesLindesay/atdatabases" rel="external nofollow noopener noreferrer" target="_blank">@databases</a> - 使用普通 SQL 查询 PostgreSQL、MySQL 和 SQLite3，而不会导致 SQL注入 的风险。</li><li><a href="https://github.com/tommybananas/finale" rel="external nofollow noopener noreferrer" target="_blank">Finale</a> - 基于 Sequelize 模型生成 RESTful接口。</li><li><a href="https://github.com/mlaanderson/database-js" rel="external nofollow noopener noreferrer" target="_blank">database-js</a> - 类似 JDBC连接 的多个数据库连接封装。</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><a href="https://github.com/isaacs/node-lru-cache" rel="external nofollow noopener noreferrer" target="_blank">lru-cache</a> - 最近最少使用的缓存（LRU）实现。</li><li><a href="https://github.com/node-cache/node-cache" rel="external nofollow noopener noreferrer" target="_blank">node-cache</a> - Node.js内存缓存模块。</li><li><a href="https://github.com/3rd-Eden/memcached" rel="external nofollow noopener noreferrer" target="_blank">memcached</a> - 功能齐全的Memcached Node.js客户端库。 考虑到扩展性，因此它将支持Memcached群集和一致的哈希。</li><li><a href="https://github.com/BryanDonovan/node-cache-manager" rel="external nofollow noopener noreferrer" target="_blank">node-cache-manager</a> - Node.js Cache模块。</li><li><a href="https://github.com/dominictarr/hashlru" rel="external nofollow noopener noreferrer" target="_blank">hashlru</a> - 更轻量更快的LRU算法。</li><li><a href="https://github.com/royriojas/flat-cache" rel="external nofollow noopener noreferrer" target="_blank">flat-cache</a> - 一个傻瓜般简单的键/值存储使用文件来持久化数据。</li><li><a href="https://github.com/node-modules/ylru" rel="external nofollow noopener noreferrer" target="_blank">ylru</a> - 基于hashlru添加过期时间，允许空值。</li></ul><h2 id="自动化-amp-机器人流程自动化-RPA"><a href="#自动化-amp-机器人流程自动化-RPA" class="headerlink" title="自动化 &amp; 机器人流程自动化 - RPA"></a><strong>自动化 &amp; 机器人流程自动化 - RPA</strong></h2><ul><li><a href="https://github.com/puppeteer/puppeteer" rel="external nofollow noopener noreferrer" target="_blank">puppeteer</a> - 无头Chrome Node.js API。</li><li><a href="https://github.com/microsoft/playwright" rel="external nofollow noopener noreferrer" target="_blank">playwright</a> - 使用单一API自动操作Chromium, Firefox and WebKi。</li><li><a href="https://github.com/ariya/phantomjs" rel="external nofollow noopener noreferrer" target="_blank">phantomjs</a> - 脚本化无头浏览器。</li><li><a href="https://github.com/appium/appium" rel="external nofollow noopener noreferrer" target="_blank">appium</a> - iOS, Android, and Windows Apps自动化。</li><li><a href="https://github.com/octalmage/robotjs" rel="external nofollow noopener noreferrer" target="_blank">robotjs</a> - Node.js桌面自动化。</li><li><a href="https://github.com/nut-tree/nut.js" rel="external nofollow noopener noreferrer" target="_blank">nut.js</a> - 使用Node.js进行原生 UI 测试/控制</li></ul><h2 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h2><ul><li><p><strong>断言库</strong></p></li><li><p><a href="https://github.com/chaijs/chai" rel="external nofollow noopener noreferrer" target="_blank">chai</a> - 基于行为驱动开发(BDD)和测试驱动开发(TDD)理念的Node.js和浏览器断言库，可与任何 JavaScript 测试框架集成。</p></li><li><a href="https://github.com/power-assert-js/power-assert" rel="external nofollow noopener noreferrer" target="_blank">power-assert</a> - 使用标准assert接口提供的描述型断言消息。</li><li><a href="https://github.com/Automattic/expect.js" rel="external nofollow noopener noreferrer" target="_blank">expect.js</a> - 适用于Node.JS和浏览器的简约BDD风格的断言库。</li><li><a href="https://github.com/shouldjs/should.js" rel="external nofollow noopener noreferrer" target="_blank">should.js</a> - Node.JS的行为驱动开发(BDD)风格断言库。</li><li><a href="https://github.com/tj/better-assert" rel="external nofollow noopener noreferrer" target="_blank">better-assert</a> - C语言风格的Node.js断言，将表达式字符串报告为错误消息。</li><li><a href="https://github.com/jshttp/http-assert" rel="external nofollow noopener noreferrer" target="_blank">http-assert</a> - 带状态码的断言。</li></ul><ul><li><strong>假数据生成</strong></li></ul><ul><li><a href="https://github.com/marak/Faker.js/" rel="external nofollow noopener noreferrer" target="_blank">faker.js</a> - 在Node.js和浏览器中生成大量逼真的假数据。</li><li><a href="https://github.com/boo1ean/casual" rel="external nofollow noopener noreferrer" target="_blank">casual</a> - JavaScript假数据生成。</li><li><a href="https://github.com/captainsafia/fony" rel="external nofollow noopener noreferrer" target="_blank">fony</a> - 一个简单的命令行工具，从字符串模板中生成假数据。</li></ul><ul><li><strong>Mock</strong></li></ul><ul><li><a href="https://github.com/nuysoft/Mock" rel="external nofollow noopener noreferrer" target="_blank">Mock.js</a> - 浏览器和 Node 均可用，支持自定义 schema 和 随机数据。</li><li><a href="https://github.com/pgte/nock" rel="external nofollow noopener noreferrer" target="_blank">Nock</a> - HTTP mock和期望。</li><li><a href="https://github.com/sinonjs/sinon" rel="external nofollow noopener noreferrer" target="_blank">Sinon.JS</a> - 通过间谍函数(spies), 目标函数替换（stubs）和mocks功能提供的Mock库。</li><li><a href="https://github.com/easy-mock/easy-mock" rel="external nofollow noopener noreferrer" target="_blank">easy-mock</a> - 可视化，并且能快速生成模拟数据的持久化服务。</li><li><a href="https://github.com/node-modules/mm" rel="external nofollow noopener noreferrer" target="_blank">mm</a> - 简单但灵活的 mock(或者叫stub) 包, mock伴侣。</li><li><a href="https://github.com/sinedied/smoke" rel="external nofollow noopener noreferrer" target="_blank">smoke</a> - 具有记录功能的，简单但功能强大的基于文件的Mock服务器。</li></ul><ul><li><strong>端到端的测试(E2E) / 自动化UI</strong></li></ul><ul><li><a href="https://github.com/nightwatchjs/nightwatch" rel="external nofollow noopener noreferrer" target="_blank">nightwatch</a> - 用 Node.js 编写，并使用 Webdriver API 的端到端测试框架。</li><li><a href="https://github.com/codeceptjs/CodeceptJS" rel="external nofollow noopener noreferrer" target="_blank">CodeceptJS</a> - Node.js端到端测试框架。</li></ul><ul><li><strong>测试框架</strong></li></ul><ul><li><a href="https://github.com/facebook/jest" rel="external nofollow noopener noreferrer" target="_blank">jest</a> - 愉悦的JavaScript测试。</li><li><a href="https://github.com/mochajs/mocha" rel="external nofollow noopener noreferrer" target="_blank">mocha</a> - 简单、灵活、有趣的功能丰富的Node.js和浏览器测试框架。</li><li><a href="https://github.com/avajs/ava" rel="external nofollow noopener noreferrer" target="_blank">ava</a> - 面向未来的测试运行程序。</li><li><a href="https://github.com/jasmine/jasmine" rel="external nofollow noopener noreferrer" target="_blank">jasmine</a> - 简单的Node.js和浏览器测试框架。</li><li><a href="https://github.com/visionmedia/supertest" rel="external nofollow noopener noreferrer" target="_blank">supertest</a> - 使用流畅的API，基于Super-agent库测试Node.js HTTP服务器。</li><li><a href="https://github.com/tapjs/node-tap" rel="external nofollow noopener noreferrer" target="_blank">node-tap</a> - 用于Node.js测试任何协议的工具。</li></ul><ul><li><strong>覆盖率</strong></li></ul><ul><li><a href="https://github.com/istanbuljs/nyc" rel="external nofollow noopener noreferrer" target="_blank">nyc</a> - Istanbul的命令行工具。</li><li><a href="https://github.com/nickmerwin/node-coveralls" rel="external nofollow noopener noreferrer" target="_blank">node-coveralls</a> - 借助持续集成服务(Travis CI 或 Jenkins) 向用户报告自动测试的测试覆盖率；为README添加一个很酷的覆盖率按钮。</li><li><a href="https://github.com/codecov/codecov-node" rel="external nofollow noopener noreferrer" target="_blank">codecov</a> - NodeJS中代码覆盖率报告上载器。</li></ul><ul><li><strong>基准测试</strong></li></ul><ul><li><a href="https://github.com/bestiejs/benchmark.js" rel="external nofollow noopener noreferrer" target="_blank">Benchmark.js</a> - 基准测试库，支持高分辨率计时器并返回具有统计意义的结果。</li><li><a href="https://github.com/logicalparadox/matcha" rel="external nofollow noopener noreferrer" target="_blank">matcha</a> - 基准测试的简化方法。</li><li><a href="https://github.com/caderek/benny" rel="external nofollow noopener noreferrer" target="_blank">benny</a> - 一个非常简单的 JS/TS 库基准测试框架。</li><li><a href="https://github.com/sidorares/node-wrk" rel="external nofollow noopener noreferrer" target="_blank">node-wrk</a> - Wrk负载测试工具Node.js版封装。</li></ul><ul><li><strong>解决方案</strong></li></ul><ul><li><a href="https://github.com/alibaba/macaca" rel="external nofollow noopener noreferrer" target="_blank">macaca</a> - 多端自动化解决方案。</li></ul><h2 id="办公软件"><a href="#办公软件" class="headerlink" title="办公软件"></a>办公软件</h2><ul><li><p><strong>Excel</strong></p></li><li><p><a href="https://github.com/SheetJS/sheetjs" rel="external nofollow noopener noreferrer" target="_blank">sheetjs</a> - 电子表格数据工具箱。</p></li><li><a href="https://github.com/exceljs/exceljs" rel="external nofollow noopener noreferrer" target="_blank">exceljs</a> - Excel工作表管理工具。</li><li><a href="https://github.com/dtjohnson/xlsx-populate" rel="external nofollow noopener noreferrer" target="_blank">xlsx-populate</a> - Excel XLSX生成和解析工具，可运行在Node和浏览器。</li></ul><ul><li><strong>Word</strong></li></ul><ul><li><a href="https://github.com/Ziv-Barber/officegen" rel="external nofollow noopener noreferrer" target="_blank">officegen</a> - 使用Javascript，生成可打开Word（docx）、PowerPoint（pptx）和Excel（xlsx）的XML文件（需Microsoft Office 2007及更高版本），输出是一个stream。</li><li><a href="https://github.com/mwilliamson/mammoth.js" rel="external nofollow noopener noreferrer" target="_blank">Mammoth</a> - 将Word文档(.docx文件)转化为HTML。</li><li><a href="https://github.com/dolanmiu/docx" rel="external nofollow noopener noreferrer" target="_blank">docx</a> - 通过良好定义的API,在NodeJS和浏览器中，使用JS/TS轻松的生成docx文件。</li></ul><ul><li><strong>PDF</strong></li></ul><ul><li><a href="https://github.com/MrRio/jsPDF" rel="external nofollow noopener noreferrer" target="_blank">jsPDF</a> - 使用JavaScript生成PDF文件的库。</li><li><a href="https://github.com/foliojs/pdfkit" rel="external nofollow noopener noreferrer" target="_blank">PDFKit</a> - 在Node.js和浏览器中生成PDF的库。</li><li><a href="https://github.com/danburzo/percollate" rel="external nofollow noopener noreferrer" target="_blank">percollate</a> - 一个命令行工具，可将网页转换为漂亮的，可读的PDF，EPUB或HTML文档。</li><li><a href="https://github.com/Hopding/pdf-lib" rel="external nofollow noopener noreferrer" target="_blank">pdf-lib</a> - 在任意JavaScript环境中创建和修改PDF文档。</li><li><a href="https://github.com/modesty/pdf2json" rel="external nofollow noopener noreferrer" target="_blank">pdf2json</a> - PDF文件解析器，它将PDF二进制文件转换为基于文本的JSON。</li></ul><ul><li><strong>PPT</strong></li></ul><ul><li><a href="https://github.com/ksky521/nodeppt" rel="external nofollow noopener noreferrer" target="_blank">nodeppt</a> - Web端展示端PPT工具。</li></ul><h2 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h2><ul><li><a href="https://github.com/sebhildebrandt/systeminformation" rel="external nofollow noopener noreferrer" target="_blank">systeminformation</a> - 获取硬件和软件系统信息。</li><li><a href="https://github.com/sindresorhus/is-wsl" rel="external nofollow noopener noreferrer" target="_blank">is-wsl</a> - 判断当前是否是否为WSL (适用于Linux的Windows子系统)。</li><li><a href="https://github.com/sindresorhus/os-name" rel="external nofollow noopener noreferrer" target="_blank">os-name</a> - 获取当前操作系统的名字。</li><li><a href="https://github.com/retrohacker/getos" rel="external nofollow noopener noreferrer" target="_blank">getos</a> - 获取当前操作系统名称，包括Linux的发行版名称。</li><li><a href="https://github.com/jonschlinkert/is-windows" rel="external nofollow noopener noreferrer" target="_blank">is-windows</a> - 判断当前系统是否为Windows。</li></ul><h2 id="文件压缩解压"><a href="#文件压缩解压" class="headerlink" title="文件压缩解压"></a>文件压缩解压</h2><ul><li><a href="https://github.com/Stuk/jszip" rel="external nofollow noopener noreferrer" target="_blank">jszip</a> - 使用JavaScript创建、读取、编辑.zip文件。</li><li><a href="https://github.com/cthackers/adm-zip" rel="external nofollow noopener noreferrer" target="_blank">adm-zip</a> - 使用JavaScript创建、读取、编辑.zip文件。</li><li><a href="https://github.com/npm/node-tar" rel="external nofollow noopener noreferrer" target="_blank">node-tar</a> - 快速且功能齐全的Tar。</li><li><a href="https://github.com/thejoshwolfe/yauzl" rel="external nofollow noopener noreferrer" target="_blank">yauzl</a> - Node.js unzip解压库。</li><li><a href="https://github.com/mafintosh/tar-fs" rel="external nofollow noopener noreferrer" target="_blank">tar-fs</a> - tar-fs允许您将目录打包到tar格式压缩包中，并将tar格式压缩包提取到目录中。</li><li><a href="https://github.com/node-modules/compressing" rel="external nofollow noopener noreferrer" target="_blank">compressing</a> - 压缩和解压缩你所需的一切。</li><li><a href="https://github.com/thejoshwolfe/yazl" rel="external nofollow noopener noreferrer" target="_blank">yazl</a> - Node.js zip压缩库。</li><li><a href="https://github.com/fritx/win-7zip" rel="external nofollow noopener noreferrer" target="_blank">7zip</a> - Windows包压缩/解压 - 7zip。</li></ul><h2 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h2><ul><li><a href="https://github.com/mishoo/UglifyJS" rel="external nofollow noopener noreferrer" target="_blank">UglifyJS</a> - JavaScript压缩工具。</li><li><a href="https://github.com/imagemin/imagemin" rel="external nofollow noopener noreferrer" target="_blank">imagemin</a> - Image压缩工具。</li><li><a href="https://github.com/babel/minify" rel="external nofollow noopener noreferrer" target="_blank">babel-minify</a> - 基于Babel工具链的 ES6+ 压缩库。</li><li><a href="https://github.com/cssnano/cssnano" rel="external nofollow noopener noreferrer" target="_blank">cssnano</a> - 建立在PostCSS生态系统之上模块化的压缩工具。</li><li><a href="https://github.com/jakubpawlowicz/clean-css" rel="external nofollow noopener noreferrer" target="_blank">clean-css</a> - CSS压缩工具。</li><li><a href="https://github.com/Swaagie/minimize" rel="external nofollow noopener noreferrer" target="_blank">minimize</a> - HTML压缩工具。</li><li><a href="https://github.com/sindresorhus/strip-css-comments" rel="external nofollow noopener noreferrer" target="_blank">strip-css-comments</a> - CSS注释剔除工具。</li></ul><h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><ul><li><a href="https://github.com/nylas/nylas-mail" rel="external nofollow noopener noreferrer" target="_blank">Nylas Mail</a> - 构建在现代Web技术的高扩展性邮件客户端程序。</li><li><a href="https://github.com/nodemailer/nodemailer" rel="external nofollow noopener noreferrer" target="_blank">Nodemailer</a> - 使用Node.js轻松发送电子邮件。</li><li><a href="https://github.com/forwardemail/email-templates" rel="external nofollow noopener noreferrer" target="_blank">Email Templates</a> - 创建、预览和发送自定义电子邮件模板。</li><li><a href="https://github.com/eleith/emailjs" rel="external nofollow noopener noreferrer" target="_blank">emailjs</a> - 向任何SMTP服务器发送带有附件的文本/HTML电子邮件。</li><li><a href="https://github.com/mjmlio/mjml" rel="external nofollow noopener noreferrer" target="_blank">mjml</a> - 旨在减少创建响应电子邮件的痛苦的标记语言。</li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li><p><strong>IP</strong></p></li><li><p><a href="https://github.com/indutny/node-ip" rel="external nofollow noopener noreferrer" target="_blank">node-ip</a> - NodeJS IP地址工具。</p></li><li><a href="https://github.com/sindresorhus/public-ip" rel="external nofollow noopener noreferrer" target="_blank">public-ip</a> - 非常快的获取你的公网IP地址。</li><li><a href="https://github.com/pbojinov/request-ip" rel="external nofollow noopener noreferrer" target="_blank">request-ip</a> - 在服务器中获取请求的IP地址。</li><li><a href="https://github.com/whitequark/ipaddr.js" rel="external nofollow noopener noreferrer" target="_blank">ipaddr.js</a> - JavaScript 中的 IP 地址操作库。</li><li><a href="https://github.com/sindresorhus/internal-ip" rel="external nofollow noopener noreferrer" target="_blank">internal-ip</a> - 获取您的内网IP地址。</li><li><a href="https://github.com/sindresorhus/ipify" rel="external nofollow noopener noreferrer" target="_blank">ipify</a> - 获取你的公网IP地址。</li><li><a href="https://github.com/node-modules/address" rel="external nofollow noopener noreferrer" target="_blank">address</a> - 获取当前机器IP地址和MAC地址。</li></ul><ul><li><strong>端口</strong></li></ul><ul><li><a href="https://github.com/http-party/node-portfinder" rel="external nofollow noopener noreferrer" target="_blank">node-portfinder</a> - 在当前机器上查找开放端口 或 域套接字的简单工具。</li><li><a href="https://github.com/sindresorhus/get-port" rel="external nofollow noopener noreferrer" target="_blank">get-port</a> - 获取一个可用的端口。</li><li><a href="https://github.com/node-modules/detect-port" rel="external nofollow noopener noreferrer" target="_blank">detect-port</a> - 端口探测的Node.JS实现。</li></ul><ul><li><strong>隧道代理</strong></li></ul><ul><li><a href="https://github.com/koichik/node-tunnel" rel="external nofollow noopener noreferrer" target="_blank">node-tunnel</a> - 用于隧道代理的 HTTP/HTTPS代理。</li><li><a href="https://github.com/request/tunnel-agent" rel="external nofollow noopener noreferrer" target="_blank">tunnel-agent</a> - HTTP 隧道代理。以前是 mikeal/request 的一部分，现在是一个独立的模块。</li></ul><ul><li><strong>其他</strong></li></ul><ul><li><a href="https://github.com/roccomuso/netcat" rel="external nofollow noopener noreferrer" target="_blank">netcat</a> - 纯JS中的Netcat端口。</li><li><a href="https://github.com/bevry/getmac" rel="external nofollow noopener noreferrer" target="_blank">getmac</a> - 获取电脑的MAC地址。</li><li><a href="https://github.com/infusion/node-dhcp" rel="external nofollow noopener noreferrer" target="_blank">DHCP</a> - DHCP客户端和服务器。</li><li><a href="https://github.com/silverwind/default-gateway" rel="external nofollow noopener noreferrer" target="_blank">default-gateway</a> - 获取默认网络网关(跨平台)。</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li><p><strong>请求库</strong></p></li><li><p><a href="https://github.com/mzabriskie/axios" rel="external nofollow noopener noreferrer" target="_blank">axios</a> - 基于Promise 的HTTP客户端（也可以在浏览器中工作）。</p></li><li><a href="https://github.com/request/request" rel="external nofollow noopener noreferrer" target="_blank">request</a> - 简单的 HTTP 请求客户端。</li><li><a href="https://github.com/visionmedia/superagent" rel="external nofollow noopener noreferrer" target="_blank">superagent</a> - HTTP请求库。</li><li><a href="https://github.com/sindresorhus/got" rel="external nofollow noopener noreferrer" target="_blank">got</a> - 更好的基于内建“http”模块接口实现。</li><li><a href="https://github.com/bitinn/node-fetch" rel="external nofollow noopener noreferrer" target="_blank">node-fetch</a> - Node.js的 <code>window.fetch</code> 实现。</li><li><a href="https://github.com/tomas/needle" rel="external nofollow noopener noreferrer" target="_blank">needle</a> - 灵活，基于流的HTTP Node.js客户端请求库。支持proxy，iconv，cookie，deflate和multipart。</li><li><a href="https://github.com/node-modules/urllib" rel="external nofollow noopener noreferrer" target="_blank">urllib</a> - 在复杂世界中请求HTTP/HTTPS的URL。</li><li><a href="https://github.com/ethanent/phin" rel="external nofollow noopener noreferrer" target="_blank">phin</a> - Node HTTP client.</li><li><a href="https://github.com/khaosdoctor/gotql" rel="external nofollow noopener noreferrer" target="_blank">gotql</a> - 基于<a href="https://github.com/sindresorhus/got" rel="external nofollow noopener noreferrer" target="_blank">got</a>构建的GraphQL请求库。</li><li><a href="https://github.com/hapijs/wreck" rel="external nofollow noopener noreferrer" target="_blank">wreck</a> - HTTP 客户端工具。</li><li><a href="https://github.com/lukechilds/cacheable-request" rel="external nofollow noopener noreferrer" target="_blank">cacheable-request</a> - 使用符合RFC的缓存封装的本机HTTP请求库。</li><li><a href="https://github.com/sindresorhus/gh-got" rel="external nofollow noopener noreferrer" target="_blank">gh-got</a> - 基于”got”封装，与GitHub API更方便的交互。</li><li><a href="https://github.com/bbc/flashheart" rel="external nofollow noopener noreferrer" target="_blank">flashheart</a> - REST 客户端。</li></ul><ul><li><strong>服务端库</strong></li></ul><ul><li><a href="https://github.com/http-party/http-server" rel="external nofollow noopener noreferrer" target="_blank">http-server</a> - 零配置的命令行Http服务端。</li><li><a href="https://github.com/JacksonTian/anywhere" rel="external nofollow noopener noreferrer" target="_blank">anywhere</a> - 随启随用的静态文件服务器。</li><li><a href="https://github.com/micromata/http-fake-backend" rel="external nofollow noopener noreferrer" target="_blank">http-fake-backend</a> - 通过可配置的路由，提供JSON文件或JavaScript对象来构建伪造的后端。</li><li><a href="https://github.com/typicode/json-server" rel="external nofollow noopener noreferrer" target="_blank">json-server</a> - 在不到30秒的时间内获得具有零编码的完整伪造的REST API。</li></ul><ul><li><strong>代理</strong></li></ul><ul><li><a href="https://github.com/nodejitsu/node-http-proxy" rel="external nofollow noopener noreferrer" target="_blank">http-proxy</a> - HTTP代理。</li><li><a href="https://github.com/TooTallNate/node-https-proxy-agent" rel="external nofollow noopener noreferrer" target="_blank">https-proxy-agent</a> - HTTP(S) 代理 <code>http.Agent</code>实现。</li><li><a href="https://github.com/gajus/global-agent" rel="external nofollow noopener noreferrer" target="_blank">global-agent</a> - 可以使用环境变量配置的全局 HTTP/HTTPS 代理。</li><li><a href="https://github.com/fastify/fast-proxy" rel="external nofollow noopener noreferrer" target="_blank">fast-proxy</a> - Node.js框架，使您可以将http请求转发到另一个HTTP服务器。 支持的协议：HTTP，HTTPS，HTTP2。</li><li><a href="https://github.com/argo/argo" rel="external nofollow noopener noreferrer" target="_blank">argo</a> - 一个可扩展的异步 HTTP 反向代理和源服务器。</li></ul><ul><li><strong>中间件</strong></li></ul><ul><li><a href="https://github.com/chimurai/http-proxy-middleware" rel="external nofollow noopener noreferrer" target="_blank">http-proxy-middleware</a> - ⚡用于connect，express和browser-sync的单线Node.js Http代理中间件。</li></ul><ul><li><strong>下载</strong></li></ul><ul><li><a href="https://github.com/kevva/download" rel="external nofollow noopener noreferrer" target="_blank">download</a> - 轻松下载和提取文件。</li><li><a href="https://github.com/maxogden/nugget" rel="external nofollow noopener noreferrer" target="_blank">nugget</a> - 使用Node.js编写的极简主义wget clone。 HTTP GET文件并将其下载到当前目录。</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h2><ul><li><a href="https://github.com/jaredhanson/passport" rel="external nofollow noopener noreferrer" target="_blank">Passport</a> - 简单的身份验证。</li><li><a href="https://github.com/simov/grant" rel="external nofollow noopener noreferrer" target="_blank">Grant</a> - 适用于Express，Koa，Hapi，Fastify，AWS Lambda，Azure，Google Cloud，Vercel等的OAuth程序。</li><li><a href="https://github.com/ianstormtaylor/permit" rel="external nofollow noopener noreferrer" target="_blank">permit</a> - 用于构建Node.js API的非标准认证库。</li></ul><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><ul><li><a href="https://github.com/stalniy/casl" rel="external nofollow noopener noreferrer" target="_blank">CASL</a> - 同构授权用于可视化界面和API。</li><li><a href="https://github.com/casbin/node-casbin" rel="external nofollow noopener noreferrer" target="_blank">node-casbin</a> - 支持访问控制模型（如ACL，RBAC和ABAC）的授权库。</li><li><a href="https://github.com/jshttp/basic-auth" rel="external nofollow noopener noreferrer" target="_blank">basic-auth</a> - 通用基础身份验证授权头字段解析器。</li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul><li><a href="https://github.com/alexguan/node-zookeeper-client" rel="external nofollow noopener noreferrer" target="_blank">node-zookeeper-client</a> - 纯JavaScript ZooKeeper客户端。</li></ul><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ul><li><a href="https://github.com/protobufjs/protobuf.js" rel="external nofollow noopener noreferrer" target="_blank">protobuf</a> - Protocol Buffers实现。</li><li><a href="https://github.com/node-modules/hessian.js" rel="external nofollow noopener noreferrer" target="_blank">hessian.js</a> - JavaScript hessian 二进制web服务协议实现，支持与 java 通信。</li><li><a href="https://github.com/kesla/node-snappy" rel="external nofollow noopener noreferrer" target="_blank">snappy</a> - Google 的 Snappy 压缩库的原生绑定（Native bindings）。</li><li><a href="https://github.com/compactr/compactr.js" rel="external nofollow noopener noreferrer" target="_blank">compactr</a> - Compactr协议的实现。</li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ul><li><a href="https://github.com/grpc/grpc-node/tree/master/packages/grpc-js" rel="external nofollow noopener noreferrer" target="_blank">grpc-js</a> - 纯JavaScript gRPC客户端。</li><li><a href="https://github.com/tedeh/jayson" rel="external nofollow noopener noreferrer" target="_blank">jayson</a> - Jayson是用于Node.js的简单但功能强大的JSON-RPC 2.0 / 1.0客户端和服务器。</li><li><a href="https://github.com/sofastack/sofa-rpc-node" rel="external nofollow noopener noreferrer" target="_blank">sofa-rpc-node</a> - SOFARPC Node是高性能、高可扩展性、产品级Node.js RPC框架。</li></ul><h2 id="服务端DOM"><a href="#服务端DOM" class="headerlink" title="服务端DOM"></a>服务端DOM</h2><ul><li><a href="https://github.com/cheeriojs/cheerio" rel="external nofollow noopener noreferrer" target="_blank">cheerio</a> - 运行在服务器端，快速、灵活和精益的jQuery核心功能实现。</li><li><a href="https://github.com/jsdom/jsdom" rel="external nofollow noopener noreferrer" target="_blank">jsdom</a> - Node.js版Web标准实现。</li><li><a href="https://github.com/fgnass/domino" rel="external nofollow noopener noreferrer" target="_blank">domino</a> - 基于 Mozilla的dom.js的服务器端DOM实现。</li></ul><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><ul><li><a href="https://github.com/bda-research/node-crawler" rel="external nofollow noopener noreferrer" target="_blank">node-crawler</a> - NodeJS Web爬虫 + 服务端jQuery。</li><li><a href="https://github.com/lapwinglabs/x-ray" rel="external nofollow noopener noreferrer" target="_blank">x-ray</a> - 具有分页的Web抓取爬虫。</li><li><a href="https://github.com/yujiosaka/headless-chrome-crawler" rel="external nofollow noopener noreferrer" target="_blank">headless-chrome-crawler</a> - 使用Chrome无头浏览器的分布式爬虫。</li><li><a href="https://github.com/rchipka/node-osmosis" rel="external nofollow noopener noreferrer" target="_blank">node-osmosis</a> - Node.js的HTML / XML解析器和Web抓取工具。</li><li><a href="https://github.com/IonicaBizau/scrape-it" rel="external nofollow noopener noreferrer" target="_blank">scrape-it</a> - 适用于人类的Node.js抓取工具。</li><li><a href="https://github.com/ruipgil/scraperjs" rel="external nofollow noopener noreferrer" target="_blank">scraperjs</a> - 完整而多功能的Web抓取器。</li><li><a href="https://github.com/cgiffard/node-simplecrawler" rel="external nofollow noopener noreferrer" target="_blank">simplecrawler</a> - 事件驱动的Web爬虫。</li><li><a href="https://github.com/martinsbalodis/web-scraper-chrome-extension" rel="external nofollow noopener noreferrer" target="_blank">web-scraper-chrome-extension</a> -实现为Chrome插件的Web数据抽取工具。</li><li><a href="https://github.com/zhuyingda/webster" rel="external nofollow noopener noreferrer" target="_blank">webster</a> - 一个可靠的Web爬虫框架，可以在网页中抓取Ajax和js呈现的内容。</li><li><a href="https://github.com/brendonboshell/supercrawler" rel="external nofollow noopener noreferrer" target="_blank">supercrawler</a> - 定义自定义处理程序以解析内容。 遵守robots.txt，速率限制和并发限制。</li><li><a href="https://github.com/n0tan3rd/squidwarc" rel="external nofollow noopener noreferrer" target="_blank">Squidwarc</a> - 高保真度，用户可编写脚本的归档爬虫程序，使用带头或不带头的Chrome或Chromium。</li><li><a href="https://github.com/antivanov/js-crawler" rel="external nofollow noopener noreferrer" target="_blank">js-crawler</a> - 适用于Node.JS的Web爬虫，同时支持HTTP和HTTPS。</li></ul><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><ul><li><p><strong>解析器</strong></p></li><li><p><a href="https://github.com/babel/babel/tree/master/packages/babel-parser" rel="external nofollow noopener noreferrer" target="_blank">babel-parser</a> - JavaScript解析器。</p></li><li><a href="https://github.com/antlr/antlr4" rel="external nofollow noopener noreferrer" target="_blank">antlr</a> - ANTLR (ANother Tool for Language Recognition)是一个用于阅读、处理、执行和翻译结构化文本或二进制文件的强大的解析生成器。</li><li><a href="https://github.com/acornjs/acorn/tree/master/acorn" rel="external nofollow noopener noreferrer" target="_blank">acorn</a> - 小巧、快速的JavaScript解析器。</li><li><a href="https://github.com/jquery/esprima" rel="external nofollow noopener noreferrer" target="_blank">esprima</a> - 高性能、符合ECMASCRIPT标准的解析器。</li><li><a href="https://github.com/benjamn/recast" rel="external nofollow noopener noreferrer" target="_blank">recast</a> - JavaScript语法树转换器，非破坏性漂亮print和自动source map生成器。</li><li><a href="https://github.com/kach/nearley" rel="external nofollow noopener noreferrer" target="_blank">nearley</a> - JavaScript的简单、快速、功能强大的解析工具集。</li><li><a href="https://github.com/eslint/espree" rel="external nofollow noopener noreferrer" target="_blank">espree</a> - 与Esprima兼容的JavaScript解析器。</li><li><a href="https://github.com/csstree/csstree" rel="external nofollow noopener noreferrer" target="_blank">csstree</a> - 基于W3C标准和浏览器标准实现，包含快速详细的解析器、遍历器、生成器、词法解析的CSS工具集。</li><li><a href="https://github.com/guybedford/es-module-lexer" rel="external nofollow noopener noreferrer" target="_blank">es-module-lexer</a> - 低开销的词法分析器，专门用于ES模块快速分析解析。</li></ul><ul><li><strong>遍历</strong></li></ul><ul><li><a href="https://github.com/acornjs/acorn/tree/master/acorn-walk" rel="external nofollow noopener noreferrer" target="_blank">acorn-walker</a> - 小巧、快速的JavaScript解析器。</li><li><a href="https://github.com/estools/estraverse" rel="external nofollow noopener noreferrer" target="_blank">estraverse</a> - ECMAScript JS AST遍历功能。</li></ul><ul><li><strong>代码生成</strong></li></ul><ul><li><a href="https://github.com/estools/escodegen" rel="external nofollow noopener noreferrer" target="_blank">escodegen</a> - ECMAScript代码生成。</li><li><a href="https://github.com/davidbonnet/astring" rel="external nofollow noopener noreferrer" target="_blank">astring</a> - 小巧快速的JavaScript代码生成器（通过ESTree兼容的AST）。</li></ul><ul><li><strong>JavaScript解释器</strong></li></ul><ul><li><a href="https://github.com/NeilFraser/JS-Interpreter" rel="external nofollow noopener noreferrer" target="_blank">JS-Interpreter</a> - JavaScript中沙箱解释器。</li><li><a href="https://github.com/bramblex/jsjs" rel="external nofollow noopener noreferrer" target="_blank">jsjs</a> - 简易的 JavaScript 元循环解释器。</li><li><a href="https://github.com/Siubaak/sval" rel="external nofollow noopener noreferrer" target="_blank">sval</a> - 使用JavaScript编写的JavaScript解释器。</li></ul><ul><li><strong>其他</strong></li></ul><ul><li><a href="https://github.com/fkling/astexplorer" rel="external nofollow noopener noreferrer" target="_blank">astexplorer</a> - 使用多种解析器的AST Web可视化工具。</li><li><a href="https://github.com/Rich-Harris/estree-walker" rel="external nofollow noopener noreferrer" target="_blank">estree-walker</a> - 用于遍历ESTree兼容树的AST。</li><li><a href="https://github.com/Rich-Harris/periscopic" rel="external nofollow noopener noreferrer" target="_blank">periscopic</a> - 用于分析符合ESTree的AST的作用域的工具。</li></ul><h2 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h2><ul><li><a href="https://github.com/dcodeIO/webassembly" rel="external nofollow noopener noreferrer" target="_blank">webassembly</a> - 用于生成和运行 WebAssembly 模块的最小工具包和运行时。</li></ul><h2 id="设计稿转代码（D2C）"><a href="#设计稿转代码（D2C）" class="headerlink" title="设计稿转代码（D2C）"></a>设计稿转代码（D2C）</h2><ul><li><a href="https://github.com/meltingice/psd.js" rel="external nofollow noopener noreferrer" target="_blank">psd.js</a> - 在Node.js和浏览器中解析Photoshop PSD文件。</li></ul><h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><ul><li><a href="https://github.com/patriksimek/vm2" rel="external nofollow noopener noreferrer" target="_blank">vm2</a> - Node.js高级虚拟机/沙箱。</li><li><a href="https://github.com/gf3/sandbox" rel="external nofollow noopener noreferrer" target="_blank">sandbox</a> - 用于Node.js漂亮的JavaScript沙箱。</li></ul><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li><a href="https://github.com/rwaldron/johnny-five" rel="external nofollow noopener noreferrer" target="_blank">johnny-five</a> - 基于Firmata的Arduino框架。</li><li><a href="https://github.com/voodootikigod/node-serialport" rel="external nofollow noopener noreferrer" target="_blank">serialport</a> - 访问串行端口以进行读写。</li><li><a href="https://github.com/nonolith/node-usb" rel="external nofollow noopener noreferrer" target="_blank">usb</a> - USB 库。</li><li><a href="https://github.com/fivdi/onoff" rel="external nofollow noopener noreferrer" target="_blank">onoff</a> - GPIO访问和中断检测.</li><li><a href="https://github.com/fivdi/pigpio" rel="external nofollow noopener noreferrer" target="_blank">pigpio</a> - 树莓派（Raspberry Pi）上的快速GPIO，PWM，伺服控制，状态更改通知和中断处理。</li><li><a href="https://github.com/song940/node-escpos" rel="external nofollow noopener noreferrer" target="_blank">node-escpos</a> - ESC/POS打印机驱动程序。</li><li><a href="https://github.com/fivdi/i2c-bus" rel="external nofollow noopener noreferrer" target="_blank">i2c-bus</a> - I2C串行总线访问。</li><li><a href="https://github.com/infusion/GPS.js" rel="external nofollow noopener noreferrer" target="_blank">gps</a> - NMEA解析器，用于处理GPS接收器。</li><li><a href="https://github.com/song940/node-bluetooth" rel="external nofollow noopener noreferrer" target="_blank">node-bluetooth</a> - Node.js 的蓝牙串口通信。</li><li><a href="https://github.com/fivdi/spi-device" rel="external nofollow noopener noreferrer" target="_blank">spi-device</a> - SPI串行总线访问。</li></ul><h2 id="物联网IoT"><a href="#物联网IoT" class="headerlink" title="物联网IoT"></a>物联网IoT</h2><ul><li><a href="https://github.com/zettajs/zetta" rel="external nofollow noopener noreferrer" target="_blank">zetta</a> - 面向物联网的 API 优先的开源软件平台。</li><li><a href="https://github.com/ibm-watson-iot/iot-nodejs" rel="external nofollow noopener noreferrer" target="_blank">iot-nodejs</a> - 用于使用 nodejs 连接到 IBM Watson IoT 的客户端库和示例。</li></ul><h2 id="机器学习-和-神经网络"><a href="#机器学习-和-神经网络" class="headerlink" title="机器学习 和 神经网络"></a>机器学习 和 神经网络</h2><ul><li><a href="https://github.com/tensorflow/tfjs" rel="external nofollow noopener noreferrer" target="_blank">tfjs</a> - 一个WebGL加速的JavaScript库，用于训练和部署ML模型（Tensorflow官方）。</li><li><a href="https://github.com/lutzroeder/netron" rel="external nofollow noopener noreferrer" target="_blank">netron</a> - 神经网络、深度学习和机器学习模型的可视化工具。</li><li><a href="https://github.com/BrainJS/brain.js" rel="external nofollow noopener noreferrer" target="_blank">brain.js</a> - 基于模型训练的神经网络 JS 库，支持浏览器和 Node.js。</li><li><a href="https://github.com/alibaba/pipcook" rel="external nofollow noopener noreferrer" target="_blank">pipcook</a> - 为Web开发者提供的机器学习平台。</li><li><a href="https://github.com/microsoft/onnxjs" rel="external nofollow noopener noreferrer" target="_blank">onnxjs</a> - 使用JavaScript运行ONNX模型。</li><li><a href="https://github.com/yorkie/tensorflow-nodejs" rel="external nofollow noopener noreferrer" target="_blank">tensorflow-nodejs</a> - TensorFlow Node.js为Node.js用户提供常用的JavaScript语言绑定和高级API。</li></ul><h2 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h2><ul><li><a href="https://github.com/spencermountain/compromise" rel="external nofollow noopener noreferrer" target="_blank">compromise</a> - 自然语言处理。</li><li><a href="https://github.com/NaturalNode/natural" rel="external nofollow noopener noreferrer" target="_blank">natural</a> - 自然语言设施。</li><li><a href="https://github.com/axa-group/nlp.js" rel="external nofollow noopener noreferrer" target="_blank">nlp.js</a> - 构建机器人，具有实体提取、情感分析、自动语言识别等功能。</li><li><a href="https://github.com/wooorm/franc" rel="external nofollow noopener noreferrer" target="_blank">franc</a> - 检测文本使用的语言。</li><li><a href="https://github.com/thisandagain/sentiment" rel="external nofollow noopener noreferrer" target="_blank">sentiment</a> - 基于AFINN的Node.js情感判断库。</li><li><a href="https://github.com/wooorm/retext" rel="external nofollow noopener noreferrer" target="_blank">retext</a> - 一个可扩展的自然语言系统。</li><li><a href="https://github.com/sindresorhus/leven" rel="external nofollow noopener noreferrer" target="_blank">leven</a> - 使用Levenshtein距离算法测量两个字符串之间的差异。</li></ul><h2 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h2><ul><li><a href="https://github.com/naptha/tesseract.js" rel="external nofollow noopener noreferrer" target="_blank">tesseract.js</a> - 100 多种语言的纯 Javascript OCR。</li><li><a href="https://github.com/axa-group/Parsr" rel="external nofollow noopener noreferrer" target="_blank">Parsr</a> - 将 PDF、文档和图像转换为丰富的结构化数据。</li></ul><h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><ul><li><a href="https://github.com/cjb/GitTorrent" rel="external nofollow noopener noreferrer" target="_blank">GitTorrent</a> - 使用 BitTorrent 和比特币的 GitHub 去中心化。</li><li><a href="https://github.com/bitcoinjs/bitcoinjs-lib" rel="external nofollow noopener noreferrer" target="_blank">bitcoinjs-lib</a> - 一个用于 node.js 和浏览器的 javascript 比特币库。</li><li><a href="https://github.com/bitpay/bitcore" rel="external nofollow noopener noreferrer" target="_blank">bitcore</a> - 比特币和基于区块链的应用程序的全栈。</li></ul><h2 id="低代码（Lowcode）"><a href="#低代码（Lowcode）" class="headerlink" title="低代码（Lowcode）"></a>低代码（Lowcode）</h2><p><em>(你也许会喜欢 <a href="https://github.com/taowen/awesome-lowcode" rel="external nofollow noopener noreferrer" target="_blank">awesome-lowcode</a>)</em></p><ul><li><p><strong>H5/PC</strong></p></li><li><p><a href="https://github.com/baidu/amis" rel="external nofollow noopener noreferrer" target="_blank">amis</a> - 前端低代码框架，通过 JSON 配置就能生成各种页面。</p></li></ul><ul><li><strong>H5</strong></li></ul><ul><li><a href="https://github.com/MrXujiang/h5-Dooring" rel="external nofollow noopener noreferrer" target="_blank">h5-Dooring</a> - 让H5制作像搭积木一样简单, 轻松搭建H5页面, H5网站, PC端网站, 可视化设计,LowCode平台。</li><li><a href="https://github.com/ly525/luban-h5" rel="external nofollow noopener noreferrer" target="_blank">luban-h5</a> - 类似易企秀的H5制作、建站工具、可视化搭建系统。</li><li><a href="https://github.com/ymm-tech/gods-pen" rel="external nofollow noopener noreferrer" target="_blank">gods-pen</a> - 基于vue的高扩展在线网页制作平台，可自定义组件，可添加脚本，可数据统计。</li></ul><ul><li><strong>PC</strong></li></ul><ul><li><a href="https://github.com/MrXujiang/pc-Dooring" rel="external nofollow noopener noreferrer" target="_blank">pc-Dooring</a> - 让网页制作像搭积木一样简单, 轻松搭建PC页面, Web网站, PC端网站. lowcode(low-code)可视化搭建平台。</li></ul><ul><li><strong>逻辑编排</strong></li></ul><ul><li><a href="https://github.com/node-red/node-red" rel="external nofollow noopener noreferrer" target="_blank">node-red</a> - 事件驱动应用的低代码编程。</li><li><a href="https://github.com/ykfe/imove" rel="external nofollow noopener noreferrer" target="_blank">imove</a> - iMove 是一个逻辑可复用的，面向函数的，流程可视化的 JavaScript 工具库。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是一个&lt;a href=&quot;https://github.com/huaize2020/awesome-nodejs&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;开源项目&lt;/a&gt;收集整理的一些很有用、很酷的 Node.js 包。强烈推荐给大家。喜欢的话，别忘了去 &lt;a href=&quot;https://github.com/huaize2020/awesome-nodejs&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt; 上 star 哦。
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>全网echarts案例资源大总结和echarts的高效使用技巧（细节版）</title>
    <link href="https://water.buging.cn/2023/07/27/%E5%85%A8%E7%BD%91echarts%E6%A1%88%E4%BE%8B%E8%B5%84%E6%BA%90%E5%A4%A7%E6%80%BB%E7%BB%93%E5%92%8Cecharts%E7%9A%84%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%88%E7%BB%86%E8%8A%82%E7%89%88%EF%BC%89/"/>
    <id>https://water.buging.cn/2023/07/27/全网echarts案例资源大总结和echarts的高效使用技巧（细节版）/</id>
    <published>2023-07-27T14:40:35.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h2 id="theme-mk-cute"><a href="#theme-mk-cute" class="headerlink" title="theme: mk-cute"></a>theme: mk-cute</h2><h5 id="一-前言。"><a href="#一-前言。" class="headerlink" title="一.前言。"></a>一.前言。</h5><p>众所周知，在现今的开发大环境下，数据可视化（大屏化）项目在前端开发中的比重越来越大。而其中使用率最高的插件无疑就是 <a href="https://echarts.apache.org/zh/index.html" rel="external nofollow noopener noreferrer" target="_blank">Apache Echarts</a>。（ps: 以下简称为echarts）。本文就结合vue框架来讲解如何快速、高效、优雅地在项目中使用echarts。当然，本文篇幅也会为读者精心准备目前网络上<strong>最全面、最高效</strong>的<strong>echarts案例资源站集合</strong>。<br><a id="more"></a></p><h5 id="二-全网最全的echarts图表案例和实例资源站整理。"><a href="#二-全网最全的echarts图表案例和实例资源站整理。" class="headerlink" title="二. 全网最全的echarts图表案例和实例资源站整理。"></a>二. 全网最全的echarts图表案例和实例资源站整理。</h5><ol><li>资源一：<strong><a href="http://chart.majh.top/" rel="external nofollow noopener noreferrer" target="_blank">分享你我</a></strong>  <em>（推荐指数：⭐⭐⭐⭐）</em></li></ol><ul><li>优点：案例资源丰富，有主体分类，可检索，访问速度较快。</li><li>缺点：未做分页。</li></ul><ol start="2"><li>资源二：<strong><a href="https://www.isqqw.com/homepage#/homepage" rel="external nofollow noopener noreferrer" target="_blank">ISWWQ.com</a></strong>   <em>（推荐指数：⭐⭐⭐⭐）</em></li></ol><ul><li>优点：案例资源丰富，可检索，有主体分类。</li><li>缺点：未做分页，访问速度较慢。</li></ul><ol start="3"><li>资源三：<strong><a href="http://ppchart.com/#/" rel="external nofollow noopener noreferrer" target="_blank">PPChart</a></strong>  <em>（推荐指数：<strong>⭐⭐⭐⭐⭐</strong>）</em></li></ol><ul><li>优点：案例资源丰富，有主体分类且分类较细，有分页，可检索，访问速度较快。</li><li>缺点：暂无。</li></ul><ol start="4"><li>资源四：<strong><a href="https://www.makeapie.cn/echarts" rel="external nofollow noopener noreferrer" target="_blank">ECHARTS社区</a></strong>  <em>（推荐指数：⭐⭐⭐）</em></li></ol><ul><li>优点：案例资源丰富，有主体分类且分类较细，有分页，可检索，提供登录和社区。</li><li>缺点：访问速度慢，有广告。</li></ul><ol start="5"><li>资源五：<strong><a href="https://madeapie.com/#/" rel="external nofollow noopener noreferrer" target="_blank">Made A Pie</a></strong>   <em>（推荐指数：⭐⭐⭐⭐）</em></li></ol><ul><li>优点：案例资源丰富，可检索，有主体分类。</li><li>缺点：访问速度较慢，未做分页。</li></ul><ol start="6"><li>资源六：<strong><a href="http://echarts.zhangmuchen.top/#/index" rel="external nofollow noopener noreferrer" target="_blank">MCChart</a></strong>   <em>（推荐指数：⭐⭐⭐⭐）</em></li></ol><ul><li>优点：案例资源丰富，可检索，有主体分类。</li><li>缺点：详情图例加载慢，图例加载不出。</li></ul><ol start="7"><li>资源七：<strong><a href="https://echarts.apache.org/examples/zh/index.html" rel="external nofollow noopener noreferrer" target="_blank">ECharts官方案例</a></strong>  <em>（推荐指数：<strong>⭐⭐⭐⭐⭐</strong>）</em></li></ol><ul><li>优点：官方案例，资源稳定，主体分类多，可调节模式，可直接查看对应案例的配置项。</li><li>缺点：案例资源较少，未做分页，未提供检索。</li></ul><ol start="8"><li>资源八：<strong><a href="http://192.144.199.210/forum-2-1.html" rel="external nofollow noopener noreferrer" target="_blank">chartsdev.com</a></strong>   <em>（推荐指数：⭐⭐）</em></li></ol><ul><li>优点：案例资源丰富，有主体分类。</li><li>缺点：访问速度一般，未能开箱即用，排版较差，适用性较差等。</li></ul><ol start="9"><li>资源九：<strong>[仿ECharts]</strong>  <em>（推荐指数：⭐⭐⭐）</em></li></ol><ul><li>优点：资源较稳定，图标效果加载速度较快。</li><li>缺点：案例资源较少，未做分页，未提供检索等。</li></ul><ol start="10"><li>资源十：<strong><a href="http://analysis.datains.cn/finance-admin/index.html#/chartLib/all" rel="external nofollow noopener noreferrer" target="_blank">DataInsight</a></strong> <em>（推荐指数：⭐⭐）</em></li></ol><ul><li>优点：案例资源较丰富。</li><li>缺点：访问速度慢，未做主体分类，未提供检索等。</li></ul><ol start="11"><li>资源十一：<strong><a href="https://www.aliyundrive.com/s/hH9wXex8jYa" rel="external nofollow noopener noreferrer" target="_blank">阿里云–原ECharts官方社区Make A Pie案例源码及图表图</a></strong>    <em>（推荐指数：<strong>⭐⭐⭐⭐⭐</strong>）</em></li></ol><ul><li>优点：提供原ECharts官方社区Make A Pie网站的所有案例源码及其对应的图例，可供查阅与开发成共享资源社区或网站。</li><li>缺点：未实现开箱即用。</li><li>说明：提取码：<strong>6l3t</strong>。</li></ul><ol start="12"><li>资源十二：<strong><a href="https://pan.baidu.com/s/1z73BAufIo0aV5_ZGQ66xmg" rel="external nofollow noopener noreferrer" target="_blank">百度云–原ECharts官方社区Make A Pie案例源码及图表图</a></strong>     <em>（推荐指数：<strong>⭐⭐⭐⭐⭐</strong>）</em></li></ol><ul><li>优点：提供原ECharts官方社区Make A Pie网站的所有案例源码及其对应的图例，可供查阅与开发成共享资源社区或网站。</li><li>缺点：未实现开箱即用。</li><li>说明：提取码：<strong>qqsy</strong>。</li></ul><h5 id="三-echarts在vue项目中的使用说明和技巧。"><a href="#三-echarts在vue项目中的使用说明和技巧。" class="headerlink" title="三.echarts在vue项目中的使用说明和技巧。"></a>三.echarts在vue项目中的使用说明和技巧。</h5><ol><li>安装依赖和注意事项及对应的处理办法。</li></ol><ul><li><p>说明：<br>vue中直接安装最新的echarts依赖包，可能会在运行时报echarts的init方法未定义的异常，此时可先<strong>卸载当前版本的echarts依赖包，重新安装指定稳定版本（如：v4.8.0）</strong>。如若此时还是报init未定义，那么可在入口文件main.js中引入时需按这种方式引入即可解决 —- <strong>import * as echarts from ‘echarts’</strong>。</p></li><li><p>核心代码和图例：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规安装</span></span><br><span class="line"> </span><br><span class="line">npm install echarts --save</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//如若按官网的上述依赖安装后报init未定义的话,那可能是由于所安装的当前ECharts版本过高导致,请安装以下版本</span></span><br><span class="line"> </span><br><span class="line">npm uninstall echarts --save   <span class="comment">//卸载当前安装的ECahrts依赖</span></span><br><span class="line"> </span><br><span class="line">npm install echarts@<span class="number">4.8</span><span class="number">.0</span> --save     <span class="comment">//重新安装低版ECahrts依赖</span></span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0841337029424d17b0cd27d9ead59c91~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><ol start="2"><li>组件化实现每个echarts图表的独立管理，避免不必要的耦合。</li></ol><ul><li>说明：<br>主组件（父组件）只用来存主内容区域和对应echrts图表的外部盒子；用子组件实现真正的容器来装载整个图表和实现对应图表的数据和图表渲染。</li></ul><ul><li>核心代码：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-section bg"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-title"</span>&gt;业务类型占比&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!--以下为子组件--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ywlxzbChart&gt;&lt;/y</span>wlxzbChart&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">子组件（echarts图表核心）：</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    id=<span class="string">"ywlx"</span></span><br><span class="line">    style=<span class="string">"width: 100%; height: 195px"</span></span><br><span class="line">    v-loading=<span class="string">"ywlezbLoading"</span></span><br><span class="line">  &gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">"echarts"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> API <span class="keyword">from</span> <span class="string">"api/home.js"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ywlezbLoading: <span class="literal">false</span>,</span><br><span class="line">      myChartLine: <span class="literal">null</span>,</span><br><span class="line">      formData: [],</span><br><span class="line">      nameData: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  name: <span class="string">"ywlxzbChart"</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">//获取数据,Promise确保执行和绘画顺序</span></span><br><span class="line">    getProfessionalCardsCount() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.ywlezbLoading = <span class="literal">true</span>;</span><br><span class="line">        API.getProfessionalCardsCount()</span><br><span class="line">          .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.ywlezbLoading = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (res.code == <span class="number">200</span>) &#123;</span><br><span class="line">              <span class="keyword">this</span>.formData = res.data.professions;</span><br><span class="line">              <span class="keyword">this</span>.nameData = [];</span><br><span class="line">              <span class="keyword">this</span>.formData.map(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.nameData.push(i.name);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.ywlezbLoading = <span class="literal">false</span>;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    myEcharts() &#123;</span><br><span class="line">      <span class="comment">// 基于准备好的dom，初始化echarts实例</span></span><br><span class="line">      <span class="keyword">this</span>.myChartLine = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">"ywlx"</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 指定图表的配置项和数据</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> option = &#123;</span><br><span class="line">        tooltip: &#123;</span><br><span class="line">          trigger: <span class="string">"item"</span>,</span><br><span class="line">          formatter: <span class="string">"&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        color: [<span class="string">"#31ceee"</span>, <span class="string">"#20adeb"</span>, <span class="string">"#6be7e8"</span>],</span><br><span class="line">        legend: &#123;</span><br><span class="line">          orient: <span class="string">"vertical"</span>,</span><br><span class="line">          x: <span class="string">"right"</span>,</span><br><span class="line">          align: <span class="string">"left"</span>,</span><br><span class="line">          padding: [<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">          data: <span class="keyword">this</span>.nameData,</span><br><span class="line">          formatter: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> oa = option.series[<span class="number">0</span>].data;</span><br><span class="line">            <span class="keyword">var</span> num = oa[<span class="number">0</span>].value + oa[<span class="number">1</span>].value + oa[<span class="number">2</span>].value;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; option.series[<span class="number">0</span>].data.length; i++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (name == oa[i].name) &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        series: [</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">"业务类型占比"</span>,</span><br><span class="line">            type: <span class="string">"pie"</span>,</span><br><span class="line">            radius: <span class="string">"68%"</span>,</span><br><span class="line">            center: [<span class="string">"40%"</span>, <span class="string">"50%"</span>],</span><br><span class="line">            data: <span class="keyword">this</span>.formData,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                label: &#123;</span><br><span class="line">                  show: <span class="literal">true</span>,</span><br><span class="line">                  <span class="comment">//                            position:'inside',</span></span><br><span class="line">                  formatter: <span class="string">"&#123;b&#125;: &#123;d&#125;%"</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">              labelLine: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            labelLine: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                length: <span class="number">1</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用刚指定的配置项和数据显示图表。</span></span><br><span class="line">      <span class="keyword">this</span>.myChartLine.setOption(option);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">//图的大小自适应</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.myChartLine) &#123;</span><br><span class="line">        <span class="keyword">this</span>.myChartLine.resize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.getProfessionalCardsCount().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.myEcharts();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    <span class="comment">//实例销毁之前调用</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.myChartLine) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.myChartLine.dispose();</span><br><span class="line">    <span class="keyword">this</span>.myChartLine = <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><ul><li>注意点：</li></ul><ol><li>将echarts图表的 <strong>数据</strong> 和 <strong>绘制</strong> 分为两部分各自处理，一目了然，层次分明。</li><li><strong>真实图表绘制操作务必放在数据请求赋值之后操作</strong>；为了确保执行准确性和可靠性，这里借助了<strong>Promise</strong>来实现。</li><li>组件销毁时要重置（销毁）图表。</li><li>为了提高用户体验感，强烈建议为图表容器加上loading状态。</li></ol><ul><li>效果图：</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc35b330d6442dbb95ad7822dbde976~tplv-k3u1fbpfcp-watermark.image?" alt="c99d048b8f1f40e98184d0c9ce4d00d8_tplv-k3u1fbpfcp-watermark.gif"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;theme-mk-cute&quot;&gt;&lt;a href=&quot;#theme-mk-cute&quot; class=&quot;headerlink&quot; title=&quot;theme: mk-cute&quot;&gt;&lt;/a&gt;theme: mk-cute&lt;/h2&gt;&lt;h5 id=&quot;一-前言。&quot;&gt;&lt;a href=&quot;#一-前言。&quot; class=&quot;headerlink&quot; title=&quot;一.前言。&quot;&gt;&lt;/a&gt;一.前言。&lt;/h5&gt;&lt;p&gt;众所周知，在现今的开发大环境下，数据可视化（大屏化）项目在前端开发中的比重越来越大。而其中使用率最高的插件无疑就是 &lt;a href=&quot;https://echarts.apache.org/zh/index.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Apache Echarts&lt;/a&gt;。（ps: 以下简称为echarts）。本文就结合vue框架来讲解如何快速、高效、优雅地在项目中使用echarts。当然，本文篇幅也会为读者精心准备目前网络上&lt;strong&gt;最全面、最高效&lt;/strong&gt;的&lt;strong&gt;echarts案例资源站集合&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>一次搞懂数据大屏适配方案 (vw vh、rem、scale)</title>
    <link href="https://water.buging.cn/2023/07/27/%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88-vw-vh%E3%80%81rem%E3%80%81scale/"/>
    <id>https://water.buging.cn/2023/07/27/一次搞懂数据大屏适配方案-vw-vh、rem、scale/</id>
    <published>2023-07-27T14:36:01.000Z</published>
    <updated>2023-08-01T06:26:37.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当接到可视化大屏需求时，你是否会有以下疑问👇<br><strong>如何做一款定制化的数据大屏？<br>开发可视化数据大屏如何做自适应？<br>vw vh、rem、scale 到底哪种比较好？<br>时间不够，有没有偷懒的方法？</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eca164ef1c8471eaabd171963d91c5e~tplv-k3u1fbpfcp-watermark.image" alt="sceen-demo.jpg"><br>最近在公司开发了一个可视化大屏，开发定制化大屏，大家可能都一个感受，开发大屏主要是两方面的工作：</p><ul><li><code>大屏之关键-前期的自适应适配</code></li><li><code>根据 ui 稿绘制图表，调细节</code></li></ul><p>而解决了适配问题后，后面就只是一个慢工出细活，耗时间的事情了。<a id="more"></a></p><h3 id="适配方案分析"><a href="#适配方案分析" class="headerlink" title="适配方案分析"></a>适配方案分析</h3><p>看了网上的各种方案，目前大家采用的大概有 3 种👇</p><table><thead><tr><th>方案</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>vw vh</strong></td><td>1.按照设计稿的尺寸，将<code>px</code>按比例计算转为<code>vw</code>和<code>vh</code></td><td>1.可以动态计算图表的宽高，字体等，灵活性较高<br>2.当屏幕比例跟 ui 稿不一致时，不会出现两边留白情况</td><td>1.每个图表都需要单独做字体、间距、位移的适配，比较麻烦</td></tr><tr><td><strong>scale</strong></td><td>1.通过 <code>scale</code> 属性，根据屏幕大小，对图表进行整体的等比缩放</td><td>1.代码量少，适配简单<br>2.一次处理后不需要在各个图表中再去单独适配</td><td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况 <br>2.当缩放比例过大时候，字体会有一点点模糊，就一点点 <br>3.当缩放比例过大时候，事件热区会偏移。</td></tr><tr><td><strong>rem + vw vh</strong></td><td>1.获得 rem 的基准值<br>2.动态的计算<code>html根元素的font-size</code><br>3.图表中通过 vw vh 动态计算字体、间距、位移等</td><td>1.布局的自适应代码量少，适配简单</td><td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况<br>2.图表需要单个做字体、间距、位移的适配</td></tr></tbody></table><p>以上 3 种方案在实际应用中该怎么选择视具体情况而定，也有看到大家说自适应在地图的适配中会有一些兼容问题，我这边还没有实践过。</p><ul><li>如果想简单，客户能同意留白，选用 <code>scale</code> 即可</li><li>如果需要兼容不同比例的大屏，并且想在不同比例中都有比较好的效果，图表占满屏幕，类似于移动端的响应式，可以采用 vw vh 的方案</li><li>至于 rem，个人觉得就是 scale 和 vw vh 的综合，最终的效果跟 <code>scale</code> 差不多</li></ul><p>接下来介绍下三种方案的具体实现，方案中的代码都以 vue2.0 和 vue-cli3 搭建的 vue 项目为例，因为是 demo，图表的一些细节就没有过多细致的调整了</p><h3 id="方案一：vw-vh"><a href="#方案一：vw-vh" class="headerlink" title="方案一：vw vh"></a>方案一：vw vh</h3><h4 id="上效果"><a href="#上效果" class="headerlink" title="上效果"></a>上效果</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06ae40cbdefb4417b34eb00aa3a718bd~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (1).gif"></p><p>当屏幕的尺寸比例刚好是 16:9 时</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d57353767aff4d8a920e142fb9606127~tplv-k3u1fbpfcp-watermark.image?" alt="vwh02.jpg"></p><p>当屏幕的尺寸比例大于 16:9 时</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/921953ab6a63442a896324bba43320b1~tplv-k3u1fbpfcp-watermark.image?" alt="vwh03.jpg"></p><p>当屏幕的尺寸比例小于 16:9 时</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/779df26fb501472ea294178c90b8705a~tplv-k3u1fbpfcp-watermark.image?" alt="vwh09.jpg"></p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>按照设计稿的尺寸，将<code>px</code>按比例计算转为<code>vw</code>和<code>vh</code>，转换公式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">假设设计稿尺寸为 <span class="number">1920</span>*<span class="number">1080</span>（做之前一定问清楚 ui 设计稿的尺寸）</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">网页宽度=<span class="number">1920</span>px</span><br><span class="line">网页高度=<span class="number">1080</span>px</span><br><span class="line"></span><br><span class="line">我们都知道</span><br><span class="line">网页宽度=<span class="number">100</span>vw</span><br><span class="line">网页宽度=<span class="number">100</span>vh</span><br><span class="line"></span><br><span class="line">所以，在 <span class="number">1920</span>px*<span class="number">1080</span>px 的屏幕分辨率下</span><br><span class="line"></span><br><span class="line"><span class="number">1920</span>px = <span class="number">100</span>vw</span><br><span class="line"></span><br><span class="line"><span class="number">1080</span>px = <span class="number">100</span>vh</span><br><span class="line"></span><br><span class="line">这样一来，以一个宽 <span class="number">300</span>px 和 <span class="number">200</span>px 的 div 来说，其所占的宽高，以 vw 和 vh 为单位，计算方式如下:</span><br><span class="line"></span><br><span class="line">vwDiv = (<span class="number">300</span>px / <span class="number">1920</span>px ) * <span class="number">100</span>vw</span><br><span class="line">vhDiv = (<span class="number">200</span>px / <span class="number">1080</span>px ) * <span class="number">100</span>vh</span><br><span class="line"></span><br><span class="line">所以，就在 <span class="number">1920</span>*<span class="number">1080</span> 的屏幕分辨率下，计算出了单个 div 的宽高</span><br><span class="line"></span><br><span class="line">当屏幕放大或者缩小时，div 还是以 vw 和 vh 作为宽高的，就会自动适应不同分辨率的屏幕</span><br></pre></td></tr></table></figure><h4 id="话不多说，上代码"><a href="#话不多说，上代码" class="headerlink" title="话不多说，上代码"></a>话不多说，上代码</h4><h5 id="css-方案-sass"><a href="#css-方案-sass" class="headerlink" title="css 方案 - sass"></a>css 方案 - sass</h5><p>util.scss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用 scss 的 math 函数，https://sass-lang.com/documentation/breaking-changes/slash-div</span><br><span class="line"><span class="keyword">@use</span> <span class="string">"sass:math"</span>;</span><br><span class="line"></span><br><span class="line">// 默认设计稿的宽度</span><br><span class="line">$designWidth: 1920;</span><br><span class="line">// 默认设计稿的高度</span><br><span class="line">$designHeight: 1080;</span><br><span class="line"></span><br><span class="line">// px 转为 vw 的函数</span><br><span class="line"><span class="keyword">@function</span> vw($px) &#123;</span><br><span class="line">  <span class="keyword">@return</span> math.div($px, $designWidth) * <span class="number">100vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// px 转为 vh 的函数</span><br><span class="line"><span class="keyword">@function</span> vh($px) &#123;</span><br><span class="line">  <span class="keyword">@return</span> math.div($px, $designHeight) * <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>路径配置</strong><br>只需在<code>vue.config.js</code>里配置一下<code>utils.scss</code>的路径，就可以全局使用了</p><p>vue.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">""</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    name: <span class="string">"app name"</span>,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        <span class="string">"@"</span>: resolve(<span class="string">"src"</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  css: &#123;</span><br><span class="line">    <span class="comment">// 全局配置 utils.scs，详细配置参考 vue-cli 官网</span></span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        prependData: <span class="string">`@import "@/styles/utils.scss";`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>在 .vue 中使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    name: <span class="string">"Box"</span>,</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style lang="scss" scoped="scoped"&gt;</span></span><br><span class="line"><span class="regexp">/</span>* </span><br><span class="line"> 直接使用 vw 和 vh 函数，将像素值传进去，得到的就是具体的 vw vh 单位 </span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">.box&#123;</span></span><br><span class="line"><span class="regexp">    width: vw(300);</span></span><br><span class="line"><span class="regexp">    height: vh(100);</span></span><br><span class="line"><span class="regexp">    font-size: vh(16);</span></span><br><span class="line"><span class="regexp">    background-color: black;</span></span><br><span class="line"><span class="regexp">    margin-left: vw(10);</span></span><br><span class="line"><span class="regexp">    margin-top: vh(10);</span></span><br><span class="line"><span class="regexp">    border: vh(2) solid red;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><h5 id="css-方案-less"><a href="#css-方案-less" class="headerlink" title="css 方案 - less"></a>css 方案 - less</h5><p>utils.less</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@charset &quot;utf-8&quot;;</span><br><span class="line"></span><br><span class="line">// 默认设计稿的宽度</span><br><span class="line">@designWidth: 1920;</span><br><span class="line"></span><br><span class="line">// 默认设计稿的高度</span><br><span class="line">@designHeight: 1080;</span><br><span class="line"></span><br><span class="line">.px2vw(@name, @px) &#123;</span><br><span class="line">  @&#123;name&#125;: (@px / @designWidth) * 100vw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.px2vh(@name, @px) &#123;</span><br><span class="line">  @&#123;name&#125;: (@px / @designHeight) * 100vh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.px2font(@px) &#123;</span><br><span class="line">  font-size: (@px / @designWidth) * 100vw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>路径配置</strong><br>在<code>vue.config.js</code>里配置一下<code>utils.less</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">""</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    name: <span class="string">"app name"</span>,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        <span class="string">"@"</span>: resolve(<span class="string">"src"</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  css: &#123;</span><br><span class="line">    <span class="comment">// 全局配置utils.scss</span></span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      less: &#123;</span><br><span class="line">        additionalData: <span class="string">`@import "@/styles/utils.less";`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在 .vue 文件中使用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    name: &quot;Box&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped=&quot;scoped&quot;&gt;</span><br><span class="line">/* </span><br><span class="line"> 直接使用 vw 和 vh 函数，将像素值传进去，得到的就是具体的 vw vh单位 </span><br><span class="line"> */</span><br><span class="line">.box&#123;</span><br><span class="line">    .px2vw(width, 300);</span><br><span class="line">    .px2vh(height, 100);</span><br><span class="line">    .px2font(16);</span><br><span class="line">    .px2vw(margin-left, 300);</span><br><span class="line">    .px2vh(margin-top, 100);</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h5 id="定义-js-样式处理函数"><a href="#定义-js-样式处理函数" class="headerlink" title="定义 js 样式处理函数"></a>定义 js 样式处理函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义设计稿的宽高</span></span><br><span class="line"><span class="keyword">const</span> designWidth = <span class="number">1920</span>;</span><br><span class="line"><span class="keyword">const</span> designHeight = <span class="number">1080</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// px转vw</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> px2vw = <span class="function">(<span class="params">_px</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (_px * <span class="number">100.0</span>) / designWidth + <span class="string">'vw'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> px2vh = <span class="function">(<span class="params">_px</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (_px * <span class="number">100.0</span>) / designHeight + <span class="string">'vh'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> px2font = <span class="function">(<span class="params">_px</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (_px * <span class="number">100.0</span>) / designWidth + <span class="string">'vw'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="屏幕变化后，图表自动调整"><a href="#屏幕变化后，图表自动调整" class="headerlink" title="屏幕变化后，图表自动调整"></a>屏幕变化后，图表自动调整</h5><p>这种使用方式有个弊端，就是屏幕尺寸发生变化后，需要手动刷新一下才能完成自适应调整</p><p>为了解决这个问题，你需要在各个图表中监听页面尺寸变化，重新调整图表，在 vue 项目中，也可以借助<code>element-resize-detector</code>，最好封装个 resize 的指令，在各图表中就只要使用该指令就可以了，毕竟作为程序员，能偷懒就偷懒</p><ol><li><p>安装 element-resize-detector</p><blockquote><p>npm install element-resize-detector –save</p></blockquote></li><li><p>引入工具包在组件中使用或者在单独的 js 中使用</p><blockquote><p>import resizeDetector from ‘element-resize-detector’</p></blockquote></li><li><p>封装 directive</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// directive.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ECharts <span class="keyword">from</span> <span class="string">"echarts"</span>;</span><br><span class="line"><span class="keyword">import</span> elementResizeDetectorMaker <span class="keyword">from</span> <span class="string">"element-resize-detector"</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">const</span> HANDLER = <span class="string">"_vue_resize_handler"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el[HANDLER] = binding.value</span><br><span class="line">    ? binding.value</span><br><span class="line">    : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> chart = ECharts.getInstanceByDom(el);</span><br><span class="line">        <span class="keyword">if</span> (!chart) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chart.resize();</span><br><span class="line">      &#125;;</span><br><span class="line">  <span class="comment">// 监听绑定的div大小变化，更新 echarts 大小</span></span><br><span class="line">  elementResizeDetectorMaker().listenTo(el, el[HANDLER]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unbind</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// window.removeEventListener("resize", el[HANDLER]);</span></span><br><span class="line">  elementResizeDetectorMaker().removeListener(el, el[HANDLER]);</span><br><span class="line">  <span class="keyword">delete</span> el[HANDLER];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义指令：v-chart-resize 示例：v-chart-resize="fn"</span></span><br><span class="line">Vue.directive(<span class="string">"chart-resize"</span>, &#123; bind, unbind &#125;);</span><br></pre></td></tr></table></figure></li><li><p>main.js 中引入</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'@/directive/directive'</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li>html 代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"linechart"</span>&gt;</span><br><span class="line">    &lt;div ref=<span class="string">"chart"</span> v-chart-resize <span class="class"><span class="keyword">class</span></span>=<span class="string">"chart"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure><p>这里要注意的是，图表中如果需要 tab 切换动态更新图表数据，在更新数据时一定不要用 echarts 的 dispose 方法先将图表移除，再重新绘制，因为 resize 指令中挂载到的图表实例还是旧的，就监听不到新的 chart 元素的 resize 了，更新数据只需要用 chart 的 setOption 方法重新设置配置项即可。</p><h5 id="图表字体、间距、位移等尺寸自适应"><a href="#图表字体、间距、位移等尺寸自适应" class="headerlink" title="图表字体、间距、位移等尺寸自适应"></a>图表字体、间距、位移等尺寸自适应</h5><p>echarts 的字体大小只支持具体数值（像素），不能用百分比或者 vw 等尺寸，一般字体不会去做自适应，当宽高比跟 ui 稿比例出入太大时，会出现文字跟图表重叠的情况</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65eb81b9699b487a80cd98b863e60e9f~tplv-k3u1fbpfcp-watermark.image?" alt="vwh03.jpg"><br>这里我们就需要封装一个工具函数，来处理图表中文字自适应了👇</p><ul><li><p>默认情况下，这里以你的设计稿是 1920*1080 为例，即网页宽度是 1920px (做之前一定问清楚 ui 设计稿的尺寸）</p></li><li><p>把这个函数写在一个单独的工具文件<code>dataUtil.js</code>里面，在需要的时候调用</p></li><li><p>其原理是计算出当前屏幕宽度和默认设计宽度的比值，将原始的尺寸乘以该值</p></li><li><p>另外，其它 echarts 的配置项，比如间距、定位、边距也可以用该函数</p></li></ul><ol><li><p>编写 dataUtil.js 工具函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Echarts图表字体、间距自适应</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fitChartSize = <span class="function">(<span class="params">size,defalteWidth = <span class="number">1920</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> clientWidth = <span class="built_in">window</span>.innerWidth||<span class="built_in">document</span>.documentElement.clientWidth||<span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">  <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span> size;</span><br><span class="line">  <span class="keyword">let</span> scale = (clientWidth / defalteWidth);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Number</span>((size*scale).toFixed(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将函数挂载到原型上</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fitChartSize&#125; <span class="keyword">from</span> <span class="string">'@src/utils/dataUtil.js'</span></span><br><span class="line">Vue.prototype.fitChartFont = fitChartSize;</span><br></pre></td></tr></table></figure><ol start="3"><li>这样你可以在<code>.vue</code>文件中直接使用<code>this.fitChartSize()</code>调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"chartsdom"</span> ref=<span class="string">"chart"</span> v-chart-resize&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"dashboardChart"</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      option: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getEchart();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getEchart() &#123;</span><br><span class="line">      <span class="keyword">let</span> myChart = <span class="keyword">this</span>.$echarts.init(<span class="keyword">this</span>.$refs.chart);</span><br><span class="line">      <span class="keyword">const</span> option = &#123;</span><br><span class="line">        backgroundColor: <span class="string">"transparent"</span>,</span><br><span class="line">        tooltip: &#123;</span><br><span class="line">          trigger: <span class="string">"item"</span>,</span><br><span class="line">          formatter: <span class="string">"&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125;%"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        grid: &#123;</span><br><span class="line">          left: <span class="keyword">this</span>.fitChartSize(<span class="number">10</span>),</span><br><span class="line">          right: <span class="keyword">this</span>.fitChartSize(<span class="number">20</span>),</span><br><span class="line">          top: <span class="keyword">this</span>.fitChartSize(<span class="number">20</span>),</span><br><span class="line">          bottom: <span class="keyword">this</span>.fitChartSize(<span class="number">10</span>),</span><br><span class="line">          containLabel: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        calculable: <span class="literal">true</span>,</span><br><span class="line">        series: [</span><br><span class="line">          &#123;</span><br><span class="line">            color: [<span class="string">"#0db1cdcc"</span>],</span><br><span class="line">            name: <span class="string">"计划投入"</span>,</span><br><span class="line">            type: <span class="string">"funnel"</span>,</span><br><span class="line">            width: <span class="string">"45%"</span>,</span><br><span class="line">            height: <span class="string">"70%"</span>,</span><br><span class="line">            x: <span class="string">"5%"</span>,</span><br><span class="line"></span><br><span class="line">            minSize: <span class="string">"10%"</span>,</span><br><span class="line">            funnelAlign: <span class="string">"right"</span>,</span><br><span class="line"></span><br><span class="line">            center: [<span class="string">"50%"</span>, <span class="string">"50%"</span>], <span class="comment">// for pie</span></span><br><span class="line"></span><br><span class="line">            data: [</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">30</span>,</span><br><span class="line">                name: <span class="string">"下单30%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">55</span>,</span><br><span class="line">                name: <span class="string">"咨询55%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">65</span>,</span><br><span class="line">                name: <span class="string">"点击65%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">60</span>,</span><br><span class="line">                name: <span class="string">"访问62%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">80</span>,</span><br><span class="line">                name: <span class="string">"展现80%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            ].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> a.value - b.value;</span><br><span class="line">            &#125;),</span><br><span class="line">            roseType: <span class="literal">true</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                formatter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">                position: <span class="string">"inside"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                borderWidth: <span class="number">0</span>,</span><br><span class="line">                shadowBlur: <span class="keyword">this</span>.fitChartSize(<span class="number">20</span>),</span><br><span class="line">                shadowOffsetX: <span class="number">0</span>,</span><br><span class="line">                shadowOffsetY: <span class="keyword">this</span>.fitChartSize(<span class="number">5</span>),</span><br><span class="line">                shadowColor: <span class="string">"rgba(0, 0, 0, 0.3)"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line">            color: [<span class="string">"#0C66FF"</span>],</span><br><span class="line">            name: <span class="string">"实际投入"</span>,</span><br><span class="line">            type: <span class="string">"funnel"</span>,</span><br><span class="line">            width: <span class="string">"45%"</span>,</span><br><span class="line">            height: <span class="string">"70%"</span>,</span><br><span class="line">            x: <span class="string">"50%"</span>,</span><br><span class="line"></span><br><span class="line">            minSize: <span class="string">"10%"</span>,</span><br><span class="line">            funnelAlign: <span class="string">"left"</span>,</span><br><span class="line"></span><br><span class="line">            center: [<span class="string">"50%"</span>, <span class="string">"50%"</span>], <span class="comment">// for pie</span></span><br><span class="line"></span><br><span class="line">            data: [</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">35</span>,</span><br><span class="line">                name: <span class="string">"下单35%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">40</span>,</span><br><span class="line">                name: <span class="string">"咨询40%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">70</span>,</span><br><span class="line">                name: <span class="string">"访问70%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">90</span>,</span><br><span class="line">                name: <span class="string">"点击90%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                value: <span class="number">95</span>,</span><br><span class="line">                name: <span class="string">"展现95%"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            ].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> a.value - b.value;</span><br><span class="line">            &#125;),</span><br><span class="line">            roseType: <span class="literal">true</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                position: <span class="string">"inside"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                borderWidth: <span class="number">0</span>,</span><br><span class="line">                shadowBlur: <span class="keyword">this</span>.fitChartSize(<span class="number">20</span>),</span><br><span class="line">                shadowOffsetX: <span class="number">0</span>,</span><br><span class="line">                shadowOffsetY: <span class="keyword">this</span>.fitChartSize(<span class="number">5</span>),</span><br><span class="line">                shadowColor: <span class="string">"rgba(0, 0, 0, 0.3)"</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;;</span><br><span class="line">      myChart.setOption(option, <span class="literal">true</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style lang="scss" scoped&gt;</span></span><br><span class="line"><span class="regexp">.chartsdom &#123;</span></span><br><span class="line"><span class="regexp">  width: 100%;</span></span><br><span class="line"><span class="regexp">  height: 100%;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><h3 id="方案二：scale"><a href="#方案二：scale" class="headerlink" title="方案二：scale"></a>方案二：scale</h3><p>通过 css 的 scale 属性，根据屏幕大小，对图表进行整体的等比缩放，从而达到自适应效果</p><h4 id="上效果-1"><a href="#上效果-1" class="headerlink" title="上效果"></a>上效果</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f5570596234d8899b564862fce2ccd~tplv-k3u1fbpfcp-watermark.image?" alt="sceen-scale.gif"></p><p>当屏幕的尺寸比例刚好是 16:9 时，页面能刚好全屏展示，内容占满显示器</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a1e86da017b4cfd9dfe5377001340a6~tplv-k3u1fbpfcp-watermark.image?" alt="sceen-demo.jpg"></p><p>当屏幕的尺寸比例小于 16:9 时，页面上下留白，左右占满并上下居中，显示比例保持 16:9</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5953ad56ba294d4888280ea197d32e74~tplv-k3u1fbpfcp-watermark.image?" alt="sceen-demo-02.jpg"></p><p>当屏幕尺寸比例大于 16:9 时，页面左右留白，上下占满并居中，显示比例保持 16:9</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0da5c6e9ad0e440abb7d7d4f93e81057~tplv-k3u1fbpfcp-watermark.image?" alt="sceen-demo-03.jpg"></p><h4 id="话不多说，上代码-1"><a href="#话不多说，上代码-1" class="headerlink" title="话不多说，上代码"></a>话不多说，上代码</h4><p><strong>html 部分</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"screen-wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"screen"</span> <span class="attr">id</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>js 部分</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="comment">// 初始化自适应  ----在刚显示的时候就开始适配一次</span></span><br><span class="line">  handleScreenAuto();</span><br><span class="line">  <span class="comment">// 绑定自适应函数   ---防止浏览器栏变化后不再适配</span></span><br><span class="line">  <span class="built_in">window</span>.onresize = <span class="function"><span class="params">()</span> =&gt;</span> handleScreenAuto();</span><br><span class="line">&#125;,</span><br><span class="line">deleted() &#123;</span><br><span class="line">  <span class="built_in">window</span>.onresize = <span class="literal">null</span>;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 数据大屏自适应函数</span></span><br><span class="line">  handleScreenAuto() &#123;</span><br><span class="line">    <span class="keyword">const</span> designDraftWidth = <span class="number">1920</span>; <span class="comment">//设计稿的宽度</span></span><br><span class="line">    <span class="keyword">const</span> designDraftHeight = <span class="number">960</span>; <span class="comment">//设计稿的高度</span></span><br><span class="line">    <span class="comment">// 根据屏幕的变化适配的比例</span></span><br><span class="line">    <span class="keyword">const</span> scale =</span><br><span class="line">      <span class="built_in">document</span>.documentElement.clientWidth /</span><br><span class="line">        <span class="built_in">document</span>.documentElement.clientHeight &lt;</span><br><span class="line">      designDraftWidth / designDraftHeight</span><br><span class="line">        ? <span class="built_in">document</span>.documentElement.clientWidth / designDraftWidth</span><br><span class="line">        : <span class="built_in">document</span>.documentElement.clientHeight / designDraftHeight;</span><br><span class="line">    <span class="comment">// 缩放比例</span></span><br><span class="line">    <span class="built_in">document</span>.querySelector(</span><br><span class="line">      <span class="string">'#screen'</span>,</span><br><span class="line">    ).style.transform = <span class="string">`scale(<span class="subst">$&#123;scale&#125;</span>) translate(-50%, -50%)`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>css部分</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  除了设计稿的宽高是根据您自己的设计稿决定以外，其他复制粘贴就完事</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="selector-class">.screen-root</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    .screen &#123;</span><br><span class="line">        <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line">        width: 1920px;  //设计稿的宽度</span><br><span class="line">        height: 960px;  //设计稿的高度</span><br><span class="line">        <span class="selector-tag">transform-origin</span>: 0 0;</span><br><span class="line">        <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">        <span class="selector-tag">left</span>: 50%;</span><br><span class="line">        <span class="selector-tag">top</span>: 50%;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h4><p><strong>如何缩放</strong></p><p>当<code>屏幕宽高比 &lt; 设计稿宽高比</code>，我们需要缩放的比例是<code>屏幕宽度 / 设计稿宽度</code><br>当<code>屏幕宽高比 &gt; 设计稿宽高比</code>，我们需要缩放的比例是<code>屏幕高度 / 设计稿高度</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="built_in">document</span>.documentElement.clientWidth / <span class="built_in">document</span>.documentElement.clientHeight &lt; designDraftWidth / designDraftHeight ?</span><br><span class="line">            (<span class="built_in">document</span>.documentElement.clientWidth / designDraftWidth) :</span><br><span class="line">            (<span class="built_in">document</span>.documentElement.clientHeight / designDraftHeight);</span><br></pre></td></tr></table></figure><p>如果我们拿到的设计稿宽高为: 1920 <em> 960 px ，而我们的屏幕大小是 1440 </em> 900 px，那么 1440/900 = 1.6，920/960 = 2</p><p>因为 1.6 &lt; 2 （当前屏幕宽高比小于设计稿宽高比）</p><p>所以我们需要缩放的比例是：屏幕宽度除以设计稿宽度 = 1440/1920 = 0.75</p><p><strong>如何居中</strong><br>首先我们利用 <code>transform:translate(-50%,-50%)</code> ，将动画的基点设为左上角</p><blockquote><p>transform-origin：设置动画的基点(中心点)，默认点是元素的中心点</p></blockquote><p>语法</p><blockquote><p>transform-origin: x-axis y-axis z-axis;</p></blockquote><p>然后利用<code>transform:translate(-50%,-50%)</code>，将图表沿 x，y 轴移动 50%</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa9186723c634d468d376040c197de4b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>接下来利用<code>绝对定位</code>将图表定位到中间位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">left</span>: 50%;</span><br><span class="line"><span class="selector-tag">top</span>: 50%;</span><br></pre></td></tr></table></figure><h4 id="偷懒方法-插件"><a href="#偷懒方法-插件" class="headerlink" title="偷懒方法-插件"></a>偷懒方法-插件</h4><p><code>v-scale-screen</code>是使用 css 属性 transform 实现缩放效果的一个大屏自适应组件，通过 scale 进行等比例计算，达到等比例缩放的效果，同时也支持铺满全屏，宽度等比，高度等比，等自适应方案,具体可查<a href="https://juejin.cn/post/7075253747567296548" rel="external nofollow noopener noreferrer" target="_blank">大屏自适应终极解决方案</a></p><h3 id="方案三：rem-vw-wh"><a href="#方案三：rem-vw-wh" class="headerlink" title="方案三：rem + vw wh"></a>方案三：rem + vw wh</h3><h4 id="上效果-2"><a href="#上效果-2" class="headerlink" title="上效果"></a>上效果</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a517572ce85c40c882394db74a7b5ef8~tplv-k3u1fbpfcp-watermark.image?" alt="rem.gif"></p><p>当屏幕的尺寸比例刚好是 16:9 时，页面能刚好全屏展示，内容占满显示器</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/591f96cb9a2a44379892e9a91842c8eb~tplv-k3u1fbpfcp-watermark.image?" alt="rem01.jpg"></p><p>当屏幕的尺寸比例小于 16:9 时，页面上下留白，左右占满并上下居中，显示比例保持 16:9</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403500447e734a44be43af9da0809428~tplv-k3u1fbpfcp-watermark.image?" alt="rem02.jpg"></p><p>当屏幕尺寸比例大于 16:9 时，页面左右留白，上下占满并居中，显示比例保持 16:9</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11f4908f68fb49ada3597d3d07161a32~tplv-k3u1fbpfcp-watermark.image?" alt="rem03.jpg"></p><h4 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h4><p><strong>关于 rem</strong><br><code>rem(font size of the root element)</code>，是 css3 中新增的一个大小单位，即相对于根元素 font-size 值的大小。<br><strong>自适应思路</strong><br>动态的计算出页面的 fontsize 从而改变 rem 的大小。</p><ol><li>拿 1920 * 1080 的标准屏幕大小为例，将屏幕分为<code>10</code>份，先计算<code>rem 的基准值:</code> 1920 / 10 = 192；</li><li>把所有元素的长、宽、位置、字体大小等原来的 px 单位全部转换成 rem；</li><li>网页加载后，用 js 去计算当前浏览器的宽度，并设置 html 的 font-size 为 (<code>当前浏览器窗口宽度 / 10</code>) 。<br>这样的话 10rem 就刚好等于浏览器窗口的宽度，也就可以保证 100% 宽度，等比例缩放设计稿的页面了。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/591f96cb9a2a44379892e9a91842c8eb~tplv-k3u1fbpfcp-watermark.image?" alt="rem01.jpg"></li></ol><p><strong>因此 rem + vw vh 方案要解决三件事</strong></p><ol><li>获得 rem 的基准值；</li><li>页面内写一段 js 代码，动态的计算<code>html根元素的font-size</code>；</li><li>屏幕变化后，图表自动调整和图表字体、间距、位移等的自适应。</li></ol><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><p><strong>第一点：获得 rem 的基准值</strong></p><ol><li>首先安装 <code>@njleonzhang/postcss-px-to-rem</code> 这个包</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @njleonzhang/postcss-px-to-rem -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在项目根目录新建<code>.postcssrc.js</code>配置文件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;&#125;,</span><br><span class="line">    <span class="string">"@njleonzhang/postcss-px-to-rem"</span>: &#123;</span><br><span class="line">      unitToConvert: <span class="string">'px'</span>, <span class="comment">// (String) 要转换的单位，默认是 px。</span></span><br><span class="line">      widthOfDesignLayout: <span class="number">1920</span>, <span class="comment">// (Number) 设计布局的宽度。对于pc仪表盘，一般是 1920.</span></span><br><span class="line">      unitPrecision: <span class="number">3</span>, <span class="comment">// (Number) 允许 rem 单位增长到的十进制数字.</span></span><br><span class="line">      selectorBlackList: [<span class="string">'.ignore'</span>, <span class="string">'.hairlines'</span>], <span class="comment">// (Array) 要忽略并保留为 px 的选择器.</span></span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// (Number) 设置要替换的最小像素值.</span></span><br><span class="line">      mediaQuery: <span class="literal">false</span> <span class="comment">// (Boolean) 允许在媒体查询中转换 px.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置完成后，页面内的 px 就会被转换成 rem 了</li></ol><p><strong>第二点：动态的计算<code>html根元素的font-size</code></strong></p><ol><li><p>在工具函数文件中新建一个 rem.js 文件，用于动态计算 font-size</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">screenRatioByDesign = <span class="number">16</span> <span class="regexp">/ 9) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  let docEle = document.documentElement</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  function setHtmlFontSize() &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    var screenRatio = docEle.clientWidth /</span> docEle.clientHeight;</span></span></span><br><span class="line"><span class="function"><span class="params">    var fontSize = (</span></span></span><br><span class="line"><span class="function"><span class="params">      screenRatio &gt; screenRatioByDesign</span></span></span><br><span class="line"><span class="function"><span class="params">        ? (screenRatioByDesign <span class="regexp">/ screenRatio)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">        : 1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    ) * docEle.clientWidth /</span> <span class="number">10</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    docEle.style.fontSize = fontSize.toFixed(<span class="number">3</span></span>) + "<span class="title">px</span>";</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params">docEle.style.fontSize</span>);</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="title">setHtmlFontSize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  <span class="title">window</span>.<span class="title">addEventListener</span>(<span class="params"><span class="string">'resize'</span>, setHtmlFontSize</span>)</span></span><br><span class="line"><span class="function">&#125;)(<span class="params"></span>)</span></span><br></pre></td></tr></table></figure></li><li><p>在入口文件 main.js 中引入 rem.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./utils/rem.js'</span>;</span><br></pre></td></tr></table></figure></li></ol><p>至此，页面就已经可以实现 16:9 自适应了。</p><p><strong>第三点：屏幕变化，图表自适应</strong><br>屏幕变化后，图表自动调整字体、间距、位移等，此处参考上面 vw vh 的实现方式即可，在此就不重复赘述了</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>推荐一个echarts 的案列网站，需要什么直接图表直接在上面去找，可以省去很多查 echarts 配置的时间<br><a href="https://juejin.cn/post/7078834647005822983" rel="external nofollow noopener noreferrer" target="_blank">全网echarts案例资源大总结和echarts的高效使用技巧（细节版）</a></li></ul><ul><li><p>scale 方案参考：<br><a href="https://juejin.cn/post/7148733509744459790" rel="external nofollow noopener noreferrer" target="_blank">数据大屏最简单自适应方案，无需适配rem单位</a></p></li><li><p>vw vh 方案参考：<br><a href="https://juejin.cn/post/7009081081760579591#heading-31" rel="external nofollow noopener noreferrer" target="_blank">Vue+Echarts企业级大屏项目适配方案</a></p></li><li><p>rem 方案参考：<a href="https://juejin.cn/post/7035930041498206216#heading-0" rel="external nofollow noopener noreferrer" target="_blank">数据大屏rem适配方案</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;当接到可视化大屏需求时，你是否会有以下疑问👇&lt;br&gt;&lt;strong&gt;如何做一款定制化的数据大屏？&lt;br&gt;开发可视化数据大屏如何做自适应？&lt;br&gt;vw vh、rem、scale 到底哪种比较好？&lt;br&gt;时间不够，有没有偷懒的方法？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eca164ef1c8471eaabd171963d91c5e~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;sceen-demo.jpg&quot;&gt;&lt;br&gt;最近在公司开发了一个可视化大屏，开发定制化大屏，大家可能都一个感受，开发大屏主要是两方面的工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;大屏之关键-前期的自适应适配&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;根据 ui 稿绘制图表，调细节&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而解决了适配问题后，后面就只是一个慢工出细活，耗时间的事情了。
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>mac item2 ssh 登录云服务器</title>
    <link href="https://water.buging.cn/2023/03/14/mac-item2-ssh-%E7%99%BB%E5%BD%95%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://water.buging.cn/2023/03/14/mac-item2-ssh-登录云服务器/</id>
    <published>2023-03-14T19:14:26.000Z</published>
    <updated>2023-08-01T06:26:37.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-创建脚本文件"><a href="#1-创建脚本文件" class="headerlink" title="1. 创建脚本文件"></a>1. 创建脚本文件</h3><p>新建一个名为tencentServerLogin的文件：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch tencenServerLogin</span><br></pre></td></tr></table></figure><a id="more"></a><p>将服务器信息写入到该文件中，内容示例如下：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect -f</span></span><br><span class="line"><span class="built_in">set</span> user root</span><br><span class="line"><span class="built_in">set</span> host 33.123.323.41</span><br><span class="line"><span class="built_in">set</span> password 34343Bh-e343476-c</span><br><span class="line"><span class="built_in">set</span> timeout 30</span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$host</span></span><br><span class="line">expect <span class="string">"*assword:*"</span></span><br><span class="line">send <span class="string">"<span class="variable">$password</span>\r"</span></span><br><span class="line">interact</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><h3 id="2-新建一个iTerm2-Profile"><a href="#2-新建一个iTerm2-Profile" class="headerlink" title="2. 新建一个iTerm2 Profile"></a>2. 新建一个iTerm2 Profile</h3><ol><li>打开iTerm2 -&gt; preferences -&gt; Profiles</li><li>点击左下角的”+”号, 新建一个profile</li><li>在右边的内容框中,找到Command, 填入expect + 前面新建tencenServerLogin文件的绝对路径</li></ol><p>示例如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202303141917407" alt></p><h3 id="3-iTerm2保持ssh连接不断开"><a href="#3-iTerm2保持ssh连接不断开" class="headerlink" title="3. iTerm2保持ssh连接不断开"></a>3. iTerm2保持ssh连接不断开</h3><p>用iTerm2进行ssh时，空闲了一段时间就会与服务器断开连接。这个问题可以通过添加以下配置来解决，配置示例如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202303141918096" alt></p><h3 id="4-使用iTerm2登录云服务器"><a href="#4-使用iTerm2登录云服务器" class="headerlink" title="4. 使用iTerm2登录云服务器"></a>4. 使用iTerm2登录云服务器</h3><p>示例如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202303141918585" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-创建脚本文件&quot;&gt;&lt;a href=&quot;#1-创建脚本文件&quot; class=&quot;headerlink&quot; title=&quot;1. 创建脚本文件&quot;&gt;&lt;/a&gt;1. 创建脚本文件&lt;/h3&gt;&lt;p&gt;新建一个名为tencentServerLogin的文件：&lt;/p&gt;
&lt;figure class=&quot;highlight zsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;touch tencenServerLogin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>um3使用tailwindcss</title>
    <link href="https://water.buging.cn/2023/02/08/um3%E4%BD%BF%E7%94%A8tailwindcss/"/>
    <id>https://water.buging.cn/2023/02/08/um3使用tailwindcss/</id>
    <published>2023-02-08T16:14:33.000Z</published>
    <updated>2023-08-01T06:26:37.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://tailwindcss.com/docs/installation/using-postcss" rel="external nofollow noopener noreferrer" target="_blank">Tailwind CSS</a> 是最近几年很火的 CSS UI 框架，遵循 Atomic/Utility-First 的原则，能够大幅提升样式开发效率。在本篇博客中，我将介绍 UmiJS 项目接入 Tailwind CSS 的流程，并分享遇到的问题及其解决方法。<a id="more"></a></p><h2 id="安装-Tailwind"><a href="#安装-Tailwind" class="headerlink" title="安装 Tailwind"></a>安装 Tailwind</h2><h3 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h3><p>Tailwind 依赖 <a href="https://postcss.org" rel="external nofollow noopener noreferrer" target="_blank">PostCSS</a> 提供的样式处理能力。PostCSS 将 CSS 代码解析成 AST 结构，并交由 JS 插件来进行处理，常见的 PostCSS 插件有 <code>autoprefixer</code>、<code>cssnano</code> 等。其中，<code>autoprefixer</code> 用于为 CSS 中的属性添加浏览器特定的前缀，提升 CSS 代码的兼容性。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>目前，Umi 的稳定版本是 <code>3.5.20</code> ，其（<a href="https://github.com/umijs/umi/blob/master/packages/bundler-webpack/package.json" rel="external nofollow noopener noreferrer" target="_blank">@umijs/bundler-webpack</a>）使用的 PostCSS 版本为 <code>7.0.32</code> ，而 Tailwind 依赖 PostCSS 的版本为 <code>8.x.x</code> 。因此，我们需要安装兼容 PostCSS 7 的 Tailwind 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn add \</span><br><span class="line">  tailwindcss@npm:@tailwindcss/postcss7-compat \</span><br><span class="line">  @tailwindcss/postcss7-compat \</span><br><span class="line">  autoprefixer@^9</span><br></pre></td></tr></table></figure><h2 id="修改-Umi-配置"><a href="#修改-Umi-配置" class="headerlink" title="修改 Umi 配置"></a>修改 Umi 配置</h2><p>完成相关依赖的安装后，我们需要修改 Umi 配置文件（<code>.umirc</code> 或 <code>config/config.ts</code>）的 <code>extraPostCSSPlugins</code> 选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &quot;umi&quot;;</span><br><span class="line"></span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  extraPostCSSPlugins: [require(&quot;tailwindcss&quot;), require(&quot;autoprefixer&quot;)],</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>默认情况下，<code>tailwindcss</code> 会识别根目录下的 <code>tailwind.config.js</code> 配置文件。如果我们想指定配置文件的读取路径，可设置 <code>config</code> 属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &quot;umi&quot;;</span><br><span class="line"></span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  extraPostCSSPlugins: [</span><br><span class="line">    require(&quot;tailwindcss&quot;)(&#123; config: &quot;[custom_path]/tailwind.config.js&quot; &#125;),</span><br><span class="line">    require(&quot;autoprefixer&quot;),</span><br><span class="line">  ],</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="添加-Tailwind-配置"><a href="#添加-Tailwind-配置" class="headerlink" title="添加 Tailwind 配置"></a>添加 Tailwind 配置</h2><p><code>tailwind.config.js</code> 是 Tailwind 的配置文件，通常存放在项目根目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &quot;jit&quot;,</span><br><span class="line">  purge: [&quot;./src/**/*.&#123;ts,tsx,js,jsx&#125;&quot;],</span><br><span class="line">  darkMode: false,</span><br><span class="line">  theme: &#123;&#125;,</span><br><span class="line">  variants: &#123;&#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到在上面的文件中，通过配置 <code>mode</code> 属性为 <code>jit</code> ，我们开启了 Tailwind 的 JIT（Just In Time）编译模式。开启 JIT 模式，有什么好处呢？</p><h3 id="JIT-编译模式"><a href="#JIT-编译模式" class="headerlink" title="JIT 编译模式"></a>JIT 编译模式</h3><p>首先，我们需要了解在不开启 JIT 模式（<strong>传统模式</strong>）下的 Tailwind 构建流程：Tailwind 通过读取配置文件，预生成所有的工具类，提供给开发者使用。最后在打包时，通过 PostCSS 提供的 <code>pure</code> 插件，执行 Tree Shaking 操作，移除未被使用的工具类，从而简化产物。在该模式下，如果配置文件有很多自定义的配置，那么就会延长预生成的时间。  </p><p>在开启 JIT 模式后，Tailwind 不预生成所有的工具类，而是根据开发者的实际使用，来生成对应的类，大大提升了编译速度。  </p><p>此外，JIT 模式支持 <code>w-[100px]</code> 等包含特殊尺寸的工具类生成，而不需要开发者自行编写特定尺寸的 <code>style</code> 或 <code>class</code> ，这也提升了开发体验。</p><h2 id="使用-Tailwind"><a href="#使用-Tailwind" class="headerlink" title="使用 Tailwind"></a>使用 Tailwind</h2><p>如下图所示，<a href="https://tailwindcss.com/docs/installation/using-postcss" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>建议我们在项目中引入 <code>base</code>、<code>components</code> 和 <code>utilities</code> 。</p><p><img src="https://pic2.zhimg.com/v2-2528ab6ca625c66252d9b99a8e81ff51_r.jpg" alt></p><p>Tailwind 官方建议引入的编译指令</p><p>经过验证，<code>base</code> 和 <code>components</code> 会影响 Ant Design 的样式，会带来样式问题。因此，在 Umi 项目的 <code>global.less</code> 文件中，我们只需引入 <code>utilities</code> 样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@tailwind utilities;</span><br></pre></td></tr></table></figure><h2 id="修复工具类无法生成的问题"><a href="#修复工具类无法生成的问题" class="headerlink" title="修复工具类无法生成的问题"></a>修复工具类无法生成的问题</h2><p>在开启 JIT 模式后，会遇到工具类无法生成的问题。如下图所示，可以发现 Tailwind 并没有为 <code>text-red-500</code> 生成对应的样式规则。</p><p><img src="https://pic1.zhimg.com/v2-0183b45405630e6d64c02826b7c9b8b0_r.jpg" alt></p><p>Tailwind 工具类无法生成</p><p>查看相关 <a href="https://github.com/tailwindlabs/tailwindcss/issues/5132%23issuecomment-894549642" rel="external nofollow noopener noreferrer" target="_blank">Issue</a> 得知，该问题只会在 PostCSS 7 开启 JIT 模式出现，因为 PostCSS 7 不支持 <code>dir-dependency</code> 的消息类型。  </p><p>该问题的具体解决办法是在执行 <code>umi start</code> 命令时，配置 <code>TAILWIND_MODE=watch</code> 的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;TAILWIND_MODE=watch umi dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.dute.org/blog/what-is-postcss.html" rel="external nofollow noopener noreferrer" target="_blank">一文搞懂什么是 PostCSS</a></li><li><a href="https://github.com/dewfall123/umi-plugin-tailwindcss" rel="external nofollow noopener noreferrer" target="_blank">github.com/dewfall123/umi-plugin-tailwindcss</a></li><li><a href="https://iorigina.com/p/%25E5%259C%25A8-umi-%25E4%25B8%25AD%25E4%25BD%25BF%25E7%2594%25A8-tailwindcss/" rel="external nofollow noopener noreferrer" target="_blank">在 Umi 中使用 TailwindCSS</a></li><li><a href="https://juejin.cn/post/7025549579495931935" rel="external nofollow noopener noreferrer" target="_blank">Tailwind 适配 Umi H5 方案</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://tailwindcss.com/docs/installation/using-postcss&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Tailwind CSS&lt;/a&gt; 是最近几年很火的 CSS UI 框架，遵循 Atomic/Utility-First 的原则，能够大幅提升样式开发效率。在本篇博客中，我将介绍 UmiJS 项目接入 Tailwind CSS 的流程，并分享遇到的问题及其解决方法。
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>mac常用的命令</title>
    <link href="https://water.buging.cn/2023/02/02/mac%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>https://water.buging.cn/2023/02/02/mac常用的命令/</id>
    <published>2023-02-02T21:24:55.000Z</published>
    <updated>2023-08-01T06:26:37.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-最常用终端命令"><a href="#1-最常用终端命令" class="headerlink" title="1.最常用终端命令"></a>1.最常用终端命令</h1><p>Mac OS系统有些文件默认隐藏,如果需要显示,可以通过终端显示隐藏文件或文件夹<a id="more"></a></p><ul><li>显示隐藏路径的终端命令:defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder</li><li>取消隐藏路径的终端命令:defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder</li></ul><h1 id="2-其他终端命令"><a href="#2-其他终端命令" class="headerlink" title="2.其他终端命令"></a>2.其他终端命令</h1><h2 id="1-目录操作"><a href="#1-目录操作" class="headerlink" title="1.目录操作"></a>1.目录操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>cd</td><td>打开当前目录</td><td>cd dirname</td></tr><tr><td>pwd</td><td>显示当前目录的路径名</td><td>pwd</td></tr><tr><td>ls</td><td>显示当前目录的内容</td><td>ls -la</td></tr><tr><td>dircmp</td><td>比较两个目录的内容</td><td>dircmp dir1 dir2</td></tr><tr><td>mkdir</td><td>创建一个目录</td><td>mkdir dirname</td></tr><tr><td>rmdir</td><td>删除一个目录</td><td>rmdir dirname</td></tr><tr><td>mvdir</td><td>移动或重命名一个目录</td><td>mvdir dir1 dir2</td></tr></tbody></table><h2 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2.文件操作"></a>2.文件操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>cat</td><td>显示或连接文件</td><td>cat filename</td></tr><tr><td>ln</td><td>联接文件</td><td>ln -s file1 file2</td></tr><tr><td>find</td><td>使用匹配表达式查找文件</td><td>find . -name “*.c” -print</td></tr><tr><td>file</td><td>显示文件类型</td><td>file filename</td></tr><tr><td>open</td><td>使用默认的程序打开文件</td><td>open filename</td></tr><tr><td>od</td><td>显示非文本文件的内容</td><td>od -c filename</td></tr><tr><td>cp</td><td>复制文件或目录</td><td>cp file1 file2</td></tr><tr><td>rm</td><td>删除文件或目录</td><td>rm filename</td></tr><tr><td>mv</td><td>改变文件名或所在目录</td><td>mv file1 file2</td></tr><tr><td>pg</td><td>分页格式化显示文件内容</td><td>pg filename</td></tr><tr><td>more</td><td>分屏显示文件内容</td><td>more filename</td></tr></tbody></table><h2 id="3-选择操作"><a href="#3-选择操作" class="headerlink" title="3.选择操作"></a>3.选择操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>comm</td><td>显示两有序文件的公共和非公共行</td><td>comm file1 file2</td></tr><tr><td>wc</td><td>统计文件的字符数、词数和行数</td><td>wc filename</td></tr><tr><td>nl</td><td>给文件加上行号</td><td>nl file1 &gt;file2</td></tr><tr><td>awk</td><td>在文件中查找并处理模式</td><td>awk ‘{print $1 $1}’ filename</td></tr><tr><td>sort</td><td>排序或归并文件</td><td>sort -d -f -u file1</td></tr><tr><td>uniq</td><td>去掉文件中的重复行</td><td>uniq file1 file2</td></tr><tr><td>diff</td><td>比较并显示两个文件的差异</td><td>diff file1 file2</td></tr><tr><td>sed</td><td>非交互方式流编辑器</td><td>sed “s/red/green/g” filename</td></tr><tr><td>cut</td><td>显示文件每行中的某些域</td><td>cut -f1,7 -d: /etc/passwd</td></tr><tr><td>colrm</td><td>从标准输入中删除若干列</td><td>colrm 8 20 file2</td></tr><tr><td>paste</td><td>横向连接文件</td><td>paste file1 file2</td></tr><tr><td>head</td><td>显示文件的最初几行</td><td>head -20 filename</td></tr><tr><td>tail</td><td>显示文件的最后几行</td><td>tail -15 filename</td></tr></tbody></table><h2 id="4-安全操作"><a href="#4-安全操作" class="headerlink" title="4.安全操作"></a>4.安全操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>chown</td><td>改变文件或目录的属主</td><td>chown newowner filename</td></tr><tr><td>chgrp</td><td>改变文件或目录的所属组</td><td>chgrp staff filename</td></tr><tr><td>xlock</td><td>给终端上锁</td><td>xlock -remote</td></tr><tr><td>passwd</td><td>修改用户密码</td><td>passwd</td></tr><tr><td>chmod</td><td>改变文件或目录的权限</td><td>chmod ug+x filename umask</td></tr><tr><td>umask</td><td>定义创建文件的权限掩码</td><td>umask 027</td></tr></tbody></table><h2 id="5-编程操作"><a href="#5-编程操作" class="headerlink" title="5.编程操作"></a>5.编程操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>touch</td><td>更新文件的访问和修改时间</td><td>touch -m 05202400 filename</td></tr><tr><td>dbx</td><td>命令行界面调试工具</td><td>dbx a.out</td></tr><tr><td>xde</td><td>图形用户界面调试工具</td><td>xde a.out</td></tr><tr><td>make</td><td>维护可执行程序的最新版本</td><td>make</td></tr></tbody></table><h2 id="6-进程操作"><a href="#6-进程操作" class="headerlink" title="6.进程操作"></a>6.进程操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>nice</td><td>改变待执行命令的优先级</td><td>nice cc -c *.c</td></tr><tr><td>renice</td><td>改变已运行进程的优先级</td><td>renice +20 32768</td></tr><tr><td>ps</td><td>显示进程当前状态</td><td>ps u</td></tr><tr><td>kill</td><td>终止进程</td><td>kill -9 30142</td></tr></tbody></table><h2 id="7-时间操作"><a href="#7-时间操作" class="headerlink" title="7.时间操作"></a>7.时间操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>date</td><td>显示系统的当前日期和时间</td><td>date</td></tr><tr><td>cal</td><td>显示日历</td><td>cal 8 1996</td></tr><tr><td>time</td><td>统计程序的执行时间</td><td>time a.out</td></tr></tbody></table><h2 id="8-网络与通信操作"><a href="#8-网络与通信操作" class="headerlink" title="8.网络与通信操作"></a>8.网络与通信操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>mail</td><td>阅读和发送电子邮件</td><td>mail</td></tr><tr><td>write</td><td>给另一用户发送报文</td><td>write username pts/1</td></tr><tr><td>mesg</td><td>允许或拒绝接收报文</td><td>mesg n</td></tr><tr><td>ftp</td><td>在本地主机与远程主机之间传输文件</td><td>ftp ftp.sp.net.edu.cn</td></tr><tr><td>rcp</td><td>在本地主机与远程主机之间复制文件</td><td>rcp file1 host1:file2</td></tr><tr><td>ping</td><td>给一个网络主机发送 回应请求</td><td>ping hpc.sp.net.edu.cn</td></tr><tr><td>telnet</td><td>远程登录</td><td>telnet hpc.sp.net.edu.cn</td></tr><tr><td>rlogin</td><td>远程登录</td><td>rlogin hostname -l username</td></tr><tr><td>rsh</td><td>在远程主机执行指定命令</td><td>rsh f01n03 date</td></tr></tbody></table><h2 id="9-Korn-Shell-命令"><a href="#9-Korn-Shell-命令" class="headerlink" title="9.Korn Shell 命令"></a>9.Korn Shell 命令</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>history</td><td>列出最近执行过的几条命令及编号</td><td>history</td></tr><tr><td>r</td><td>重复执行最近执行过的某条命令</td><td>r -2</td></tr><tr><td>alias</td><td>给某个命令定义别名</td><td>alias del=rm -i</td></tr><tr><td>unalias</td><td>取消对某个别名的定义</td><td>unalias del</td></tr></tbody></table><h2 id="10-其它命令"><a href="#10-其它命令" class="headerlink" title="10.其它命令"></a>10.其它命令</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>stty</td><td>显示或重置控制键定义</td><td>stty -a</td></tr><tr><td>du</td><td>查询磁盘使用情况</td><td>du -k subdir</td></tr><tr><td>df</td><td>显示文件系统的总空间和可用空间</td><td>df /tmp</td></tr><tr><td>w</td><td>显示当前系统活动的总信息</td><td>w</td></tr><tr><td>env</td><td>显示当前所有设置过的环境变量</td><td>env</td></tr><tr><td>who</td><td>列出当前登录的所有用户</td><td>who</td></tr><tr><td>whoami</td><td>显示当前正进行操作的用户名</td><td>whoami</td></tr><tr><td>tty</td><td>显示终端或伪终端的名称</td><td>tty</td></tr><tr><td>uname</td><td>显示操作系统的有关信息</td><td>uname -a</td></tr><tr><td>clear</td><td>清除屏幕或窗口内容</td><td>clear</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-最常用终端命令&quot;&gt;&lt;a href=&quot;#1-最常用终端命令&quot; class=&quot;headerlink&quot; title=&quot;1.最常用终端命令&quot;&gt;&lt;/a&gt;1.最常用终端命令&lt;/h1&gt;&lt;p&gt;Mac OS系统有些文件默认隐藏,如果需要显示,可以通过终端显示隐藏文件或文件夹
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="https://water.buging.cn/2023/01/10/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>https://water.buging.cn/2023/01/10/前端工程化/</id>
    <published>2023-01-10T12:52:42.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、前端代码规范工具"><a href="#一、前端代码规范工具" class="headerlink" title="一、前端代码规范工具"></a>一、前端代码规范工具</h2><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>代码规范和质量是编码中很重要的一部分，目前有很多工具可以帮助我们处理。</p><p>在使用这些工具的过程中发现，存在一下问题：</p><ul><li>功能重复</li><li>不同工具，相同配置冲突</li><li>版本迭代导致配置变更</li><li><p>工具相互组合，使用困难</p><a id="more"></a><p>这篇文章主要从工程化的角度出发，分享以下内容：</p></li><li><p>1、介绍各种工具的使用（Prettier、ESLint、lint-staged、commitlint、Hooks）</p></li><li>2、通过Git Hooks来自动化执行这些工具。</li><li>3、配置CI在代码提交阶段格式化、检测代码、检测提交信息。</li></ul><p>学习完这篇文章你将了解：</p><ul><li>1、了解如何区分这些工具、不同的配置入口</li><li>2、在项目中如何配置这些检测工具</li><li>3、如果避免每次的全量检测代码</li><li>4、如何规范提交代码和描述信息</li><li>5、学习Git Hooks知识</li><li>6、如何将这些工具通过Hooks自动化处理</li><li>7、通过CI将这些流程自动化执行</li></ul><p><a href="https://link.zhihu.com/?target=https%3A//github.com/richLpf/auto-format-demo" rel="external nofollow noopener noreferrer" target="_blank">本文代码示例参考</a></p><h2 id="2、工具分类介绍"><a href="#2、工具分类介绍" class="headerlink" title="2、工具分类介绍"></a>2、工具分类介绍</h2><p>检测代码的工具很多，主要分为三类：</p><ul><li>一类是代码格式化工具，专注代码结构美化，不处理任何有关语法的内容  </li></ul><ul><li><code>[Prettier](https://link.zhihu.com/?target=https%3A//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29e62e3c6c514314b06e0f37aca21b3b~tplv-k3u1fbpfcp-zoom-1.image)</code>：专注代码格式化</li><li><code>[Stylelint](https://link.zhihu.com/?target=https%3A//stylelint.io/)</code>：专注CSS语法格式化</li></ul><ul><li>一类是lint类，这些工具也支持处理代码格式，但重点是检测代码语法质量  </li></ul><ul><li><code>[ESLint](https://link.zhihu.com/?target=https%3A//cn.eslint.org/)</code>: 可以配置代码格式规则，也可以检测代码语法质量</li></ul><ul><li>一类是将不同的工具进行合成，成为一个包含子功能或者有定制功能的插件，可以避免Prettier和Lint二者在代码处理上的冲突。  </li></ul><ul><li><code>[eslint-config-prettier](https://link.zhihu.com/?target=https%3A//github.com/prettier/eslint-config-prettier)</code>：ESLint检测和Prettier格式化</li><li><code>[tslint-config-prettier](https://link.zhihu.com/?target=https%3A//github.com/alexjoverm/tslint-config-prettier)</code>：TS检测和代码格式化</li><li><code>[lint-staged](https://link.zhihu.com/?target=https%3A//github.com/okonet/lint-staged%23readme)</code>：仅过滤Git暂存区上的文件，可以有效避免每次提交处理所有文件。</li></ul><p><strong>Git暂存区：执行命令git add后，要提交的代码存放的空间</strong></p><p>这些工具有小而精的，也有大而全的，具体使用要根据具体场景</p><ul><li>写一个主题样式，肯定首选Stylelint，重点处理CSS；</li><li>开发一个产品，不妨使用大而全。因为项目中有很多格式需要处理，如果都用小而精的处理，会引入很多荣誉的配置。</li></ul><p><strong>这些工具配置都比较相似，但尤其要注意版本的不同，导致的配置不同。</strong></p><h2 id="3、本文环境"><a href="#3、本文环境" class="headerlink" title="3、本文环境"></a>3、本文环境</h2><p>下文依赖的工具和环境</p><ul><li>OS：mac m1</li><li>Git版本：2.24.3</li><li>npm版本：7.21.1</li><li>Husky版本：7.0.4</li><li>Nodejs版本：v16.9.0</li></ul><h2 id="二、自动化工具原理和配置"><a href="#二、自动化工具原理和配置" class="headerlink" title="二、自动化工具原理和配置"></a>二、自动化工具原理和配置</h2><h2 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h2><p><strong>Prettier、ESLint</strong></p><p>两者的工作原理是将代码解析成<code>AST</code>，再通过我们写的配置，还原格式化后的代码，具体转化可以体验下<a href="https://link.zhihu.com/?target=https%3A//cn.eslint.org/parser/%25E3%2580%2582" rel="external nofollow noopener noreferrer" target="_blank">https://cn.eslint.org/parser/。</a></p><p><strong>lint-staged、commitlint、husky</strong></p><ul><li><code>lint-staged</code>是获取git add后暂存区的代码。</li><li><code>commitlint</code>是获取git commit的描述信息然后对格式进行规则校验。</li><li><code>husky</code>是将git内置的勾子函数暴露出来，便于配置</li></ul><h2 id="2、配置对比"><a href="#2、配置对比" class="headerlink" title="2、配置对比"></a>2、配置对比</h2><blockquote><p>下面这些自动化工具，可以不同的地方进行配置，版本也不同，看起来很复杂，其实并没有，除了注意大版本的不同，其他的配置方式都大同小异。这里我们整理下这些配置通用的部分，下面就不再分开写，只展示package.json这一种方式。</p></blockquote><table><thead><tr><th>工具名称</th><th>package.json关键字</th><th>常用配置文件</th><th>忽略文件</th><th>共享文件</th><th>插件</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><a href="https://link.zhihu.com/?target=https%3A//github.com/richLpf/auto-format-demo/tree/main/config" rel="external nofollow noopener noreferrer" target="_blank">配置示例地址</a></li><li>package.json中关键字内容和配置文件内容一致</li><li>共享配置一般都是导出配置文件，上传npm，规范命名即可</li><li>这些工具大都还提供了编辑器集成、CLI等</li></ul><h2 id="三、代码格式美化：Prettier"><a href="#三、代码格式美化：Prettier" class="headerlink" title="三、代码格式美化：Prettier"></a>三、代码格式美化：Prettier</h2><h2 id="1、初始化项目构建"><a href="#1、初始化项目构建" class="headerlink" title="1、初始化项目构建"></a>1、初始化项目构建</h2><p>新建项目，并在index.html和index.js写一些格式不规范的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir front-demo</span><br><span class="line">cd front-demo</span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line">mkdir src</span><br><span class="line">touch src/index.js</span><br></pre></td></tr></table></figure><p>目录结构如图：</p><p><img src="https://pic1.zhimg.com/v2-be84b384e89940536470c005f804ee80_r.jpg" alt></p><h2 id="2、插件使用"><a href="#2、插件使用" class="headerlink" title="2、插件使用"></a>2、插件使用</h2><p>安装Prettier插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add prettier -D</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn prettier -w .</span><br></pre></td></tr></table></figure><p>发现当前所有目录下的文件，都进行了格式化</p><p><strong>这里使用yarn prettier是为了读取项目下的prettier指令，如果你安装全局命令或者配置了环境变量，可以不用yarn指令</strong></p><p><code>prettier</code>格式有一套默认的格式化规则，一般情况下，选择默认就可以了</p><blockquote><p>当然也可以自行配置，下面有两种配置方法：  </p></blockquote><ul><li>在package.json中添加关键词<code>prettier</code></li><li>在项目根目录下新建<code>.prettierrc</code>文件，js、json、yaml等也可以。</li><li>下面就不再写package.json中配置了，具体关键字可以查看上面的表格。我们统一通过配置文件进行配置，其他的工具也是一样的。</li><li>规则解释见配置文件<a href="https://link.zhihu.com/?target=https%3A//github.com/richLpf/auto-format-demo/tree/main/config" rel="external nofollow noopener noreferrer" target="_blank">Github地址</a></li></ul><p>这里在根目录下新建文件<code>.prettierrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;singleQuote&quot;: true,</span><br><span class="line">  &quot;printWidth&quot;: 120,</span><br><span class="line">  &quot;arrowParens&quot;: &quot;avoid&quot;,</span><br><span class="line">  &quot;trailingComma&quot;: &quot;none&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时Prettier根据<code>.prettierrc</code>定义的规则，对整个项目做了格式化操作。 但一些场景下需要我们对个别文件进行处理，可以通过覆盖配置来实现</p><h2 id="3、覆盖配置"><a href="#3、覆盖配置" class="headerlink" title="3、覆盖配置"></a>3、覆盖配置</h2><p>修改<code>.prettierrc</code>文件，添加<code>overrides</code>字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;semi&quot;: false,</span><br><span class="line">  &quot;overrides&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;files&quot;: &quot;*.test.js&quot;,</span><br><span class="line">      &quot;options&quot;: &#123;</span><br><span class="line">        &quot;semi&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;files&quot;: [&quot;*.html&quot;, &quot;legacy/**/*.js&quot;],</span><br><span class="line">      &quot;options&quot;: &#123;</span><br><span class="line">        &quot;tabWidth&quot;: 4</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样针对<code>test.js</code>文件、<code>html</code>文件和<code>legacy/**/*.js</code>的格式就会按当前配置走。</p><h2 id="4、共享配置"><a href="#4、共享配置" class="headerlink" title="4、共享配置"></a>4、共享配置</h2><p>项目的配置一般都不会变化，所以常常多个项目使用同一个配置，特别是针对大点的项目。</p><p>下面我们实践下创建一份Prettier配置到npm仓库</p><p>1、<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/" rel="external nofollow noopener noreferrer" target="_blank">注册npm账号</a></p><p>2、创建一个包、包的命名规则：<code>@prettier/plugin-</code> or <code>prettier-plugin-</code> or <code>@&lt;scope&gt;/prettier-plugin-</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ./config/prettier/prettier-plugin-frontdemo</span><br><span class="line">npm init</span><br><span class="line">mkdir .prettierrc</span><br><span class="line">yarn add -D prettier</span><br><span class="line">echo &quot;/node_modules&quot; &gt; .gitignore</span><br></pre></td></tr></table></figure><p>3、发布创建好的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 如果第一次发布需要创建</span><br><span class="line">npm adduser</span><br><span class="line"></span><br><span class="line"># 如果不是第一次发布，只需要登陆</span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line"># 发布</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-60a66d1de84d7d2923ecc4275c06b780_r.jpg" alt></p><p>4、登陆npm官网，即可看到上传的包<code>prettier-plugin-frontdemo</code></p><p><img src="https://pic1.zhimg.com/v2-13cca03bdb697a92ed4557173729418c_r.jpg" alt></p><p>5、使用包，在<code>package.json</code>中，添加远程仓库地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;prettier&quot;: &quot;prettier -w src/*.js&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;name&quot;: &quot;front-demo&quot;,</span><br><span class="line">  &quot;prettier&quot;: &quot;prettier-plugin-frontdemo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、执行<code>yarn prettier</code></p><h2 id="5、忽略文件"><a href="#5、忽略文件" class="headerlink" title="5、忽略文件"></a>5、忽略文件</h2><p>如果想要忽略某个文件的格式化，可以新建文件<code>.prettierignore</code>，添加要忽略的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dist</span><br><span class="line">*.html</span><br></pre></td></tr></table></figure><h2 id="四、代码质量检测：ESLint"><a href="#四、代码质量检测：ESLint" class="headerlink" title="四、代码质量检测：ESLint"></a>四、代码质量检测：ESLint</h2><h2 id="1、安装ESLint插件"><a href="#1、安装ESLint插件" class="headerlink" title="1、安装ESLint插件"></a>1、安装ESLint插件</h2><p><code>yarn add eslint -D</code></p><h2 id="2、新建配置文件"><a href="#2、新建配置文件" class="headerlink" title="2、新建配置文件"></a>2、新建配置文件</h2><p><code>yarn add eslint --init</code></p><p>上述命令行会弹出选择提示，根据需要选择eslint规则，最后会在根目录下生成<code>.eslintrc.js</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;es2021&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;,</span><br><span class="line">        &quot;plugin:react/recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">            &quot;jsx&quot;: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ecmaVersion&quot;: &quot;latest&quot;,</span><br><span class="line">        &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;react&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>env: 包含了执行环境配置，浏览器环境、node环境或支持es5、es6.</li><li>extends: 使用的扩展配置，这里主要是引入一些集成好的检测规则</li><li>parseOptioins: 解析器配置</li><li>plugins: 引入的eslint插件</li><li>rules: 用来定义具体规则，检查缩进，函数是否有返回值等。</li></ul><p>第一个参数，如果只有一个参数，直接使用字符串或数字就可以了</p><ul><li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li><li><code>&quot;warn&quot;</code> 或 <code>1</code> - 开启规则，使用警告级别的错误：<code>warn</code> (不会导致程序退出，即可以正常提交代码)</li><li><code>&quot;error&quot;</code> 或 <code>2</code> - 开启规则，使用错误级别的错误：<code>error</code> (当被触发的时候，程序会退出，存在error告警不能提交代码)</li></ul><p>第二个参数：你想要的配置参数</p><ul><li><code>&quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]</code>，如果存在单引号的就报错，终止提交。</li><li><code>&quot;quotes&quot;: [&quot;warn&quot;, &quot;double&quot;]</code>，如果存在单引号就告警，但可以正常提交。</li></ul><p>ESLint的<a href="https://link.zhihu.com/?target=https%3A//cn.eslint.org/docs/rules/" rel="external nofollow noopener noreferrer" target="_blank">配置规则</a></p><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn eslint src/*.js</span><br></pre></td></tr></table></figure><p>ESLint对代码进行了检测</p><p><img src="https://pic1.zhimg.com/v2-dfb5969183bbd13804b47e9c17009674_r.jpg" alt></p><p><strong>注意，如果项目根目录配置了<code>.eslintrc</code>, 那么package.json中配置了eslintConfig将不会生效</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;es2021&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">            &quot;jsx&quot;: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ecmaVersion&quot;: &quot;latest&quot;,</span><br><span class="line">        &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、覆盖ESLint配置"><a href="#3、覆盖ESLint配置" class="headerlink" title="3、覆盖ESLint配置"></a>3、覆盖ESLint配置</h2><p>我们看到不管是共享的配置还是使用官方推荐的配置，如果我们想要在这个基础上修改某个规则怎么办，使用overrides来覆盖，可以指定使用的范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;...&#125;,</span><br><span class="line">  &quot;overrides&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;files&quot;: [&quot;./src/*.js&quot;],</span><br><span class="line">      &quot;rules&quot;: &#123;</span><br><span class="line">          &quot;no-console&quot;: &quot;error&quot;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到no-console告警出来了。</p><p><img src="https://pic1.zhimg.com/v2-b73e3b7374bcdfed6bb053b3ee31af6c_r.jpg" alt></p><p><strong>其实ESLint还提供了创建规则，自定义解析器，编写插件的能力，下面我们主要实践下编写插件</strong></p><h2 id="4、共享配置-1"><a href="#4、共享配置-1" class="headerlink" title="4、共享配置"></a>4、共享配置</h2><blockquote><p>和Prettier一样，如果每个项目都配置一个太麻烦了，可以整体使用一套</p></blockquote><p>新建一个项目导出这个js文件，然后上传到npm，直接通过extends字段引用就可以了。发布流程和prettier是一样的，命名还要用eslint-config-开头。<a href="https://link.zhihu.com/?target=https%3A//cn.eslint.org/docs/developer-guide/shareable-configs" rel="external nofollow noopener noreferrer" target="_blank">官网</a></p><p><img src="https://pic4.zhimg.com/v2-57c1fb15f72a7a4bc14133587b3f88a7_r.jpg" alt></p><p>安装<code>yarn add -D eslint-config-frontdemo</code></p><p>修改<code>package.json</code>（修改.eslintrc.js文件也是一样的，这里用了package.json的配置，所以根目录下的.eslintrc.js要删除掉）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;eslint&quot;: &quot;eslint . --fix&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;eslintConfig&quot;: &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;browser&quot;: true,</span><br><span class="line">      &quot;node&quot;: true,</span><br><span class="line">      &quot;es2021&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: &quot;frontdemo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>yarn eslint</code>，成功</p><p><img src="https://pic3.zhimg.com/v2-1016e91d71033bc9d2aec41b6b9b143a_r.jpg" alt></p><h2 id="五、Git暂存区代码过滤：lint-staged"><a href="#五、Git暂存区代码过滤：lint-staged" class="headerlink" title="五、Git暂存区代码过滤：lint-staged"></a>五、Git暂存区代码过滤：lint-staged</h2><p>在实际使用过程，会遇到这样的问题：</p><ul><li>每次都要全局处理代码，浪费时间</li><li>每个人对所有代码格式化，规则不同，导致大量代码冲突</li></ul><blockquote><p>lint-staged，仅过滤Git暂存区的代码</p></blockquote><p>1、安装lint-staged</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add lint-staged -D</span><br></pre></td></tr></table></figure><p>2、<code>package.json</code>配置lint-staged</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">      &quot;*.js&quot;: &quot;prettier -w .&quot;,</span><br><span class="line">      &quot;*.js&quot;: &quot;eslint . --fix&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 修改业务代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;test lint-staged&quot;</span><br></pre></td></tr></table></figure><p>此时发现，这些命令仅对暂存区<code>*.js</code>的内容进行了格式化。</p><h2 id="六、Git提交规范自动化"><a href="#六、Git提交规范自动化" class="headerlink" title="六、Git提交规范自动化"></a>六、Git提交规范自动化</h2><h2 id="1、规范说明"><a href="#1、规范说明" class="headerlink" title="1、规范说明"></a>1、规范说明</h2><blockquote><p>如图所示，我们看到优秀的开源项目，对提交代码的描述信息都是很规范的。想要和这些项目一样清晰，我们可以借助插件commitlint</p></blockquote><p><img src="https://pic4.zhimg.com/v2-2ecdb0297c762bfa6f81b56ab5ddd92b_r.jpg" alt></p><p>在此之前我们要了解常用的Git提交规范</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Subject 一句话概述commit主题(必须)</span><br><span class="line">&lt;Body&gt; 详细描述 What 和 Why (可选)</span><br><span class="line">&lt;Footer&gt; 不兼容或关闭 issue 等说明(可选)</span><br><span class="line"></span><br><span class="line">主题(Subject)是 commit 的简短描述，不超过50个字符</span><br><span class="line">- 用一句话说明本次所作的提交, 如果一句话说不清楚，那有可能这个提交得拆分成多次</span><br><span class="line">- 主要采用 Verb + Object + Adverb 的形式描述，常见动词及示例如下</span><br><span class="line">1. feat: 添加代码和逻辑, 如 feat: add xxx field/method/class</span><br><span class="line">2. fix: 修复bug，如 fix: #123, fix xxx error</span><br><span class="line">3. docs: 文档更新，如 docs: change documents</span><br><span class="line">4. style: 样式修改，如 style: add class or change style</span><br><span class="line">5. refactor: 代码重构, 如refactor: rename, move, extract, inline等</span><br><span class="line">6. perf: 代码性能优化，perf: improves performance</span><br><span class="line">7. test: 代码单元测试，test: test menu component</span><br><span class="line">8. build: 项目构建，build: build project</span><br><span class="line">9. ci: 修改CI文件 ci: change gitlab-ci.yml</span><br><span class="line">10. chore: 构建过程或辅助工具的变动 chore: change webpack</span><br><span class="line"></span><br><span class="line">正文(Body)详细描述本次 commit 做了什么、为什么这样做(不是怎么做的)</span><br><span class="line">- 每行不要超过70字符</span><br><span class="line">1. 这个改动解决了什么问题？</span><br><span class="line">2. 这个改动为什么是必要的？</span><br><span class="line">3. 会影响到哪些其他的代码？</span><br><span class="line">  bug fix - 组件 bug 修复；</span><br><span class="line">  breaking change - 不兼容的改动；</span><br><span class="line">  new feature - 新功能</span><br><span class="line"></span><br><span class="line">尾注(Footer) 用于关闭 Issue 或存在不兼容时添加相关说明等</span><br><span class="line">1. breaking change: 与上一个版本不兼容的相关描述、理由及迁移办法</span><br><span class="line">2. close #issue: 关闭相关问题（附链接）</span><br><span class="line">3. revert: 撤销以前的commit</span><br></pre></td></tr></table></figure><p>比如我们修改了一个列表Bug：<code>git commit -m &quot;bug: change id columns&quot;</code>，这样我们后面查询起来就很简单了。</p><h2 id="2、提交信息规范配置：commitlint"><a href="#2、提交信息规范配置：commitlint" class="headerlink" title="2、提交信息规范配置：commitlint"></a>2、提交信息规范配置：commitlint</h2><p>安装commitlint-cli和commitlint常用配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd font-demo</span><br><span class="line"></span><br><span class="line">yarn add @commitlint/cli @commitlint/config-conventional -D</span><br><span class="line"></span><br><span class="line">touch .commitlint.config.js</span><br></pre></td></tr></table></figure><p>.commitlint.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;commitlint&quot;: &#123;</span><br><span class="line">    extends: [</span><br><span class="line">      &apos;@commitlint/config-conventional&apos;</span><br><span class="line">    ],</span><br><span class="line">    rules: &#123;</span><br><span class="line">      &apos;type-enum&apos;: [2, &apos;always&apos;, [</span><br><span class="line">        &apos;feat&apos;, &apos;fix&apos;, &apos;perf&apos;, &apos;refactor&apos;, &apos;build&apos;, &apos;style&apos;, &apos;docs&apos;, &apos;chore&apos;</span><br><span class="line">      ]],</span><br><span class="line">      &apos;type-case&apos;: [0]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@commitlint/config-conventional</code>默认使用这个提交规范</p><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;this is a new feature&quot; | commitlint</span><br><span class="line">echo &quot;feat: this is a new feature&quot; | commitlint</span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-e32cb82dc6482ac7307dc6f1e1ec7894_r.jpg" alt></p><p>commitlint用来检测Git提交信息是否规范。</p><h2 id="3、通过插件来规范提交信息"><a href="#3、通过插件来规范提交信息" class="headerlink" title="3、通过插件来规范提交信息"></a>3、通过插件来规范提交信息</h2><p><strong>虽然我们按照格式提交没有问题，但是很多时候，可能记不住这些命令，我们可以弹出提示信息进行交互式提交</strong></p><p>安装依赖<code>@commitlint/cz-commitlint</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @commitlint/cz-commitlint commitizen @commitlint/cli @commitlint/config-conventional</span><br></pre></td></tr></table></figure><p>在package.json中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;commit&quot;: &quot;git add . &amp;&amp; git-cz&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;commitizen&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;@commitlint/cz-commitlint&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目根目录下新建文件<code>[commitlint.config.js](https://link.zhihu.com/?target=https%3A//github.com/richLpf/auto-format-demo/blob/main/commitlint.config.js)</code></p><p>修改业务代码，并执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn commit</span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-0917abb993006cae52e11c90d05913b0_r.jpg" alt></p><p>就可以通过选择来提交代码了。</p><h2 id="4、一键执行自动化工具"><a href="#4、一键执行自动化工具" class="headerlink" title="4、一键执行自动化工具"></a>4、一键执行自动化工具</h2><p>以上<code>prettier</code>、<code>esliint</code>、<code>lint-staged</code>、<code>commitlint</code>都配置在package.json中，通过命令<code>yarn commit</code>按顺序执行这些工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;prettier&quot;: &quot;prettier -w .&quot;,</span><br><span class="line">    &quot;commit&quot;: &quot;git add . &amp;&amp; lint-staged &amp;&amp; git-cz&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prettier&quot;: &quot;@isayme/prettier-config&quot;,</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;commitizen&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;@commitlint/cz-commitlint&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslintConfig&quot;: &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;browser&quot;: true,</span><br><span class="line">      &quot;node&quot;: true,</span><br><span class="line">      &quot;es2021&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: &quot;eslint:recommended&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">    &quot;*.js&quot;: [</span><br><span class="line">      &quot;eslint . --fix&quot;,</span><br><span class="line">      &quot;prettier -w .&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>配置完成后，修改业务代码，执行<code>yarn commit</code>，发现对Git暂存区的文件依次进行了<code>ESLint检测</code>、<code>prettier</code>、<code>commitlint录入</code>，这就完成了简单的自动化工作流。</p><p>然而这种方法把git的命令覆盖了，而且可能很多人不想要每次都通过提示提交信息，那么下面我们接着看，如何通过Hooks处理自动化工作流。</p><h2 id="七、Git-Hooks"><a href="#七、Git-Hooks" class="headerlink" title="七、Git Hooks"></a>七、Git Hooks</h2><h2 id="1、Git-Hooks介绍"><a href="#1、Git-Hooks介绍" class="headerlink" title="1、Git Hooks介绍"></a>1、Git Hooks介绍</h2><p>要自动化上面的流程，就要用到Git的钩子函数Hooks。</p><p>Git Hooks通过一个个钩子，允许Git在每个节点执行一些shell脚本，如果哪个阶段有问题，就会抛出错误，拒绝提交代码。</p><p>常见的Git 钩子：</p><p><strong>客户端钩子</strong>：</p><ul><li><code>pre-commit</code>，输入git commit调出提交信息编辑器之前，主要用来代码格式，代码检测、单元测试等。</li><li><code>prepare-commit-msg</code> git commit编辑器启动提交信息之前，默认信息被创建之后，主要编辑提交信息</li><li><code>commit-msg</code> git commit 信息提交，用来检查提交信息的格式。</li><li><code>post-commit</code> 在提交完成后，可以用来发送通知，提醒其他同事等。</li></ul><p><strong>服务器端钩子</strong>：</p><ul><li><code>pre-receive</code>：客户端推送代码到服务器时，只会触发一次</li><li><code>update</code>：客户端推送代码到服务器，如果多个分支，分别触发一次</li><li><code>post-receive</code>：推送完成后。</li></ul><p>整个钩子触发的时间点可以理解为：在网站上打开一个弹框输入信息，提交信息，关闭弹框的过程</p><ul><li>1、点击新建按钮，弹框弹出前（pre-commit）</li><li>2、弹框获取初始模版信息后（prepare-commit-msg）</li><li>3、编辑信息以后，点击提交时（commit-msg），这时可以对提交的信息进行检测</li><li>4、点击保存信息完成（post-commit）</li></ul><h2 id="2、Git-Hooks实践"><a href="#2、Git-Hooks实践" class="headerlink" title="2、Git Hooks实践"></a>2、Git Hooks实践</h2><p>安装Git(默认本地安装了Git)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd front-demo</span><br><span class="line">git init</span><br><span class="line">ls -al</span><br><span class="line">cd .git</span><br><span class="line">cd hooks</span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-7670b8f0850038d1375abfbcb08f96c0_r.jpg" alt></p><p>Git Hooks每个钩子都有示例文件，这些是git预置的hooks脚本示例，因为加了sample后缀，所以并不会被执行。</p><p>我们在当前目录下新建<code>pre-commit</code>脚本，文件内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">echo &quot;this is a test file&quot;</span><br></pre></td></tr></table></figure><p>回到项目根目录下，修改项目内任意文件，提交代码，发现成功提交，但是有告警。</p><p><img src="https://pic4.zhimg.com/v2-52982af26f0a01c2d68ff4a94689f2df_r.jpg" alt></p><p>因为<code>pre-commit</code>没有执行权限，我们给文件执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x pre-commit</span><br></pre></td></tr></table></figure><p>然后再次提交代码，发现git commit后，打印出了<code>this is a test file</code>，我们写在<code>.git/hooks/pre-commit</code>中的代码，这就说明Git Hooks触发了。</p><h2 id="3、Husky实践"><a href="#3、Husky实践" class="headerlink" title="3、Husky实践"></a>3、Husky实践</h2><p>Hooks需要更改.git下的配置，非常不方便，所以有了Husky，将Hooks暴露在项目中。</p><blockquote><p>安装Git Hooks，husky v4版本可以在package.json中配置，v5版本后，husky就独立在项目根目录下配置，这里使用的是<code>7.0.4</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装husky</span><br><span class="line">yarn add husky -D</span><br><span class="line"></span><br><span class="line"># 激活husky的使用</span><br><span class="line">yarn husky install</span><br></pre></td></tr></table></figure><p>4.x.x版本在package.json中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">   &quot;hooks&quot;: &#123;</span><br><span class="line">      &quot;pre-commit&quot;: &quot;lint-staged&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.x.x版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 添加一个钩子脚本，检测Git提交信息规范</span><br><span class="line">yarn husky add .husky/commit-msg &apos;yarn commitlint --edit $1&apos;</span><br></pre></td></tr></table></figure><p>我们看到在项目根目录下，生成了.husky文件夹，下面有Hooks相关的脚本。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;264&#39; height=&#39;310&#39;&gt;&lt;/svg" alt></p><p><strong>这里不光可以使用shell脚本，用node、python脚本都可以。</strong></p><p>提交代码，发现如果没有按标准格式，就会被拦截。</p><p><img src="https://pic3.zhimg.com/v2-141a6e22bc6fb8a1606cdff79a9ae18a_r.jpg" alt></p><h2 id="4、通过Husky自动化规范"><a href="#4、通过Husky自动化规范" class="headerlink" title="4、通过Husky自动化规范"></a>4、通过Husky自动化规范</h2><p><code>pre-commit</code>钩子：prettier和eslint检测代码格式和代码质量</p><p><code>commit-msg</code>钩子：执行commitlint，检测提交信息是否符合格式</p><p>首先安装这两个钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn husky add .husky/pre-commit &apos;yarn lint-staged --allow-empty&apos;</span><br><span class="line">yarn husky add .husky/commit-msg &apos;yarn commitlint --edit $1&apos;</span><br></pre></td></tr></table></figure><p>这里lint-staged 添加允许空提交是为了避免报错<a href="https://link.zhihu.com/?target=https%3A//github.com/okonet/lint-staged/issues/588" rel="external nofollow noopener noreferrer" target="_blank">lint-staged issues</a></p><p><img src="https://pic4.zhimg.com/v2-163ae034454e81601e2c9cd256c629a7_r.jpg" alt></p><p>然后改动代码src/index.js</p><p><img src="https://pic4.zhimg.com/v2-17027c2a3b56f5c9600ff4900c651ebb_r.jpg" alt></p><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;test&quot;</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/v2-81da88c8b29f34f429cc7f69af985739_r.jpg" alt></p><p>发现检测出了不符合eslint规范的编码。</p><p><img src="https://pic4.zhimg.com/v2-5ff314138f71a3fb5454833514f70683_r.jpg" alt></p><p>修复eslint错误，再次提交，发现报错提交信息不规范，但代码已经格式化过了。</p><p><img src="https://pic3.zhimg.com/v2-7068b73ac7133c9a9631f0b57dbb419a_r.jpg" alt></p><p>修改提交信息，Ok大功告成，成功提交。</p><p><img src="https://pic1.zhimg.com/v2-2f55e05d895bd2b164fccc71e4216aa0_r.jpg" alt></p><h2 id="八、通过CI自动化检测代码"><a href="#八、通过CI自动化检测代码" class="headerlink" title="八、通过CI自动化检测代码"></a>八、通过CI自动化检测代码</h2><p>之前介绍的是，本地提交代码的自动化检测。</p><p>那么并不是每个开发都会去注意这一块，针对提交上线的代码，除了服务器端钩子来检测，还可以通过CI/CD来检测。这块的工具也很多，常用的有：Gitlab/CI、Github/Action。</p><p>这里我们选择Github/Action</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd front-demo</span><br><span class="line">mkdir -p .github/workflows</span><br><span class="line">touch github-action.yml</span><br></pre></td></tr></table></figure><p><code>github-action.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">name: GitHub Actions Demo</span><br><span class="line">on: [push]</span><br><span class="line">jobs:</span><br><span class="line">  eslint:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v2</span><br><span class="line">      - uses: actions/setup-node@v2</span><br><span class="line">      - run: yarn install</span><br><span class="line">      - run: yarn eslint . --fix</span><br><span class="line">      </span><br><span class="line">  prettier:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v2</span><br><span class="line">      - uses: actions/setup-node@v2</span><br><span class="line">      - run: echo &quot;check current commit is prettier&quot;</span><br><span class="line">      - run: yarn install</span><br><span class="line">      - run: yarn prettier:check</span><br></pre></td></tr></table></figure><p>每次推送都执行下面两个任务</p><ul><li>执行eslint校验</li><li>执行prettier检查</li></ul><p>修改front-demo项目下的<code>package.json</code>，运行命令检查是否Prettier格式化</p><p><img src="https://pic1.zhimg.com/v2-0b877391a97c36e7caf06e493f68dee8_r.jpg" alt></p><p>直接提交代码，推送Github，打开<a href="https://link.zhihu.com/?target=https%3A//github.com/richLpf/auto-format-demo/actions/runs/1979731289" rel="external nofollow noopener noreferrer" target="_blank">Action页面</a></p><p><img src="https://pic4.zhimg.com/v2-289867bdddd3baff8daded17d1e9ee83_r.jpg" alt></p><p>两个任务执行成功</p><p>接着注释掉本地钩子执行的 eslint和prettier，修改代码提交到远程仓库（故意打乱）</p><p><img src="https://pic4.zhimg.com/v2-20392b8d0a03fa7ca678459878eec6eb_r.jpg" alt></p><p>打开Action页面，发现任务都失败了，并且提示除了错误信息。</p><p><img src="https://pic3.zhimg.com/v2-7a2798a19fb02131e0642387c80be2b6_r.jpg" alt></p><p>如果任务执行成功，就可以继续执行构建，部署，打包文件检测等。</p><p>当然也可以在这个阶段，增加单元测试，代码分析等操作。</p><h2 id="九、参考文章"><a href="#九、参考文章" class="headerlink" title="九、参考文章"></a>九、参考文章</h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//www.prettier.cn/docs/index.html" rel="external nofollow noopener noreferrer" target="_blank">Prettier</a></li><li><a href="https://link.zhihu.com/?target=https%3A//cn.eslint.org/docs/user-guide/getting-started" rel="external nofollow noopener noreferrer" target="_blank">ESLint</a></li><li><a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/lint-staged" rel="external nofollow noopener noreferrer" target="_blank">lint-staged</a></li><li><a href="https://link.zhihu.com/?target=https%3A//commitlint.js.org/%23/" rel="external nofollow noopener noreferrer" target="_blank">commitlint</a></li><li><a href="https://link.zhihu.com/?target=https%3A//typicode.github.io/husky/%23/%3Fid%3Dusage" rel="external nofollow noopener noreferrer" target="_blank">Husky</a></li><li><a href="https://link.zhihu.com/?target=https%3A//docs.github.com/cn/actions/quickstart" rel="external nofollow noopener noreferrer" target="_blank">Github/Action</a></li></ul><p>欢迎加入讨论，如果觉得还不错，给个赞吧</p><p>本文转自 <a href="https://zhuanlan.zhihu.com/p/487898449" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/487898449</a>，如有侵权，请联系删除。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前端代码规范工具&quot;&gt;&lt;a href=&quot;#一、前端代码规范工具&quot; class=&quot;headerlink&quot; title=&quot;一、前端代码规范工具&quot;&gt;&lt;/a&gt;一、前端代码规范工具&lt;/h2&gt;&lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;代码规范和质量是编码中很重要的一部分，目前有很多工具可以帮助我们处理。&lt;/p&gt;
&lt;p&gt;在使用这些工具的过程中发现，存在一下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能重复&lt;/li&gt;
&lt;li&gt;不同工具，相同配置冲突&lt;/li&gt;
&lt;li&gt;版本迭代导致配置变更&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工具相互组合，使用困难&lt;/p&gt;
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>git中版本回退的各种方式</title>
    <link href="https://water.buging.cn/2022/12/30/git%E4%B8%AD%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://water.buging.cn/2022/12/30/git中版本回退的各种方式/</id>
    <published>2022-12-30T10:57:42.000Z</published>
    <updated>2023-08-01T06:26:37.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>git</code>作为一款版本控制工具，其最核心的功能就是版本回退，没有之一。熟悉<code>git</code>版本回退的操作能够让你真真正正地放开手脚去开发，不用小心翼翼，怕一不小心删除了不该删除的文件。本节除了介绍版本回退的内容之外，还会介绍<code>stash</code>的使用。<a id="more"></a></p><h2 id="一、版本回退"><a href="#一、版本回退" class="headerlink" title="一、版本回退"></a>一、版本回退</h2><p>在<code>git</code>中永远有后悔药可吃，总是可以回到<strong>版本库</strong>的某一个时刻，这就叫做<strong>版本回退</strong>；</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301100124.image" alt="image-20200406144058526"></p><p>如上图所示：当前<code>master</code>分支指针指向<code>D</code>，通过版本回退可以使<code>master</code>指向<code>C</code>、<code>B</code>或<code>A</code>。进行版本回退的命令大体上有三种：<code>reset</code>、<code>revert</code>和<code>checkout</code>。下面就来一一讲解：</p><h3 id="Ⅰ-git-reset"><a href="#Ⅰ-git-reset" class="headerlink" title="Ⅰ.git reset"></a>Ⅰ.<code>git reset</code></h3><h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h4><p><code>reset</code>命令可以添加很多参数，常用的有<code>--mixed</code>、<code>--soft</code>和<code>--hard</code>三种。下图为一次完整提交的四个阶段：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301100185.image" alt="image-20200412192613526"></p><p>三个参数大体上的区别为：</p><ul><li><code>--mixed</code>：为默认值，等同于<code>git reset</code>。作用为：将文件回退到<strong>工作区</strong>，此时会保留<strong>工作区</strong>中的文件，但会丢弃<strong>暂存区</strong>中的文件；</li><li><code>--soft</code>：作用为：将文件回退到<strong>暂存区</strong>，此时会保留<strong>工作区</strong>和<strong>暂存区</strong>中的文件；</li><li><code>--hard</code>：作用为：将文件回退到<strong>修改前</strong>，此时会丢弃<strong>工作区</strong>和<strong>暂存区</strong>中的文件；</li></ul><p>下面就来详细地讲解它们的使用方法：</p><p>首先在<code>master</code>分支进行四次提交，每次提交在<code>test.txt</code>中添加一行文本信息：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301100462.image" alt="image-20200406164503683"></p><h5 id="mixed"><a href="#mixed" class="headerlink" title="--mixed"></a><code>--mixed</code></h5><p>该参数为默认值，作用为：将文件回退到工作区中：如下图所示，将<code>test.txt</code>文件回退一次提交：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301100251.image" alt="image-20200412194811197"></p><p>可以看到第四次提交对<code>test.txt</code>的修改操作被回退到了工作区当中，并且保留了工作区中第四次提交对<code>test.txt</code>所做的修改，所以工作区中的<code>test.txt</code>文件内容与回退前一致。</p><h5 id="soft"><a href="#soft" class="headerlink" title="--soft"></a><code>--soft</code></h5><p>该参数的作用为：将文件回退到暂存区中：如下图所示，将<code>test.txt</code>文件回退一次提交：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301100965.image" alt="image-20200412195321082"></p><p>可以看到第四次提交对<code>test.txt</code>的修改操作被回退到了暂存区当中，并且保留了工作区和暂存区中第四次提交对<code>test.txt</code>所做的修改，所以，工作区中的文件内容与回退前一致。</p><h5 id="hard"><a href="#hard" class="headerlink" title="--hard"></a><code>--hard</code></h5><p>该参数的作用为：将文件回退到修改前：如下图所示，将<code>test.txt</code>文件回退一次提交：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101322.image" alt="image-20200412205112201"></p><p>可以看到<code>test.txt</code>直接回到了进行第四次提交前，此时删除了工作区和暂存区中第四次提交对<code>test.txt</code>所做的修改。所以，工作区变得干净了，<code>test.txt</code>文件内容回退到刚完成第三次提交时。</p><h4 id="2-写法"><a href="#2-写法" class="headerlink" title="2.写法"></a>2.写法</h4><p>为了方便演示<code>reset</code>的各种使用方法，下面的指令都采用<code>--hard</code>参数。</p><h5 id="git-reset-hard-HEAD"><a href="#git-reset-hard-HEAD" class="headerlink" title="git reset --hard HEAD^"></a><code>git reset --hard HEAD^</code></h5><p><strong>该命令的作用为回退一次提交：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101863.image" alt="image-20200406164628192"></p><p>回退后的状态为：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101780.image" alt="image-20200406164713774"></p><p>可以看到，该方法会同时改变了<code>HEAD</code>和<code>master</code>指针的指向；</p><h5 id="git-reset-hard-HEAD-1"><a href="#git-reset-hard-HEAD-1" class="headerlink" title="git reset --hard HEAD^^"></a><code>git reset --hard HEAD^^</code></h5><p><strong>该命令的作用为回退两次提交：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101325.image" alt="image-20200406170323254"></p><p>回退后的状态为：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101015.image" alt="image-20200406170352024"></p><p>同样，使用<code>--hard</code>参数回退，工作区是干净的；可以看到，该方法也会同时改变<code>HEAD</code>和<code>master</code>指针的指向；</p><h5 id="git-reset-hard-HEAD-n"><a href="#git-reset-hard-HEAD-n" class="headerlink" title="git reset --hard HEAD~n"></a><code>git reset --hard HEAD~n</code></h5><p><strong>该命令的作用为回退<code>n</code>次提交：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301101546.image" alt="image-20200406203027868"></p><p>可以看到使用了<code>--hard</code>参数，回退结果符合预期，并且该方法也会同步修改<code>HEAD</code>和分支<code>master</code>指针的指向。</p><p><strong>注意：该方式只能向前回退，不能向后回退</strong>。</p><blockquote><p>上述命令中的<code>HEAD</code>可以更换为分支名，比如<code>master</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git reset --hard master~n</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>该命令表示将<code>master</code>分支回退<code>n</code>次提交。由于<code>HEAD</code>始终指向当前分支，所以使用分支名和使用<code>HEAD</code>效果是一样的。</p></blockquote><h5 id="git-reset-hard-commit-id"><a href="#git-reset-hard-commit-id" class="headerlink" title="git reset --hard commit_id"></a><code>git reset --hard commit_id</code></h5><p>**该指令的作用为回退到指定的<code>commit id</code>的提交版本；<strong>由于<code>commit id</code>是不会重复的，一般只需要写前几（<code>6</code>）位就可以识别出来。通过<code>commit id</code>的回退方式</strong>既可以向前回退，也可以向后回退。**如下所示，从<code>1st commit</code>往后回退到<code>4th commit</code>，其中<code>4th commit</code>的<code>commit id = bdb373...</code>。</p><p>为了熟悉该指令，我们分两种方式进行回退：使用<code>--hard</code>参数与使用默认参数。</p><ul><li><p><strong>使用<code>--hard</code>参数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102731.image" alt="image-20200406193422130"></p><p>从图中可以看出：通过第四次提交的<code>commit_id: bdb373</code>顺利地从第一次提交向后回退到了第四次提交，并且工作区干净。该方法也同时修改了<code>HEAD</code>和分支<code>master</code>的指向，具体过程为：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102485.image" alt="image-20200414171228274"></p></li><li><p><strong>使用默认参数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102009.image" alt="image-20200406193005200"></p><p>可以看到切换回了<code>4th commit</code>，但是工作区的<code>test.txt</code>文件并没有变化；这是因为，在<code>4th -&gt; 1st</code>的过程中，需要在工作区中删除<code>test.txt</code>文件中的<code>2nd line、3rd line、4th line</code>。通过默认参数<code>--mixed</code>，将<code>4th commit</code>对文件的修改回退到了工作区当中，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102806.image" alt="image-20200406202451310"></p><p>这个过程丢弃了<strong>暂存区</strong>中对文件的删除操作，但是保留了<strong>工作区</strong>中对文件的删除操作。所以，工作区中的<code>test.txt</code>文件仍然处于删除了三行内容的状态。</p><p>此时只需要将修改操作从阶段<code>1</code>移动到修改前的阶段<code>0</code>，即可将文件恢复到修改前的状态，并清空工作区。可以采用<code>git restore test.txt</code>实现：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102098.image" alt="image-20200406202716247"></p></li></ul><h3 id="Ⅱ-git-revert"><a href="#Ⅱ-git-revert" class="headerlink" title="Ⅱ.git revert"></a>Ⅱ.<code>git revert</code></h3><p><code>revert</code>是回滚，重做的意思。不同于<code>reset</code>直接通过改变分支指向来进行版本回退，并且不产生新的提交；<code>revert</code>是通过额外创建一次提交，来取消分支上指定的某次提交的方式，来实现版本回退的。如下图所示，假如想要重做提交<code>B</code>，重做前与重做后的状态为：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102830.image" alt="image-20200413234440432"></p><p>所谓重做提交<code>B</code>，指的是在新建的提交<code>B&#39;</code>中取消提交<code>B</code>中所做的一切操作。也就是说<code>revert</code>的思想为：通过创建一个新提交来取消不要的提交。所以，提交数会增加。</p><h4 id="1-参数-1"><a href="#1-参数-1" class="headerlink" title="1.参数"></a>1.参数</h4><p><code>git</code>同样为<code>revert</code>提供了许多参数，常用的有以下三种。为了演示它们的作用，首先需要设置对应的测试环境：在<code>dev</code>分支上进行四次提交，每次提交都为<code>test.txt</code>添加一行内容：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301102855.image" alt="image-20200414000404304"></p><h5 id="e"><a href="#e" class="headerlink" title="-e"></a><code>-e</code></h5><p><code>-e</code>参数是<code>--edit</code>的缩写，为<code>revert</code>指令的默认参数，即<code>git revert -e</code>等同于<code>git revert</code>。该参数的作用为在重做过程中，新建一次提交的同时编辑提交信息。比如通过以下命令重做上述的<code>dev2</code>提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert f4a95</span><br></pre></td></tr></table></figure><p>执行该指令后会创建一次新的提交来取消提交<code>dev2</code>所做的一切操作，并且会进入<code>vim</code>编辑器，编辑新提交的提交注释：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301103107.image" alt="image-20200414115052089"></p><p>如下图所示，提交<code>dev2</code>为文件<code>test.txt</code>添加的<code>dev2</code>文本被取消了，并且<code>dev</code>分支上多了一次提交：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301103439.image" alt="image-20200414114945783"></p><h5 id="no-edit"><a href="#no-edit" class="headerlink" title="--no-edit"></a><code>--no-edit</code></h5><p>该参数的作用为不编辑由于<code>revert</code>重做，所新增提交的注释信息。如下图所示，通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert --no-edit f4a95b</span><br></pre></td></tr></table></figure><p>重做提交<code>dev2</code>的过程中，并不会进入<code>vim</code>编辑器编辑新增提交的注释信息，而是采用默认的注释信息：<code>Revert &quot;dev2&quot;</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301103973.image" alt="image-20200414114748865"></p><h5 id="n"><a href="#n" class="headerlink" title="-n"></a><code>-n</code></h5><p><code>-n</code>参数是<code>--no-commit</code>的简写形式，作用为对<code>revert</code>重做某次提交时所产生的修改，不进行提交，也就是不会新增一次提交；</p><p>如下图所示，这是<code>revert</code>指令通过新建提交<code>B&#39;</code>来取消提交<code>B</code>的过程，分为<code>0~4</code>个阶段。不添加<code>-n</code>参数时，<code>revert</code>指令会产生一次额外提交<code>B&#39;</code>，此时处于下图中的第<code>3</code>阶段。而使用<code>-n</code>参数时，虽然<code>revert</code>指令也会通过新建提交<code>B&#39;</code>来重做提交<code>B</code>。但是，此时还处于生成提交<code>B&#39;</code>的过程，还没有完全生成提交<code>B&#39;</code>，也就是处于下图中的第<code>2</code>阶段。</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301103671.image" alt="image-20200414002942670"></p><p>这种做法的好处是，允许我们干涉<code>revert</code>重做过程，手动进行提交。如下图所示，通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert -n f4a95</span><br></pre></td></tr></table></figure><p>重做提交<code>dev2</code>的过程中，手动暂停了重做过程。虽然提交<code>dev2</code>对<code>test.txt</code>所做的修改已被撤销，但是这一重做操作还未进行提交：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301103050.image" alt="image-20200414120436217"></p><p>这样我们既可以修改重做过程中不满意的地方，也可以随意添加注释。修改完后，通过手动提交的方式，完成重做（<code>REVERTING</code>）操作：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301104376.image" alt="image-20200414121147251"></p><h4 id="2-写法-1"><a href="#2-写法-1" class="headerlink" title="2.写法"></a>2.写法</h4><p><code>revert</code>指令也有多种写法，下面介绍主要的几种。为了方便演示，下列指令都采用默认参数<code>-e</code>手动编辑每次新增提交的注释信息。</p><h5 id="git-revert-commit-id"><a href="#git-revert-commit-id" class="headerlink" title="git revert commit_id"></a><code>git revert commit_id</code></h5><p>这是最常用的写法，通过<code>commit_id</code>精准地选择想要重做的提交。分两种情况：</p><ul><li><p>**情况一：**重做最新一次提交，不会发生冲突。</p><p>例如：通过以下指令，重做<code>dev</code>分支上最新的一次提交<code>dev2</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert f4a95b</span><br></pre></td></tr></table></figure></li></ul><pre><code>首先进入`vim`编辑器编辑新增提交的注释信息：![image-20200414135326937](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301104770.image)随后完成重做操作，如下图所示；可见提交`dev2`给`test.txt`添加的`dev2`内容被删除了，并且多出一次提交，说明重做成功：![image-20200414140040443](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301104069.image)</code></pre><ul><li><p>**情况二：**重做非最新一次提交，会发生冲突。</p><p>例如：通过以下指令，重做<code>dev</code>分支上的第三次提交<code>dev1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert dbde45</span><br></pre></td></tr></table></figure></li></ul><pre><code>会出现合并冲突：![image-20200414140502098](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301104296.image)使用`git mergetool`指令，通过`vim`编辑器的工具`vimdiff`显示冲突文件`test.txt`：![image-20200414140645448](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301104090.image)回车进入`vim`编辑器界面，解决冲突：![image-20200414141354304](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105846.image)解决冲突之后，手动进行一次提交，完成`revert`过程：![image-20200414142323103](https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105788.image)</code></pre><ul><li><p><strong>为什么会出现冲突？</strong></p><p>通过上面的例子不难看出，<code>revert</code>操作生成的<strong>新提交其实是通过两次提交合并而成</strong>的。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105796.image" alt="image-20200414143430837"></p><ul><li>首先，将被重做的提交<code>dev1</code>的前一次提交<code>2nd</code>复制一份，即图中的<code>2nd&#39;</code>；</li><li>然后，将它与当前分支的最新提交<code>dev2</code>进行合并，由此生成<code>revert</code>操作新增的提交；</li></ul><p>知道了<code>revert</code>操作新增的提交的由来后，就不难解释为什么会出现合并冲突了，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105276.image" alt="image-20200414144109389"></p><p>合并的两次提交中，文件<code>test.txt</code>的内容不一样。<code>git</code>不知道以哪个版本为准，自然会导致自动合并失败，需要手动合并。</p></li></ul><h5 id="git-revert-HEAD"><a href="#git-revert-HEAD" class="headerlink" title="git revert HEAD"></a><code>git revert HEAD</code></h5><p>该指令的作用为重做所在分支的最新一次提交，并且不会发生冲突：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105655.image" alt="image-20200414150640086"></p><h5 id="git-revert-HEAD-1"><a href="#git-revert-HEAD-1" class="headerlink" title="git revert HEAD^"></a><code>git revert HEAD^</code></h5><p>该指令的作用为重做所在分支的倒数第二次提交，会发生冲突，需要手动合并，完成重做操作：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301105229.image" alt="image-20200414151002143"></p><h5 id="git-revert-HEAD-2"><a href="#git-revert-HEAD-2" class="headerlink" title="git revert HEAD^^"></a><code>git revert HEAD^^</code></h5><p>该指令的作用为重做所在分支的倒数第三次提交，会发生冲突，需要手动合并，完成重做操作：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106374.image" alt="image-20200414180953703"></p><h5 id="git-revert-HEAD-n"><a href="#git-revert-HEAD-n" class="headerlink" title="git revert HEAD~n"></a><code>git revert HEAD~n</code></h5><p>该指令的作用为重做所在分支的倒数第<code>n+1</code>次提交，会发生冲突，需要手动合并，完成重做操作。过程与上述一致，这里就不再赘述了。</p><blockquote><p>**总结：**常用<code>git revert commit_id</code>这种方式。</p></blockquote><h4 id="3-撤销revert操作"><a href="#3-撤销revert操作" class="headerlink" title="3.撤销revert操作"></a>3.撤销<code>revert</code>操作</h4><p>思路很简单，再次通过<code>revert</code>操作取消上一次的<code>revert</code>操作（即所谓”负负得正”）。</p><p>操作前，<code>dev</code>分支上的提交记录和<code>test.txt</code>文件内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106645.image" alt="image-20200414153206034"></p><p>通过：<code>git revert --no-edit f4a95</code>重做提交<code>dev2</code>（<code>--no-edit</code>表示不修改新增提交的注释）：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106538.image" alt="image-20200414153456451"></p><p>重做后，多了一次提交，并且<code>test.txt</code>文件中删除了<code>dev2</code>这一行内容。此时，可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert --no-edit 582d127</span><br></pre></td></tr></table></figure><p>重做上一次重做操作，以此达到取消上一次重做操作的目的：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106590.image" alt="image-20200414153724455"></p><p>如上图所示，虽然多出了一次提交，但是<code>test.txt</code>文件中被删除的<code>dev2</code>内容被恢复了，这样就撤销了<code>revert</code>操作。</p><h3 id="Ⅲ-git-checkout"><a href="#Ⅲ-git-checkout" class="headerlink" title="Ⅲ.git checkout"></a>Ⅲ.<code>git checkout</code></h3><h4 id="1-git-checkout-commit-id"><a href="#1-git-checkout-commit-id" class="headerlink" title="1.git checkout commit_id"></a>1.<code>git checkout commit_id</code></h4><p>使用<code>checkout</code>可以进行版本回退，如直接使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout cb214</span><br></pre></td></tr></table></figure><p>回退到提交<code>3rd</code>，此时会出现如下提示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106736.image" alt="image-20200311111540863"></p><p>注意到，切换后<code>HEAD</code>指向的不再是<code>master</code>分支，而是<code>cb214...</code>即第三次提交，查看历史提交记录：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106205.image" alt="image-20200311111719389"></p><p>可看到只有<code>3</code>次提交，什么意思呢？如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301106569.image" alt="image-20200412001646768"></p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107947.image" alt="image-20200311112656834"></p><p>通过<code>git checkout</code>让<code>HEAD</code>指针指向了第<code>3</code>次提交，可以将它想象为一个新的分支。但是却没有实际创建分支，即此时<code>head</code>指向的由提交<code>1~3</code>组成的<code>commit</code>对象链条处于游离状态；</p><p>接着，在<code>HEAD</code>还指向游离的提交节点<code>3</code>的基础上对文件做出新的修改：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107564.image" alt="image-20200311113237150"></p><ul><li>此时如果我们切换回<code>master</code>分支，会出现下列错误</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107178.image" alt="image-20200311113209483"></p><p>提示显示：如果没有保存就从游离的提交上切换到<code>master</code>分支，这一修改就会被<code>checkout</code>命令覆盖。我们可以在切换前进行一次提交操作：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107915.image" alt="image-20200311113625297"></p><p>此时的状态为：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107738.image" alt="image-20200412002213790"></p><ul><li>在游离的<code>Commit</code>对象链中进行了一次提交之后，再次通过：<code>git checkout master</code>切换到<code>master</code>分支：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301107243.image" alt="image-20200311114055018"></p><p>提示大意为：如果没有任何分支指向刚才在游离的<code>Commit</code>对象链中进行的提交，那么该提交就会被忽略。此时的状态如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108718.image" alt="image-20200412002655921"></p><p>如果想要创建一个分支保存（指向）这条游离的<code>Commit</code>对象链，现在就是很好的时机。根据上述提示的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch mycommit  c4d5cc3</span><br></pre></td></tr></table></figure><p>创建指向<code>commit_id</code>为<code>c4d5cc3</code>的提交（即上述的提交节点<code>5</code>）的分支<code>mycommit</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108392.image" alt="image-20200311115117279"></p><p>由此游离的<code>commit</code>对象链得以被新分支所指向，并得到了保存，此时的状态如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108526.image" alt="image-20200412004042471"></p><blockquote><p><strong>总结：</strong></p><ul><li>通过<code>checkout</code>进行版本回退会造成游离的提交对象链，需要额外创建一个分支进行保存；</li><li>因此，使用<code>checkout</code>进行版本回退的思路为，先切换到想要回退的提交版本，再删除进行版本回退的分支<code>dev</code>。最后，创建一个新的<code>dev</code>分支指向游离的提交对象链，完成分支<code>dev</code>的版本回退，简称”偷天换日”；</li><li>只要有分支指向，提交就不会被丢弃。</li></ul></blockquote><h3 id="Ⅳ-revert与reset的选择"><a href="#Ⅳ-revert与reset的选择" class="headerlink" title="Ⅳ.revert与reset的选择"></a>Ⅳ.<code>revert</code>与<code>reset</code>的选择</h3><p>由于<code>checkout</code>会造成游离的提交对象链，所以，一般不使用<code>checkout</code>而是使用<code>reset</code>和<code>revert</code>进行版本回退：</p><ul><li><code>revert</code>通过创建一个新提交的方式来撤销某次操作，该操作之前和之后的提交记录都会被保留，并且会将该撤销操作作为最新的提交；</li><li><code>reset</code>是通过改变<code>HEAD</code>和分支指针指向的方式，进行版本回退，该操作之后的提交记录不会被保留，并且不会创建新的提交；</li></ul><p>在个人开发上，建议使用<code>reset</code>；但是在团队开发中建议使用<code>revert</code>，特别是公共的分支（比如<code>master</code>)，这样能够完整保留提交历史，方便回溯。</p><h3 id="Ⅴ-回退方法汇总"><a href="#Ⅴ-回退方法汇总" class="headerlink" title="Ⅴ.回退方法汇总"></a>Ⅴ.回退方法汇总</h3><p>版本回退主要有<strong>三大方式</strong>：<code>reset</code>、<code>revert</code>和<code>checkout</code>，各方式的比较如下：</p><table><thead><tr><th>方法</th><th>效果</th><th>向前回退</th><th>向后回退</th><th>同步修改<code>HEAD</code>与分支指向</th></tr></thead><tbody><tr><td><code>git reset --hard HEAD^</code></td><td>往前回退<code>1</code>次提交</td><td>能</td><td>否</td><td>是</td></tr><tr><td><code>git reset --hard HEAD^^</code></td><td>往前回退<code>2</code>次提交</td><td>能</td><td>否</td><td>是</td></tr><tr><td><code>git reset --hard HEAD~n</code></td><td>往前回退<code>n</code>次提交</td><td>能</td><td>否</td><td>是</td></tr><tr><td><code>git reset --hard &lt;commit_id&gt;</code></td><td>回退到指定<code>commit id</code>的提交</td><td>能</td><td>能</td><td>是</td></tr><tr><td><code>git revert HEAD</code></td><td>重做最新一次提交</td><td>能</td><td>否</td><td>是</td></tr><tr><td><code>git revert HEAD^</code></td><td>重做倒数第二次提交</td><td>能</td><td>否</td><td>是</td></tr><tr><td><code>git revert HEAD^^</code></td><td>重做倒数第三次提交</td><td>能</td><td>否</td><td>是</td></tr><tr><td><code>git revert HEAD~n</code></td><td>重做倒数第<code>n+1</code>次提交</td><td>能</td><td>否</td><td>是</td></tr><tr><td><code>git revert commit_id</code></td><td>重做指定<code>commit_id</code>的提交</td><td>能</td><td>能</td><td>是</td></tr><tr><td><code>git checkout commit_id</code></td><td>回退到指定<code>commit id</code>的提交</td><td>能</td><td>能</td><td>否</td></tr></tbody></table><p>从上表可知，只有下列三种方式可以自由地向前向后回退：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br><span class="line">git revert commit_id</span><br><span class="line">git checkout commit_id</span><br></pre></td></tr></table></figure><p>但是，使用<code>checkout</code>进行回退会出现游离的提交，需要创建一个新分支进行保存，所以不常用。</p><h2 id="二、git-stash"><a href="#二、git-stash" class="headerlink" title="二、git stash"></a>二、<code>git stash</code></h2><h4 id="1-git-stash的作用"><a href="#1-git-stash的作用" class="headerlink" title="1.git stash的作用"></a>1.<code>git stash</code>的作用</h4><p><code>git stash</code>指令的作用为：对没有提交到版本库的，位于工作区或暂存区中游离的修改进行保存，在需要时可进行恢复。具体应用场景如下：</p><p>在<code>master</code>分支进行两次提交：<code>1st</code>和<code>2nd</code>，随后创建并切换到<code>dev</code>分支。在<code>dev</code>分支上进行一次提交（<code>dev1</code>），此时两分支的状态为：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108081.image" alt="image-20200412235844426"></p><p>随后在<code>dev</code>分支上给文件<code>test.txt</code>添加一行<code>dev2</code>，但是不提交到暂存区，直接切换到<code>master</code>分支，会出现如下错误：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108229.image" alt="image-20200413001632846"></p><p>图中显示的错误大意为：在<code>dev</code>分支上的修改会被<code>checkout</code>操作覆盖。下面我们来看看，将<code>dev</code>分支上的这一修改操作添加到暂存区后，再切换分支，是否还会出现同样的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301108839.image" alt="image-20200413001752227"></p><p>可见还是会出现该错误，这初步验证了位于工作区和暂存区中的修改都会被<code>checkout</code>操作覆盖的结论。原因如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109688.image" alt="image-20200413001917190"></p><p>虽然在<code>dev</code>分支上修改了文件，但是没有将这一修改操作进行提交。这样就不会产生提交节点，就如上图所示，修改<code>dev2</code>是游离的，在切换分支的时候会被丢弃。</p><p>这种情况在日常开发中很常见，当在<code>develop</code>分支上开发新功能的时候，<code>master</code>分支出现紧急情况需要切换回去进行修复。但是，当前分支的新功能还没开发完全，贸然切换分支，原来开发的内容就会因被覆盖而丢失，怎么办呢？</p><p>有人可能会说进行一次<code>commit</code>不就可以了吗？确实可以。但是，这样不符合提交的代码就是正确代码的原则。更好的解决方法为使用<code>git stash</code>，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109677.image" alt="image-20200413002115302"></p><p>可见<code>git stash</code>可以将当前<code>dev</code>分支上，位于在工作区或暂存区中的修改，在未提交的情况下进行了保存；并且将分支回退到修改前的状态，保存过后，就可以很顺畅地切换回<code>master</code>分支了。</p><blockquote><p>图中的<code>WIP</code>（<code>working in progress</code>）表示的是正在进行的工作；</p></blockquote><p>当我们在<code>master</code>分支上完成了工作，再次切换回<code>dev</code>分支时，查看<code>test.txt</code>文件：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109078.image" alt="image-20200413002256321"></p><p>发现切换分支前所做的修改<code>dev2</code>消失了，这是为什么呢？</p><ul><li><p>其实，上面通过<code>git stash</code>将<code>dev</code>分支上工作区或暂存区中的修改，提交到了<code>stash</code>区域进行保存，并将<code>dev</code>分支回退到修改前的状态。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109676.image" alt="image-20200413003349365"></p></li><li><p>切换到<code>master</code>分支时<code>test</code>分支上的修改依旧会被覆盖。所以，再次回到<code>dev</code>分支时需要从<code>stash</code>区域中恢复切换分支前保存的修改；</p></li></ul><p>怎样恢复通过<code>git stash</code>保存到<code>stash</code>中的修改呢？可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>查看该分支上被<code>stash</code>保存的修改：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109221.image" alt="image-20200413224408623"></p><p>继续给<code>test.txt</code>文件添加内容：<code>dev3</code>，并通过以下指令保存修改的同时添加注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save &apos;注释&apos;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109732.image" alt="image-20200413225024618"></p><ul><li>首先，通过上述命令可以修改<code>stash</code>中存储修改的备注信息；</li><li>其次，虽然在<code>test</code>分支上进行了两次修改，但是使用<code>git stash</code>保存修改后，文件<code>test.txt</code>并没有实际被修改；</li></ul><h4 id="2-恢复stash存储的修改"><a href="#2-恢复stash存储的修改" class="headerlink" title="2.恢复stash存储的修改"></a>2.恢复<code>stash</code>存储的修改</h4><p>方法有很多，主要有以下三种：</p><h5 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a><code>git stash pop</code></h5><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301109359.image" alt="image-20200413225140030"></p><p>如图所示，通过上述命令将<code>stash</code>中存储的最新一次修改恢复了。相信你已经发现了，<code>stash</code>与<strong>栈</strong>非常类似：先保存的修改，排在最后，序号最大；后保存的修改，排在最前，序号最小；</p><p>恢复了最新一次修改后，再次查看<code>stash</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110445.image" alt="image-20200413225221071"></p><p>可以看到存储的修改只剩下一条了，由此可推断出<code>git stash pop</code>作用为：</p><ul><li>**第一：**恢复<code>stash</code>中存储的最新一次修改；</li><li>**第二：**将该修改从<code>stash</code>中删除；</li></ul><h5 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a><code>git stash apply</code></h5><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110409.image" alt="image-20200413225457480"></p><p>如上图所示，使用该指令时发生了合并冲突。这是因为，<code>stash</code>中保存的每一次修改代表的都是一个版本。</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110310.image" alt="image-20200413231349820"></p><ul><li>如上图所示，在<code>test</code>分支上，进行第一次修改后，通过<code>git stash</code>将该修改作为修改<code>0</code>保存到<code>stash</code>中，此时分支中的文件并没有发生改变；</li><li>进行第二次修改后，通过<code>git stash</code>将修改作为修改<code>1</code>保存到<code>stash</code>中，分支中的文件依旧没有发生改变；此时的<code>stash</code>中相当于保存着同一分支上两个修改后的版本；</li><li>此时通过**<code>git stash pop</code><strong>取出修改<code>0</code>，与<code>test</code>分支进行合并；再通过</strong><code>git stash pop</code>**取出修改<code>1</code>，再次与<code>test</code>分支进行合并，两个版本合并自然会产生冲突。</li></ul><p>手动解决冲突后，要进行一次提交才算完成了手动合并；随后查看<code>stash</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110378.image" alt="image-20200413230750201"></p><p>修改<code>0</code>仍然存在，说明**<code>git stash apply</code>**的作用为取出<code>stash</code>中最新（前面）的修改并与分支进行合并。但是，<code>stash</code>中存储的该修改并不会被删除；</p><h5 id="git-stash-apply-stash-n"><a href="#git-stash-apply-stash-n" class="headerlink" title="git stash apply stash@{n}"></a><code>git stash apply stash@{n}</code></h5><p>这是最常用的方法，作用为从<code>stash</code>中恢复特定的修改，并且不删除<code>stash</code>中的该修改。</p><p>将<code>test.txt</code>的两次修改通过<code>git stash</code>存储到<code>stash</code>中，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110739.image" alt="image-20200413232024080"></p><p>通过<code>git stash apply stash@{1}</code>恢复<code>stash</code>中存储的修改<code>1</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212301110148.image" alt="image-20200413232309330"></p><p>如上图所示，成功地恢复了<code>stash</code>中的修改<code>1</code>，并且<code>stash</code>中的修改<code>1</code>并没有被删除；</p><p><strong>总结：</strong></p><ul><li><code>git stash pop</code>：恢复并删除<code>stash</code>中存储的最新修改；</li><li><code>git stash apply</code>：恢复但不删除<code>stash</code>中存储的最新修改；</li><li><code>git stash apply stash@{0}</code>：恢复但不删除<code>stash</code>中存储的特定提交；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;git&lt;/code&gt;作为一款版本控制工具，其最核心的功能就是版本回退，没有之一。熟悉&lt;code&gt;git&lt;/code&gt;版本回退的操作能够让你真真正正地放开手脚去开发，不用小心翼翼，怕一不小心删除了不该删除的文件。本节除了介绍版本回退的内容之外，还会介绍&lt;code&gt;stash&lt;/code&gt;的使用。
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>mac上git同时关联gitlab和github</title>
    <link href="https://water.buging.cn/2022/12/29/mac%E4%B8%8Agit%E5%90%8C%E6%97%B6%E5%85%B3%E8%81%94gitlab%E5%92%8Cgithub/"/>
    <id>https://water.buging.cn/2022/12/29/mac上git同时关联gitlab和github/</id>
    <published>2022-12-29T11:31:57.000Z</published>
    <updated>2023-08-01T06:26:37.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、生成ssh密钥并配置"><a href="#一、生成ssh密钥并配置" class="headerlink" title="一、生成ssh密钥并配置"></a>一、生成ssh密钥并配置</h2><p>分别对gitlab和github生成对应的密钥（默认情况下本地生成的秘钥位于/Users/用户名/.ssh/）<a id="more"></a></p><h3 id="1-、生成gitlab密钥并配置"><a href="#1-、生成gitlab密钥并配置" class="headerlink" title="1 、生成gitlab密钥并配置"></a>1 、生成gitlab密钥并配置</h3><pre><code>打开Timinal终端，输入命令：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “公司邮箱地址”</span><br></pre></td></tr></table></figure><p>生成对应的<code>gitlab</code>密钥：id_rsa和id_rsa.pub，将gitlab公钥即id_rsa.pub（Mac下路径为/Users/用户名/.ssh/）中的内容配置到公司的gitlab上。</p><h3 id="2、生成github密钥并配置"><a href="#2、生成github密钥并配置" class="headerlink" title="2、生成github密钥并配置"></a>2、生成github密钥并配置</h3><p>在Timinal终端中输入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “github邮箱地址” -f  ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure></p><p>生成对应的github密钥：github_rsa和github_rsa.pub，将github公钥即github_rsa.pub中的内容配置到自己的github上。</p><h3 id="3、配置git，访问不同host时使用不同的密钥。"><a href="#3、配置git，访问不同host时使用不同的密钥。" class="headerlink" title="3、配置git，访问不同host时使用不同的密钥。"></a>3、配置git，访问不同host时使用不同的密钥。</h3><p>进入密钥生成的位置（/Users/用户名/.ssh/），手动创建一个config文件（注意这个config文件要无后缀）。<br>在新建的config文件里面配置如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User xxx@xxx.com       //user后边为github的邮箱</span><br><span class="line">IdentityFile ~/.ssh/github_rsa</span><br><span class="line"></span><br><span class="line">Host gitlab.xxx.cn    //host后边为公司gitlab域名</span><br><span class="line">HostName gitlab.xxx.cn   //同上为公司gitlab域名</span><br><span class="line">User xxx@xxx.com          //user后为gitlab的邮箱</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">备注：公司内网地址，设置HostName时需要注意，复制公司gitlab或者自己的github地址时，需要把”https://&quot; 去掉。</span><br></pre></td></tr></table></figure></p><h3 id="二、验证是否设置成功"><a href="#二、验证是否设置成功" class="headerlink" title="二、验证是否设置成功"></a>二、验证是否设置成功</h3><p> 打开Timinal终端，分别输入命令：<br>测试github<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>测试gitlab(@符后面的为公司gitlab地址)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitlab.xxx.com</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 全局配置</span><br><span class="line">$ git config --global user.name  &apos;gitlab账号名&apos; </span><br><span class="line">$ git config --global user.email  &apos;gitlab账号邮箱&apos;</span><br><span class="line"></span><br><span class="line">// 本地配置</span><br><span class="line">$ git config --local user.name  &apos;github账号名&apos;   </span><br><span class="line">$ git config --local user.email  &apos;github邮箱&apos;</span><br></pre></td></tr></table></figure><p>到这里，多账号的配置基本上已经完成了，但是还有一个不足的地方就是虽然私钥根据域名自动选择了，但是提交的配置还是共享 .gitconfig 中的配置，例如 user.name 和 user.email，能不能根据仓库所在的不同位置选择不同的全局配置文件呢？ 答案是可以的，打开 ~/.gitconfig 文件，在末尾添加下面的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[includeIf &quot;gitdir:~/work/gitlab/&quot;]</span><br><span class="line">    path = .gitconfig-gitlab</span><br></pre></td></tr></table></figure></p><p>然后再建一个 ~/.gitconfig-gitlab 文件，里面写全局配置，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = keliq</span><br><span class="line">    email = keliq</span><br></pre></td></tr></table></figure></p><p>那么只要仓库被放到了 ~/work/gitlab 目录下面，默认就会使用这个配置了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、生成ssh密钥并配置&quot;&gt;&lt;a href=&quot;#一、生成ssh密钥并配置&quot; class=&quot;headerlink&quot; title=&quot;一、生成ssh密钥并配置&quot;&gt;&lt;/a&gt;一、生成ssh密钥并配置&lt;/h2&gt;&lt;p&gt;分别对gitlab和github生成对应的密钥（默认情况下本地生成的秘钥位于/Users/用户名/.ssh/）
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你需要知道的git子模块</title>
    <link href="https://water.buging.cn/2022/12/21/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84git%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    <id>https://water.buging.cn/2022/12/21/你需要知道的git子模块/</id>
    <published>2022-12-21T13:21:25.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>先引用 <code>git</code> 的官方定义描述：</p><blockquote><p>A submodule is a repository embedded inside another repository. The submodule has its own history; the repository it is embedded in is called a superproject.</p></blockquote><p>子模块（<code>submodule</code>）是一个内嵌在其他 git 仓库（父工程）中的 git 仓库，子模块有自己的 git 记录。</p><p>通常，如果一个仓库存在子模块，父工程目录下的 <code>.git/modules/</code> 目录中会存在一个 <code>git</code> 目录，子模块的仓库目录会存在于父工程的仓库目录中，并且子模块的仓库目录中也会存在一个 <code>.git</code> 目录；<a id="more"></a></p><p>使用场景：</p><ul><li>想要在一个工程中使用另一个工程，但是那个工程包含了单独的提交记录，<code>submodule</code> 就可以实现在一个工程中引入另一个工程，同时保留二者的提交记录并且区分开来；目前 <code>submodule</code> 还能实现单独开发子工程，并且不会影响父工程，父工程可以在需要的时候更新子模块的版本；</li><li>想要把一个工程拆分成多个仓库并进行集中管理，这可以用来实现 <code>git</code> 当前的限制，实现更细粒度的访问，解决当仓库过于庞大时所出现的传输量大、提交记录冗杂、权限分设等问题；</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="新增子模块"><a href="#新增子模块" class="headerlink" title="新增子模块"></a>新增子模块</h3><p>向一个项目中添加子模块：</p><pre><code>git submodule add https://github.com/yyy/xxx.git</code></pre><p>之后会 <code>clone</code> 该子模块对应的远程项目文件到本地父项目目录下的同名文件夹中（<code>./xxx/</code>），父项目下也会多一个叫 <code>.gitmodules</code> 的文件，内容大致为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;xxx&quot;]</span><br><span class="line">path = xxx</span><br><span class="line">url = git@github.com:yyy/xxx.git</span><br></pre></td></tr></table></figure></p><p>如果存在多个子模块，则会继续向该文件中追加与上面相同格式的内容；</p><p>同时父项目下的 <code>.git</code> 目录中也会新增 <code>/modules/xxx/</code> 目录，里面的内容对应子模块仓库中原有的 <code>.git</code> 目录中的文件，此时虽然子模块目录下的 <code>.git</code> 依然存在，但是已经由一个文件夹变成了文件，内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitdir: ../.git/modules/xxx</span><br></pre></td></tr></table></figure></p><p>即指向了父项目的 <code>.git/modules/xxx</code> 目录；如果运行 <code>git config --list</code> 查看项目的配置，也会发现多了类似下面两行的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">submodule.xxx.url=git@github.com:yyy/xxx.git</span><br><span class="line">submodule.xxx.active=true</span><br></pre></td></tr></table></figure></p><p>如果修改 <code>submodule.xxx.url</code> 的值，则会覆盖 <code>.gitmodules</code> 文件中对应的 <code>url</code> 值；</p><h3 id="查看子模块"><a href="#查看子模块" class="headerlink" title="查看子模块"></a>查看子模块</h3><p>查看当前项目下的子模块：</p><blockquote><p><code>git submodule</code></p></blockquote><p> 或者</p><blockquote><p><code>git submodule status</code></p></blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70c316ecb7c41a5bdf8a37ff93bf866d3b903388 xxx (heads/master)</span><br></pre></td></tr></table></figure></p><p>如果将父项目推送到远程仓库（如 Github），在网页浏览该项目时子模块所在的目录会多一个类似 <strong><code>@70c316e</code></strong> 的后缀，即上面查看子模块命令输出内容的 hash 值的前面部分，点击这个目录会跳转到这个子模块对应的仓库地址（另一个 url）；</p><p>如果执行：</p><pre><code>git submodule deinit</code></pre><p>删除了子模块，则再次查看时输出会是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-70c316ecb7c41a5bdf8a37ff93bf866d3b903388 xxx</span><br></pre></td></tr></table></figure></p><h3 id="拉取子模块"><a href="#拉取子模块" class="headerlink" title="拉取子模块"></a>拉取子模块</h3><p>如果要 <code>clone</code> 一个项目，并且包含其子模块的文件，则需要给 <code>git clone</code> 命令最后加上 <code>--recurse-submodules</code> 或者 <code>--recursive</code> 参数（<strong>否则</strong>只会下载一个空的子模块文件）：</p><pre><code>git clone https://github.com/yyy/xxx.git --recursive</code></pre><p>当然，克隆时忘记了加这个参数，后续也有办法去拉取子模块的文件，首先执行：</p><pre><code>git submodule init</code></pre><p>这会初始化子模块相关配置，比如自动在 <code>config</code> 中加入下面两行内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">submodule.xxx.url=git@github.com:yyy/xxx.git</span><br><span class="line">submodule.xxx.active=true</span><br></pre></td></tr></table></figure></p><p>然后执行：</p><pre><code>git submodule update</code></pre><p>就可以拉取到子模块仓库中的文件了，也可以将这两步命令合并为一步：</p><pre><code>git submodule update --init</code></pre><p>要拉取所有层层嵌套的子模块，则执行：</p><pre><code>git submodule update --init --recursive</code></pre><p>之前 <code>clone</code> 时加参数不过是自动执行初始化配置并拉取子模块（甚至嵌套的子模块）中的文件罢了；</p><p>命令默认拉取<strong>主分支</strong>（<code>master</code>），想要修改这个默认拉取分支可以修改 <code>.gitmodules</code> 文件中子模块对应的 <code>branch</code> 值，或者执行：</p><pre><code>git config submodule.xxx.branch dev</code></pre><p>或者执行同时将配置写入文件，这样其他人拉取父项目也会获取该配置：</p><pre><code>git config -f .gitmodules submodule.xxx.branch dev</code></pre><h3 id="更新子模块"><a href="#更新子模块" class="headerlink" title="更新子模块"></a>更新子模块</h3><h4 id="拉取更新"><a href="#拉取更新" class="headerlink" title="拉取更新"></a>拉取更新</h4><p>获取子模块仓库的最新提交，同步远程分支的变更，可以直接在子模块目录下执行：</p><pre><code>git pull</code></pre><p>或者在父目录下执行：</p><pre><code>git submodule update --remote</code></pre><p>这里给 <code>git submodule update</code> 加上 <strong><code>--remote</code></strong> 是为了直接从子模块的当前分支的远程追踪分支获取最新变更，不加则是默认从父项目的 <code>SHA-1</code> 记录中获取变更；当有多个子模块时，该命令默认拉取<strong>所有</strong>子模块的变更，指定更新子模块 <code>xxx</code> 需要执行：</p><pre><code>git submodule update --remote xxx</code></pre><p>如果将修改子模块的相关变更推送到父项目的远程，其他人拉取代码时，只用 <code>git pull</code> 的话只会把子模块的相关修改拉取到父项目，具体变更并<strong>不会更新</strong>到子模块中，在父项目里执行：</p><blockquote><p><code>git diff --submodule</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Submodule xxx a6e2962..70c316e (rewind):</span><br><span class="line">  &lt; add file</span><br></pre></td></tr></table></figure><p>注意子模块提交记录中前的 <strong><code>&lt;</code></strong> 符号，表示变更未更新到子模块文件夹里，所以更新子模块变更需要执行：</p><pre><code>git submodule update --init --recursive</code></pre><p>或者直接在父项目拉取时同时更新子模块（需要子模块已经 <code>init</code>，否则仍然拉取不到文件）：</p><pre><code>git pull --recurse-submodules</code></pre><h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p>更新完子模块（<code>git submodule update</code>）后，虽然会将文件变更同步到子模块目录下，但是此时子模块并没有处于任何已有分支下，去子模块目录下检查一下分支就会发现：</p><blockquote><p><code>git branch -vv</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* (HEAD detached at 16d1b6b) 16d1b6b mod file</span><br><span class="line">  master                     16d1b6b [origin/master] mod file</span><br></pre></td></tr></table></figure><p>当前分支并不是 <code>master</code>，而是一个 <code>detached</code> 状态的编号分支，官方文档称为“游离的 HEAD”，虽然可以提交，但是并没有本地分支跟踪这些更改，意味着下次更新子模块就会<strong>丢失</strong>这些更改；</p><p>所以在子模块下开始开发前，需要先<strong>切换</strong>到某个已有分支或者创建新的分支，比如进入主分支：</p><pre><code>git checkout master</code></pre><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>除了默认的分支同步更新操作，也可以执行其他类型的分支更新行为，比如 <code>merge</code>，<code>rebase</code> 等；如将父项目中记录的子模块最新变更（分支是 <code>submodule.xxx.branch</code> 中配置的，默认主分支 <code>master</code>）<code>merge</code> 到子模块的当前分支中，则执行：</p><pre><code>git submodule update --remote --merge</code></pre><p><code>rebase</code> 到子模块当前分支则执行：</p><pre><code>git submodule update --remote --rebase</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果其他人修改了子模块的内容并提交了记录，父项目也提交并推送了远程仓库，但是子模块<strong>没有</strong>推送其对应的远程仓库，<br>那么其他人拉取父项目代码变更时没有问题，但是<strong>更新</strong>子模块时就会遇到下面的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote error: upload-pack: not our ref 16d1b6b94e3245f3a7fb4f43e5b6f44b14027fbb</span><br><span class="line">Fetched in submodule path &apos;xxx&apos;, but it did not contain 16d1b6b94e3245f3a7fb4f43e5b6f44b14027fbb.</span><br><span class="line">Direct fetching of that commit failed.</span><br></pre></td></tr></table></figure></p><p>即由于其他人没有及时将子模块的提交 <code>push</code> 的子模块的远程仓库，我们本地父项目有了关于子模块最新的变更，但是在子模块的仓库中却找不到，就报错了，让对方在子模块下 <code>push</code> 一下这边再重新更新就行了；</p><p>为了避免制造这一不必要的麻烦，可以把在父项目中推送远程的命令替换为：</p><pre><code>git push --recurse-submodules=check</code></pre><p>这样如果子模块（与父项目记录的对应分支）存在未 <code>push</code> 的提交，就会报错，并且子模块有推送失败的，父项目也会推送失败；需要在推送父项目时自动推送未推送的子模块，则执行：</p><pre><code>git push --recurse-submodules=on-demand</code></pre><p>觉得每次手输太麻烦，就直接将其写入配置：</p><pre><code>git config push.recurseSubmodules check</code></pre><p>如果父项目中子模块的仓库地址（<code>submodule.xxx.url</code>）被其他协作者修改了，那么我们再更新子模块时就可能遇到问题，需要执行：</p><pre><code>git submodule sync --recursive</code></pre><p>同步完 <code>url</code>，然后再重新初始化更新：</p><pre><code>git submodule update --int --recursive</code></pre><h3 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h3><p>在确认移除子模块前，需要先将其取消注册（<code>unregister</code>），即删除该子模块相关的配置文件（<code>git config</code>），比如要移除子模块 <code>xxx</code>，则执行：</p><pre><code>git submodule deinit xxx</code></pre><p>然后子模块的相关配置会被删除（<code>.gitmodules</code> 和 <code>.git/modules/xxx</code> 中的配置会保留），子模块对应的目录也会被清空（子模块目录本身会保留），再运行 <code>git submodule status</code> 查看子模块则会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-70c316ecb7c41a5bdf8a37ff93bf866d3b903388 xxx</span><br></pre></td></tr></table></figure></p><p>前缀 <strong><code>-</code></strong> 表示该子模块已经被取消注册，可理解为暂时移除，想必官方这样做也是给我们提供反悔的余地，因为想要<strong>恢复</strong>刚才删除的子模块，重新执行 <code>git submodule update --init xxx</code> 就能重新初始子模块并拉取文件；</p><p>由于还有一些配置文件仍然被保留，所以想要<strong>彻底删除</strong>的话，需要继续手动删除这里配置文件，即：</p><ul><li>删除子模块对应的目录 <code>xxx</code>；</li><li>删除 <code>.gitmoduls</code> 中子模块 <code>xxx</code> 对应的区块配置；</li><li>删除 <code>.git/modules/</code> 目录下的子模块目录 <code>xxx</code>；</li><li>删除子模块的缓存：<code>git rm --cached xxx</code>；</li></ul><p>然后再执行 <code>git submodule</code> 就没有任何输出了，清除完毕；</p><h3 id="子模块与父项目的联系"><a href="#子模块与父项目的联系" class="headerlink" title="子模块与父项目的联系"></a>子模块与父项目的联系</h3><p>父项目和子模块有着分开的 <code>git</code> 仓库，所以可以分别在父项目和子模块的目录下使用 <code>git</code> 命令，操作的也是<strong>各自</strong>的仓库，比如分别在父项目和子模块中执行 <code>git branch -a</code> 或者 <code>git remote -v</code> 的输出结果是不同的；</p><p>虽然二者有个分开的仓库与提交记录，但是又是关联起来的（这正是 <code>submodule</code> 所做的工作），举个例子，在子模块目录 <code>xxx/</code> 下新增一个文件 <code>test.txt</code>，然后在子模块目录中执行 <code>git satus</code> 会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        xxx/test.txt</span><br></pre></td></tr></table></figure></p><p>此时在父项目下执行 <code>git status</code> 输出的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">  (commit or discard the untracked or modified content in submodules)</span><br><span class="line">        modified:   xxx (untracked content)</span><br></pre></td></tr></table></figure></p><p>即提示需要先在子模块下提交修改记录；</p><p>然后子模块下提交记录，执行：</p><pre><code>git add .git commit -m &quot;add file&quot;</code></pre><p>这时再分别运行 <code>git status</code>，子模块的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p><p>而父项目的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   xxx (new commits)</span><br></pre></td></tr></table></figure></p><p>提示子模块中有了新的提交（<code>new commits</code>）；</p><p>假如再把子模块下的这个 <code>test.txt</code> 文件删除，则子模块的状态是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        deleted:    xxx/test.txt</span><br></pre></td></tr></table></figure></p><p>但是父项目的状态依然是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   xxx (new commits)</span><br></pre></td></tr></table></figure></p><p>子模块撤销刚才的删除操作，将新增文件的记录 <code>git push</code> 到远程（这会推送到子模块<strong>自己</strong>的远程仓库），此时子模块的工作区状态是清空状态，但是父项目的依旧是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   xxx (new commits)</span><br></pre></td></tr></table></figure></p><p>所以，父项目与子模块的关联便是，父模块只是单纯的识别子模块的<strong>总体变化</strong>，而不会在意具体是新增、修改还是删除，甚至修改已经提交推送到子模块所属的远程仓库，只是将这些调整统一识别为 <code>modified</code> 状态，然后需要提交并推送到自己（父项目）所属的远程仓库；</p><p>在父项目中使用 <code>git diff</code> 可以查看当前的变更，会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/xxx b/xxx</span><br><span class="line">index 70c316e..a6e2962 160000</span><br><span class="line">--- a/xxx</span><br><span class="line">+++ b/xxx</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Subproject commit 70c316ecb7c41a5bdf8a37ff93bf866d3b903388</span><br><span class="line">+Subproject commit a6e29629904538e8f70694df607617084d2659ca</span><br></pre></td></tr></table></figure></p><p>如果想要查看具体子模块的变动，可以执行：</p><blockquote><p><code>git diff --submodule</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Submodule xxx 70c316e..a6e2962:</span><br><span class="line">  &gt; add file</span><br></pre></td></tr></table></figure><p>输出会列出当前子模块的所有变动的提交日志；也可以直接日志中关联的子模块提交记录，执行：</p><blockquote><p><code>git log -p --submodule</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">commit 909a721e3755affb7620316b44df8fbc1b3488f2 (HEAD -&gt; master)</span><br><span class="line">Author: ******</span><br><span class="line">Date:   ******</span><br><span class="line"></span><br><span class="line">    mod submodule</span><br><span class="line"></span><br><span class="line">Submodule xxx 70c316e..a6e2962:</span><br><span class="line">  &gt; add file</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>父项目从含有子模块的分支切换到没有子模块的分支时，默认会<strong>保留</strong>子模块对应的目录，所以这使得切换过去时本地会保留关于子模块的修改记录，显然这不太合理，所以从包含子模块的分支切换到 <code>xxx</code> 时，需要这样执行：</p><pre><code>git checkout xxx --recurse-submodules</code></pre><p>当父项目存在许多子模块时，有时需要对多个子模块执行相同的操作，这时就可以使用 <strong><code>foreach</code></strong> 功能，比如批量存储：</p><pre><code>git submodule foreach &apos;git stash&apos;</code></pre><p>或者在每个子模块中新建切换分支：</p><pre><code>git submodule foreach &apos;git checkout -b new&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;先引用 &lt;code&gt;git&lt;/code&gt; 的官方定义描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A submodule is a repository embedded inside another repository. The submodule has its own history; the repository it is embedded in is called a superproject.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;子模块（&lt;code&gt;submodule&lt;/code&gt;）是一个内嵌在其他 git 仓库（父工程）中的 git 仓库，子模块有自己的 git 记录。&lt;/p&gt;
&lt;p&gt;通常，如果一个仓库存在子模块，父工程目录下的 &lt;code&gt;.git/modules/&lt;/code&gt; 目录中会存在一个 &lt;code&gt;git&lt;/code&gt; 目录，子模块的仓库目录会存在于父工程的仓库目录中，并且子模块的仓库目录中也会存在一个 &lt;code&gt;.git&lt;/code&gt; 目录；
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你需要知道的git命令和用法</title>
    <link href="https://water.buging.cn/2022/12/13/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84git%E5%91%BD%E4%BB%A4%E5%92%8C%E7%94%A8%E6%B3%95/"/>
    <id>https://water.buging.cn/2022/12/13/你需要知道的git命令和用法/</id>
    <published>2022-12-13T13:19:21.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在平时的 Coding 过程中，我们还是需要一定的 Git 操作的能力的。但是总还是存在一些场景自己突然想不起来，某个场景，应该使用什么 Git 命令可以满足自己的诉求，这个时候又需要打开 Google / Baidu，各种搜索一番，与其把时间消磨在这一次次的重复工作中，倒不如好好研究一下我们常用的命令的玩法。在这里，本文也将提供一系列的案例，为大家介绍这些常用的 Git 的体系和命令的应用场景以及大体的使用方式。<br>当然，除了我们需要了解 Git 的命令使用方式之外，我们也应该来了解下 Git 是的整个体系结构是怎么样的，这样才能更加清晰的知道我们每天操作的命令都是在做什么。<a id="more"></a></p><h2 id="Git-体系"><a href="#Git-体系" class="headerlink" title="Git 体系"></a>Git 体系</h2><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212211907078.png" alt></p><h2 id="Git-区域理解"><a href="#Git-区域理解" class="headerlink" title="Git 区域理解"></a>Git 区域理解</h2><ul><li>远程仓库区：也就是我们代码最终提交的归宿，没啥好说的。</li><li>远端分支本地副本：这个其实主要储存了远程仓库各分支数据在本地的一个副本，你可以打开你 Git 项目下的 .git 文件，里面有个 refs/remotes，这里就主要存的就是远程仓库的分支信息，一般你执行 push 或者 pull、fetch 都会往这里进行更新。</li><li>本地分支：这里就是我们经常会打交道的区域，你在执行 commit 之后，本质上就是提交到了这个区域，你可以查看你的 .git 目录下的 refs/heads 目录，里面存的就是我们本地的分支代码信息。</li><li>暂存区：这个区域就是我们每次执行 git add 之后会存到的区域，用来与本地仓库之间做一个缓存，同时也是 Git 底层设计上来说也算是比较重要的一个区域，它能帮助 Git 在做 diff 的时候提高查找性能。</li><li>工作区：这个一般就是我们写代码的地方，比如你的 vscode 打开的项目，你可以进行代码编辑的地方。</li></ul><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>除此之外，还有一个特殊的区域，那就是本地的 git 储存区，它是用来干嘛的呢？一般来说你可能在某些场景下会用到它，我们有的时候本地改了代码，但是突然有个人过来问你另一个分支的问题，同时这个时候你在实现某个功能，实现一半，又不想提交到 Git 仓库中，那么你就可以考虑使用 git stash save “临时存一下”，这个时候它就会帮你存到这个储存区，你去其他分支做完事情回来，再 git stash pop就好了。</p><p>但笔者还是不是很建议使用这个功能，因为哪天你切走了再切回来，忘记了这个存储，又写了点其他的，这个时候你到时候被坑一把就哭吧。当然了，这个功能还是很有用的，但是的确需要细心点用。</p><h3 id="Git-简单工作流理解"><a href="#Git-简单工作流理解" class="headerlink" title="Git 简单工作流理解"></a>Git 简单工作流理解</h3><p>日常工作中，我们可能在 Git 使用上频繁交互的流程大致会是这样的（不同规范下会有一些区别，但是大差不大）：</p><ol><li>来了一个新需求，我们会从 master checkout 一个新的 feature 分支出来进行开发。</li><li>开发完某个功能点，我们会执行 git add 将代码提交到暂存区。</li><li>执行 git commit 将代码提交到本地仓库</li><li>执行 git push 将代码提交到远端分支</li><li>当我们开发完所有需求之后，可能会设立一个专门的测试分支比如名叫 dev 的分支，那么我们就把代码合并到这个测试分支上，发布测试环境进行测试。</li><li>测试完毕之后，我们就需要合代码了，这个时候，我们可以发起一个 merge request，将我们的代码走 CR 流程合并到 master 分支。</li><li>在提交 MR 的过程中，我们一般需要先自己预先将 master 分支的代码合并到当前需要被合并的分支，提交并解决冲突。</li></ol><p>以上流程大致概括了一般常规的 Git flow 流程，不同的公司可能会设计自己的规范，这里就不过多指示了。</p><h2 id="命令概览"><a href="#命令概览" class="headerlink" title="命令概览"></a>命令概览</h2><ul><li>git stash</li><li>git clone</li><li>git init</li><li>git remote</li><li>git branch</li><li>git checkout</li><li>git add</li><li>git commit</li><li>git rm</li><li>git push</li><li>git pull</li><li>git fetch</li><li>git merge</li><li>git log</li><li>git reset</li><li>git reflog</li><li>git revert</li><li>git cherry-pick</li><li>git tag</li><li>git rebase</li></ul><p>乍一看，眼花缭乱，当场决定放弃，还是用可视化工具吧。莫慌，且让笔者为你娓娓道来。</p><h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><p>一般来说，我们本地如果想要使用 Git 管理一些资源文件，首先我们需要有一个仓库才行。常用的方式莫过于，第一去 Gitlab / Github 先创建一个仓库，然后再拉到本地，那这个时候我们就可以用到我们的 clone 命令了。</p><h3 id="git-stash（临时插进来快速介绍一下）"><a href="#git-stash（临时插进来快速介绍一下）" class="headerlink" title="git stash（临时插进来快速介绍一下）"></a>git stash（临时插进来快速介绍一下）</h3><p>上面也有初步介绍这个命令的用法，就是用来临时存一下不想被提交的代码变更的，常用命令如下：</p><ul><li>git stash save ‘xxx’: 储存变更</li><li>git stash list: 查看储存区所有提交列表</li><li>git stash pop: 弹出并应用最近的一次储存区的代码提交</li><li>git stash drop stash@{n}: 删除某次储存记录</li><li>git stash clear: 清楚所有 stash 信息</li></ul><p>它的数据将被存在你仓库 .git 文件下的 refs/stash 里。</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>最基础也是最常用的用法莫过于直接使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx.git</span><br></pre></td></tr></table></figure></p><p>这样就能轻松把一个仓库代码拉到本地了，但仅仅知道这一点似乎还不太够。一般我们直接 clone 下来不带参数的话，它会默认停留在 master 分支，有的时候我们依旧需要一些其他诉求，比如怎么拉到本地之后自动切到指定分支呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx.git -b branch1</span><br></pre></td></tr></table></figure></p><p>有了仓库之后，我们总不能一直在 master 分支搞事吧，一般是不是都需要开个新分支改代码，再最后完事了再合到 master，那就需要用到下面介绍 git branch 命令了，不过呢，在讲到具体的分支操作之前呢，笔者还是要先补一下有关于本地仓库的初始化的流程。</p><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>除了我们从远端建仓库，有的时候我们自己本地也是可以自己初始化一个 Git 仓库来操作的，这个时候我们就直接使用 git init 就能轻松为当前目录创建一个 git 仓库，也就能开始对当前目录的改动纳入版本管理库了。<br>不过本地 init 的仓库没法和远端进行交互，所以我们还是需要去 github/gitlab 创建一个远端仓库，然后关联一下，也就是 git remote 命令了。</p><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>用于和远程仓库进行关系绑定处理等等操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add: 添加一个远程版本库关联</span><br><span class="line">git remote rm: 删除某个远程版本库关联</span><br></pre></td></tr></table></figure><p>比如我们本地有个初始化好的仓库，同时还有一个创建好的远程空仓库，那么我们就可以执行一下操作让他们关联起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin xxx.git先添加到本地仓库</span><br><span class="line">git push -u origin master：表示把当前仓库的 master 分支和远端仓库的 master 分支关联起来，后面我们执行 push 或者 pull 都可以非常方便的进行操作了。</span><br></pre></td></tr></table></figure></p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>在拿到一个项目之后，你首先还是应该看一下当前仓库现在有哪些分支，不要待会创建新分支发现名字重复之类的问题，那这个时候我们就可以使用 git branch 来查看一下相关的分支了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch：查看本地所有分支信息</span><br><span class="line">git branch -r：查看远程仓库所有分支</span><br><span class="line">git branch -a：查看本地和远程仓库所有分支</span><br></pre></td></tr></table></figure><p>一般来说如果分支太多的话，还是建议使用可视化工具来查看分支信息，比如 vscode 或者 source tree 等软件等等。</p><p>当然 IDEA 也是可以的。</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>如果我们想以当前分支为基准，创建一个新的分支并切换过去，可以使用如下命令。</p><p>创建并切换到指定新分支：git checkout -b branch1</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>我们在某个分支更改了代码之后，想要把它提交一下，那么你第一步要做的就是，执行 git add</p><ul><li>git add [file1] [file2]: 添加一个或多个文件到暂存区</li></ul><p>一般我们平时在使用的时候，用的比较多的应该还是：</p><ul><li>git add .：把当前目录下得所有文件改动都添加到暂存区</li><li>git add -A：把当前仓库内所有文件改动都添加到暂存区</li></ul><p>对笔者来说，用的最多的还是这个 git add -A 命令，因为大多数情况，我们都应该把所有变更都加到暂存区里，如果没有，那大概率是忘了。</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>文件添加到暂存区之后，我们就可以执行下一步操作了。</p><ul><li>git commit [file1] … -m [message]：将暂存区的内容提交到本地 git 版本仓库中</li></ul><p>-m 表示的是当前提交的信息<br>-a 对于已经被纳入 git 管理的文件（该文件你之前提交过 commit），那么这个命令就相当于帮你执行了上述 git add -A，你就不用再 add 一下了；对于未被 git 管理过的（也就是新增的文件），那么还是需要你先执行一下 git add -A，才能正确被 commit 到本地 git 库。</p><p>通常情况下，我们用的比较多得应该是 git commit -m ‘feat: do something’，设置当前提交的信息。当然，如果你没有强诉求需要 git add 和 git commit 一定要分开，那你大可选择 git commit -am，方便又快捷。</p><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>这个其实也挺有用的，比如我们项目中有个文件叫 .env，这个文件是一个私有的，不能被提交到远程的，但是我们不小心提交到了本地仓库中，这个时候我们把这个文件添加到 .gitignore 文件中，表示需要被 git 忽略提交，但是由于我们已经提交到本地仓库了，所以如果不先从 git 仓库删除是没用的。<br>如果直接右键删除，那么这个文件的记录还是会被保存到远端仓库，别人还是能看得到你这个信息，所以我们需要先从 git 仓库中删掉这个文件才行。</p><ul><li><p>git rm .env：执行完这个命令就表示 .env 文件从 git 仓库中删除了，配合 .gitignore 就能保证以后所有的 .env 文件变更都不用担心被提交到远程仓库。</p></li><li><p>git rm -r dist：如果我们要删除的是一个目录，那么加上 -r 参数就好了。</p></li></ul><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>接下来我们想要把刚创建好得分支推送到远端，一般来说我们可能会需要用到 git push，但我们这是个新分支，根本没和远端仓库建立任何联系，那么我们就需要加点参数，让他们关联上：</p><ul><li>推送分支并建立关联关系：git push –set-upstream origin branch1</li></ul><p>完事之后我们可以再去远程仓库看一眼就会发现我们创建的新分支已经推上去了。接下来可能会有小伙伴要问了，那如果远端仓库已经有了这个分支名咋整？<br>这里就分两种：</p><ol><li>一种就是你本地的代码和远端代码没有冲突的情况下，并且你本地有新增提交，那么你可以仍然执行上述命令，这样就会直接将当前本地分支合远程分支关联上，同时把你的改动提交上去。</li><li>另一种就是本地分支和远端分支存在冲突，这个时候你执行上述命令就会出现提示冲突，那么接下来就需要你先把远端当前分支的代码拉下来，解决一下冲突了，就需要用到 git pull 命令了。</li></ol><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>通常情况下，如果当前分支已经和远端分支建立了联系，那么我们想要合并一下远端分支，只需要执行 git pull 就好了，不用带其他参数，但如果和上面提到的 git push 时产生了冲突，还没有建立联系的时候，我们就需要指定需要拉取哪个分支的代码下来进行合并了。</p><ul><li>拉取指定远端分支合并到本地当前分支：git pull origin branch1</li></ul><p>这里的 origin 是我们对远端仓库的命名，想改也是可以的，不过一般都是用的 origin。<br>回到上面提到的冲突问题，我们可以直接使用 git pull 然后指定合并当前本地分支想要建立联系的远程分支，然后本地解决一下冲突，然后提交一下改动，再执行 git push –set-upstream origin branch1 命令就大功告成了。</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>了解完上面描述的 git pull，命令之后，其实这个命令也很好理解了，特定时候，可能我们只是想把远端仓库对应分支的变更拉到本地而已，并不想自动合并到我的工作区（你当前正在进行代码变更的工作区），等晚些时候我写完了某部分的代码之后再考虑合并，那么你就可以先使用 git fetch。<br>fetch 完毕之后，我提交了自己当前工作去的变更到本地仓库，然后想合并一下远端分支的更改，这个时候执行一下 git merge origin/[当前分支名]（默认一般是用 origin 表示远端的分支前缀）即可。</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>合并指定分支代码到当前分支。一般来说，我们用的比较多的场景可能是，远端仓库 master 分支有变更了，同时这个时候我们准备提 MR 了，那么就需要先合一下 master 的代码，有冲突就解决下冲突，那这个时候我们可以做以下操作：</p><ol><li>切到 master 分支，git pull 拉一下最新代码</li><li>切回开发分支，执行 git merge master 合并一下 master 代码</li></ol><p>同理，上面介绍的 git merge origin/xxx 也是一样的用法。</p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>顾名思义，就是日志的意思，执行这个命令之后，我们能看到当前分支的提交记录信息，比如 commitId 和提交的时间描述等等，大概长下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit e55c4d273141edff401cbc6642fe21e14681c258 (HEAD -&gt; branch1, origin/branch1)</span><br><span class="line">Author: 陌小路 &lt;44311619+STDSuperman@users.noreply.github.com&gt;</span><br><span class="line">Date:   Mon Aug 1 23:16:11 2022 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit</span><br></pre></td></tr></table></figure><p>这个时候可能有读者会问了，这个都用来干啥的，简单的用法呢就是看看有谁提交了啥，还有更重要的用法呢就是进行代码版本的回滚，或者其他有意思的操作，且听笔者为你微微道来。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>git reset [–soft | –mixed | –hard] [HEAD]</p><h3 id="关于-HEAD："><a href="#关于-HEAD：" class="headerlink" title="关于 HEAD："></a>关于 HEAD：</h3><ul><li>HEAD 表示当前版本</li><li>HEAD^ 上一个版本</li><li>HEAD^^ 上上一个版本</li><li>HEAD^^^ 上上上一个版本</li><li>HEAD~n 回撤 n 个版本，这种也是更加方便的</li></ul><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>以下解析均基于后接参数为 HEAD^，也就是git reset HEAD^。</p><ul><li>–soft: 重置你最新一次提交版本，不会修改你的暂存区和工作区。</li><li>–mixed: 默认参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。</li><li>–hard: 重置所有提交到上一个版本，并且修改你的工作区，会彻底回到上一个提交版本，在代码中看不到当前提交的代码，也就是你的工作区改动也被干掉了。</li></ul><p>说了半天似乎不是很好理解，我们举个栗子理解下：<br>比如：</p><ol><li>我改动了我的 README 文件，在我们的工作区就产生了一次改动，但是这个时候还没有提交到暂存区，在 vscode 里会显示为工作区修改的标记</li><li>接着我们执行 git add，这个时候你查看暂存区，会发现这次改动被提交进去了，同时被 vscode 标记为已被提交至暂存区</li><li>然后再执行 git commit，这个时候就完成了一次提交</li></ol><p>接下来我们想撤回这次提交，以上三种参数所体现的表现会是这样的：</p><ul><li>–soft：我们对 README 的更改状态现在变成已被提交至暂存区，也就是上面 2 的步骤。</li><li>–mixed： 我们对 README 的更改变成还未被提交至暂存区，也就是上面 1 的步骤。</li><li>–hard：我们对 README 的所有更改全没了，git log 中也找不到我们对 README 刚刚那次修改的痕迹。</li></ul><p>默认情况下我们不加参数，就是 –mixed，也就是重置暂存区的文件到上一次提交的版本，文件内容不动。一般会在什么时候用到呢？</p><h4 id="场景一（撤销-git-add）"><a href="#场景一（撤销-git-add）" class="headerlink" title="场景一（撤销 git add）"></a>场景一（撤销 git add）</h4><p>可能大部分情况下，比如 vscode 其实大家更习惯于使用可视化的撤销能力，但是呢，这里我们其实也可以稍微了解下这其中的奥秘，其实也很简单：</p><ul><li>方式一：git reset</li><li>方式二：git reset HEAD</li></ul><p>其实一二都是一样，如果 reset 后面不跟东西就是默认 HEAD。</p><h4 id="场景二-撤销-git-commit"><a href="#场景二-撤销-git-commit" class="headerlink" title="场景二 (撤销 git commit)"></a>场景二 (撤销 git commit)</h4><p>当你某个改动提交到本地仓库之后，也就是 commit 之后，这个时候你想撤回来，再改点其他的，那么就可以直接使用 git reset HEAD^。这个时候你会惊奇的发现，你上一版的代码改动，全部变成了未被提交到暂存区的状态，这个时候你再改改代码，然后再提交到暂存区，然后一起再 commit 就可满足你的需求了。<br>除了这种基础用法，我们还可以配合其他命令操作一下。</p><h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h4><p>某一天你老板跟你说，昨天新加的功能不要了，给我切回之前的版本看看效果，那么这个时候，你可能就需要将工作区的代码回滚到上一个 commit 版本了，操作也十分简单：</p><ul><li>git log 查看上一个 commit 记录，并复制 commitId</li><li>git reset –hard commitId 直接回滚。</li></ul><h4 id="场景四"><a href="#场景四" class="headerlink" title="场景四"></a>场景四</h4><p>如果某一个你开发需求正开心呢，突然发现，自己以前改的某个东西怎么不见了，你想起来好像是某次合并，没注意被其他提交冲掉了，你心一想，完了，写了那么多，怎么办？很简单，回到有这份代码的那个版本就好了（前提你提交过到本地仓库）。<br>假设我们有这么两个提交记录，我们需要下面那个 365 开头 commitId 的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commit e62b559633387ab3a5324ead416f09bf347d8e4a (HEAD -&gt; master)</span><br><span class="line">Author: xiaohang.lin &lt;xiaohang.lin@alibaba-inc.com&gt;</span><br><span class="line">Date:   Sun Aug 14 18:08:56 2022 +0800</span><br><span class="line"></span><br><span class="line">    merge</span><br><span class="line"></span><br><span class="line">commit 36577ea21d79350845f104eee8ae3e740f19e038 (origin/master, origin/HEAD)</span><br><span class="line">Author: 陌小路 &lt;44311619+STDSuperman@users.noreply.github.com&gt;</span><br><span class="line">Date:   Sun Aug 14 15:57:34 2022 +0800</span><br><span class="line"> </span><br><span class="line">  Update README.md</span><br></pre></td></tr></table></figure><ol><li>抢救第一步 git log 找到有你这个代码的那个 commitId（也就是 36577ea21d79350845f104eee8ae3e740f19e038）</li><li>抢救第二步 git reset –hard commitId</li><li>第三步：Ctrl + c 你的目标代码</li></ol><p>这个时候你想把复制好的代码写回去，该怎么办呢，你可能会再 git log 看一下我们 reset 之前的 commitId，你会发现，完了，之前的 commitId 都没了，只有这个 365 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit 36577ea21d79350845f104eee8ae3e740f19e038 (origin/master, origin/HEAD)</span><br><span class="line">Author: 陌小路 &lt;44311619+STDSuperman@users.noreply.github.com&gt;</span><br><span class="line">Date:   Sun Aug 14 15:57:34 2022 +0800</span><br><span class="line"></span><br><span class="line">Update README.md</span><br></pre></td></tr></table></figure><p>不要慌，请记住一句话，只要你不删你本地的 .git 仓库，你都能找回以前所有的提交。</p><p>git log 看不到的话，我们就可以祭出我们的绝招了：git reflog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">36577ea (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@&#123;0&#125;: reset: moving to 36577ea21d79350845f104eee8ae3e740f19e038</span><br><span class="line">e62b559 HEAD@&#123;1&#125;: reset: moving to e62b559633387ab3a5324ead416f09bf347d8e4a</span><br></pre></td></tr></table></figure><p>这里我们可以看到两行记录，一个是我们执行 reset 到 365 的记录，另一条不知道是啥，不重要，我们想回到我们刚刚 reset 之前的状态也很简单，直接复制它上一次的变动也就是这个 e62b559，然后执行 git reset –hard e62b559，然后你会惊奇的发现，你之前的代码又回来了。</p><p>接下来把你以前版本的代码，再 Ctrl + v 放进来就完成了。</p><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>介绍：用来查看你的所有操作记录。<br>既然 git log 看不到我之前 commitId 了，那么就回到 reset 之前的状态吧！</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>当然了，如果是针对 master 的操作，为了安全起见，一般还是建议使用 revert 命令，他也能实现和 reset 一样的效果，只不过区别来说，reset 是向后的，而 revert 是向前的，怎么理解呢？简单来说，把这个过程当做一次时光穿梭，reset 表示你犯了一个错，他会带你回到没有犯错之前，而 revert 会给你一个弥补方案，采用这个方案之后让你得到的结果和没犯错之前一样。</p><p>举个栗子：<br>假设你改了 README 的描述，新增了一行文字，提交上去了，过一会你觉得这个写了有问题，想要撤销一下，但是又不想之前那个提交消失在当前历史当中，那么你就可以选择使用 git revert [commitId]，那么它就会产生一次新的提交，提交的内容就是帮你删掉你上面新增的内容，相当于是一个互补的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Code\other\git-practice&gt; git revert 3b18a20ad39eea5264b52f0878efcb4f836931ce</span><br><span class="line">On branch branch2</span><br><span class="line">Your branch is ahead of &apos;origin/branch2&apos; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure><p>这个时候，它会提示你可以把新的改动 push 上去了。<br>其实你如果在 gitlab 进行 mr 之后，想要回滚这个 mr，一般它会给你一个 revert 的按钮选项，让你进行更安全的回滚操作。</p><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>其实对于我们工作中大部分场景下应该用不到这个功能，但是呢有的时候这个命令又能挽救你于水火之间，那就是当某个倒霉蛋忘记切分支，然后在 master 分支上改了代码，并且提交到了本地仓库中，这个时候使用git cherry-pick简直就是神器了。</p><ul><li>git cherry-pick：将执行分支的指定提交合并到当前分支。</li></ul><p>一听介绍就来精神了，雀氏有点东西，比如我在 master 分支提交了某个需求的代码，同时还没提交到远程分支，那么你就可以先 <code>git log</code>查看一下当前的提交，找到 <code>master</code> 分支正常提交之后的所有 <code>commitId</code>，然后复制出来，然后再切到你建好的开发分支，接着执行 <code>git cherry-pick master commitId1 commitId2 commitId4</code>。<br>完事之后记得清理一下作案现场，把你的 master 分支代码恢复到正常的提交上去。</p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>顾名思义，也就是打标签的意思。一般可能会在你发布了某个版本，需要给当前版本打个标签，你可以翻阅 vite 的官方 git 仓库，查看它的 tag 信息，它这里就标注了各个版本发布时候的 tag 标签。<br>它有两种标签形式，一种是轻量标签，另一种是附注标签。</p><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><ul><li>创建方式：git tag v1.0.0</li></ul><p>它有点像是对某个提交的引用，从表现上来看，它又有点像基于当前分支提交给你创建了一个不可变的分支，它是支持你直接 checkout 到这个分支上去，但是它和普通分支还是有着本质的区别的，如果你切换到了这个 tag “分支”，你去修改代码同时产生了一次提交，亦或者是 reset 版本，这对于该 tag 本身不会有任何影响，而是为你生成了一个独立的提交，但是却在你的分支历史中是找不到的，你只能通过 commitId 来切换到本次提交，看图：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212201169.png" alt></p><p>那如果你从其他分支通过 commitId 切换到这个改动上，它会提示你以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Note: switching to &apos;be276009&apos;.</span><br><span class="line"></span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by switching back to a branch.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -c with the switch command. Example:</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">Or undo this operation with:</span><br><span class="line"></span><br><span class="line">  git switch -</span><br></pre></td></tr></table></figure><p>大致意思就是你可以选择丢弃或者保留当前更改，如果需要保留的话直接使用下面的 git switch 命令创建一个新分支即可。</p><h3 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h3><ul><li>创建方式：git tag -a v1.0.1 -m “发布正式版 1.0.1”</li></ul><p>引用官方文档的描述：</p><blockquote><p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。</p></blockquote><p>从概念上看，轻量标签更像是一个临时的标签，而附注标签更加正式一点，能够保留更多的信息。它创建的方式和轻量标签区别主要是 -a 和 -m 参数，如果你的 -m 参数不传，那么编辑器会让你手动填写。</p><h4 id="对比标签信息"><a href="#对比标签信息" class="headerlink" title="对比标签信息"></a>对比标签信息</h4><p>打完标签之后，我们可以使用 git show 命令来看看这两种标签最终体现的信息有哪些。<br><strong>轻量标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">commit dcbd335be87f51eaa0cc1852400e64e9f46e84d8 (HEAD -&gt; test-branch1, tag: v1.0.2, tag: v1.0.1)</span><br><span class="line">Author: STDSuperman &lt;2750556766@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 16 22:54:36 2022 +0800</span><br><span class="line"></span><br><span class="line">xx</span><br><span class="line"></span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 715766a..b4cdea6 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line">-# git-practice</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+# git-practice</span><br><span class="line">+</span><br><span class="line">+test tag</span><br></pre></td></tr></table></figure><p><strong>附注标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tag v1.0.1</span><br><span class="line">Tagger: STDSuperman &lt;2750556766@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 16 22:58:27 2022 +0800</span><br><span class="line"></span><br><span class="line">发布正式版 1.0.0</span><br><span class="line"></span><br><span class="line">commit dcbd335be87f51eaa0cc1852400e64e9f46e84d8 (HEAD -&gt; test-branch1, tag: v1.0.1)</span><br><span class="line">Author: STDSuperman &lt;2750556766@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 16 22:54:36 2022 +0800</span><br><span class="line"></span><br><span class="line">xx</span><br><span class="line"></span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 715766a..b4cdea6 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br></pre></td></tr></table></figure><p>从信息丰富度上来说，附注标签能保留的信息会更多。</p><h3 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h3><ul><li>git push origin tagName</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&gt; git push origin v1.0.1</span><br><span class="line">Enumerating objects: 6, done.</span><br><span class="line">Counting objects: 100% (6/6), done.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (4/4), 448 bytes | 448.00 KiB/s, done.</span><br><span class="line">Total 4 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To github.com:STDSuperman/git-practice.git</span><br><span class="line"></span><br><span class="line">* [new tag]         v1.0.1 -&gt; v1.0.1</span><br></pre></td></tr></table></figure><p>当然，附注标签和轻量标签都是可以被推送到远端的。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul><li>查看标签：git tag</li><li>筛选标签：git tag -l v1.0.1</li><li>删除标签：git tag -d v1.0.1</li><li><p>删除远程标签：git push origin –delete v1.0.2</p></li><li><p>另一种删除远程方式（表示将“:”前面空值替换到远程，也不失为一种方式）：<code>git push origin :refs/tags/v1.0.1</code></p></li></ul><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>使用 Git 已经好几年了，却始终只是熟悉一些常用的操作。对于 Git Rebase 却很少用到，直到这一次，不得不用。</p><h4 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h4><p>上线构建的过程中扫了一眼代码变更，突然发现，commit 提交竟然多达 62 次。我们来看看都提交了什么东西：</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212207584.png" alt></p><p>这里我们先不说 git 提交规范，就单纯这么多次无用的 commit 就很让人不舒服。可能很多人觉得无所谓，无非是多了一些提交纪录。</p><p>然而，并非如此，你可能听过破窗效应，编程也是如此！</p><h4 id="二、导致问题"><a href="#二、导致问题" class="headerlink" title="二、导致问题"></a>二、导致问题</h4><ol><li><p>不利于代码 review<br>设想一下，你要做 code review ，结果一个很小的功能，提交了 60 多次，会不会有一些崩溃？</p></li><li><p>会造成分支污染<br>你的项目充满了无用的 commit 纪录，如果有一天线上出现了紧急问题，你需要回滚代码，却发现海量的 commit 需要一条条来看。</p></li></ol><p>遵循项目规范才能提高团队协作效率，而不是随心所欲。</p><h4 id="三、Rebase-场景一：如何合并多次提交纪录？"><a href="#三、Rebase-场景一：如何合并多次提交纪录？" class="headerlink" title="三、Rebase 场景一：如何合并多次提交纪录？"></a>三、Rebase 场景一：如何合并多次提交纪录？</h4><p>基于上面所说问题，我们不难想到：每一次功能开发， 对多个 commit 进行合并处理。</p><p>这时候就需要用到 git rebase 了。这个命令没有太难，不常用可能源于不熟悉，所以我们来通过示例学习一下。</p><p>1.我们来合并最近的 4 次提交纪录，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure><p>2.这时候，会自动进入 vi 编辑模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">s cacc52da add: qrcode</span><br><span class="line">s f072ef48 update: indexeddb hack</span><br><span class="line">s 4e84901a feat: add indexedDB floder</span><br><span class="line">s 8f33126c feat: add test2.js</span><br><span class="line"></span><br><span class="line"># Rebase 5f2452b2..8f33126c onto 5f2452b2 (4 commands)</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Commands:</span><br><span class="line"></span><br><span class="line"># p, pick = use commit</span><br><span class="line"></span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"></span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"></span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"></span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"></span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"></span><br><span class="line"># d, drop = remove commit</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line"></span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>有几个命令需要注意一下：</p><ul><li>p, pick = use commit</li><li>r, reword = use commit, but edit the commit message</li><li>e, edit = use commit, but stop for amending</li><li>s, squash = use commit, but meld into previous commit</li><li>f, fixup = like “squash”, but discard this commit’s log message</li><li>x, exec = run command (the rest of the line) using shell</li><li>d, drop = remove commit<br>按照如上命令来修改你的提交纪录：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s cacc52da add: qrcode</span><br><span class="line">s f072ef48 update: indexeddb hack</span><br><span class="line">s 4e84901a feat: add indexedDB floder</span><br><span class="line">p 8f33126c feat: add test2.js</span><br></pre></td></tr></table></figure><p>3.如果保存的时候，你碰到了这个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: cannot &apos;squash&apos; without a previous commit</span><br></pre></td></tr></table></figure><p>注意不要合并先前提交的东西，也就是已经提交远程分支的纪录。</p><p>4.如果你异常退出了 vi 窗口，不要紧张：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --edit-todo</span><br></pre></td></tr></table></figure><p>这时候会一直处在这个编辑的模式里，我们可以回去继续编辑，修改完保存一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>5.查看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>三次提交合并成了一次，减少了无用的提交信息。</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212211635.png" alt></p><h4 id="四、Rebase-场景二：分支合并"><a href="#四、Rebase-场景二：分支合并" class="headerlink" title="四、Rebase 场景二：分支合并"></a>四、Rebase 场景二：分支合并</h4><p>1.我们先从 master 分支切出一个 dev 分支，进行开发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:(master) git checkout -b feature1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212212787.png" alt><br>2.这时候，你的同事完成了一次 <code>hotfix</code>，并合并入了 <code>master</code> 分支，此时 <code>master</code>已经领先于你的<code>feature1</code> 分支了：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212213205.png" alt><br>3.恰巧，我们想要同步 master 分支的改动，首先想到了 merge，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:(feature1) git merge master</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212213592.png" alt><br>图中绿色的点就是我们合并之后的结果，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:(feature1) git log</span><br></pre></td></tr></table></figure><p>就会在记录里发现一些 merge 的信息，但是我们觉得这样污染了 commit 记录，想要保持一份干净的 commit，怎么办呢？这时候，git rebase 就派上用场了。</p><p>4.让我们来试试 git rebase ，先回退到同事 hotfix 后合并 master 的步骤：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212214539.png" alt><br>5.使用 rebase 后来看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:(feature1) git rebase master</span><br></pre></td></tr></table></figure><p>这里补充一点：rebase 做了什么操作呢？</p><p>首先，git 会把 feature1 分支里面的每个 commit 取消掉；<br>其次，把上面的操作临时保存成 patch 文件，存在 .git/rebase 目录下；<br>然后，把 feature1 分支更新到最新的 master 分支；<br>最后，把上面保存的 patch 文件应用到 feature1 分支上；</p><p><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212215385.png" alt></p><p>从 commit 记录我们可以看出来，feature1 分支是基于 hotfix 合并后的 master ，自然而然的成为了最领先的分支，而且没有 merge 的 commit 记录，是不是感觉很舒服了。</p><p>6.在 rebase 的过程中，也许会出现冲突 conflict。在这种情况，git 会停止 rebase 并会让你去解决冲突。在解决完冲突后，用 git add 命令去更新这些内容。</p><p>注意，你无需执行 git-commit，只要执行 continue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>这样 git 会继续应用余下的 patch 补丁文件。</p><p>7.在任何时候，我们都可以用 –abort 参数来终止 rebase 的行动，并且分支会回到 rebase 开始前的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase —abort</span><br></pre></td></tr></table></figure><h4 id="五、更多-Rebase-的使用场景"><a href="#五、更多-Rebase-的使用场景" class="headerlink" title="五、更多 Rebase 的使用场景"></a>五、更多 Rebase 的使用场景</h4><p>git-rebase 存在的价值是：对一个分支做「变基」操作。</p><p>1.当我们在一个过时的分支上面开发的时候，执行 rebase 以此同步 master 分支最新变动；<br>2.假如我们要启动一个放置了很久的并行工作，现在有时间来继续这件事情，很显然这个分支已经落后了。这时候需要在最新的基准上面开始工作，所以 rebase 是最合适的选择。</p><h4 id="六、为什么会是危险操作？"><a href="#六、为什么会是危险操作？" class="headerlink" title="六、为什么会是危险操作？"></a>六、为什么会是危险操作？</h4><p>根据上文来看，git-rebase 很完美，解决了我们的两个问题：<br>1.合并 commit 记录，保持分支整洁；<br>2.相比 merge 来说会减少分支合并的记录；</p><p>如果你提交了代码到远程，提交前是这样的：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212216598.png" alt></p><p>提交后远程分支变成了这样：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212216406.png" alt></p><p>而此时你的同事也在 feature1 上开发，他的分支依然还是：<br><img src="https://cdn.jsdelivr.net/gh/wangyuan0108/img/note/202212212217646.png" alt></p><p>那么当他 pull 远程 master 的时候，就会有丢失提交纪录。这就是为什么我们经常听到有人说 git rebase 是一个危险命令，因为它改变了历史，我们应该谨慎使用。</p><p>除非你可以肯定该 feature1 分支只有你自己使用，否则请谨慎操作。</p><p>结论：只要你的分支上需要 rebase 的所有 commits 历史还没有被 push 过，就可以安全地使用 git-rebase来操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在平时的 Coding 过程中，我们还是需要一定的 Git 操作的能力的。但是总还是存在一些场景自己突然想不起来，某个场景，应该使用什么 Git 命令可以满足自己的诉求，这个时候又需要打开 Google / Baidu，各种搜索一番，与其把时间消磨在这一次次的重复工作中，倒不如好好研究一下我们常用的命令的玩法。在这里，本文也将提供一系列的案例，为大家介绍这些常用的 Git 的体系和命令的应用场景以及大体的使用方式。&lt;br&gt;当然，除了我们需要了解 Git 的命令使用方式之外，我们也应该来了解下 Git 是的整个体系结构是怎么样的，这样才能更加清晰的知道我们每天操作的命令都是在做什么。
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你需要知道的前端鉴权方式</title>
    <link href="https://water.buging.cn/2021/08/27/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%89%8D%E7%AB%AF%E9%89%B4%E6%9D%83/"/>
    <id>https://water.buging.cn/2021/08/27/你需要知道的前端鉴权/</id>
    <published>2021-08-27T07:01:01.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 web 开发中，鉴权是非常常用的。而且鉴权的方式也有很多种，有各自的优缺点和使用场景。这里笔者就对当下几种常用的鉴权手段进行一个整理，方便大家的学习巩固和自己的复习<a id="more"></a></p><h2 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a>HTTP Basic Authentication</h2><p>这种授权方式是浏览器遵守 http 协议实现的基本授权方式,HTTP 协议进行通信的过程中，HTTP 协议定义了基本认证认证允许 HTTP 服务器对客户端进行用户身份证的方法。</p><p><strong>认证过程：</strong> </p><p>1． 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个 ajax 异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get /index.html HTTP/1.0</span><br><span class="line">Host:www.google.com</span><br></pre></td></tr></table></figure><p>2． <strong>服务器向客户端发送验证请求代码 401</strong>,（<code>WWW-Authenticate: Basic realm=”google.com”</code>这句话是关键，如果没有客户端不会<strong>弹出用户名和密码输入界面</strong>）服务器返回的数据大抵如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 401 Unauthorised</span><br><span class="line">Server: SokEvo/1.0</span><br><span class="line">WWW-Authenticate: Basic realm=”google.com”</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: xxx</span><br></pre></td></tr></table></figure><p>3． 当符合 http1.0 或 1.1 规范的客户端（如 IE，FIREFOX）收到 401 返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。</p><p>4． 用户输入用户名和密码后，将<strong>用户名及密码以 BASE64 加密方式加密(base64 不安全!)</strong>，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Get /index.html HTTP/1.0</span><br><span class="line">Host:www.google.com</span><br><span class="line">Authorization: Basic d2FuZzp3YW5n</span><br></pre></td></tr></table></figure><p>注：d2FuZzp3YW5n 表示加密后的用户名及密码（用户名：密码 然后通过 base64 加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）</p><p>5． 服务器收到上述请求信息后，将 Authorization 字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端</p><p>效果：<br>客户端未未认证的时候，会弹出用户名密码输入框，这个时候请求时属于 pending 状态， 这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带 Authentication 头的请求。</p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/20210827065501.png" alt></p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/20210827065408.png" alt></p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/20210827065546.png" alt></p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/blog/20210827065740.png" alt></p><p>当然有登陆就有注销，我们会发现当我们认证成功后每次请求请求头都会带上 Authentication 及里面的内容，那么如何做到让这次登陆失效的？</p><p>网上查了半天，目前最有效的方式就是在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的 Authentication 信息为注销用户名密码的时候纠就带便注销成功了，而客户端在注销操作的时候，手动的的去修改请求头重的 Authentication，将他设置未服务器默认的注销账号和密码。</p><p>通过上面的简单讲解 其实我们已经可以返现这种验证方式的缺陷加密方式简单，仅仅是 base64 加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。</p><p>总结:</p><p>正式因为这样，这种加密方式一般多被用在内部安全性要求不高的的系统上，只是相对的多，总的来说现在使用这种鉴权比较少了。如果项目需要部署在公网上，这种方式不推荐。</p><h2 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session-cookie"></a>session-cookie</h2><p>第二种这个方式是利用服务器端的 session（会话）和浏览器端的 cookie 来实现前后端的认证，由于 http 请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话(seesion),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建 seesion，如果有则已经认证成功了，否则就没有认证。<br>session-cookie 认证主要分四步：</p><ol><li><p>服务器在接受客户端首次访问时在服务器端创建 seesion，然后保存 seesion(我们可以将 seesion 保存在内存中，也可以保存在 redis 中，推荐使用后者)，然后给这个 session 生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。</p></li><li><p>签名。这一步只是对 sid 进行加密处理，服务端会根据这个 secret 密钥进行解密。（非必需步骤）</p></li><li><p>浏览器中收到请求响应的时候会解析响应头，然后将 sid 保存在本地 cookie 中，浏览器在下次 http 请求 de 请求头中会带上该域名下的 cookie 信息，</p></li><li><p>服务器在接受客户端请求时会去解析请求头 cookie 中的 sid，然后根据这个 sid 去找服务器端保存的该客户端的 session，然后判断该请求是否合法。<br><img src="https://gitee.com/wangyuan0108/image/raw/master/blog/20210827070926.png" alt></p></li></ol><h2 id="Token（jwt"><a href="#Token（jwt" class="headerlink" title="Token（jwt)"></a>Token（jwt)</h2><p>使用基于 Token 的身份验证方法，大概的流程是这样的：</p><ul><li><p>客户端使用用户名跟密码请求登录</p></li><li><p>服务端收到请求，去验证用户名与密码</p></li><li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p></li><li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p></li><li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p></li><li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p></li></ul><p>总的来说就是客户端在首次登陆以后，服务端再次接收 http 请求的时候，就只认 token 了，请求只要每次把 token 带上就行了，服务器端会拦截所有的请求，然后校验 token 的合法性，合法就放行，不合法就返回 401（鉴权失败）。</p><p>乍的一看好像和前面的 seesion-cookie 有点像，seesion-cookie 是通过 seesionid 来作为浏览器和服务端的链接桥梁，而 token 验证方式貌似是 token 来起到 seesionid 的角色。其实这两者差别是很大的。</p><ol><li>sessionid 他只是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的 seesion，这里面才保存着用户的登陆状态。但是 token 本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个 token 是否合法就行。</li><li>session-cookie 是需要 cookie 配合的，居然要 cookie，那么在 http 代理客户端的选择上就是只有浏览器了，因为只有浏览器才会去解析请求响应头里面的 cookie,然后每次请求再默认带上该域名下的 cookie。但是我们知道 http 代理客户端不只有浏览器，还有原生 APP 等等，这个时候 cookie 是不起作用的，或者浏览器端是可以禁止 cookie 的(虽然可以，但是这基本上是属于吃饱没事干的人干的事)…，但是 token 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的 cookie,storage，或者内存中，然后再下一次请求的请求头重带上这个 token 就行了。简单点来说 cookie-session 机制他限制了客户端的类型，而 token 验证机制丰富了客户端类型。</li><li>时效性。session-cookie 的 sessionid 实在登陆的时候生成的而且在登出事时一直不变的，在一定程度上安全就会低，而 token 是可以在一段时间内动态改变的。</li><li>可扩展性。token 验证本身是比较灵活的，一是 token 的解决方案有许多，常用的是 JWT,二来我们可以基于 token 验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。</li></ol><p>下面就拿最常用的 <code>JWT（JSON WEB TOKEN）</code>来说：</p><p>JWT 是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成 json 对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个 token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。<br>JWT 对象通常由三部分构成：</p><ul><li>Headers： 包括类别（typ）、加密算法（alg）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">&quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Claims ：包括需要传递的用户信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">&quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">&quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Signature： 根据 alg 算法与私有秘钥进行加密得到的签名字串， 这一段是最重要的敏感信息，只能在服务端解密；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(  </span><br><span class="line"> base64UrlEncode(Headers) + &quot;.&quot; +</span><br><span class="line">base64UrlEncode(Claims),</span><br><span class="line">SECREATE_KEY</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>编码之后的 JWT 看起来是这样的一串字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure><h2 id="OAuth-开放授权"><a href="#OAuth-开放授权" class="headerlink" title="OAuth(开放授权)"></a>OAuth(开放授权)</h2><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供 OAuth 认证服务的厂商有支付宝，QQ,微信。<br>OAuth 协议又有 1.0 和 2.0 两个版本。相比较 1.0 版，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。</p><p>假设是微信授权登录，OAuth 2.0 涉及的关键参与方有：</p><ul><li>Resource Owner：资源所有者。这里指微信用户。</li><li>Third-party application：第三方应用。这里指个人网站。。</li><li>Authorization server：授权服务器。这里指微信开放平台的授权服务。</li><li>Resource server：资源服务器，用来存储、获取用户资源。这里指的是微信开放平台的服务器。</li></ul><p>OAuth 的基本流程</p><p>OAuth2.0 主要包含两个关键步骤：</p><ol><li>第三方应用取得用户的授权</li><li>第三方应用访问用户资源</li></ol><p><img src="https://gitee.com/wangyuan0108/image/raw/master/blog/20210827071851.png" alt></p><p>如图所示，access token 的获取分为两步：</p><ol><li>获取授权码 code，这是临时授权凭证：步骤 A、B、C、D</li><li>通过 code 交换 access token，这是正式授权凭证：步骤 E、F<br>获取 access token 是重点</li></ol><p>1、请求用户授权<br>第三方应用，将资源所有者导向一个特定的地址，并在地址里带上如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response_type：必选，请求类型。这里固定为&quot;code&quot;。</span><br><span class="line">client_id：必选，标识第三方应用的id。很多地方也用apppid来代替。</span><br><span class="line">edirect_uri：可选，授权完成后重定向的地址。当取得用户授权后，授权服务会重定向到这个地址，并在地址里带上授权码。</span><br><span class="line">scope：可选，第三方请求的资源范围。比如是想获取基本信息、敏感信息等。</span><br><span class="line">state：推荐，用于状态保持，可以是任意字符串。授权服务会原封不动地返回。</span><br></pre></td></tr></table></figure><p>对于redirect_uri是可选的，大家可能会有疑惑。在实际中，redirect_uri 一般在应用后台就完成了填写和验证，因此可以是选填的。</p><p>2、用户授权返回<br>资源所有者，同意授权第三方应用访问受限资源后，请求返回，跳转到 redirect_uri 指定的地址。<br>地址中带了如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code：必选，授权码。后续步骤中，用来交换access token。</span><br><span class="line">state：必选（如果授权请求中，带上了state），这里原封不动地回传。</span><br></pre></td></tr></table></figure><p>3、请求 access token<br>第三方应用，向授权服务请求获取 access token。请求参数包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant_type：必选，许可类型，这里固定为“authorization_code”。</span><br><span class="line">code：必选，授权码。在用户授权步骤中，授权服务返回的。</span><br><span class="line">redirect_uri：必选，如果在授权请求步骤中，带上了redirect_uri，那么这里也必须带上，且值相同。</span><br><span class="line">client_id：必选，第三方应用id。</span><br></pre></td></tr></table></figure><p>4、返回 access token<br>请求合法且授权验证通过，那么授权服务将 access token 返回给第三方应用。<br>关键返回字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access token：必选，访问令牌，第三方应用访问用户资源的凭证。</span><br><span class="line">expires_in：推荐，access token的有效时长。</span><br><span class="line">refresh token：可选，更新access token的凭证。当access token过期，可以refresh token为凭证，获取新的access token。</span><br></pre></td></tr></table></figure><p>下图为微信统一登录的时序图：</p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/20211015153839.png" alt></p><p>步骤分解如下：</p><p>1、请求用户授权：步骤 2、3、4<br>带上 appid、redirect_uri、response_type、scope、state。其中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appid：应用id，就是前面提到的client_id。</span><br><span class="line">redirect_uri：授权回调的地址，在微信管理后台填写。</span><br><span class="line">response_type：响应类型，固定为&quot;code&quot;。</span><br><span class="line">scope：授权许可范围，固定为&quot;snsapi_login&quot;。</span><br><span class="line">state：可选，授权服务回传。</span><br></pre></td></tr></table></figure><p>2、用户授权返回：步骤 5<br>用户同意授权，重定向到 redirect_uri， 并返回临时票据 code。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect_uri?code=CODE&amp;state=STATE</span><br></pre></td></tr></table></figure><p>3、请求 access token<br>应用拿到临时票据后，用临时票据去换取真实票据 access token。所需参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appid：必选，应用id。</span><br><span class="line">secret：必选，应用秘钥，在微信后台生成。</span><br><span class="line">code：必选，前面获取的授权码。</span><br><span class="line">grant_type：必选，值固定为&quot;authorization_code&quot;</span><br></pre></td></tr></table></figure></p><p>4、返回 access token<br>微信后台经过验证，确认请求合法后，将 access token 返回给第三方应用。<br>返回例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span><br><span class="line">&quot;expires_in&quot;:7200,</span><br><span class="line">&quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">&quot;openid&quot;:&quot;OPENID&quot;,</span><br><span class="line">&quot;scope&quot;:&quot;SCOPE&quot;,</span><br><span class="line">&quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除前面提到的 access_token、refresh_token、expires_in，这里还返回了 openid、unionid，这两者是用户信息，微信体系特有的。</p><h2 id="sso（单点登录鉴权）"><a href="#sso（单点登录鉴权）" class="headerlink" title="sso（单点登录鉴权）"></a>sso（单点登录鉴权）</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在 web 开发中，鉴权是非常常用的。而且鉴权的方式也有很多种，有各自的优缺点和使用场景。这里笔者就对当下几种常用的鉴权手段进行一个整理，方便大家的学习巩固和自己的复习
    
    </summary>
    
      <category term="WEB 前端" scheme="https://water.buging.cn/categories/WEB-%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你需要知道的在小程序中使用cookie</title>
    <link href="https://water.buging.cn/2021/07/29/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8cookie/"/>
    <id>https://water.buging.cn/2021/07/29/你需要知道的在小程序中使用cookie/</id>
    <published>2021-07-29T23:19:50.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近由于项目需要，需要开发一个h5。然后这h5是内嵌到小程序中使用的，在小程序中的web-view使用h5也是遇到了一些问题，主要是cookie的共享问题，还有一些奇怪的现象，这里简单记录下，方便遇到同样问题的有个参考<a id="more"></a></p><p>小程序中的cookie是无法带到接口上的</p><p>由于受到web开发的思路影响，觉得只要设置了cookie，那么在请求的时候就会自动带上cookie。在写小程序的cookie鉴权的时候，当时也是这样想的，但是事实是虽然是可以写入cookie，不过在请求接口的时候并不会自动带上cookie。果然还是太年轻了。</p><h2 id="小程序请求如何带上cookie"><a href="#小程序请求如何带上cookie" class="headerlink" title="小程序请求如何带上cookie"></a>小程序请求如何带上cookie</h2><p>因为请求不能够自动带上cookie，那就没得办法只能手动把cookie存下来然后在写入到请求头中，让每个请求都带上cookie</p><p>这样小程序的每次接口请求就都带上了cookie和web端的请求自动带cookie就功能相同了</p><h2 id="web-view中的h5如何使用cookie达到同步鉴权"><a href="#web-view中的h5如何使用cookie达到同步鉴权" class="headerlink" title="web-view中的h5如何使用cookie达到同步鉴权"></a>web-view中的h5如何使用cookie达到同步鉴权</h2><p>按照正常思路，最好的方式就是h5中能够直接获取到小程序中的cookie。这样就简单了，但是小程序是不会让你如愿的。事实证明你在h5是无法拿到cookie。因为它们是两个独立的域，可以理解为小程序调用的是原生的能力，来发请求的，而且小程序的运行机制和web也不一样，web-view中的h5拿不到cookie倒是也能理解。然而小程序中的web-view和微信中直接打开的h5，因为用的是同一个浏览器内核，所以，它们的cookie、storage是可以共享的。</p><p>但是这个cookie是无论如何又需要共享的，所以还是要来解决这个问题。那没有办法，那就在跳转到web-view中页面的时候把小程序中的cookie作为url的参数传递过去，然后在h5中把cookie拿到，然后存储到cookie中。自此cookie共享就完成了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = `cookie=$&#123;history.location.query.cookie&#125;`;</span><br></pre></td></tr></table></figure><p>这样就把cookie共享搞定了。</p><h2 id="使用js-cookie库设置的cookie在web-view中不生效"><a href="#使用js-cookie库设置的cookie在web-view中不生效" class="headerlink" title="使用js-cookie库设置的cookie在web-view中不生效"></a>使用js-cookie库设置的cookie在web-view中不生效</h2><p>有简单的设置cookie的包，那就拿来用一下喽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add js-cookie</span><br><span class="line">​</span><br><span class="line">import cookies from &apos;js-cookie&apos;</span><br><span class="line">​</span><br><span class="line">cookies.set(&apos;key&apos;,value)</span><br></pre></td></tr></table></figure><p>这样cookie就设置成功了，h5在浏览器中使用也是生效的。但是当把h5接入到web-view中就出现问题了。看了下js-cookie的源码实现，发现也就多了加解码的过程保证字符串不改变，按道理是没有什么问题的。所以这里还是使用了原生的方式来写cookie，用这个库的老铁遇到这个问题可以先用原生的方法代替，具体为什么有知道的大佬告诉我一下，我也在找找是什么原因</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>大概记录下小程序和web-view共享cookie遇到的问题和解决方法，对自己是个记录，希望对你有所帮助，欢迎点赞！！！谢谢！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近由于项目需要，需要开发一个h5。然后这h5是内嵌到小程序中使用的，在小程序中的web-view使用h5也是遇到了一些问题，主要是cookie的共享问题，还有一些奇怪的现象，这里简单记录下，方便遇到同样问题的有个参考
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="小程序" scheme="https://water.buging.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用umijs开发移动端h5</title>
    <link href="https://water.buging.cn/2021/07/05/%E4%BD%BF%E7%94%A8umijs%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AFh5/"/>
    <id>https://water.buging.cn/2021/07/05/使用umijs开发移动端h5/</id>
    <published>2021-07-05T10:53:11.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于最近业务原因，需要开发一些移动端h5页面。之前是使用vue技术栈开发，这里因为一些原因需要使用react技术栈开发，在后台系统方面这里选择的是umijs作为开发框架。所以在h5开发的也选用umijs来进行开发，这里记录下框架搭建的基础过程，方便直接使用，少走弯路<a id="more"></a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>首先得有 <a href="https://nodejs.org/en/" rel="external nofollow noopener noreferrer" target="_blank">node</a>，并确保 node 版本是 10.13 或以上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">v10.13.0</span><br></pre></td></tr></table></figure><h4 id="使用脚手架创建"><a href="#使用脚手架创建" class="headerlink" title="使用脚手架创建"></a>使用脚手架创建</h4><ul><li>先创建一个目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir myapp &amp;&amp; cd myapp</span><br></pre></td></tr></table></figure><ul><li>通过脚手架创建项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yarn create @umijs/umi-app</span><br><span class="line"># 或 npx @umijs/create-umi-app</span><br><span class="line"></span><br><span class="line">Copy:  .editorconfig</span><br><span class="line">Write: .gitignore</span><br><span class="line">Copy:  .prettierignore</span><br><span class="line">Copy:  .prettierrc</span><br><span class="line">Write: .umirc.ts</span><br><span class="line">Copy:  mock/.gitkeep</span><br><span class="line">Write: package.json</span><br><span class="line">Copy:  README.md</span><br><span class="line">Copy:  src/pages/index.less</span><br><span class="line">Copy:  src/pages/index.tsx</span><br><span class="line">Copy:  tsconfig.json</span><br><span class="line">Copy:  typings.d.ts</span><br></pre></td></tr></table></figure><ul><li>安装依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br><span class="line"></span><br><span class="line">yarn install v1.21.1</span><br><span class="line">[1/4] 🔍  Resolving packages...</span><br><span class="line">success Already up-to-date.</span><br><span class="line">✨  Done in 0.71s.</span><br></pre></td></tr></table></figure><ul><li>启动项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br><span class="line"></span><br><span class="line">Starting the development server...</span><br><span class="line"></span><br><span class="line">✔ Webpack</span><br><span class="line">  Compiled successfully in 17.84s</span><br><span class="line"></span><br><span class="line"> DONE  Compiled successfully in 17842ms                                       8:06:31 PM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  App running at:</span><br><span class="line">  - Local:   http://localhost:8000 (copied to clipboard)</span><br><span class="line">  - Network: http://192.168.12.34:8000</span><br></pre></td></tr></table></figure><h2 id="配置h5相关"><a href="#配置h5相关" class="headerlink" title="配置h5相关"></a>配置h5相关</h2><h4 id="配置移动端适配"><a href="#配置移动端适配" class="headerlink" title="配置移动端适配"></a>配置移动端适配</h4><p>这里使用的是rem适配的方案，这个适配也可以改成其他的比如vw合vh。大家自行百度，就不多说了。rem适配的方案需要安装<code>amfe-flexible</code>和<code>postcss-pxtorem</code>。 前一个是用来缩放根节点字体大小的，后面一个是对css的px单位进行转换成对应的rem单位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add amfe-flexible</span><br><span class="line">yarn add postcss-pxtorem --dev</span><br></pre></td></tr></table></figure><p>然后在global.js中引入amfe-flexible</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;amfe-flexible/index&apos;</span><br></pre></td></tr></table></figure><p>global.js这个文件是全局的js文件，详细说明请参看umijs的文档</p><p>在使用postcss-pxtorem插件的时候需要配置转换的参考基数，大部分是以750px的设计稿来作为参考，这里就写下750px作为参考的配置，在umijs的配置文件.umirc.js中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extraPostCSSPlugins: [</span><br><span class="line">    pxtorem(&#123;</span><br><span class="line">      rootValue: <span class="number">75</span>, <span class="comment">// 换算的基数</span></span><br><span class="line">      <span class="comment">// 忽略转换正则匹配项。插件会转化所有的样式的px。比如引入了三方UI，也会被转化。目前我使用 selectorBlackList字段，来过滤</span></span><br><span class="line">      <span class="comment">//如果个别地方不想转化px。可以简单的使用大写的 PX 或 Px 。</span></span><br><span class="line">      <span class="comment">// selectorBlackList: ["am"],</span></span><br><span class="line">      exclude: <span class="regexp">/node_modules/i</span>,</span><br><span class="line">      propList: [<span class="string">'*'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><h4 id="ui库"><a href="#ui库" class="headerlink" title="ui库"></a>ui库</h4><p>移动端的ui库也没有多少，大家可以选用自己喜欢的。这里umijs中集成了antd-mobile，所以就直接使用这个库了。</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>本地开发需要配置代理，在配置文件.umirc.js中进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    &apos;/api&apos;: &#123;</span><br><span class="line">      target: &apos;http:/www.baidu.com/&apos;,</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">      pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="调试日志"><a href="#调试日志" class="headerlink" title="调试日志"></a>调试日志</h4><p>由于移动端h5要在移动端打开进行调试，所以调试起来如果看不到日志也是非常麻烦的。这里使用vconsole库让移动端显示出调试日志</p><ul><li>安装vconsole</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vconsole --dev</span><br></pre></td></tr></table></figure><ul><li>使用vconsole</li></ul><p>在global.js中实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import VConsole from &apos;vconsole&apos;;</span><br><span class="line">new VConsole();</span><br></pre></td></tr></table></figure><h4 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h4><p>如果直接是部署在服务器根路径，直接打包生成dist目录就行了。如果不是根目录还需要添加一些配置如下，在.umirc.js中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据环境进行区分</span></span><br><span class="line">publicPath: process.env.NODE_ENV === <span class="string">'development'</span> ? <span class="string">'/'</span> : <span class="string">'/h5/'</span>,</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以上步骤，一个简单的umijs开发h5的基础框架就算完成了，可以进行业务开发了，希望对大家有帮助，觉得有帮助的给个赞，谢谢！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;由于最近业务原因，需要开发一些移动端h5页面。之前是使用vue技术栈开发，这里因为一些原因需要使用react技术栈开发，在后台系统方面这里选择的是umijs作为开发框架。所以在h5开发的也选用umijs来进行开发，这里记录下框架搭建的基础过程，方便直接使用，少走弯路
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="umijs" scheme="https://water.buging.cn/tags/umijs/"/>
    
  </entry>
  
  <entry>
    <title>你需要知道的vue开发公众号网页</title>
    <link href="https://water.buging.cn/2021/05/11/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84vue%E5%BC%80%E5%8F%91%E5%85%AC%E4%BC%97%E5%8F%B7%E7%BD%91%E9%A1%B5/"/>
    <id>https://water.buging.cn/2021/05/11/你需要知道的vue开发公众号网页/</id>
    <published>2021-05-11T17:27:53.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>因为项目需要，近期做了一个公众号网页开发。在此期间也踩了一些坑，解决这些坑之后，准备对这个项目进行复盘。记录下项目从开发到上线所解决的问题，并对使用vue进行公众号开发的步骤进行一个总结。方便以后有问题进行查阅。希望对你有所帮助<a id="more"></a></p><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>主要就是一个h5页面，涉及的功能不是很难，主要很久没有开发公众号，对整个开发步骤有些生疏。其中包括对微信sdk的调用方式、用户的微信授权和sdk的接入等。主要围绕开发步骤进行梳理。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>因为是一个h5页面，整体而言项目不大，然后在项目技术选型的时候确定使用vue框架进行开发。使用vue开发h5，个人整体感觉还是效率比较高的。在ui库方面选择的是vant库，组件整体而言还是不错的，支持自定义主题方便样式自定义比较适合h5的开发。</p><h2 id="通过vue-cli创建项目"><a href="#通过vue-cli创建项目" class="headerlink" title="通过vue-cli创建项目"></a>通过vue-cli创建项目</h2><p>安装脚手架工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"># OR</span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure></p><p>创建一个项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create water_project</span><br></pre></td></tr></table></figure></p><p>然后就创建了项目目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── jsconfig.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   └── index.html</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   ├── api</span><br><span class="line">│   ├── assets</span><br><span class="line">│   ├── components</span><br><span class="line">│   ├── global.less</span><br><span class="line">│   ├── main.js</span><br><span class="line">│   ├── mock</span><br><span class="line">│   ├── router</span><br><span class="line">│   ├── store</span><br><span class="line">│   ├── utils</span><br><span class="line">│   └── views</span><br><span class="line">└── vue.config.js</span><br></pre></td></tr></table></figure></p><h2 id="关于移动的适配"><a href="#关于移动的适配" class="headerlink" title="关于移动的适配"></a>关于移动的适配</h2><p>因为是移动端网页，所以需要做适配。网上有很多适配方案这里就不展开说了，主要说下本项目使用的方案是<code>amfe-flexible</code>结合<code>rem</code>来做的，是淘宝的一种解决方案。关于设计稿的单位<code>px</code>转换为<code>rem</code>使用的是<code>postcss</code>的<code>postcss-pxtorem</code>方案。其实用<code>webpack</code>的<code>loader</code>来做也是可以的，具体方案自行百度。</p><ol><li>安装<code>amfe-flexible</code>包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i amfe-flexible -S</span><br></pre></td></tr></table></figure><ol start="2"><li>安装<code>postcss-pxtorem</code>插件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i postcss-pxtorem -D</span><br></pre></td></tr></table></figure><ol start="3"><li>在main.js中引入<code>amfe-flexible</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"amfe-flexible"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在vue.config.js中配置postcss插件</li></ol><p>项目中如果没有vue.config.js文件就手动创建一个，这个是vue cli的配置文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      postcss: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">          autoprefixer(),</span><br><span class="line">          pxtorem(&#123;</span><br><span class="line">            rootValue: <span class="number">37.5</span>,</span><br><span class="line">            propList: [<span class="string">"*"</span>],</span><br><span class="line">          &#125;),</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>到此样式适配已经完成，至于rootValue为什么是37.5.主要是为了vant的适配，所以设计稿以375px为参考。如果没有使用第三方ui库可以设计稿以750为参考，此时rootValue为75。</p><h2 id="使用-normalize-css"><a href="#使用-normalize-css" class="headerlink" title="使用 normalize.css"></a>使用 normalize.css</h2><p>使用normalize.css来消除浏览器之间的基础样式差异</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i normalize.css -S</span><br></pre></td></tr></table></figure><p>在<code>main.js</code>中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"normalize.css"</span></span><br></pre></td></tr></table></figure><h2 id="接入vant库"><a href="#接入vant库" class="headerlink" title="接入vant库"></a>接入vant库</h2><p>vant是有赞出品的一个ui库，站在巨人的肩膀上效率当然是要快很多。这种第三方库只能作为基础，在有设计稿的情况下要对样式进行定制。简单的样式vant都支持主题定制化还是比较方便的，如果有一些样式没有提供自定义主题，就只能写样式进行覆盖了。</p><ul><li>下载安装vant</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vant -S</span><br></pre></td></tr></table></figure><ul><li>引入组件有3种方式，官网也有介绍，<a href="https://vant-contrib.gitee.io/vant/#/zh-CN/quickstart" rel="external nofollow noopener noreferrer" target="_blank">详情可以查看官网</a>，简单说下使用方式：</li></ul><h3 id="方式一-自动按需引入组件-推荐"><a href="#方式一-自动按需引入组件-推荐" class="headerlink" title="方式一. 自动按需引入组件 (推荐)"></a>方式一. 自动按需引入组件 (推荐)</h3><p><a href="https://github.com/ant-design/babel-plugin-import" rel="external nofollow noopener noreferrer" target="_blank">babel-plugin-import</a> 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装插件</span></span><br><span class="line">npm i babel-plugin-import -D</span><br><span class="line">// 在.babelrc 中添加配置</span><br><span class="line">// 注意：webpack 1 无需设置 libraryDirectory</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>, &#123;</span><br><span class="line">      <span class="string">"libraryName"</span>: <span class="string">"vant"</span>,</span><br><span class="line">      <span class="string">"libraryDirectory"</span>: <span class="string">"es"</span>,</span><br><span class="line">      <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对于使用 babel7 的用户，可以在 babel.config.js 中配置</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [<span class="string">'import'</span>, &#123;</span><br><span class="line">      libraryName: <span class="string">'vant'</span>,</span><br><span class="line">      libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">      style: <span class="literal">true</span></span><br><span class="line">    &#125;, <span class="string">'vant'</span>]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接着你可以在代码中直接引入 Vant 组件</span></span><br><span class="line"><span class="comment">// 插件会自动将代码转化为方式二中的按需引入形式</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'vant'</span>;</span><br></pre></td></tr></table></figure><h3 id="方式二-手动按需引入组件"><a href="#方式二-手动按需引入组件" class="headerlink" title="方式二. 手动按需引入组件"></a>方式二. 手动按需引入组件</h3><p>在不使用插件的情况下，可以手动引入需要的组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'vant/lib/button'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/button/style'</span>;</span><br></pre></td></tr></table></figure><h3 id="方式三-导入所有组件"><a href="#方式三-导入所有组件" class="headerlink" title="方式三. 导入所有组件"></a>方式三. 导入所有组件</h3><p>Vant 支持一次性导入所有组件，引入所有组件会增加代码包体积，因此不推荐这种做法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vant <span class="keyword">from</span> <span class="string">'vant'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/index.css'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vant);</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 配置按需引入后，将不允许直接导入所有组件。</p></blockquote><h2 id="定制vant主题"><a href="#定制vant主题" class="headerlink" title="定制vant主题"></a>定制vant主题</h2><h3 id="步骤一-引入样式源文件"><a href="#步骤一-引入样式源文件" class="headerlink" title="步骤一 引入样式源文件"></a>步骤一 引入样式源文件</h3><p>定制主题时，需要引入组件对应的 Less 样式文件，支持按需引入和手动引入两种方式。</p><h4 id="按需引入样式（推荐）"><a href="#按需引入样式（推荐）" class="headerlink" title="按需引入样式（推荐）"></a>按需引入样式（推荐）</h4><p>在 babel.config.js 中配置按需引入样式源文件，注意 babel6 不支持按需引入样式，请手动引入样式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'import'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: <span class="string">'vant'</span>,</span><br><span class="line">        libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">        <span class="comment">// 指定样式路径</span></span><br><span class="line">        style: <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>/style/less`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'vant'</span>,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="手动引入样式"><a href="#手动引入样式" class="headerlink" title="手动引入样式"></a>手动引入样式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入全部样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/index.less'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入单个组件样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/button/style/less'</span>;</span><br></pre></td></tr></table></figure><h3 id="步骤二-修改样式变量"><a href="#步骤二-修改样式变量" class="headerlink" title="步骤二 修改样式变量"></a>步骤二 修改样式变量</h3><p>使用 Less 提供的 <a href="http://lesscss.org/usage/#using-less-in-the-browser-modify-variables" rel="external nofollow noopener noreferrer" target="_blank">modifyVars</a> 即可对变量进行修改，下面是参考的 webpack 配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="comment">// ...其他 loader 配置</span></span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'less-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            <span class="comment">// 若 less-loader 版本小于 6.0，请移除 lessOptions 这一级，直接配置选项。</span></span><br><span class="line">            lessOptions: &#123;</span><br><span class="line">              modifyVars: &#123;</span><br><span class="line">                <span class="comment">// 直接覆盖变量</span></span><br><span class="line">                <span class="string">'text-color'</span>: <span class="string">'#111'</span>,</span><br><span class="line">                <span class="string">'border-color'</span>: <span class="string">'#eee'</span>,</span><br><span class="line">                <span class="comment">// 或者可以通过 less 文件覆盖（文件路径为绝对路径）</span></span><br><span class="line">                hack: <span class="string">`true; @import "your-less-file-path.less";`</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 vue-cli 搭建的项目，可以在 <code>vue.config.js</code> 中进行配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      less: &#123;</span><br><span class="line">        <span class="comment">// 若 less-loader 版本小于 6.0，请移除 lessOptions 这一级，直接配置选项。</span></span><br><span class="line">        lessOptions: &#123;</span><br><span class="line">          modifyVars: &#123;</span><br><span class="line">            <span class="comment">// 直接覆盖变量</span></span><br><span class="line">            <span class="string">'text-color'</span>: <span class="string">'#111'</span>,</span><br><span class="line">            <span class="string">'border-color'</span>: <span class="string">'#eee'</span>,</span><br><span class="line">            <span class="comment">// 或者可以通过 less 文件覆盖（文件路径为绝对路径）</span></span><br><span class="line">            hack: <span class="string">`true; @import "your-less-file-path.less";`</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="引入微信jssdk"><a href="#引入微信jssdk" class="headerlink" title="引入微信jssdk"></a>引入微信jssdk</h2><p>引入jsssdk有两种方式，一种是用js链接直接引入，写在index.html中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://res2.wx.qq.com/open/js/jweixin-1.6.0.js "</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在使用的地方就调用window.wx.xxx就能使用sdk提供的方法了。</p><p>第二种就是使用npm包的方式</p><ul><li>安装weixin-js-sdk</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i weixin-js-sdk -S</span><br></pre></td></tr></table></figure><ul><li>在main.js中使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx <span class="keyword">from</span> <span class="string">"weixin-js-sdk"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂在vue的原型上方便使用</span></span><br><span class="line">Vue.prototype.$wx = wx;</span><br></pre></td></tr></table></figure><p>这样引入之后就可以用this.$wx.xx来使用相应的方法了比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$wx.config(&#123;</span><br><span class="line">         debug: <span class="literal">false</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">         appId: res.data.appId, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">         timestamp: <span class="built_in">String</span>(res.data.timestamp), <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">         nonceStr: <span class="built_in">String</span>(res.data.nonceStr), <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">         signature: res.data.signature, <span class="comment">// 必填，签名，见附录1</span></span><br><span class="line">         jsApiList: [</span><br><span class="line">           <span class="string">"getNetworkType"</span>,</span><br><span class="line">           <span class="string">"getLocation"</span>,</span><br><span class="line">         ], <span class="comment">// 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span></span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h3 id="注册验证sdk才可以使用api"><a href="#注册验证sdk才可以使用api" class="headerlink" title="注册验证sdk才可以使用api"></a>注册验证sdk才可以使用api</h3><p>其实注册的重要逻辑都在后端，提供一个获取配置信息的接口，前端直接调用sdk的config方法进行注册就好了。这里把sdk的注册逻辑写在app.vue文件中</p><ul><li>封装一个注册sdk的方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> getWxJssdkConf() &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.$api.getSdkConfig(&#123;</span><br><span class="line">        url: <span class="built_in">window</span>.location.href.split(<span class="string">"#"</span>)[<span class="number">0</span>],</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$wx.config(&#123;</span><br><span class="line">          debug: <span class="literal">false</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">          appId: res.data.appId, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">          timestamp: <span class="built_in">String</span>(res.data.timestamp), <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">          nonceStr: <span class="built_in">String</span>(res.data.nonceStr), <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">          signature: res.data.signature, <span class="comment">// 必填，签名，见附录1</span></span><br><span class="line">          jsApiList: [</span><br><span class="line">            <span class="string">"getNetworkType"</span>,</span><br><span class="line">            <span class="string">"getLocation"</span>,</span><br><span class="line">          ], <span class="comment">// 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.$wx.ready(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.$wx.checkJsApi(&#123;</span><br><span class="line">            jsApiList: [<span class="string">"getNetworkType"</span>, <span class="string">"getLocation"</span>], <span class="comment">// 需要检测的JS接口列表，所有JS接口列表见附录2,</span></span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">"checkJsApi"</span>, res);</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.$wx.error(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"wx.error"</span>, res);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getWxJssdkConf();</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>其中<code>this.$api.getSdkConfig</code>为调用后台的接口，这里是给api也挂载到了vue的原型上，方便使用不用每个页面都去引入api</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$api = api</span><br></pre></td></tr></table></figure><p>在app.vue中注册成功后，就可以使用sdk的api了。</p><h2 id="微信的授权"><a href="#微信的授权" class="headerlink" title="微信的授权"></a>微信的授权</h2><p>如果要获取用户的信息，就必须让用户进行授权。在授权的时候使用的是微信提供的接口，<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html" rel="external nofollow noopener noreferrer" target="_blank">详细请看这里</a>，如果是只获取用户的openid只用静默授权就可以了，不用用户主动授权。具体请看文档，这里只需要openid就使用静默授权如下：</p><ul><li>在需要授权的主入口使用，比如这里是主页Home，要先调用微信的接口获取code，在用code去后端换取openid</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: 获取授权code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getCode() &#123;</span><br><span class="line">      <span class="comment">// 从 window.location.href 中截取 code 并且赋值</span></span><br><span class="line">      <span class="comment">// window.location.href.split('#')[0]</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.location.href.indexOf(<span class="string">"state"</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = qs.parse(</span><br><span class="line">          <span class="built_in">window</span>.location.href.split(<span class="string">"#"</span>)[<span class="number">0</span>].split(<span class="string">"?"</span>)[<span class="number">1</span>]</span><br><span class="line">        ).code;</span><br><span class="line">      &#125; </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.code) &#123;</span><br><span class="line">          <span class="comment">// 存在 code 直接调用接口</span></span><br><span class="line">          <span class="keyword">this</span>.handGetUserInfo(<span class="keyword">this</span>.code);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.handLogin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: 获取用户授权登陆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    handLogin() &#123;</span><br><span class="line">      <span class="comment">// 重定向地址重定到当前页面，在路径获取 code</span></span><br><span class="line">      <span class="keyword">const</span> hrefUrl = <span class="built_in">window</span>.location.href;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.code === <span class="string">""</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.location.replace(<span class="string">`</span></span><br><span class="line"><span class="string">https://open.weixin.qq.com/connect/oauth2/authorize</span></span><br><span class="line"><span class="string">?appid=XXXXXXXX</span></span><br><span class="line"><span class="string">&amp;redirect_uri=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(hrefUrl)&#125;</span></span></span><br><span class="line"><span class="string">&amp;response_type=code</span></span><br><span class="line"><span class="string">&amp;scope=snsapi_base</span></span><br><span class="line"><span class="string">&amp;state=h5#wechat_redirect</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">code</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    handGetUserInfo(code) &#123;</span><br><span class="line">      <span class="comment">// 调用后台接口</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>这里就是授权的主要逻辑，没啥意外就基本走通了。</p><h2 id="断网进行提示"><a href="#断网进行提示" class="headerlink" title="断网进行提示"></a>断网进行提示</h2><p>如果用户的网络断了，就跳转到断网提示页。主要使用的是html提供的方法进行判断，判断逻辑写在app.vue文件中，因为每个页面都会提示，就直接在主入口进行处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"online"</span>, <span class="keyword">this</span>.updateOnlineStatus);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"offline"</span>, <span class="keyword">this</span>.updateOnlineStatus);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line"> methods: &#123;</span><br><span class="line"> updateOnlineStatus(e) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; type &#125; = e;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"type=============="</span>, type);</span><br><span class="line">      <span class="keyword">this</span>.onLine = type === <span class="string">"online"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> beforeDestroy() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">"online"</span>, <span class="keyword">this</span>.updateOnlineStatus);</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">"offline"</span>, <span class="keyword">this</span>.updateOnlineStatus);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>主要就是这个方法来检查用户网络连接情况</p><h2 id="判断是不是微信打开的网页"><a href="#判断是不是微信打开的网页" class="headerlink" title="判断是不是微信打开的网页"></a>判断是不是微信打开的网页</h2><p>这里主要使用的是vue-router的导航守卫来做的，在跳转之前对浏览器进行判断，如果不是微信内置浏览器就直接跳转到异常提示页</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ua = navigator.userAgent.toLowerCase();</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    to.path !== <span class="string">"/notwx"</span> &amp;&amp;</span><br><span class="line">    !(ua.match(<span class="regexp">/MicroMessenger/i</span>) == <span class="string">"micromessenger"</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    next(<span class="string">"/notwx"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有时跳转页面，页面的滚动高度会保留在上个页面的滚动高度，这里也是在导航守卫中解决的，主动给滚动到顶部</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此整个开发流程简单记录完毕，也是对自己开发的一个梳理，也方便以后查阅。希望对看到文章的你有所帮助，个人见解，如有问题欢迎指正，觉得有帮助，欢迎点个赞，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;因为项目需要，近期做了一个公众号网页开发。在此期间也踩了一些坑，解决这些坑之后，准备对这个项目进行复盘。记录下项目从开发到上线所解决的问题，并对使用vue进行公众号开发的步骤进行一个总结。方便以后有问题进行查阅。希望对你有所帮助
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://water.buging.cn/tags/vue/"/>
    
      <category term="微信" scheme="https://water.buging.cn/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>你需要知道的36道js手写</title>
    <link href="https://water.buging.cn/2021/04/08/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8436%E9%81%93js%E6%89%8B%E5%86%99/"/>
    <id>https://water.buging.cn/2021/04/08/你需要知道的36道js手写/</id>
    <published>2021-04-08T09:54:24.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="为什么要写这类文章"><a href="#为什么要写这类文章" class="headerlink" title="为什么要写这类文章"></a>为什么要写这类文章</h3><p>作为一个程序员，代码能力毋庸置疑是非常非常重要的，就像现在为什么大厂面试基本都问什么 API 怎么实现可见其重要性。我想说的是居然手写这么重要，那我们就必须掌握它，所以文章标题用了死磕，一点也不过分，也希望不被认为是标题党。</p><p>作为一个普通前端，我是真的写不出 Promise A+ 规范，但是没关系，我们可以站在巨人的肩膀上，要相信我们现在要走的路，前人都走过，所以可以找找现在社区已经存在的那些优秀的文章，比如工业聚大佬写的 100 行代码实现 Promises/A+ 规范，找到这些文章后不是收藏夹吃灰，得找个时间踏踏实实的学，一行一行的磨，直到搞懂为止。我现在就是这么干的。<a id="more"></a></p><h3 id="能收获什么"><a href="#能收获什么" class="headerlink" title="能收获什么"></a>能收获什么</h3><p>这篇文章总体上分为 2 类手写题，前半部分可以归纳为是常见需求，后半部分则是对现有技术的实现；</p><ul><li>对常用的需求进行手写实现，比如数据类型判断函数、深拷贝等可以直接用于往后的项目中，提高了项目开发效率；</li><li>对现有关键字和 API 的实现，可能需要用到别的知识或 API，比如在写 forEach 的时候用到了无符号位右移的操作，平时都不怎么能够接触到这玩意，现在遇到了就可以顺手把它掌握了。所以手写这些实现能够潜移默化的扩展并巩固自己的 JS 基础；</li><li>通过写各种测试用例，你会知道各种 API 的边界情况，比如 Promise.all， 你得考虑到传入参数的各种情况，从而加深了对它们的理解及使用；<h3 id="阅读的时候需要做什么"><a href="#阅读的时候需要做什么" class="headerlink" title="阅读的时候需要做什么"></a>阅读的时候需要做什么</h3></li></ul><p>阅读的时候，你需要把每行代码都看懂，知道它在干什么，为什么要这么写，能写得更好嘛？比如在写图片懒加载的时候，一般我们都是根据当前元素的位置和视口进行判断是否要加载这张图片，普通程序员写到这就差不多完成了。而大佬程序员则是会多考虑一些细节的东西，比如性能如何更优？代码如何更精简？比如 yeyan1996 写的图片懒加载就多考虑了 2 点：比如图片全部加载完成的时候得把事件监听给移除；比如加载完一张图片的时候，得把当前 img 从 imgList 里移除，起到优化内存的作用。</p><p>除了读通代码之外，还可以打开 Chrome 的 Script snippet 去写测试用例跑跑代码，做到更好的理解以及使用。</p><p>在看了几篇以及写了很多测试用例的前提下，尝试自己手写实现，看看自己到底掌握了多少。条条大路通罗马，你还能有别的方式实现嘛？或者你能写得比别人更好嘛？</p><p>好了，还楞着干啥，开始干活。</p><h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><p>typeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function typeOf(obj) &#123;</span><br><span class="line">-   let res = Object.prototype.toString.call(obj).split(&apos; &apos;)[1]</span><br><span class="line">-   res = res.substring(0, res.length - 1).toLowerCase()</span><br><span class="line">-   return res</span><br><span class="line">// 评论区里提到的更好的写法</span><br><span class="line">+   return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line">typeOf([])        // &apos;array&apos;</span><br><span class="line">typeOf(&#123;&#125;)        // &apos;object&apos;</span><br><span class="line">typeOf(new Date)  // &apos;date&apos;</span><br></pre></td></tr></table></figure></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Animal() &#123;</span><br><span class="line">    this.colors = [&apos;black&apos;, &apos;white&apos;]</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getColor = function() &#123;</span><br><span class="line">    return this.colors</span><br><span class="line">&#125;</span><br><span class="line">function Dog() &#123;&#125;</span><br><span class="line">Dog.prototype =  new Animal()</span><br><span class="line"></span><br><span class="line">let dog1 = new Dog()</span><br><span class="line">dog1.colors.push(&apos;brown&apos;)</span><br><span class="line">let dog2 = new Dog()</span><br><span class="line">console.log(dog2.colors)  // [&apos;black&apos;, &apos;white&apos;, &apos;brown&apos;]</span><br></pre></td></tr></table></figure><p>原型链继承存在的问题：</p><p>问题1：原型中包含的引用类型属性将被所有实例共享；<br>问题2：子类在实例化的时候不能给父类构造函数传参；</p><h3 id="借用构造函数实现继承"><a href="#借用构造函数实现继承" class="headerlink" title="借用构造函数实现继承"></a>借用构造函数实现继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.getName = function() &#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Dog(name) &#123;</span><br><span class="line">    Animal.call(this, name)</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype =  new Animal()</span><br></pre></td></tr></table></figure><p>借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.colors = [&apos;black&apos;, &apos;white&apos;]</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getName = function() &#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">function Dog(name, age) &#123;</span><br><span class="line">    Animal.call(this, name)</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype =  new Animal()</span><br><span class="line">Dog.prototype.constructor = Dog</span><br><span class="line"></span><br><span class="line">let dog1 = new Dog(&apos;奶昔&apos;, 2)</span><br><span class="line">dog1.colors.push(&apos;brown&apos;)</span><br><span class="line">let dog2 = new Dog(&apos;哈赤&apos;, 1)</span><br><span class="line">console.log(dog2) </span><br><span class="line">// &#123; name: &quot;哈赤&quot;, colors: [&quot;black&quot;, &quot;white&quot;], age: 1 &#125;</span><br></pre></td></tr></table></figure></p><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承已经相对完善了，但还是存在问题，它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。</p><p>所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。</p><p>寄生式组合继承写法上和组合继承基本类似，区别是如下这里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Dog.prototype =  new Animal()</span><br><span class="line">- Dog.prototype.constructor = Dog</span><br><span class="line"></span><br><span class="line">+ function F() &#123;&#125;</span><br><span class="line">+ F.prototype = Animal.prototype</span><br><span class="line">+ let f = new F()</span><br><span class="line">+ f.constructor = Dog</span><br><span class="line">+ Dog.prototype = f</span><br></pre></td></tr></table></figure></p><p>稍微封装下上面添加的代码后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = o</span><br><span class="line">    return new F()</span><br><span class="line">&#125;</span><br><span class="line">function inheritPrototype(child, parent) &#123;</span><br><span class="line">    let prototype = object(parent.prototype)</span><br><span class="line">    prototype.constructor = child</span><br><span class="line">    child.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Dog, Animal)</span><br></pre></td></tr></table></figure></p><p>如果你嫌弃上面的代码太多了，还可以基于组合继承的代码改成最简单的寄生式组合继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- Dog.prototype =  new Animal()</span><br><span class="line">- Dog.prototype.constructor = Dog</span><br><span class="line"></span><br><span class="line">+ Dog.prototype =  Object.create(Animal.prototype)</span><br><span class="line">+ Dog.prototype.constructor = Dog</span><br></pre></td></tr></table></figure></p><h3 id="class-实现继承"><a href="#class-实现继承" class="headerlink" title="class 实现继承"></a>class 实现继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125; </span><br><span class="line">    getName() &#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        super(name)</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>ES5 实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var res = arr.filter(function(item, index, array) &#123;</span><br><span class="line">        return array.indexOf(item) === index</span><br><span class="line">    &#125;)</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ES6 实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var unique = arr =&gt; [...new Set(arr)]</span><br></pre></td></tr></table></figure></p><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, [2, [3]]].flat(2)  // [1, 2, 3]</span><br></pre></td></tr></table></figure></p><p>现在就是要实现 flat 这种效果。</p><p>ES5 实现：递归。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function flatten(arr) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (Array.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ES6 实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function flatten(arr) &#123;</span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>浅拷贝：只考虑对象类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function shallowCopy(obj) &#123;</span><br><span class="line">    if (typeof obj !== &apos;object&apos;) return</span><br><span class="line">    </span><br><span class="line">    let newObj = obj instanceof Array ? [] : &#123;&#125;</span><br><span class="line">    for (let key in obj) &#123;</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单版深拷贝：只考虑普通对象属性，不考虑内置对象和函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">    if (typeof obj !== &apos;object&apos;) return;</span><br><span class="line">    var newObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">    for (var key in obj) &#123;</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = typeof obj[key] === &apos;object&apos; ? deepClone(obj[key]) : obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂版深克隆：基于简单版的基础上，还考虑了内置对象比如 Date、RegExp 等对象和函数以及解决了循环引用的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const isObject = (target) =&gt; (typeof target === &quot;object&quot; || typeof target === &quot;function&quot;) &amp;&amp; target !== null;</span><br><span class="line"></span><br><span class="line">function deepClone(target, map = new WeakMap()) &#123;</span><br><span class="line">    if (map.get(target)) &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取当前值的构造函数：获取它的类型</span><br><span class="line">    let constructor = target.constructor;</span><br><span class="line">    // 检测当前对象target是否与正则、日期格式对象匹配</span><br><span class="line">    if (/^(RegExp|Date)$/i.test(constructor.name)) &#123;</span><br><span class="line">        // 创建一个新的特殊对象(正则类/日期类)的实例</span><br><span class="line">        return new constructor(target);  </span><br><span class="line">    &#125;</span><br><span class="line">    if (isObject(target)) &#123;</span><br><span class="line">        map.set(target, true);  // 为循环引用的对象做标记</span><br><span class="line">        const cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        for (let prop in target) &#123;</span><br><span class="line">            if (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">                cloneTarget[prop] = deepClone(target[prop], map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cloneTarget;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="事件总线（发布订阅模式）"><a href="#事件总线（发布订阅模式）" class="headerlink" title="事件总线（发布订阅模式）"></a>事件总线（发布订阅模式）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class EventEmitter &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.cache = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    on(name, fn) &#123;</span><br><span class="line">        if (this.cache[name]) &#123;</span><br><span class="line">            this.cache[name].push(fn)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.cache[name] = [fn]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    off(name, fn) &#123;</span><br><span class="line">        let tasks = this.cache[name]</span><br><span class="line">        if (tasks) &#123;</span><br><span class="line">            const index = tasks.findIndex(f =&gt; f === fn || f.callback === fn)</span><br><span class="line">            if (index &gt;= 0) &#123;</span><br><span class="line">                tasks.splice(index, 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    emit(name, once = false, ...args) &#123;</span><br><span class="line">        if (this.cache[name]) &#123;</span><br><span class="line">            // 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span><br><span class="line">            let tasks = this.cache[name].slice()</span><br><span class="line">            for (let fn of tasks) &#123;</span><br><span class="line">                fn(...args)</span><br><span class="line">            &#125;</span><br><span class="line">            if (once) &#123;</span><br><span class="line">                delete this.cache[name]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">let eventBus = new EventEmitter()</span><br><span class="line">let fn1 = function(name, age) &#123;</span><br><span class="line">console.log(`$&#123;name&#125; $&#123;age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">let fn2 = function(name, age) &#123;</span><br><span class="line">console.log(`hello, $&#123;name&#125; $&#123;age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">eventBus.on(&apos;aaa&apos;, fn1)</span><br><span class="line">eventBus.on(&apos;aaa&apos;, fn2)</span><br><span class="line">eventBus.emit(&apos;aaa&apos;, false, &apos;布兰&apos;, 12)</span><br><span class="line">// &apos;布兰 12&apos;</span><br><span class="line">// &apos;hello, 布兰 12&apos;</span><br></pre></td></tr></table></figure><h2 id="解析-URL-参数为对象"><a href="#解析-URL-参数为对象" class="headerlink" title="解析 URL 参数为对象"></a>解析 URL 参数为对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function parseParam(url) &#123;</span><br><span class="line">    const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来</span><br><span class="line">    const paramsArr = paramsStr.split(&apos;&amp;&apos;); // 将字符串以 &amp; 分割后存到数组中</span><br><span class="line">    let paramsObj = &#123;&#125;;</span><br><span class="line">    // 将 params 存到对象中</span><br><span class="line">    paramsArr.forEach(param =&gt; &#123;</span><br><span class="line">        if (/=/.test(param)) &#123; // 处理有 value 的参数</span><br><span class="line">            let [key, val] = param.split(&apos;=&apos;); // 分割 key 和 value</span><br><span class="line">            val = decodeURIComponent(val); // 解码</span><br><span class="line">            val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字</span><br><span class="line">    </span><br><span class="line">            if (paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值</span><br><span class="line">                paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">            &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值</span><br><span class="line">                paramsObj[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; // 处理没有 value 的参数</span><br><span class="line">            paramsObj[param] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function render(template, data) &#123;</span><br><span class="line">    const reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/; // 模板字符串正则</span><br><span class="line">    if (reg.test(template)) &#123; // 判断模板里是否有模板字符串</span><br><span class="line">        const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段</span><br><span class="line">        template = template.replace(reg, data[name]); // 将第一个模板字符串渲染</span><br><span class="line">        return render(template, data); // 递归的渲染并返回渲染后的结构</span><br><span class="line">    &#125;</span><br><span class="line">    return template; // 如果模板没有模板字符串直接返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let template = &apos;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&apos;;</span><br><span class="line">let person = &#123;</span><br><span class="line">    name: &apos;布兰&apos;,</span><br><span class="line">    age: 12</span><br><span class="line">&#125;</span><br><span class="line">render(template, person); // 我是布兰，年龄12，性别undefined</span><br></pre></td></tr></table></figure></p><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>与普通的图片懒加载不同，如下这个多做了 2 个精心处理：</p><ul><li>图片全部加载完成后移除事件监听；</li><li>加载完的图片，从 imgList 移除；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let imgList = [...document.querySelectorAll(&apos;img&apos;)]</span><br><span class="line">let length = imgList.length</span><br><span class="line"></span><br><span class="line">const imgLazyLoad = function() &#123;</span><br><span class="line">    let count = 0</span><br><span class="line">    // 修正错误，需要加上自执行</span><br><span class="line">-   return function() &#123;</span><br><span class="line">+   return (function() &#123;</span><br><span class="line">        let deleteIndexList = []</span><br><span class="line">        imgList.forEach((img, index) =&gt; &#123;</span><br><span class="line">            let rect = img.getBoundingClientRect()</span><br><span class="line">            if (rect.top &lt; window.innerHeight) &#123;</span><br><span class="line">                img.src = img.dataset.src</span><br><span class="line">                deleteIndexList.push(index)</span><br><span class="line">                count++</span><br><span class="line">                if (count === length) &#123;</span><br><span class="line">                    document.removeEventListener(&apos;scroll&apos;, imgLazyLoad)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        imgList = imgList.filter((img, index) =&gt; !deleteIndexList.includes(index))</span><br><span class="line">-   &#125;</span><br><span class="line">+   &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里最好加上防抖处理</span><br><span class="line">document.addEventListener(&apos;scroll&apos;, imgLazyLoad)</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。</p><p>简单版：函数内部支持使用 this 和 event 对象；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(function()&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var node = document.getElementById(&apos;layout&apos;)</span><br><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    console.log(this, e)  // 分别打印：node 这个节点 和 MouseEvent</span><br><span class="line">    node.innerHTML = count++;</span><br><span class="line">&#125;;</span><br><span class="line">node.onmousemove = debounce(getUserAction, 1000)</span><br></pre></td></tr></table></figure></p><p>最终版：除了支持 this 和 event 外，还支持以下功能：</p><ul><li>支持立即执行；</li><li>函数可能有返回值；</li><li>支持取消功能；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timeout, result;</span><br><span class="line">    </span><br><span class="line">    var debounced = function () &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        </span><br><span class="line">        if (timeout) clearTimeout(timeout);</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            // 如果已经执行过，不再执行</span><br><span class="line">            var callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(function()&#123;</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timeout = setTimeout(function()&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var setUseAction = debounce(getUserAction, 10000, true);</span><br><span class="line">// 使用防抖</span><br><span class="line">node.onmousemove = setUseAction</span><br><span class="line"></span><br><span class="line">// 取消防抖</span><br><span class="line">setUseAction.cancel()</span><br></pre></td></tr></table></figure></p><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>触发高频事件，且 N 秒内只执行一次。</p><p>简单版：使用时间戳来实现，立即执行一次，然后每 N 秒执行一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var context, args;</span><br><span class="line">    var previous = 0;</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        var now = +new Date();</span><br><span class="line">        context = this;</span><br><span class="line">        args = arguments;</span><br><span class="line">        if (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终版：支持取消节流；另外通过传入第三个参数，options.leading 来表示是否可以立即执行一次，opitons.trailing 表示结束调用的时候是否还要执行一次，默认都是 true。 注意设置的时候不能同时将 leading 或 trailing 设置为 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait, options) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous = 0;</span><br><span class="line">    if (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var later = function() &#123;</span><br><span class="line">        previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class="line">        timeout = null;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        if (!timeout) context = args = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var throttled = function() &#123;</span><br><span class="line">        var now = new Date().getTime();</span><br><span class="line">        if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line">        var remaining = wait - (now - previous);</span><br><span class="line">        context = this;</span><br><span class="line">        args = arguments;</span><br><span class="line">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            if (!timeout) context = args = null;</span><br><span class="line">        &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    throttled.cancel = function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        previous = 0;</span><br><span class="line">        timeout = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>节流的使用就不拿代码举例了，参考防抖的写就行。</p><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。还不懂？来举个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, c) &#123;</span><br><span class="line">    return a + b + c</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3)</span><br><span class="line">let addCurry = curry(add)</span><br><span class="line">addCurry(1)(2)(3)</span><br></pre></td></tr></table></figure></p><p>现在就是要实现 curry 这个函数，使函数从一次调用传入多个参数变成多次调用每次传一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn) &#123;</span><br><span class="line">    let judge = (...args) =&gt; &#123;</span><br><span class="line">        if (args.length == fn.length) return fn(...args)</span><br><span class="line">        return (...arg) =&gt; judge(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">    return judge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, c) &#123;</span><br><span class="line">    return a + b + c</span><br><span class="line">&#125;</span><br><span class="line">let partialAdd = partial(add, 1)</span><br><span class="line">partialAdd(2, 3)</span><br></pre></td></tr></table></figure></p><p>发现没有，其实偏函数和函数柯里化有点像，所以根据函数柯里化的实现，能够能很快写出偏函数的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function partial(fn, ...args) &#123;</span><br><span class="line">    return (...arg) =&gt; &#123;</span><br><span class="line">        return fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上这个功能比较简单，现在我们希望偏函数能和柯里化一样能实现占位功能，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function clg(a, b, c) &#123;</span><br><span class="line">    console.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">let partialClg = partial(clg, &apos;_&apos;, 2)</span><br><span class="line">partialClg(1, 3)  // 依次打印：1, 2, 3</span><br></pre></td></tr></table></figure></p><p>_ 占的位其实就是 1 的位置。相当于：partial(clg, 1, 2)，然后 partialClg(3)。明白了原理，我们就来写实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function partial(fn, ...args) &#123;</span><br><span class="line">    return (...arg) =&gt; &#123;</span><br><span class="line">        args[index] = </span><br><span class="line">        return fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 核心原理：script 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const jsonp = (&#123; url, params, callbackName &#125;) =&gt; &#123;</span><br><span class="line">    const generateUrl = () =&gt; &#123;</span><br><span class="line">        let dataSrc = &apos;&apos;</span><br><span class="line">        for (let key in params) &#123;</span><br><span class="line">            if (params.hasOwnProperty(key)) &#123;</span><br><span class="line">                dataSrc += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;`</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dataSrc += `callback=$&#123;callbackName&#125;`</span><br><span class="line">        return `$&#123;url&#125;?$&#123;dataSrc&#125;`</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        const scriptEle = document.createElement(&apos;script&apos;)</span><br><span class="line">        scriptEle.src = generateUrl()</span><br><span class="line">        document.body.appendChild(scriptEle)</span><br><span class="line">        window[callbackName] = data =&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            document.removeChild(scriptEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const getJSON = function(url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Mscrosoft.XMLHttp&apos;);</span><br><span class="line">        xhr.open(&apos;GET&apos;, url, false);</span><br><span class="line">        xhr.setRequestHeader(&apos;Accept&apos;, &apos;application/json&apos;);</span><br><span class="line">        xhr.onreadystatechange = function() &#123;</span><br><span class="line">            if (xhr.readyState !== 4) return;</span><br><span class="line">            if (xhr.status === 200 || xhr.status === 304) &#123;</span><br><span class="line">                resolve(xhr.responseText);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reject(new Error(xhr.responseText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现数组原型方法"><a href="#实现数组原型方法" class="headerlink" title="实现数组原型方法"></a>实现数组原型方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.forEach2 = function(callback, thisArg) &#123;</span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;this is null or not defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &apos; is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)  // this 就是当前的数组</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0  // 后面有解释</span><br><span class="line">    let k = 0</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line">            callback.call(thisArg, O[k], k, O);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O.length &gt;&gt;&gt; 0 是什么操作？就是无符号右移 0 位，那有什么意义嘛？就是为了保证转换后的值为正整数。其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。感兴趣可以阅读 something &gt;&gt;&gt; 0是什么意思?。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>基于 forEach 的实现能够很容易写出 map 的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span><br><span class="line">+ Array.prototype.map2 = function(callback, thisArg) &#123;</span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;this is null or not defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &apos; is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">-   let k = 0</span><br><span class="line">+   let k = 0, res = []</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line">-           callback.call(thisArg, O[k], k, O);</span><br><span class="line">+           res[k] = callback.call(thisArg, O[k], k, O);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">+   return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>同样，基于 forEach 的实现能够很容易写出 filter 的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span><br><span class="line">+ Array.prototype.filter2 = function(callback, thisArg) &#123;</span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;this is null or not defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &apos; is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">-   let k = 0</span><br><span class="line">+   let k = 0, res = []</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line">-           callback.call(thisArg, O[k], k, O);</span><br><span class="line">+           if (callback.call(thisArg, O[k], k, O)) &#123;</span><br><span class="line">+               res.push(O[k])                </span><br><span class="line">+           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">+   return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>同样，基于 forEach 的实现能够很容易写出 some 的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span><br><span class="line">+ Array.prototype.some2 = function(callback, thisArg) &#123;</span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;this is null or not defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &apos; is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">    let k = 0</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line">-           callback.call(thisArg, O[k], k, O);</span><br><span class="line">+           if (callback.call(thisArg, O[k], k, O)) &#123;</span><br><span class="line">+               return true</span><br><span class="line">+           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">+   return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.reduce2 = function(callback, initialValue) &#123;</span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;this is null or not defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &apos; is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">    let k = 0, acc</span><br><span class="line">    </span><br><span class="line">    if (arguments.length &gt; 1) &#123;</span><br><span class="line">        acc = initialValue</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 没传入初始值的时候，取数组中第一个非 empty 的值为初始值</span><br><span class="line">        while (k &lt; len &amp;&amp; !(k in O)) &#123;</span><br><span class="line">            k++</span><br><span class="line">        &#125;</span><br><span class="line">        if (k &gt; len) &#123;</span><br><span class="line">            throw new TypeError( &apos;Reduce of empty array with no initial value&apos; );</span><br><span class="line">        &#125;</span><br><span class="line">        acc = O[k++]</span><br><span class="line">    &#125;</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line">            acc = callback(acc, O[k], k, O)</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    return acc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现函数原型方法"><a href="#实现函数原型方法" class="headerlink" title="实现函数原型方法"></a>实现函数原型方法</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>使用一个指定的 this 值和一个或多个参数来调用一个函数。</p><p>实现要点：</p><ul><li>this 可能传入 null；</li><li>传入不固定个数的参数；</li><li>函数可能有返回值；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function (context) &#123;</span><br><span class="line">    var context = context || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply 和 call 一样，唯一的区别就是 call 是传入不固定个数的参数，而 apply 是传入一个数组。</p><p>实现要点：</p><ul><li>this 可能传入 null；</li><li>传入一个数组；</li><li>函数可能有返回值；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.apply2 = function (context, arr) &#123;</span><br><span class="line">    var context = context || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var args = [];</span><br><span class="line">        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&apos;arr[&apos; + i + &apos;]&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind 方法会创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><p>实现要点：</p><ul><li>bind() 除了 this 外，还可传入多个参数；</li><li>bing 创建的新函数可能传入多个参数；</li><li>新函数可能被当做构造函数调用；</li><li>函数可能有返回值；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 = function (context) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fNOP = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var fBound = function () &#123;</span><br><span class="line">        var bindArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = this.prototype;</span><br><span class="line">    fBound.prototype = new fNOP();</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="实现-new-关键字"><a href="#实现-new-关键字" class="headerlink" title="实现 new 关键字"></a>实现 new 关键字</h2><p>new 运算符用来创建用户自定义的对象类型的实例或者具有构造函数的内置对象的实例。</p><p>实现要点：</p><ul><li>new 会产生一个新对象；</li><li>新对象需要能够访问到构造函数的属性，所以需要重新指定它的原型；</li><li>构造函数可能会显示返回；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function objectFactory() &#123;</span><br><span class="line">    var obj = new Object()</span><br><span class="line">    Constructor = [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    var ret = Constructor.apply(obj, arguments);</span><br><span class="line">    </span><br><span class="line">    // ret || obj 这里这么写考虑了构造函数显示返回 null 的情况</span><br><span class="line">    return typeof ret === &apos;object&apos; ? ret || obj : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function person(name, age) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line">let p = objectFactory(person, &apos;布兰&apos;, 12)</span><br><span class="line">console.log(p)  // &#123; name: &apos;布兰&apos;, age: 12 &#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现-instanceof-关键字"><a href="#实现-instanceof-关键字" class="headerlink" title="实现 instanceof 关键字"></a>实现 instanceof 关键字</h2><p>instanceof 就是判断构造函数的 prototype 属性是否出现在实例的原型链上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function instanceOf(left, right) &#123;</span><br><span class="line">    let proto = left.__proto__</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (proto === null) return false</span><br><span class="line">        if (proto === right.prototype) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        proto = proto.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的 left.proto 这种写法可以换成 Object.getPrototypeOf(left)。</p><h2 id="实现-Object-create"><a href="#实现-Object-create" class="headerlink" title="实现 Object.create"></a>实现 Object.create</h2><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Object.create2 = function(proto, propertyObject = undefined) &#123;</span><br><span class="line">    if (typeof proto !== &apos;object&apos; &amp;&amp; typeof proto !== &apos;function&apos;) &#123;</span><br><span class="line">        throw new TypeError(&apos;Object prototype may only be an Object or null.&apos;)</span><br><span class="line">    if (propertyObject == null) &#123;</span><br><span class="line">        new TypeError(&apos;Cannot convert undefined or null to object&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = proto</span><br><span class="line">    const obj = new F()</span><br><span class="line">    if (propertyObject != undefined) &#123;</span><br><span class="line">        Object.defineProperties(obj, propertyObject)</span><br><span class="line">    &#125;</span><br><span class="line">    if (proto === null) &#123;</span><br><span class="line">        // 创建一个没有原型对象的对象，Object.create(null)</span><br><span class="line">        obj.__proto__ = null</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现-Object-assign"><a href="#实现-Object-assign" class="headerlink" title="实现 Object.assign"></a>实现 Object.assign</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object.assign2 = function(target, ...source) &#123;</span><br><span class="line">    if (target == null) &#123;</span><br><span class="line">        throw new TypeError(&apos;Cannot convert undefined or null to object&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    let ret = Object(target) </span><br><span class="line">    source.forEach(function(obj) &#123;</span><br><span class="line">        if (obj != null) &#123;</span><br><span class="line">            for (let key in obj) &#123;</span><br><span class="line">                if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                    ret[key] = obj[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-JSON-stringify"><a href="#实现-JSON-stringify" class="headerlink" title="实现 JSON.stringify"></a>实现 JSON.stringify</h2><p>JSON.stringify([, replacer [, space]) 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 replacer 和第三个参数 space，如果对这两个参数的作用还不了解，建议阅读 MDN 文档。</p><ol><li>基本数据类型：</li></ol><ul><li>undefined 转换之后仍是 undefined(类型也是 undefined)</li><li>boolean 值转换之后是字符串 “false”/“true”</li><li>number 类型(除了 NaN 和 Infinity)转换之后是字符串类型的数值</li><li>symbol 转换之后是 undefined</li><li>null 转换之后是字符串 “null”</li><li>string 转换之后仍是string</li><li>NaN 和 Infinity 转换之后是字符串 “null”</li></ul><ol start="2"><li>函数类型：转换之后是 undefined</li><li>如果是对象类型(非函数)</li></ol><ul><li>如果是一个数组：如果属性值中出现了 undefined、任意的函数以及 symbol，转换成字符串 “null” ；</li><li>如果是 RegExp 对象：返回 {} (类型是 string)；</li><li>如果是 Date 对象，返回 Date 的 toJSON 字符串值；</li><li>如果是普通对象；<ul><li>如果有 toJSON() 方法，那么序列化 toJSON() 的返回值。</li><li>如果属性值中出现了 undefined、任意的函数以及 symbol 值，忽略。</li><li>所有以 symbol 为属性键的属性都会被完全忽略掉。</li></ul></li></ul><ol start="4"><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">function jsonStringify(data) &#123;</span><br><span class="line">    let dataType = typeof data;</span><br><span class="line">    </span><br><span class="line">    if (dataType !== &apos;object&apos;) &#123;</span><br><span class="line">        let result = data;</span><br><span class="line">        //data 可能是 string/number/null/undefined/boolean</span><br><span class="line">        if (Number.isNaN(data) || data === Infinity) &#123;</span><br><span class="line">            //NaN 和 Infinity 序列化返回 &quot;null&quot;</span><br><span class="line">            result = &quot;null&quot;;</span><br><span class="line">        &#125; else if (dataType === &apos;function&apos; || dataType === &apos;undefined&apos; || dataType === &apos;symbol&apos;) &#123;</span><br><span class="line">            //function 、undefined 、symbol 序列化返回 undefined</span><br><span class="line">            return undefined;</span><br><span class="line">        &#125; else if (dataType === &apos;string&apos;) &#123;</span><br><span class="line">            result = &apos;&quot;&apos; + data + &apos;&quot;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        //boolean 返回 String()</span><br><span class="line">        return String(result);</span><br><span class="line">    &#125; else if (dataType === &apos;object&apos;) &#123;</span><br><span class="line">        if (data === null) &#123;</span><br><span class="line">            return &quot;null&quot;</span><br><span class="line">        &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &apos;function&apos;) &#123;</span><br><span class="line">            return jsonStringify(data.toJSON());</span><br><span class="line">        &#125; else if (data instanceof Array) &#123;</span><br><span class="line">            let result = [];</span><br><span class="line">            //如果是数组</span><br><span class="line">            //toJSON 方法可以存在于原型链中</span><br><span class="line">            data.forEach((item, index) =&gt; &#123;</span><br><span class="line">                if (typeof item === &apos;undefined&apos; || typeof item === &apos;function&apos; || typeof item === &apos;symbol&apos;) &#123;</span><br><span class="line">                    result[index] = &quot;null&quot;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result[index] = jsonStringify(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            result = &quot;[&quot; + result + &quot;]&quot;;</span><br><span class="line">            return result.replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //普通对象</span><br><span class="line">            /**</span><br><span class="line">             * 循环引用抛错(暂未检测，循环引用时，堆栈溢出)</span><br><span class="line">             * symbol key 忽略</span><br><span class="line">             * undefined、函数、symbol 为属性值，被忽略</span><br><span class="line">             */</span><br><span class="line">            let result = [];</span><br><span class="line">            Object.keys(data).forEach((item, index) =&gt; &#123;</span><br><span class="line">                if (typeof item !== &apos;symbol&apos;) &#123;</span><br><span class="line">                    //key 如果是symbol对象，忽略</span><br><span class="line">                    if (data[item] !== undefined &amp;&amp; typeof data[item] !== &apos;function&apos;</span><br><span class="line">                        &amp;&amp; typeof data[item] !== &apos;symbol&apos;) &#123;</span><br><span class="line">                        //键值如果是 undefined、函数、symbol 为属性值，忽略</span><br><span class="line">                        result.push(&apos;&quot;&apos; + item + &apos;&quot;&apos; + &quot;:&quot; + jsonStringify(data[item]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现-JSON-parse"><a href="#实现-JSON-parse" class="headerlink" title="实现 JSON.parse"></a>实现 JSON.parse</h2><p>介绍 2 种方法实现：</p><ul><li>eval 实现；</li><li>new Function 实现；<h3 id="eval-实现"><a href="#eval-实现" class="headerlink" title="eval 实现"></a>eval 实现</h3>第一种方式最简单，也最直观，就是直接调用 eval，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var json = &apos;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&apos;;</span><br><span class="line">var obj = eval(&quot;(&quot; + json + &quot;)&quot;);  // obj 就是 json 反序列化之后得到的对象</span><br></pre></td></tr></table></figure></li></ul><p>但是直接调用 eval 会存在安全问题，如果数据中可能不是 json 数据，而是可执行的 JavaScript 代码，那很可能会造成 XSS 攻击。因此，在调用 eval 之前，需要对数据进行校验。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var rx_one = /^[\],:&#123;&#125;\s]*$/;</span><br><span class="line">var rx_two = /\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g;</span><br><span class="line">var rx_three = /&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;</span><br><span class="line">var rx_four = /(?:^|:|,)(?:\s*\[)+/g;</span><br><span class="line"></span><br><span class="line">if (</span><br><span class="line">    rx_one.test(</span><br><span class="line">        json.replace(rx_two, &quot;@&quot;)</span><br><span class="line">            .replace(rx_three, &quot;]&quot;)</span><br><span class="line">            .replace(rx_four, &quot;&quot;)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    var obj = eval(&quot;(&quot; +json + &quot;)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new-Function-实现"><a href="#new-Function-实现" class="headerlink" title="new Function 实现"></a>new Function 实现</h3><p>Function 与 eval 有相同的字符串参数特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var json = &apos;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&apos;;</span><br><span class="line">var obj = (new Function(&apos;return &apos; + json))();</span><br></pre></td></tr></table></figure></p><h2 id="实现-Promise"><a href="#实现-Promise" class="headerlink" title="实现 Promise"></a>实现 Promise</h2><p>实现 Promise 需要完全读懂 Promise A+ 规范，不过从总体的实现上看，有如下几个点需要考虑到：</p><ul><li>then 需要支持链式调用，所以得返回一个新的 Promise；</li><li>处理异步问题，所以得先用 onResolvedCallbacks 和 onRejectedCallbacks 分别把成功和失败的回调存起来；</li><li>为了让链式调用正常进行下去，需要判断 onFulfilled 和 onRejected 的类型；</li><li>onFulfilled 和 onRejected 需要被异步调用，这里用 setTimeout 模拟异步；</li><li>处理 Promise 的 resolve；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = &apos;pending&apos;;</span><br><span class="line">const FULFILLED = &apos;fulfilled&apos;;</span><br><span class="line">const REJECTED = &apos;rejected&apos;;</span><br><span class="line"></span><br><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this.status = PENDING;</span><br><span class="line">        this.value = undefined;</span><br><span class="line">        this.reason = undefined;</span><br><span class="line">        this.onResolvedCallbacks = [];</span><br><span class="line">        this.onRejectedCallbacks = [];</span><br><span class="line">        </span><br><span class="line">        let resolve = (value) = &gt; &#123;</span><br><span class="line">            if (this.status === PENDING) &#123;</span><br><span class="line">                this.status = FULFILLED;</span><br><span class="line">                this.value = value;</span><br><span class="line">                this.onResolvedCallbacks.forEach((fn) = &gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        let reject = (reason) = &gt; &#123;</span><br><span class="line">            if (this.status === PENDING) &#123;</span><br><span class="line">                this.status = REJECTED;</span><br><span class="line">                this.reason = reason;</span><br><span class="line">                this.onRejectedCallbacks.forEach((fn) = &gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        // 解决 onFufilled，onRejected 没有传值的问题</span><br><span class="line">        onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : (v) = &gt; v;</span><br><span class="line">        // 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获</span><br><span class="line">        onRejected = typeof onRejected === &quot;function&quot; ? onRejected : (err) = &gt; &#123;</span><br><span class="line">            throw err;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 每次调用 then 都返回一个新的 promise</span><br><span class="line">        let promise2 = new Promise((resolve, reject) = &gt; &#123;</span><br><span class="line">            if (this.status === FULFILLED) &#123;</span><br><span class="line">                //Promise/A+ 2.2.4 --- setTimeout</span><br><span class="line">                setTimeout(() = &gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x = onFulfilled(this.value);</span><br><span class="line">                        // x可能是一个proimise</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            if (this.status === REJECTED) &#123;</span><br><span class="line">                //Promise/A+ 2.2.3</span><br><span class="line">                setTimeout(() = &gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x = onRejected(this.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (this.status === PENDING) &#123;</span><br><span class="line">                this.onResolvedCallbacks.push(() = &gt; &#123;</span><br><span class="line">                    setTimeout(() = &gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x = onFulfilled(this.value);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, 0);</span><br><span class="line">                &#125;);</span><br><span class="line">            </span><br><span class="line">                this.onRejectedCallbacks.push(() = &gt; &#123;</span><br><span class="line">                    setTimeout(() = &gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x = onRejected(this.reason);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, 0);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        return promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const resolvePromise = (promise2, x, resolve, reject) = &gt; &#123;</span><br><span class="line">    // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1</span><br><span class="line">    if (promise2 === x) &#123;</span><br><span class="line">        return reject(</span><br><span class="line">            new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    // Promise/A+ 2.3.3.3.3 只能调用一次</span><br><span class="line">    let called;</span><br><span class="line">    // 后续的条件要严格判断 保证代码能和别的库一起使用</span><br><span class="line">    if ((typeof x === &quot;object&quot; &amp;&amp; x != null) || typeof x === &quot;function&quot;) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1</span><br><span class="line">            let then = x.then;</span><br><span class="line">            if (typeof then === &quot;function&quot;) &#123;</span><br><span class="line">            // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3</span><br><span class="line">                then.call(</span><br><span class="line">                    x, (y) = &gt; &#123;</span><br><span class="line">                        // 根据 promise 的状态决定是成功还是失败</span><br><span class="line">                        if (called) return;</span><br><span class="line">                        called = true;</span><br><span class="line">                        // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1</span><br><span class="line">                        resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                    &#125;, (r) = &gt; &#123;</span><br><span class="line">                        // 只要失败就失败 Promise/A+ 2.3.3.3.2</span><br><span class="line">                        if (called) return;</span><br><span class="line">                        called = true;</span><br><span class="line">                        reject(r);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            // Promise/A+ 2.3.3.2</span><br><span class="line">            if (called) return;</span><br><span class="line">            called = true;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>Promise 写完之后可以通过 promises-aplus-tests 这个包对我们写的代码进行测试，看是否符合 A+ 规范。不过测试前还得加一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// promise.js</span><br><span class="line">// 这里是上面写的 Promise 全部代码</span><br><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">    let dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    return dfd;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Promise;</span><br></pre></td></tr></table></figure></p><p>全局安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i promises-aplus-tests -g</span><br></pre></td></tr></table></figure></p><p>终端下执行验证命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests promise.js</span><br></pre></td></tr></table></figure></p><p>上面写的代码可以顺利通过全部 872 个测试用例。</p><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve = function(value) &#123;</span><br><span class="line">    // 如果是 Promsie，则直接输出它</span><br><span class="line">    if(value instanceof Promise)&#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise(resolve =&gt; resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject = function(reason) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 的规则是这样的：</p><ul><li>传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；</li><li>只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；</li><li>只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Promise.all = function(promiseArr) &#123;</span><br><span class="line">    let index = 0, result = []</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">            Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">                index++</span><br><span class="line">                result[i] = val</span><br><span class="line">                if (index === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.race = function(promiseArr) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        promiseArr.forEach(p =&gt; &#123;</span><br><span class="line">            Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                rejecte(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Promise.allSettled<br>Promise.allSettled 的规则是这样：</p><ul><li>所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise，且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象；</li><li>如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled = function(promiseArr) &#123;</span><br><span class="line">    let result = []</span><br><span class="line">        </span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">            Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    status: &apos;fulfilled&apos;,</span><br><span class="line">                    value: val</span><br><span class="line">                &#125;)</span><br><span class="line">                if (result.length === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    status: &apos;rejected&apos;,</span><br><span class="line">                    reason: err</span><br><span class="line">                &#125;)</span><br><span class="line">                if (result.length === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>Promise.any 的规则是这样：</p><ul><li>空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；</li><li>只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；</li><li>其他情况都会返回一个 pending 的新实例；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Promise.any = function(promiseArr) &#123;</span><br><span class="line">    let index = 0</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        if (promiseArr.length === 0) return </span><br><span class="line">        promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">            Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">                </span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                index++</span><br><span class="line">                if (index === promiseArr.length) &#123;</span><br><span class="line">                  reject(new AggregateError(&apos;All promises were rejected&apos;))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>后话<br>能看到这里的对代码都是真爱了，毕竟代码这玩意看起来是真的很枯燥，但是如果看懂了后，就会像打游戏赢了一样开心，而且这玩意会上瘾，当你通关了越多的关卡后，你的能力就会拔高一个层次。用标题的话来说就是：搞懂后，提升真的大。加油吧💪，干饭人</p><p>噢不，代码人。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要写这类文章&quot;&gt;&lt;a href=&quot;#为什么要写这类文章&quot; class=&quot;headerlink&quot; title=&quot;为什么要写这类文章&quot;&gt;&lt;/a&gt;为什么要写这类文章&lt;/h3&gt;&lt;p&gt;作为一个程序员，代码能力毋庸置疑是非常非常重要的，就像现在为什么大厂面试基本都问什么 API 怎么实现可见其重要性。我想说的是居然手写这么重要，那我们就必须掌握它，所以文章标题用了死磕，一点也不过分，也希望不被认为是标题党。&lt;/p&gt;
&lt;p&gt;作为一个普通前端，我是真的写不出 Promise A+ 规范，但是没关系，我们可以站在巨人的肩膀上，要相信我们现在要走的路，前人都走过，所以可以找找现在社区已经存在的那些优秀的文章，比如工业聚大佬写的 100 行代码实现 Promises/A+ 规范，找到这些文章后不是收藏夹吃灰，得找个时间踏踏实实的学，一行一行的磨，直到搞懂为止。我现在就是这么干的。
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>使用eggjs和sequelize管理数据库</title>
    <link href="https://water.buging.cn/2021/03/16/%E4%BD%BF%E7%94%A8eggjs%E5%92%8Csequelize%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://water.buging.cn/2021/03/16/使用eggjs和sequelize管理数据库/</id>
    <published>2021-03-16T10:38:56.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为什么使用eggjs自不必言说，前端开发者想搞一下服务器接口啥的，最低学习成本的就是nodejs。加之koa是nodejs的封装库，使得nodejs更加好用。然而在eggjs的约定大于配置的前提下，对koa做了封装，使得上手成本更低，固然选择eggjs来作为写接口的框架。数据库使用sequelize的缘由自不必说了，让多人开发合作更加简单规范！！！<a id="more"></a></p><h2 id="eggjs快速上手"><a href="#eggjs快速上手" class="headerlink" title="eggjs快速上手"></a>eggjs快速上手</h2><h4 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h4><p>快速生成基础项目，提高开发效率，这里推荐使用脚手架快速生成项目。具体命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir egg-example &amp;&amp; cd egg-example</span><br><span class="line">npm init egg --type=simple</span><br><span class="line">npm i</span><br><span class="line">npm run dev</span><br><span class="line">// 打开一下链接</span><br><span class="line">http://localhost:7001</span><br></pre></td></tr></table></figure><h4 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a>项目目录介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">egg-project</span><br><span class="line">├── package.json</span><br><span class="line">├── app.js (可选)</span><br><span class="line">├── agent.js (可选)</span><br><span class="line">├── app</span><br><span class="line">|   ├── router.js</span><br><span class="line">│   ├── controller</span><br><span class="line">│   |   └── home.js</span><br><span class="line">│   ├── service (可选)</span><br><span class="line">│   |   └── user.js</span><br><span class="line">│   ├── middleware (可选)</span><br><span class="line">│   |   └── response_time.js</span><br><span class="line">│   ├── schedule (可选)</span><br><span class="line">│   |   └── my_task.js</span><br><span class="line">│   ├── public (可选)</span><br><span class="line">│   |   └── reset.css</span><br><span class="line">│   ├── view (可选)</span><br><span class="line">│   |   └── home.tpl</span><br><span class="line">│   └── extend (可选)</span><br><span class="line">│       ├── helper.js (可选)</span><br><span class="line">│       ├── request.js (可选)</span><br><span class="line">│       ├── response.js (可选)</span><br><span class="line">│       ├── context.js (可选)</span><br><span class="line">│       ├── application.js (可选)</span><br><span class="line">│       └── agent.js (可选)</span><br><span class="line">├── config</span><br><span class="line">|   ├── plugin.js</span><br><span class="line">|   ├── config.default.js</span><br><span class="line">│   ├── config.prod.js</span><br><span class="line">|   ├── config.test.js (可选)</span><br><span class="line">|   ├── config.local.js (可选)</span><br><span class="line">|   └── config.unittest.js (可选)</span><br><span class="line">└── test</span><br><span class="line">    ├── middleware</span><br><span class="line">    |   └── response_time.test.js</span><br><span class="line">    └── controller</span><br><span class="line">        └── home.test.js</span><br></pre></td></tr></table></figure><p>如上，由框架约定的目录：</p><ul><li><code>app/router.js</code> 用于配置 URL 路由规则，具体参见 <a href="https://eggjs.org/zh-cn/basics/router.html" rel="external nofollow noopener noreferrer" target="_blank">Router</a>。</li><li><code>app/controller/**</code> 用于解析用户的输入，处理后返回相应的结果，具体参见 <a href="https://eggjs.org/zh-cn/basics/controller.html" rel="external nofollow noopener noreferrer" target="_blank">Controller</a>。</li><li><code>app/service/**</code> 用于编写业务逻辑层，可选，建议使用，具体参见 <a href="https://eggjs.org/zh-cn/basics/service.html" rel="external nofollow noopener noreferrer" target="_blank">Service</a>。</li><li><code>app/middleware/**</code> 用于编写中间件，可选，具体参见 <a href="https://eggjs.org/zh-cn/basics/middleware.html" rel="external nofollow noopener noreferrer" target="_blank">Middleware</a>。</li><li><code>app/public/**</code> 用于放置静态资源，可选，具体参见内置插件 <a href="https://github.com/eggjs/egg-static" rel="external nofollow noopener noreferrer" target="_blank">egg-static</a>。</li><li><code>app/extend/**</code> 用于框架的扩展，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/extend.html" rel="external nofollow noopener noreferrer" target="_blank">框架扩展</a>。</li><li><code>config/config.{env}.js</code> 用于编写配置文件，具体参见<a href="https://eggjs.org/zh-cn/basics/config.html" rel="external nofollow noopener noreferrer" target="_blank">配置</a>。</li><li><code>config/plugin.js</code> 用于配置需要加载的插件，具体参见<a href="https://eggjs.org/zh-cn/basics/plugin.html" rel="external nofollow noopener noreferrer" target="_blank">插件</a>。</li><li><code>test/**</code> 用于单元测试，具体参见<a href="https://eggjs.org/zh-cn/core/unittest.html" rel="external nofollow noopener noreferrer" target="_blank">单元测试</a>。</li><li><code>app.js</code> 和 <code>agent.js</code> 用于自定义启动时的初始化工作，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/app-start.html" rel="external nofollow noopener noreferrer" target="_blank">启动自定义</a>。关于<code>agent.js</code>的作用参见<a href="https://eggjs.org/zh-cn/core/cluster-and-ipc.html#agent-机制" rel="external nofollow noopener noreferrer" target="_blank">Agent机制</a>。</li></ul><p>由内置插件约定的目录：</p><ul><li><code>app/public/**</code> 用于放置静态资源，可选，具体参见内置插件 <a href="https://github.com/eggjs/egg-static" rel="external nofollow noopener noreferrer" target="_blank">egg-static</a>。</li><li><code>app/schedule/**</code> 用于定时任务，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/schedule.html" rel="external nofollow noopener noreferrer" target="_blank">定时任务</a>。</li></ul><p><strong>若需自定义自己的目录规范，参见 <a href="https://eggjs.org/zh-cn/advanced/loader.html" rel="external nofollow noopener noreferrer" target="_blank">Loader API</a></strong></p><ul><li><code>app/view/**</code> 用于放置模板文件，可选，由模板插件约定，具体参见<a href="https://eggjs.org/zh-cn/core/view.html" rel="external nofollow noopener noreferrer" target="_blank">模板渲染</a>。</li><li><code>app/model/**</code> 用于放置领域模型，可选，由领域类相关插件约定，如 <a href="https://github.com/eggjs/egg-sequelize" rel="external nofollow noopener noreferrer" target="_blank">egg-sequelize</a>。</li></ul><p>由此一个基础项目已经创建完成，详细的eggjs如何使用可自行查看官方文档<a href="https://eggjs.org/zh-cn/" rel="external nofollow noopener noreferrer" target="_blank">https://eggjs.org/zh-cn/</a></p><h2 id="eggjs使用sequelize"><a href="#eggjs使用sequelize" class="headerlink" title="eggjs使用sequelize"></a>eggjs使用sequelize</h2><ol><li>安装并配置 <a href="https://github.com/eggjs/egg-sequelize" rel="external nofollow noopener noreferrer" target="_blank">egg-sequelize</a> 插件（它会辅助我们将定义好的 Model 对象加载到 app 和 ctx 上）和 <a href="https://github.com/sidorares/node-mysql2" rel="external nofollow noopener noreferrer" target="_blank">mysql2</a> 模块：</li></ol><ul><li>安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save egg-sequelize mysql2</span><br></pre></td></tr></table></figure><ul><li>在 <code>config/plugin.js</code> 中引入 egg-sequelize 插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exports.sequelize = &#123;</span><br><span class="line">  enable: true,</span><br><span class="line">  package: &apos;egg-sequelize&apos;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在 <code>config/config.default.js</code> 中编写 sequelize 配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config.sequelize = &#123;</span><br><span class="line">  dialect: &apos;mysql&apos;,</span><br><span class="line">  host: &apos;127.0.0.1&apos;,</span><br><span class="line">  port: 3306,</span><br><span class="line">  database: &apos;egg-sequelize-doc-default&apos;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以在不同的环境配置中配置不同的数据源地址，用于区分不同环境使用的数据库，例如我们可以新建一个 <code>config/config.unittest.js</code> 配置文件，写入如下配置，将单测时连接的数据库指向 <code>egg-sequelize-doc-unittest</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.sequelize = &#123;</span><br><span class="line">  dialect: &apos;mysql&apos;,</span><br><span class="line">  host: &apos;127.0.0.1&apos;,</span><br><span class="line">  port: 3306,</span><br><span class="line">  database: &apos;egg-sequelize-doc-unittest&apos;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完成上面的配置之后，一个使用 sequelize 的项目就初始化完成了。<a href="https://github.com/eggjs/egg-sequelize" rel="external nofollow noopener noreferrer" target="_blank">egg-sequelize</a> 和 <a href="http://docs.sequelizejs.com/" rel="external nofollow noopener noreferrer" target="_blank">sequelize</a> 还支持更多的配置项，可以在他们的文档中找到。</p><ol start="2"><li>sequelize 提供了 <a href="https://github.com/sequelize/cli" rel="external nofollow noopener noreferrer" target="_blank">sequelize-cli</a> 工具来管理，我们也可以在 egg 项目中引入 sequelize-cli。</li></ol><ul><li>安装 sequelize-cli</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev sequelize-cli</span><br></pre></td></tr></table></figure><p>在 egg 项目中，我们希望将所有数据库 Migrations 相关的内容都放在 <code>database</code> 目录下，所以我们在项目根目录下新建一个 <code>.sequelizerc</code> 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  config: path.join(__dirname, &apos;database/config.json&apos;),</span><br><span class="line">  &apos;migrations-path&apos;: path.join(__dirname, &apos;database/migrations&apos;),</span><br><span class="line">  &apos;seeders-path&apos;: path.join(__dirname, &apos;database/seeders&apos;),</span><br><span class="line">  &apos;models-path&apos;: path.join(__dirname, &apos;app/model&apos;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后查看下sequelize-cli的所有命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sequelize &lt;命令&gt;</span><br><span class="line"></span><br><span class="line">命令：</span><br><span class="line">  sequelize db:migrate                        Run pending migrations</span><br><span class="line">  sequelize db:migrate:schema:timestamps:add  Update migration table to have timestamps</span><br><span class="line">  sequelize db:migrate:status                 List the status of all migrations</span><br><span class="line">  sequelize db:migrate:undo                   Reverts a migration</span><br><span class="line">  sequelize db:migrate:undo:all               Revert all migrations ran</span><br><span class="line">  sequelize db:seed                           Run specified seeder</span><br><span class="line">  sequelize db:seed:undo                      Deletes data from the database</span><br><span class="line">  sequelize db:seed:all                       Run every seeder</span><br><span class="line">  sequelize db:seed:undo:all                  Deletes data from the database</span><br><span class="line">  sequelize db:create                         Create database specified by configuration</span><br><span class="line">  sequelize db:drop                           Drop database specified by configuration</span><br><span class="line">  sequelize init                              Initializes project</span><br><span class="line">  sequelize init:config                       Initializes configuration</span><br><span class="line">  sequelize init:migrations                   Initializes migrations</span><br><span class="line">  sequelize init:models                       Initializes models</span><br><span class="line">  sequelize init:seeders                      Initializes seeders</span><br><span class="line">  sequelize migration:generate                Generates a new migration file  [aliases: migration:create]                                         </span><br><span class="line">  sequelize model:generate                    Generates a model and its migration   [aliases: model:create]                                              </span><br><span class="line">  sequelize seed:generate                     Generates a new seed file       [aliases: seed:create]</span><br></pre></td></tr></table></figure><p>接下来就简单介绍下使用方式</p><h4 id="使用命令操作数据库"><a href="#使用命令操作数据库" class="headerlink" title="使用命令操作数据库"></a>使用命令操作数据库</h4><ol><li>初始化数据库相关</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize init</span><br></pre></td></tr></table></figure><p>这将创建以下文件夹:</p><ul><li>config, 包含配置文件，它告诉CLI如何连接数据库</li><li>models,包含您的项目的所有模型</li><li>migrations, 包含所有迁移文件</li><li>seeders, 包含所有种子文件</li></ul><p>在建立模型之前，应先修改database/config.json，以告诉 CLI 如何连接到数据库。database/config.json内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;development&quot;: &#123;</span><br><span class="line">    &quot;username&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;12345678&quot;,</span><br><span class="line">    &quot;database&quot;: &quot;egg_test&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;dialect&quot;: &quot;mysql&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;test&quot;: &#123;</span><br><span class="line">    &quot;username&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;23456789&quot;,</span><br><span class="line">    &quot;database&quot;: &quot;database_test&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;dialect&quot;: &quot;mysql&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;production&quot;: &#123;</span><br><span class="line">    &quot;username&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;12345679&quot;,</span><br><span class="line">    &quot;database&quot;: &quot;database_production&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;dialect&quot;: &quot;mysql&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用如下命令创建数据库：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize db:create</span><br></pre></td></tr></table></figure><ol start="3"><li>使用如下命令删除数据库：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize db:drop</span><br></pre></td></tr></table></figure><h3 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h3><p>我们将使用 model:generate 命令。 此命令需要两个选项：</p><ul><li>name, 模型的名称</li><li>attributes, 模型的属性列表</li></ul><p>创建一个名叫 User 的模型：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">npx</span> <span class="selector-tag">sequelize</span> <span class="selector-tag">model</span><span class="selector-pseudo">:generate</span> <span class="selector-tag">--name</span> <span class="selector-tag">User</span> <span class="selector-tag">--attributes</span> <span class="selector-tag">firstName</span><span class="selector-pseudo">:string</span>,<span class="selector-tag">lastName</span><span class="selector-pseudo">:string</span>,<span class="selector-tag">email</span><span class="selector-pseudo">:string</span></span><br></pre></td></tr></table></figure><p>这将创建一下文件:</p><ul><li>在 models 文件夹中创建了一个 user 模型文件</li><li>在 migrations 文件夹中创建了一个名字像 XXXXXXXXXXXXXX-create-user.js 的迁移文件</li></ul><p>注意: _Sequelize 将只使用模型文件，它是表描述。另一边，迁移文件是该模型的更改，或更具体的是说 CLI 所使用的表。 处理迁移，如提交或日志，以进行数据库的某些更改。</p><p>这里感觉这样用命令创建模型有点繁琐，主要是如果字段太多，命令行岂不是要写很多，我的理解是这样的不知道有其他好的方法不，初次使用这个。</p><p>我是先创建migrations文件，然后在手动创建模型文件。具体如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize migration:generate --name=init-users</span><br></pre></td></tr></table></figure><p>执行完后会在 <code>database/migrations</code> 目录下生成一个 migration 文件(<code>${timestamp}-init-users.js</code>)，我们修改它来处理初始化 <code>users</code> 表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 在执行数据库升级时调用的函数，创建 users 表</span><br><span class="line">  up: async (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    const &#123; INTEGER, DATE, STRING &#125; = Sequelize;</span><br><span class="line">    await queryInterface.createTable(&apos;users&apos;, &#123;</span><br><span class="line">      id: &#123; type: INTEGER, primaryKey: true, autoIncrement: true &#125;,</span><br><span class="line">      name: STRING(30),</span><br><span class="line">      age: INTEGER,</span><br><span class="line">      created_at: DATE,</span><br><span class="line">      updated_at: DATE,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 在执行数据库降级时调用的函数，删除 users 表</span><br><span class="line">  down: async queryInterface =&gt; &#123;</span><br><span class="line">    await queryInterface.dropTable(&apos;users&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行 migrate 进行数据库变更</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 升级数据库</span><br><span class="line">npx sequelize db:migrate</span><br><span class="line"># 如果有问题需要回滚，可以通过 `db:migrate:undo` 回退一个变更</span><br><span class="line"># npx sequelize db:migrate:undo</span><br><span class="line"># 可以通过 `db:migrate:undo:all` 回退到初始状态</span><br><span class="line"># npx sequelize db:migrate:undo:all</span><br></pre></td></tr></table></figure><p>执行之后，我们的数据库初始化就完成了。</p><p>现在终于可以开始编写代码实现业务逻辑了，首先我们来在 <code>app/model/</code> 目录下编写 user 这个 Model：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">module.exports = app =&gt; &#123;</span><br><span class="line">  const &#123; STRING, INTEGER, DATE &#125; = app.Sequelize;</span><br><span class="line"></span><br><span class="line">  const User = app.model.define(&apos;user&apos;, &#123;</span><br><span class="line">    id: &#123; type: INTEGER, primaryKey: true, autoIncrement: true &#125;,</span><br><span class="line">    name: STRING(30),</span><br><span class="line">    age: INTEGER,</span><br><span class="line">    created_at: DATE,</span><br><span class="line">    updated_at: DATE,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return User;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以结合eggjs的模式来进行数据库的处理了。</p><p>说下可以使用的cli命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize db:migrate:status // 看一下当前状态</span><br></pre></td></tr></table></figure><blockquote><p>撤销迁移      </p><p>db:migrate:undo        - 撤销上一次的迁移操作      </p><p>db:migrate:undo:all        - 撤销所有的迁移操作      </p><p>db:migrate:undo –name 具体迁移脚本</p></blockquote><p>我们现在要添加一个字段 lastname，新建一个迁移文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize migration:create --name addLastname</span><br></pre></td></tr></table></figure><p><strong>queryInterface</strong>文档： <a href="https://sequelize.org/master/class/lib/dialects/abstract/query-interface.js~QueryInterface.html" rel="external nofollow noopener noreferrer" target="_blank">https://sequelize.org/master/class/lib/dialects/abstract/query-interface.js~QueryInterface.html</a></p><h3 id="种子文件"><a href="#种子文件" class="headerlink" title="种子文件"></a>种子文件</h3><p>种子文件      </p><blockquote><p>迁移文件是用来构建数据库以及表结构的，种子文件是用来构建数据的      </p><p>seed:generate –name demo-user （自定义的名字）    </p><p>种子文件脚本与迁移脚本类似，由up于down函数组成，传入的参数也是一致的</p></blockquote><p>先生成种子文件 name 后边接的是自定义的名字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize seed:generate --name userseed</span><br></pre></td></tr></table></figure><p>会在database/seeders下创建一个种子文件以userseed结尾，然后手动修改这个文件添加点测试数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  up: (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    return queryInterface.bulkInsert(&apos;users&apos;, [&#123;</span><br><span class="line">      id: 1,</span><br><span class="line">      name: &apos;man&apos;,</span><br><span class="line">      age: 18,</span><br><span class="line">    &#125;], &#123;&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  down: (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    return queryInterface.bulkDelete(&apos;users&apos;, null, &#123;&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行种子</p><blockquote><p>db:seed 指定种子文件        运行指定种子文件      </p><p>db:seed:all        运行所有种子文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize db:seed:all</span><br></pre></td></tr></table></figure><p>然后查看数据库，添加上了一条数据</p><h3 id="撤销种子执行"><a href="#撤销种子执行" class="headerlink" title="撤销种子执行"></a>撤销种子执行</h3><blockquote><p>db:seed:undo –seed 指定种子文件        撤销指定种子文件      </p><p>db:seed:undo:all        撤销所有种子文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize db:seed:undo:all</span><br></pre></td></tr></table></figure><p>具体使用请查看官方文档</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;为什么使用eggjs自不必言说，前端开发者想搞一下服务器接口啥的，最低学习成本的就是nodejs。加之koa是nodejs的封装库，使得nodejs更加好用。然而在eggjs的约定大于配置的前提下，对koa做了封装，使得上手成本更低，固然选择eggjs来作为写接口的框架。数据库使用sequelize的缘由自不必说了，让多人开发合作更加简单规范！！！
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>js中的aop</title>
    <link href="https://water.buging.cn/2021/03/10/js%E4%B8%AD%E7%9A%84aop/"/>
    <id>https://water.buging.cn/2021/03/10/js中的aop/</id>
    <published>2021-03-10T10:15:50.000Z</published>
    <updated>2023-08-01T06:26:37.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h2><p>简介<br>AOP （面向切面编程），缩写为Aspect Oriented Programming，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是JAVA 中Spring框架的一个重要内容，是函数式编程的一种衍生范型。<a id="more"></a>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><ol><li>主要功能</li><li>日志记录</li><li>性能统计</li><li>安全控制</li><li>事务处理</li><li>异常处理</li></ol><p>等等。</p><h3 id="主要意图"><a href="#主要意图" class="headerlink" title="主要意图"></a>主要意图</h3><p>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</p><blockquote><p>注：请慎重的在JS的中使用AOP！因为部分JS的方法是异步的。必要时使用ES7中的async/await/Promise，以保证代码的顺序执行。</p></blockquote><h2 id="AOP在JS中的实现原理"><a href="#AOP在JS中的实现原理" class="headerlink" title="AOP在JS中的实现原理"></a>AOP在JS中的实现原理</h2><p>js中aop的实现原理主要依靠Function的两个函数:apply和call。</p><h3 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h3><ul><li><p>Function.apply(obj, args);</p></li><li><p>apply方法能劫持另外一个对象的方法，继承另外一个对象的属性</p></li><li><p>Function.apply(obj, args)方法能接收两个参数</p></li><li><p>obj：这个对象将代替Function类里this对象</p></li><li><p>args：这个是数组，它将作为参数传给Function（args–&gt;arguments）</p></li></ul><p>利用Function.apply()的参数数组化来提升程序的性能</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function dosomething(a,b,c)&#123;</span><br><span class="line">    console.log(&apos;do something.&apos;, a, b, c);</span><br><span class="line">    // 预期结果：   do something. see say run</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let something = [&apos;see&apos;, &apos;say&apos;, &apos;run&apos;];</span><br><span class="line">dosomething.apply(this, something);</span><br></pre></td></tr></table></figure></p><h3 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h3><ul><li>Function.call(obj, arg, arg, …);</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function dosomething(a,b,c)&#123;</span><br><span class="line">    console.log(&apos;do something.&apos;, a, b, c);</span><br><span class="line">    // 预期结果：   do something. see say run</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dosomething.call(this, &apos;see&apos;, &apos;say&apos;, &apos;run&apos;);</span><br></pre></td></tr></table></figure><p>推荐：使用apply函数。call函数和apply函数的效果是一样，但是call函数的参数不够灵活，在写法上参数无法灵活伸缩；apply函数，只需要把参数放到数组里即可。apply比call函数更适合在项目实际开发中使用，并且apply比call的性能要好。</p><h2 id="AOP在JS中的实现"><a href="#AOP在JS中的实现" class="headerlink" title="AOP在JS中的实现"></a>AOP在JS中的实现</h2><p>从事过Java Web开发的童鞋，一定用过Spring框架。在Spring的框架中有before（前置通知）、after（后置通知）、around（环绕通知）。<br>今天我们在JS中实现的这三种通知。</p><ol><li>before（前置通知）<br>before函数，用来实现函数的前置通知。在目标函数的前面执行一些前置操作。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// AOP 前置通知函数声明</span><br><span class="line">/**</span><br><span class="line"> * 给方法加入前置切片函数</span><br><span class="line"> * 可以在执行方法之前执行一些操作,</span><br><span class="line"> * 前置切片的返回值为false时，不影响原方法的执行</span><br><span class="line"> * @param func &#123;Function&#125; 被前置执行的函数</span><br><span class="line"> * @return &#123;Function&#125; 加入前置通知的函数</span><br><span class="line"> */</span><br><span class="line">Function.prototype._before = function(func)&#123;</span><br><span class="line">    var __self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        func.apply(__self, arguments);</span><br><span class="line">        return __self.apply(__self, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码</span><br><span class="line">function a()&#123;</span><br><span class="line">    console.log(&apos;I\&apos;m a&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = a._before(function()&#123;</span><br><span class="line">    console.log(&apos;before&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a();</span><br><span class="line">// 结果：</span><br><span class="line">// before</span><br><span class="line">// I&apos;m a</span><br></pre></td></tr></table></figure><ol start="2"><li><p>after（后置通知）<br>after函数，用来实现函数的后置通知。在目标函数的后面面执行一些后置操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// AOP 后置通知函数声明</span><br><span class="line">/**</span><br><span class="line"> * 给方法加入后置切片函数</span><br><span class="line"> * 可以在执行方法之之后执行一些操作</span><br><span class="line"> * 后置切片的返回值为false时，不影响原方法的执行</span><br><span class="line"> * @param func &#123;Function&#125; 被后置执行的函数</span><br><span class="line"> * @return &#123;Function&#125; 加入后置通知的函数</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">Function.prototype._after = function(func)&#123;</span><br><span class="line">    var __self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var ret = __self.apply(__self, arguments);</span><br><span class="line">        func.apply(__self, arguments);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码</span><br><span class="line">function b()&#123;</span><br><span class="line">    console.log(&apos;I\&apos;m b&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = b._after(function()&#123;</span><br><span class="line">    console.log(&apos;after&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">b();</span><br><span class="line">// 结果：</span><br><span class="line">// I&apos;m b</span><br><span class="line">// after</span><br></pre></td></tr></table></figure></li><li><p>around（环绕通知）<br>在around函数中，引入了一个JoinPoint对象。JoinPoint对象封装了目标函数和目标函数的参数。在调用JoinPoint对象的invoke函数时，会去调用原来的目标函数。在调用invoke时，如果需要改变目标函数的this对象，需要将对象传入到invoke的参数中。around函数，可以在目标函数的前面和后面随意加入逻辑代码，也可以根据条件判断是否执行目标函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// AOP 环绕通知函数声明</span><br><span class="line">/**</span><br><span class="line"> * 切入点对象</span><br><span class="line"> * 不允许切入对象多次调用</span><br><span class="line"> * @param obj   对象</span><br><span class="line"> * @param args  参数</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">function JoinPoint(obj, args)&#123;</span><br><span class="line">    var isapply = false;                       // 判断是否执行过目标函数</span><br><span class="line">    var result = null;                         // 保存目标函数的执行结果</span><br><span class="line"></span><br><span class="line">    this.source = obj;                         // 目标函数对象</span><br><span class="line">    this.args = args;                          // 目标函数对象传入的参数</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 目标函数的代理执行函数</span><br><span class="line">     * 如果被调用过，不能重复调用</span><br><span class="line">     * @return &#123;object&#125; 目标函数的返回结果</span><br><span class="line">     */</span><br><span class="line">    this.invoke = function(thiz)&#123;              </span><br><span class="line">        if(isapply)&#123; return; &#125;</span><br><span class="line">        isapply = true;</span><br><span class="line">        result = this.source.apply(thiz || this.source, this.args);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 获取目标函数执行结果</span><br><span class="line">    this.getResult = function()&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 方法环绕通知</span><br><span class="line"> * 原方法的执行需在环绕通知方法中执行</span><br><span class="line"> * @param func &#123;Function&#125; 环绕通知的函数</span><br><span class="line"> *     程序会往func中传入一个JoinPoint(切入点)对象, 在适当的时机</span><br><span class="line"> *     执行JoinPoint对象的invoke函数，调用目标函数</span><br><span class="line"> * </span><br><span class="line"> * @return &#123;Function&#125; 切入环绕通知后的函数，</span><br><span class="line"> */</span><br><span class="line">Function.prototype._around = function(func)&#123;</span><br><span class="line">    var __self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = [new JoinPoint(__self, arguments)];</span><br><span class="line">        return func.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码</span><br><span class="line"></span><br><span class="line">var isAdmin = true;</span><br><span class="line"></span><br><span class="line">function c()&#123;</span><br><span class="line">    console.log(&apos;show user list&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = c._around(function(joinpoint)&#123;</span><br><span class="line">    if(isAdmin)&#123;    // 满足条件时，执行目标函数</span><br><span class="line">        console.log(&apos;is admin&apos;);</span><br><span class="line">        joinpoint.invoke(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">c();</span><br><span class="line">// 结果</span><br><span class="line">// if isAdmin == true</span><br><span class="line">//     is admin</span><br><span class="line">//     show user list</span><br><span class="line">// if isAdmin == false</span><br><span class="line">//</span><br></pre></td></tr></table></figure></li></ol><h2 id="AOP在JS中的应用"><a href="#AOP在JS中的应用" class="headerlink" title="AOP在JS中的应用"></a>AOP在JS中的应用</h2><h3 id="AOP在数据库方面的应用"><a href="#AOP在数据库方面的应用" class="headerlink" title="AOP在数据库方面的应用"></a>AOP在数据库方面的应用</h3><p>记录sql的执行记录(AOP的前置通知)<br>记录sql的执行时间(AOP的环绕通知)<br>sql执行完后自动释放连接(AOP的环绕通知)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AOP介绍&quot;&gt;&lt;a href=&quot;#AOP介绍&quot; class=&quot;headerlink&quot; title=&quot;AOP介绍&quot;&gt;&lt;/a&gt;AOP介绍&lt;/h2&gt;&lt;p&gt;简介&lt;br&gt;AOP （面向切面编程），缩写为Aspect Oriented Programming，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是JAVA 中Spring框架的一个重要内容，是函数式编程的一种衍生范型。
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>容易混淆的umi创建命令</title>
    <link href="https://water.buging.cn/2021/03/04/%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84umi%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4/"/>
    <id>https://water.buging.cn/2021/03/04/容易混淆的umi创建命令/</id>
    <published>2021-03-04T17:25:28.000Z</published>
    <updated>2023-08-01T06:26:37.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 react 开发中，不得不提的就是 umijs 框架。这个框架把 react 全家桶打了一个包，整合在了一起。让开发者不必苦于配置初始开发环境。在 umijs2.x 升级到 umijs3.x 之后，在创建新项目的命令也发生了变化，让人容易模糊，而且 npm 和 yarn 的使用命令也不相同。这里做个简单的分享，方便以后查阅。<a id="more"></a></p><h2 id="Umi-2-x"><a href="#Umi-2-x" class="headerlink" title="Umi 2.x"></a>Umi 2.x</h2><p>通过官网得知，2.x 版本 umi 通过 create-umi 提供脚手架能力来创建的新项目。使用方式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir myapp &amp;&amp; <span class="built_in">cd</span> myapp</span><br><span class="line">$ yarn create umi</span><br></pre></td></tr></table></figure><blockquote><p>你可以通过 yarn create umi 或 npm create umi 使用 create-umi。推荐使用 yarn create 命令，能确保每次使用最新的脚手架。</p></blockquote><p>这里当时其实是很疑惑的，为啥使用的是 create-umi 脚手架来创建的项目，却不是 npm run create-umi 这样的使用命令？最后查阅资料得知，其实 yarn create umi 其实做了两步操作，根据 yarn 的官方文档。</p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/20210304175413.png" alt></p><p>而 npm create 确实平时不怎么见，而且文档也没有这个命令。最后多方查找说是 npm init 的别名，这里的作用就和 yarn create 一样随便用吧。大概就这样一段野史可证！！</p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/20210304175456.png" alt></p><p>由此创建项目的脚本命令就清楚了，就是使用了 create-umi 脚手架生成的。那么对以往的总结可以有以下方式来创建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yarn create umi // 创建文件在当前文件夹，执行脚本并更新create-umi包</span><br><span class="line">npm create umi  // 创建文件在当前文件夹，只执行脚本不更新create-umi包</span><br><span class="line">yarn create umi water // 创建文件在water文件夹，执行脚本并更新create-umi包</span><br><span class="line">npm create umi water// 创建文件在water文件夹，只执行脚本不更新create-umi包</span><br><span class="line">// npx方式</span><br><span class="line">npx create-umi</span><br><span class="line">npx create-umi</span><br><span class="line"></span><br><span class="line">第二种方式</span><br><span class="line">1. yarn global add create-umi/npm install create-umi -g // 先安装包</span><br><span class="line">2.</span><br><span class="line">create-umi // 在当前文件夹创建项目</span><br><span class="line">create-umi water //在water文件中创建项目</span><br></pre></td></tr></table></figure><h2 id="Umi-3-x"><a href="#Umi-3-x" class="headerlink" title="Umi 3.x"></a>Umi 3.x</h2><p>有以上的文字参考，3.x 版本的创建也就容易理解了。主要使用的是@umijs/create-umi-app 包来创建项目的。官网文档是这样写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir myapp &amp;&amp; cd myapp</span><br><span class="line">$ yarn create @umijs/umi-app</span><br><span class="line"># 或 npx @umijs/create-umi-app</span><br></pre></td></tr></table></figure><p>由以上命令来说，总结下创建的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yarn create @umijs/umi-app</span><br><span class="line">npm create @umijs/umi-app</span><br><span class="line">// 带文件夹</span><br><span class="line">yarn create @umijs/umi-app water</span><br><span class="line">npm create @umijs/umi-app water</span><br><span class="line">// npx方式</span><br><span class="line">npx @umijs/create-umi-app</span><br><span class="line">npx @umijs/create-umi-app water</span><br><span class="line">// 直接使用包创建</span><br><span class="line">1. 先安装包</span><br><span class="line">@umijs/create-umi-app</span><br><span class="line">2. 创建带不带文件夹</span><br><span class="line">create-umi-app</span><br><span class="line">create-umi-app water</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体就是用以上用命令通过脚手架包来创建项目的总结，希望对你有所帮助！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在 react 开发中，不得不提的就是 umijs 框架。这个框架把 react 全家桶打了一个包，整合在了一起。让开发者不必苦于配置初始开发环境。在 umijs2.x 升级到 umijs3.x 之后，在创建新项目的命令也发生了变化，让人容易模糊，而且 npm 和 yarn 的使用命令也不相同。这里做个简单的分享，方便以后查阅。
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>react中的同构</title>
    <link href="https://water.buging.cn/2021/01/19/react%E4%B8%AD%E7%9A%84%E5%90%8C%E6%9E%84/"/>
    <id>https://water.buging.cn/2021/01/19/react中的同构/</id>
    <published>2021-01-19T13:55:10.000Z</published>
    <updated>2023-08-01T06:26:37.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>随着越来越多新型前端框架的推出，SSR 这个概念在前端开发领域的流行度越来越高，也有越来越多的项目采用这种技术方案进行了实现。SSR 产生的背景是什么？适用的场景是什么？实现的原理又是什么？希望大家在这篇文章中能够找到你想要的答案。<a id="more"></a></p><p>说到 SSR，很多人的第一反应是“服务器端渲染”，但我更倾向于称之为“同构”，所以首先我们来对“客户端渲染”，“服务器端渲染”，“同构”这三个概念简单的做一个分析：</p><p><strong>客户端渲染</strong>：客户端渲染，页面初始加载的 HTML 页面中无网页展示内容，需要加载执行JavaScript 文件中的 React 代码，通过 JavaScript 渲染生成页面，同时，JavaScript 代码会完成页面交互事件的绑定，详细流程可参考下图（图片取材自 <a href="https://link.zhihu.com/?target=http%3A//fullstackacademy.com" rel="external nofollow noopener noreferrer" target="_blank">http://fullstackacademy.com</a>）：</p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/v2-721ab4c7d9e55d6b22da5109787a6617_r.jpg" alt="img"></p><p><strong>服务器端渲染</strong>：用户请求服务器，服务器上直接生成 HTML 内容并返回给浏览器。服务器端渲染来，页面的内容是由 Server 端生成的。一般来说，服务器端渲染的页面交互能力有限，如果要实现复杂交互，还是要通过引入 JavaScript 文件来辅助实现。服务器端渲染这个概念，适用于任何后端语言。</p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/v2-8fa23eb7918b58d1436e9aaffe3cc25b_r.jpg" alt="img"></p><p><strong>同构</strong>：同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。我们把页面的展示内容和交互写在一起，让代码执行两次。在服务器端执行一次，用于实现服务器端渲染，在客户端再执行一次，用于接管页面交互，详细流程可参考下图（图片取材自 <a href="https://link.zhihu.com/?target=http%3A//fullstackacademy.com" rel="external nofollow noopener noreferrer" target="_blank">http://fullstackacademy.com</a>）:</p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/v2-221bc777b5190dbdcf86db3d4870691d_r.jpg" alt="img"></p><p>一般情况下，当我们使用 React 编写代码时，页面都是由客户端执行 JavaScript 逻辑动态挂 DOM 生成的，也就是说这种普通的单页面应用实际上采用的是客户端渲染模式。在大多数情况下，客户端渲染完全能够满足我们的业务需求，那为什么我们还需要 SSR 这种同构技术呢？</p><h2 id="使用-SSR-技术的主要因素："><a href="#使用-SSR-技术的主要因素：" class="headerlink" title="使用 SSR 技术的主要因素："></a>使用 SSR 技术的主要因素：</h2><ol><li>CSR 项目的 TTFP（Time To First Page）时间比较长，参考之前的图例，在 CSR 的页面渲染流程中，首先要加载 HTML 文件，之后要下载页面所需的 JavaScript 文件，然后 JavaScript 文件渲染生成页面。在这个渲染过程中至少涉及到两个 HTTP 请求周期，所以会有一定的耗时，这也是为什么大家在低网速下访问普通的 React 或者 Vue 应用时，初始页面会有出现白屏的原因。</li><li>CSR 项目的 SEO 能力极弱，在搜索引擎中基本上不可能有好的排名。因为目前大多数搜索引擎主要识别的内容还是 HTML，对 JavaScript 文件内容的识别都还比较弱。如果一个项目的流量入口来自于搜索引擎，这个时候你使用 CSR 进行开发，就非常不合适了。</li></ol><p>SSR 的产生，主要就是为了解决上面所说的两个问题。在 React 中使用 SSR 技术，我们让 React 代码在服务器端先执行一次，使得用户下载的 HTML 已经包含了所有的页面展示内容，这样，页面展示的过程只需要经历一个 HTTP 请求周期，TTFP 时间得到一倍以上的缩减。</p><p>同时，由于 HTML 中已经包含了网页的所有内容，所以网页的 SEO 效果也会变的非常好。之后，我们让 React 代码在客户端再次执行，为 HTML 网页中的内容添加数据及事件的绑定，页面就具备了 React 的各种交互能力。</p><p>但是，SSR 这种理念的实现，并非易事。我们来看一下在 React 中实现 SSR 技术的架构图：</p><p><img src="https://gitee.com/wangyuan0108/image/raw/master/v2-744285853e079518979f68f981c5c821_r.jpg" alt="img"></p><p>使用 SSR 这种技术，将使原本简单的 React 项目变得非常复杂，项目的可维护性会降低，代码问题的追溯也会变得困难。</p><p>所以，使用 SSR 在解决问题的同时，也会带来非常多的副作用，有的时候，这些副作用的伤害比起 SSR 技术带来的优势要大的多。从个人经验上来说，我一般建议大家，除非你的项目特别依赖搜索引擎流量，或者对首屏时间有特殊的要求，否则不建议使用 SSR。</p><p>好，如果你确实遇到了 React 项目中要使用 SSR 的场景并决定使用 SSR，那么接下来我们就结合上面这张 SSR 架构图，开启 SSR 技术点的难点剖析。</p><p>在开始之前，我们先来分析下虚拟 DOM 和 SSR 的关系。</p><h2 id="SSR-之所以能够实现，本质上是因为虚拟-DOM-的存在"><a href="#SSR-之所以能够实现，本质上是因为虚拟-DOM-的存在" class="headerlink" title="SSR 之所以能够实现，本质上是因为虚拟 DOM 的存在"></a>SSR 之所以能够实现，本质上是因为虚拟 DOM 的存在</h2><p>上面我们说过，SSR 的工程中，React 代码会在客户端和服务器端各执行一次。你可能会想，这没什么问题，都是 JavaScript 代码，既可以在浏览器上运行，又可以在 Node 环境下运行。但事实并非如此，如果你的 React 代码里，存在直接操作 DOM 的代码，那么就无法实现 SSR 这种技术了，因为在 Node 环境下，是没有 DOM 这个概念存在的，所以这些代码在 Node 环境下是会报错的。</p><p>好在 React 框架中引入了一个概念叫做虚拟 DOM，虚拟 DOM 是真实 DOM 的一个 JavaScript 对象映射，React 在做页面操作时，实际上不是直接操作 DOM，而是操作虚拟 DOM，也就是操作普通的 JavaScript 对象，这就使得 SSR 成为了可能。在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。</p><p>其他的一些框架，比如 Vue，它能够实现 SSR 也是因为引入了和 React 中一样的虚拟 DOM 技术。</p><p>好，接下来我们回过头看流程图，前两步不说了，服务器端渲染肯定要先向 Node 服务器发送请求。重点是第 3 步，大家可以看到，服务器端要根据请求的地址，判断要展示什么样的页面了，这一步叫做服务器端路由。</p><p>我们再看第 10 步，当客户端接收到 JavaScript 文件后，要根据当前的路径，在浏览器上再判断当前要展示的组件，重新进行一次客户端渲染，这个时候，还要经历一次客户端路由（前端路由）。</p><p>那么，我们下面要说的就是服务器端路由和客户端路由的区别。</p><h2 id="SSR-中客户端渲染与服务器端渲染路由代码的差异"><a href="#SSR-中客户端渲染与服务器端渲染路由代码的差异" class="headerlink" title="SSR 中客户端渲染与服务器端渲染路由代码的差异"></a>SSR 中客户端渲染与服务器端渲染路由代码的差异</h2><p>实现 React 的 SSR 架构，我们需要让相同的 React 代码在客户端和服务器端各执行一次。大家注意，这里说的相同的 React 代码，指的是我们写的各种组件代码，所以在同构中，只有组件的代码是可以公用的，而路由这样的代码是没有办法公用的，大家思考下这是为什么呢？其实原因很简单，在服务器端需要通过请求路径，找到路由组件，而在客户端需通过浏览器中的网址，找到路由组件，是完全不同的两套机制，所以这部分代码是肯定无法公用。我们来看看在 SSR 中，前后端路由的实现代码：</p><p><strong>客户端路由：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/'</span> component=&#123;Home&#125;&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;App/</span>&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>))</span><br></pre></td></tr></table></figure><p>客户端路由代码非常简单，大家一定很熟悉，BrowserRouter 会自动从浏览器地址中，匹配对应的路由组件显示出来。</p><p><strong>服务器端路由代码：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/'</span> component=&#123;Home&#125;&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>StaticRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Return ReactDom.renderToString(&lt;App/</span>&gt;)</span><br></pre></td></tr></table></figure><p>服务器端路由代码相对要复杂一点，需要你把 location（当前请求路径）传递给 StaticRouter 组件，这样 StaticRouter 才能根据路径分析出当前所需要的组件是谁。（PS：StaticRouter 是 React-Router 针对服务器端渲染专门提供的一个路由组件。）</p><p>通过 BrowserRouter 我们能够匹配到浏览器即将显示的路由组件，对浏览器来说，我们需要把组件转化成 DOM，所以需要我们使用 ReactDom.render 方法来进行 DOM 的挂载。而 StaticRouter 能够在服务器端匹配到将要显示的组件，对服务器端来说，我们要把组件转化成字符串，这时我们只需要调用 ReactDom 提供的 renderToString 方法，就可以得到 App 组件对应的 HTML 字符串。</p><p>对于一个 React 应用来说，路由一般是整个程序的执行入口。在 SSR 中，服务器端的路由和客户端的路由不一样，也就意味着服务器端的入口代码和客户端的入口代码是不同的。</p><p>我们知道， React 代码是要通过 Webpack 打包之后才能运行的，也就是第 3 步和第10 步运行的代码，实际上是源代码打包过后生成的代码。上面也说到，服务器端和客户端渲染中的代码，只有一部分一致，其余是有区别的。所以，针对代码运行环境的不同，要进行有区别的 Webpack 打包。</p><h2 id="服务器端代码和客户端代码的打包差异"><a href="#服务器端代码和客户端代码的打包差异" class="headerlink" title="服务器端代码和客户端代码的打包差异"></a>服务器端代码和客户端代码的打包差异</h2><p>简单写两个 Webpack 配置文件作为 DEMO：</p><p><strong>客户端 Webpack 配置</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: './src/client/index.js',</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: 'index.js',</span><br><span class="line">    path: path.resolve(__dirname, 'public')</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.js?$/,</span><br><span class="line">      loader: 'babel-loader'</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: /\.css?$/,</span><br><span class="line">      use: ['style-loader', &#123;</span><br><span class="line">        loader: 'css-loader',</span><br><span class="line">        options: &#123;modules: true&#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: /\.(png|jpeg|jpg|gif|svg)?$/,</span><br><span class="line">      loader: 'url-loader',</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: 8000,</span><br><span class="line">        publicPath: '/'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务器端 Webpack 配置</strong>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  target: 'node',</span><br><span class="line">  entry: './src/server/index.js',</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: 'bundle.js',</span><br><span class="line">    path: path.resolve(__dirname, 'build')</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.js?$/,</span><br><span class="line">      loader: 'babel-loader'</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: /\.css?$/,</span><br><span class="line">      use: ['isomorphic-style-loader', &#123;</span><br><span class="line">        loader: 'css-loader',</span><br><span class="line">        options: &#123;modules: true&#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: /\.(png|jpeg|jpg|gif|svg)?$/,</span><br><span class="line">      loader: 'url-loader',</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: 8000,</span><br><span class="line">        outputPath: '../public/',</span><br><span class="line">        publicPath: '/'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面我们说了，在 SSR 中，服务器端渲染的代码和客户端的代码的入口路由代码是有差异的，所以在 Webpack 中，Entry 的配置首先肯定是不同的。</p><p>在服务器端运行的代码，有时我们需要引入 Node 中的一些核心模块，我们需要 Webpack 做打包的时候能够识别出类似的核心模块，一旦发现是核心模块，不必把模块的代码合并到最终生成的代码中，解决这个问题的方法非常简单，在服务器端的 Webpack配置中，你只要加入 target: node 这个配置即可。</p><p>服务器端渲染的代码，如果加载第三方模块，这些第三方模块也是不需要被打包到最终的源码中的，因为 Node 环境下通过 NPM 已经安装了这些包，直接引用就可以，不需要额外再打包到代码里。为了解决这个问题，我们可以使用 webpack-node-externals 这个插件，代码中的 nodeExternals 指的就是这个插件，通过这个插件，我们就能解决这个问题。关于 Node 这里的打包问题，可能看起来有些抽象，不是很明白的同学可以仔细读一下 webpack-node-externals 相关的文章或文档，你就能很好的明白这里存在的问题了。</p><p>接下来我们继续分析，当我们的 React 代码中引入了一些 CSS 样式代码时，服务器端打包的过程会处理一遍 CSS，而客户端又会处理一遍。查看配置，我们可以看到，服务器端打包时我们用了 isomorphic-style-loader，它处理 CSS 的时候，只在对应的 DOM 元素上生成 class 类名，然后返回生成的 CSS 样式代码。</p><p>而在客户端代码打包配置中，我们使用了 css-loader 和 style-loader，css-loader 不但会在 DOM 上生成 class 类名，解析好的 CSS 代码，还会通过 style-loader 把代码挂载到页面上。不过这么做，由于页面上的样式实际上最终是由客户端渲染时添加上的，所以页面可能会存在一开始没有样式的情况，为了解决这个问题， 我们可以在服务器端渲染时，拿到 isomorphic-style-loader 返回的样式代码，然后以字符串的形式添加到服务器端渲染的 HTML 之中。</p><p>而对于图片等类型的文件引入，url-loader 也会在服务器端代码和客户端代码打包的过程中分别进行打包，这里，我偷了一个懒，无论服务器端打包还是客户端打包，我都让打包生成的文件存储在 public 目录下，这样，虽然文件会打包出来两遍，但是后打包出来的文件会覆盖之前的文件，所以看起来还是只有一份文件。</p><p>当然，这样做的性能和优雅性并不高，只是给大家提供一个小的思路，如果想进行优化，你可以让图片的打包只进行一次，借助一些 Webpack 的插件，实现这个也并非难事，你甚至可以自己也写一个 loader，来解决这样的问题。</p><p>如果你的 React 应用中没有异步数据的获取，单纯的做一些静态内容展示，经过上面的配置，你会发现一个简单的 SSR 应用很快的就可以被实现出来了。但是，真正的一个 React 项目中，我们肯定要有异步数据的获取，绝大多数情况下，我们还要使用 Redux 管理数据。而如果想在 SSR 应用中实现，就不是这么简单了。</p><h2 id="SSR-中异步数据的获取-Redux-的使用"><a href="#SSR-中异步数据的获取-Redux-的使用" class="headerlink" title="SSR 中异步数据的获取 + Redux 的使用"></a>SSR 中异步数据的获取 + Redux 的使用</h2><p>客户端渲染中，异步数据结合 Redux 的使用方式遵循下面的流程（对应图中第 12 步）：</p><ol><li>创建 Store</li><li>根据路由显示组件</li><li>派发 Action 获取数据</li><li>更新 Store 中的数据</li><li>组件 Rerender</li></ol><p>而在服务器端，页面一旦确定内容，就没有办法 Rerender 了，这就要求组件显示的时候，就要把 Store 的数据都准备好，所以服务器端异步数据结合 Redux 的使用方式，流程是下面的样子（对应图中第 4 步）：</p><ol><li>创建 Store</li><li>根据路由分析 Store 中需要的数据</li><li>派发 Action 获取数据</li><li>更新Store 中的数据</li><li>结合数据和组件生成 HTML，一次性返回</li></ol><p>下面，我们分析下<strong>服务器端渲染</strong>这部分的流程：</p><ol><li>创建 Store：这一部分有坑，要注意避免，大家知道，客户端渲染中，用户的浏览器中永远只存在一个 Store，所以代码上你可以这么写：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer, defaultState)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>然而在服务器端，这么写就有问题了，因为服务器端的 Store 是所有用户都要用的，如果像上面这样构建 Store，Store 变成了一个单例，所有用户共享 Store，显然就有问题了。所以在服务器端渲染中，Store 的创建应该像下面这样，返回一个函数，每个用户访问的时候，这个函数重新执行，为每个用户提供一个独立的 Store：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getStore = <span class="function">(<span class="params">req</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> createStore(reducer, defaultState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getStore;</span><br></pre></td></tr></table></figure><ol><li>根据路由分析 Store 中需要的数据： 要想实现这个步骤，在服务器端，首先我们要分析当前出路由要加载的所有组件，这个时候我们可以借助一些第三方的包，比如说 react-router-config, 具体这个包怎么使用，不做过多说明，大家可以查看文档，使用这个包，传入服务器请求路径，它就会帮助你分析出这个路径下要展示的所有组件。</li><li>派发 Action 获取数据: 接下来，我们在每个组件上增加一个获取数据的方法：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Home.loadData = <span class="function">(<span class="params">store</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> store.dispatch(getHomeList())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法需要你把服务器端渲染的 Store 传递进来，它的作用就是帮助服务器端的 Store 获取到这个组件所需的数据。 所以，组件上有了这样的方法，同时我们也有当前路由所需要的所有组件，依次调用各个组件上的 loadData 方法，就能够获取到路由所需的所有数据内容了。</p><ol><li>更新 Store 中的数据: 其实，当我们执行第三步的时候，已经在更新 Store 中的数据了，但是，我们要在生成 HTML 之前，保证所有的数据都获取完毕，这怎么处理呢？</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// matchedRoutes 是当前路由对应的所有需要显示的组件集合</span></span><br><span class="line">matchedRoutes.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item.route.loadData) &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      item.route.loadData(store).then(resolve).catch(resolve);</span><br><span class="line">    &#125;)</span><br><span class="line">    promises.push(promise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 生成 HTML 逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里，我们使用 Promise 来解决这个问题，我们构建一个 Promise 队列，等待所有的 Promise 都执行结束后，也就是所有 store.dispatch 都执行完毕后，再去生成 HTML。这样的话，我们就实现了结合 Redux 的 SSR 流程。</p><p>在上面，我们说到，服务器端渲染时，页面的数据是通过 loadData 函数来获取的。而在客户端，数据获取依然要做，因为如果这个页面是你访问的第一个页面，那么你看到的内容是服务器端渲染出来的，但是如果经过 react-router 路由跳转道第二个页面，那么这个页面就完全是客户端渲染出来的了，所以客户端也要去拿数据。</p><p>在客户端获取数据，使用的是我们最习惯的方式，通过 componentDidMount 进行数据的获取。这里要注意的是，componentDidMount 只在客户端才会执行，在服务器端这个生命周期函数是不会执行的。所以我们不必担心 componentDidMount 和 loadData 会有冲突，放心使用即可。这也是为什么数据的获取应该放到 componentDidMount 这个生命周期函数中而不是 componentWillMount 中的原因，可以避免服务器端获取数据和客户端获取数据的冲突。</p><h2 id="Node-只是一个中间层"><a href="#Node-只是一个中间层" class="headerlink" title="Node 只是一个中间层"></a>Node 只是一个中间层</h2><p>上一部分我们说到了获取数据的问题，在 SSR 架构中，一般 Node 只是一个中间层，用来做 React 代码的服务器端渲染，而 Node 需要的数据通常由 API 服务器单独提供。</p><p>这样做一是为了工程解耦，二也是为了规避 Node 服务器的一些计算性能问题。</p><p>请大家关注图中的第 4 步和第 12，13 步，我们接下来分析这几个步骤。</p><p>服务器端渲染时，直接请求 API 服务器的接口获取数据没有任何问题。但是在客户端，就有可能存在跨域的问题了，所以，这个时候，我们需要在服务器端搭建 Proxy 代理功能，客户端不直接请求 API 服务器，而是请求 Node 服务器，经过代理转发，拿到 API 服务器的数据。</p><p>这里你可以通过 express-http-proxy 这样的工具帮助你快速搭建 Proxy 代理功能，但是记得配置的时候，要让代理服务器不仅仅帮你转发请求，还要把 cookie 携带上，这样才不会有权限校验上的一些问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node 代理功能实现代码</span></span><br><span class="line">app.use(<span class="string">'/api'</span>, proxy(<span class="string">'http://apiServer.com'</span>, &#123;</span><br><span class="line">  proxyReqPathResolver: <span class="function"><span class="keyword">function</span> (<span class="params">req</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'/ssr'</span> + req.url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>到这里，整个 SSR 的流程体系中关键知识点的原理就串联起来了，如果你之前适用过 SSR 框架，那么这些知识点的整理我相信可以从原理层面很好的帮助到你。</p><p>当然，我也考虑到阅读本篇文章的同学可能有很大一部分对 SSR 的基础知识非常有限，看了文章可能会云里雾里，这里为了帮助这些同学，我编写了一个非常简单的 SSR 框架，代码放在这里：</p><p><a href="https://link.zhihu.com/?target=https%3A//files.alicdn.com/tpsservice/bf46acacaab649752e9c9121bdfb7f70.zip" rel="external nofollow noopener noreferrer" target="_blank">https://files.alicdn.com/tpsservice/bf46acacaab649752e9c9121bdfb7f70.zip</a></p><p>初学者结合上面的流程图，一步步梳理流程图中的逻辑，梳理结束后，回来再看一遍这篇文章，相信大家就豁然开朗了。</p><p>当然在真正实现 SSR 架构的过程中，难点有时不是实现的思路，而是细节的处理。比如说如何针对不同页面设置不同的 title 和 description 来提升 SEO 效果，这时候，我们其实可以用 react-helmet 这样的工具帮我们达成目标，这个工具对客户端和服务器端渲染的效果都很棒，值得推荐。还有一些诸如工程目录的设计，404，301 重定向情况的处理等等，不过这些问题，我们只需要在实践中遇到的时候逐个攻破就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着越来越多新型前端框架的推出，SSR 这个概念在前端开发领域的流行度越来越高，也有越来越多的项目采用这种技术方案进行了实现。SSR 产生的背景是什么？适用的场景是什么？实现的原理又是什么？希望大家在这篇文章中能够找到你想要的答案。
    
    </summary>
    
      <category term="WEB前端" scheme="https://water.buging.cn/categories/WEB%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
